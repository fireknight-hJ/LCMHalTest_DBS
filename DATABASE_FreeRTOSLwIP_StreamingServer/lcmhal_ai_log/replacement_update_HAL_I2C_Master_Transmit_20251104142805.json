{
  "function_name": "HAL_I2C_Master_Transmit",
  "replacement_code": "HAL_StatusTypeDef HAL_I2C_Master_Transmit(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData,\n                                          uint16_t Size, uint32_t Timeout)\n{\n  uint32_t tickstart;\n  uint32_t xfermode;\n\n  if (hi2c->State == HAL_I2C_STATE_READY)\n  {\n    /* Process Locked */\n    __HAL_LOCK(hi2c);\n\n    /* Init tickstart for timeout management*/\n    tickstart = HAL_GetTick();\n\n    hi2c->State     = HAL_I2C_STATE_BUSY_TX;\n    hi2c->Mode      = HAL_I2C_MODE_MASTER;\n    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;\n\n    /* Prepare transfer parameters */\n    hi2c->pBuffPtr  = pData;\n    hi2c->XferCount = Size;\n    hi2c->XferISR   = NULL;\n\n    if (hi2c->XferCount > MAX_NBYTE_SIZE)\n    {\n      hi2c->XferSize = MAX_NBYTE_SIZE;\n      xfermode = I2C_RELOAD_MODE;\n    }\n    else\n    {\n      hi2c->XferSize = hi2c->XferCount;\n      xfermode = I2C_AUTOEND_MODE;\n    }\n\n    /* Use HAL_BE_Out to simulate data transmission */\n    int result = HAL_BE_Out(Size);\n    if (result < 0)\n    {\n      hi2c->ErrorCode = HAL_I2C_ERROR_TIMEOUT;\n      hi2c->State = HAL_I2C_STATE_READY;\n      hi2c->Mode  = HAL_I2C_MODE_NONE;\n      __HAL_UNLOCK(hi2c);\n      return HAL_ERROR;\n    }\n\n    hi2c->State = HAL_I2C_STATE_READY;\n    hi2c->Mode  = HAL_I2C_MODE_NONE;\n\n    /* Process Unlocked */\n    __HAL_UNLOCK(hi2c);\n\n    return HAL_OK;\n  }\n  else\n  {\n    return HAL_BUSY;\n  }\n}",
  "reason": "Replaced printf calls with HAL_BE_Out helper function to avoid dependency on standard C library functions"
}
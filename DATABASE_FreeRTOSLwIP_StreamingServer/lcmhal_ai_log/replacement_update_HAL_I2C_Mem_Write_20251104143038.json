{
  "function_name": "HAL_I2C_Mem_Write",
  "replacement_code": "HAL_StatusTypeDef HAL_I2C_Mem_Write(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress,\n                                    uint16_t MemAddSize, uint8_t *pData, uint16_t Size, uint32_t Timeout)\n{\n  uint32_t tickstart;\n\n  /* Check the parameters */\n  assert_param(IS_I2C_MEMADD_SIZE(MemAddSize));\n\n  if (hi2c->State == HAL_I2C_STATE_READY)\n  {\n    if ((pData == NULL) || (Size == 0U))\n    {\n      hi2c->ErrorCode = HAL_I2C_ERROR_INVALID_PARAM;\n      return  HAL_ERROR;\n    }\n\n    /* Process Locked */\n    __HAL_LOCK(hi2c);\n\n    /* Init tickstart for timeout management*/\n    tickstart = HAL_GetTick();\n\n    /* Skip hardware busy flag check */\n    /* if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY, tickstart) != HAL_OK)\n    {\n      return HAL_ERROR;\n    } */\n\n    hi2c->State     = HAL_I2C_STATE_BUSY_TX;\n    hi2c->Mode      = HAL_I2C_MODE_MEM;\n    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;\n\n    /* Prepare transfer parameters */\n    hi2c->pBuffPtr  = pData;\n    hi2c->XferCount = Size;\n    hi2c->XferISR   = NULL;\n\n    /* Skip hardware address request */\n    /* if (I2C_RequestMemoryWrite(hi2c, DevAddress, MemAddress, MemAddSize, Timeout, tickstart) != HAL_OK)\n    {\n      __HAL_UNLOCK(hi2c);\n      return HAL_ERROR;\n    } */\n\n    /* Set NBYTES to write and reload if hi2c->XferCount > MAX_NBYTE_SIZE */\n    if (hi2c->XferCount > MAX_NBYTE_SIZE)\n    {\n      hi2c->XferSize = MAX_NBYTE_SIZE;\n      /* Skip hardware transfer config */\n      /* I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_RELOAD_MODE, I2C_NO_STARTSTOP); */\n    }\n    else\n    {\n      hi2c->XferSize = hi2c->XferCount;\n      /* Skip hardware transfer config */\n      /* I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE, I2C_NO_STARTSTOP); */\n    }\n\n    /* Use HAL_BE_Out to simulate data transmission */\n    int result = HAL_BE_Out(Size);\n    if (result < 0)\n    {\n      hi2c->ErrorCode = HAL_I2C_ERROR_TIMEOUT;\n      hi2c->State = HAL_I2C_STATE_READY;\n      hi2c->Mode  = HAL_I2C_MODE_NONE;\n      __HAL_UNLOCK(hi2c);\n      return HAL_ERROR;\n    }\n\n    /* Update buffer pointers and counters to maintain state consistency */\n    hi2c->pBuffPtr += Size;\n    hi2c->XferCount = 0;\n    hi2c->XferSize = 0;\n\n    /* Skip hardware flag checks and cleanup */\n    /* if (I2C_WaitOnSTOPFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)\n    {\n      return HAL_ERROR;\n    }\n\n    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);\n    I2C_RESET_CR2(hi2c); */\n\n    hi2c->State = HAL_I2C_STATE_READY;\n    hi2c->Mode  = HAL_I2C_MODE_NONE;\n\n    /* Process Unlocked */\n    __HAL_UNLOCK(hi2c);\n\n    return HAL_OK;\n  }\n  else\n  {\n    return HAL_BUSY;\n  }\n}",
  "reason": "Replaced printf calls with HAL_BE_Out helper function to avoid dependency on standard C library functions"
}
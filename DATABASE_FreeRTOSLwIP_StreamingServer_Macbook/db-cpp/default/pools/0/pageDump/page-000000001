/*!<Capture/Compare 2 Complementary output Polarity *//*!<Capture/Compare 2 Complementary output enable *//*!<Capture/Compare 2 output Polarity *//*!<Capture/Compare 2 output enable *//*!<Capture/Compare 1 Complementary output Polarity *//*!<Capture/Compare 1 Complementary output enable *//*!<Capture/Compare 1 output Polarity *//*!<Capture/Compare 1 output enable *//*******************  Bit definition for TIM_CCER register  *******************//*!< 0x8000 *//*!< 0x4000 *//*!< 0x2000 *//*!<IC4F[3:0] bits (Input Capture 4 Filter) *//*!<IC4PSC[1:0] bits (Input Capture 4 Prescaler) *//*!<IC3F[3:0] bits (Input Capture 3 Filter) *//*!<IC3PSC[1:0] bits (Input Capture 3 Prescaler) *//*----------------------------------------------------------------------------*//*!<Output Compare 4 Fast enable    *//*!<CC4S[1:0] bits (Capture/Compare 4 Selection) *//*!<Output Compare 3 Clear Enable *//*!<OC3M[2:0] bits (Output Compare 3 Mode) *//*!<Output Compare 3 Preload enable        *//*!<Output Compare 3 Fast enable           *//*!<CC3S[1:0] bits (Capture/Compare 3 Selection)  *//******************  Bit definition for TIM_CCMR2 register  *******************//*!<IC2F[3:0] bits (Input Capture 2 Filter)       *//*!<IC2PSC[1:0] bits (Input Capture 2 Prescaler)  *//*!<IC1F[3:0] bits (Input Capture 1 Filter)      *//*!<IC1PSC[1:0] bits (Input Capture 1 Prescaler) *//*!<Output Compare 2 Clear Enable *//*!<OC2M[2:0] bits (Output Compare 2 Mode)       *//*!<Output Compare 2 Preload enable              *//*!<Output Compare 2 Fast enable                 *//*!<CC2S[1:0] bits (Capture/Compare 2 Selection) *//*!<Output Compare 1Clear Enable                 *//*!<OC1M[2:0] bits (Output Compare 1 Mode)       *//*!<Output Compare 1 Preload enable              *//*!<Output Compare 1 Fast enable                 *//*!<CC1S[1:0] bits (Capture/Compare 1 Selection) *//******************  Bit definition for TIM_CCMR1 register  *******************//*!<Break2 Generation                          *//*!<Break Generation                          *//*!<Trigger Generation                        *//*!<Capture/Compare Control Update Generation *//*!<Capture/Compare 4 Generation              *//*!<Capture/Compare 3 Generation              *//*!<Capture/Compare 2 Generation              *//*!<Capture/Compare 1 Generation              *//*!<Update Generation                         *//*******************  Bit definition for TIM_EGR register  ********************//*!<Capture/Compare 6 interrupt Flag *//*!<Capture/Compare 5 interrupt Flag *//*!<System Break interrupt Flag *//*!<Capture/Compare 4 Overcapture Flag *//*!<Capture/Compare 3 Overcapture Flag *//*!<Capture/Compare 2 Overcapture Flag *//*!<Capture/Compare 1 Overcapture Flag *//*!<Break2 interrupt Flag               *//*!<Break interrupt Flag               *//*!<Trigger interrupt Flag             *//*!<COM interrupt Flag                 *//*!<Capture/Compare 4 interrupt Flag   *//*!<Capture/Compare 3 interrupt Flag   *//*!<Capture/Compare 2 interrupt Flag   *//*!<Capture/Compare 1 interrupt Flag   *//*!<Update interrupt Flag              *//********************  Bit definition for TIM_SR register  ********************//*!<Trigger DMA request enable           *//*!<COM DMA request enable               *//*!<Capture/Compare 4 DMA request enable *//*!<Capture/Compare 3 DMA request enable *//*!<Capture/Compare 2 DMA request enable *//*!<Capture/Compare 1 DMA request enable *//*!<Update DMA request enable            *//*!<Break interrupt enable               *//*!<Trigger interrupt enable             *//*!<COM interrupt enable                 *//*!<Capture/Compare 4 interrupt enable   *//*!<Capture/Compare 3 interrupt enable   *//*!<Capture/Compare 2 interrupt enable   *//*!<Capture/Compare 1 interrupt enable   *//*!<Update interrupt enable *//*******************  Bit definition for TIM_DIER register  *******************//*!<External trigger polarity *//*!<External clock enable     *//*!<ETPS[1:0] bits (External trigger prescaler) *//*!<ETF[3:0] bits (External trigger filter) *//*!<Master/slave mode                       *//*!<TS[2:0] bits (Trigger selection)        *//*!<SMS[2:0] bits (Slave mode selection)    *//*!< 0x00010007 *//*******************  Bit definition for TIM_SMCR register  *******************//*!<Output Idle state 4 (OC4 output)  *//*!<Output Idle state 3 (OC3N output) *//*!<Output Idle state 3 (OC3 output)  *//*!<Output Idle state 2 (OC2N output) *//*!<Output Idle state 2 (OC2 output)  *//*!<Output Idle state 1 (OC1N output) *//*!<Output Idle state 1 (OC1 output)  *//*!<TI1 Selection *//*!<MMS[2:0] bits (Master Mode Selection) *//*!<Output Idle state 4 (OC4 output) *//*!<Capture/Compare DMA Selection            *//*!<Capture/Compare Control Update Selection *//*!<Capture/Compare Preloaded Control        *//*******************  Bit definition for TIM_CR2 register  ********************//*!<UIF status bit *//*!<CKD[1:0] bits (clock division) *//*!<Auto-reload preload enable     *//*!<CMS[1:0] bits (Center-aligned mode selection) *//*!<Direction             *//*!<One pulse mode        *//*!<Update request source *//*!<Update disable        *//*!<Counter enable        *//*******************  Bit definition for TIM_CR1 register  ********************//*!<TIM Break input feature available on specific devices *//*
 * @brief Specific device feature definitions (not present on all devices in the STM32F7 series)
 *//*                                    TIM                                     *//*!<Compensation cell ready flag *//*!<Compensation cell power-down *//******************  Bit definition for SYSCFG_CMPCR register  ****************//*!<PVD Lock         *//*!<Core Lockup Lock *//******************  Bit definition for SYSCFG_CBR register  ******************//*!<PJ[15] pin *//*!<PI[15] pin *//*!<PH[15] pin *//*!<PG[15] pin *//*!<PF[15] pin *//*!<PE[15] pin *//*!<PD[15] pin *//*!<PC[15] pin *//*!<PB[15] pin *//*!<PA[15] pin *//**
  * @brief   EXTI15 configuration
  *//*!<PJ[14] pin *//*!<PI[14] pin *//*!<PH[14] pin *//*!<PG[14] pin *//*!<PF[14] pin *//*!<PE[14] pin *//*!<PD[14] pin *//*!<PC[14] pin *//*!<PB[14] pin *//*!<PA[14] pin *//**
  * @brief   EXTI14 configuration
  *//*!<PJ[13] pin *//*!<PI[13] pin *//*!<PH[13] pin *//*!<PG[13] pin *//*!<PF[13] pin *//*!<PE[13] pin *//*!<PD[13] pin *//*!<PC[13] pin *//*!<PB[13] pin *//*!<PA[13] pin *//**
  * @brief   EXTI13 configuration
  *//*!<PJ[12] pin *//*!<PI[12] pin *//*!<PH[12] pin *//*!<PG[12] pin *//*!<PF[12] pin *//*!<PE[12] pin *//*!<PD[12] pin *//*!<PC[12] pin *//*!<PB[12] pin *//*!<PA[12] pin *//**
  * @brief   EXTI12 configuration
  *//*!<EXTI 15 configuration *//*!<EXTI 14 configuration *//*!<EXTI 13 configuration *//*!<EXTI 12 configuration *//*****************  Bit definition for SYSCFG_EXTICR4 register  ***************//*!<PJ[11] pin *//*!<PI[11] pin *//*!<PH[11] pin *//*!<PG[11] pin *//*!<PF[11] pin *//*!<PE[11] pin *//*!<PD[11] pin *//*!<PC[11] pin *//*!<PB[11] pin *//*!<PA[11] pin *//**
  * @brief   EXTI11 configuration
  *//*!<PJ[10] pin *//*!<PI[10] pin *//*!<PH[10] pin *//*!<PG[10] pin *//*!<PF[10] pin *//*!<PE[10] pin *//*!<PD[10] pin *//*!<PC[10] pin *//*!<PB[10] pin *//*!<PA[10] pin *//**
  * @brief   EXTI10 configuration
  *//*!<PJ[9] pin *//*!<PI[9] pin *//*!<PH[9] pin *//*!<PG[9] pin *//*!<PF[9] pin *//*!<PE[9] pin *//*!<PD[9] pin *//*!<PC[9] pin *//*!<PB[9] pin *//*!<PA[9] pin *//**
  * @brief   EXTI9 configuration
  *//*!<PJ[8] pin *//*!<PI[8] pin *//*!<PH[8] pin *//*!<PG[8] pin *//*!<PF[8] pin *//*!<PE[8] pin *//*!<PD[8] pin *//*!<PC[8] pin *//*!<PB[8] pin *//*!<PA[8] pin *//**
  * @brief   EXTI8 configuration
  *//*!<EXTI 11 configuration *//*!<EXTI 10 configuration *//*!<EXTI 9 configuration *//*!<EXTI 8 configuration *//*****************  Bit definition for SYSCFG_EXTICR3 register  ***************//*!<PK[7] pin *//*!<PJ[7] pin *//*!<PI[7] pin *//*!<PH[7] pin *//*!<PG[7] pin *//*!<PF[7] pin *//*!<PE[7] pin *//*!<PD[7] pin *//*!<PC[7] pin *//*!<PB[7] pin *//*!<PA[7] pin *//**
  * @brief   EXTI7 configuration
  *//*!<PK[6] pin *//*!<PJ[6] pin *//*!<PI[6] pin *//*!<PH[6] pin *//*!<PG[6] pin *//*!<PF[6] pin *//*!<PE[6] pin *//*!<PD[6] pin *//*!<PC[6] pin *//*!<PB[6] pin *//*!<PA[6] pin *//**
  * @brief   EXTI6 configuration
  *//*!<PK[5] pin *//*!<PJ[5] pin *//*!<PI[5] pin *//*!<PH[5] pin *//*!<PG[5] pin *//*!<PF[5] pin *//*!<PE[5] pin *//*!<PD[5] pin *//*!<PC[5] pin *//*!<PB[5] pin *//*!<PA[5] pin *//**
  * @brief   EXTI5 configuration
  *//*!<PK[4] pin *//*!<PJ[4] pin *//*!<PI[4] pin *//*!<PH[4] pin *//*!<PG[4] pin *//*!<PF[4] pin *//*!<PE[4] pin *//*!<PD[4] pin *//*!<PC[4] pin *//*!<PB[4] pin *//*!<PA[4] pin *//**
  * @brief   EXTI4 configuration
  *//*!<EXTI 7 configuration *//*!<EXTI 6 configuration *//*!<EXTI 5 configuration *//*!<EXTI 4 configuration *//*****************  Bit definition for SYSCFG_EXTICR2 register  ***************//*!<PK[3] pin *//*!<PJ[3] pin *//*!<PI[3] pin *//*!<PH[3] pin *//*!<PG[3] pin *//*!<PF[3] pin *//*!<PE[3] pin *//*!<PD[3] pin *//*!<PC[3] pin *//*!<PB[3] pin *//*!<PA[3] pin *//**
  * @brief   EXTI3 configuration
  *//*!<PK[2] pin *//*!<PJ[2] pin *//*!<PI[2] pin *//*!<PH[2] pin *//*!<PG[2] pin *//*!<PF[2] pin *//*!<PE[2] pin *//*!<PD[2] pin *//*!<PC[2] pin *//*!<PB[2] pin *//*!<PA[2] pin *//**
  * @brief   EXTI2 configuration
  *//*!<PK[1] pin *//*!<PJ[1] pin *//*!<PI[1] pin *//*!<PH[1] pin *//*!<PG[1] pin *//*!<PF[1] pin *//*!<PE[1] pin *//*!<PD[1] pin *//*!<PC[1] pin *//*!<PB[1] pin *//*!<PA[1] pin *//**
  * @brief   EXTI1 configuration
  *//*!<PK[0] pin *//*!<PJ[0] pin *//*!<PI[0] pin *//*!<PH[0] pin *//*!<PG[0] pin *//*!<PF[0] pin *//*!<PE[0] pin *//*!<PD[0] pin *//*!<PC[0] pin *//*!<PB[0] pin *//*!<PA[0] pin *//**
  * @brief   EXTI0 configuration
  *//*!<EXTI 3 configuration *//*!<EXTI 2 configuration *//*!<EXTI 1 configuration *//*!<EXTI 0 configuration *//*****************  Bit definition for SYSCFG_EXTICR1 register  ***************//*!<Ethernet PHY interface selection *//*!< Refer to AN4073 on how to use this bit  *//*!< 0x00070000 *//*!< PB9_FMP Fast Mode + Enable *//*!< PB8_FMP Fast Mode + Enable *//*!< PB7_FMP Fast Mode + Enable *//*!< PB6_FMP Fast Mode + Enable *//*!< I2C4_FMP I2C4 Fast Mode + Enable *//*!< I2C3_FMP I2C3 Fast Mode + Enable *//*!< I2C2_FMP I2C2 Fast Mode + Enable *//*!< I2C1_FMP I2C1 Fast Mode + Enable *//******************  Bit definition for SYSCFG_PMC register  ******************//*!< FMC Memory Mapping swapping *//*!< User Flash Bank swap    *//*!< Boot information after Reset *//******************  Bit definition for SYSCFG_MEMRMP register  ***************//*                                 SYSCFG                                     *//*!<Master Clock Output Enable   *//*!<Odd factor for the prescaler *//*!<I2S Linear prescaler         *//******************  Bit definition for SPI_I2SPR register  *******************//*!<Asynchronous start enable                        *//*!<I2S mode selection                                *//*!<I2S Enable                                        *//*!<I2SCFG[1:0] bits (I2S configuration mode)         *//*!<PCM frame synchronization                         *//*!<I2SSTD[1:0] bits (I2S standard selection)         *//*!<steady state clock polarity                       *//*!<DATLEN[1:0] bits (Data length to be transferred)  *//*!<Channel length (number of bits per audio channel) *//******************  Bit definition for SPI_I2SCFGR register  *****************//*!< Tx CRC Register *//******************  Bit definition for SPI_TXCRCR register  ******************//*!< Rx CRC Register *//******************  Bit definition for SPI_RXCRCR register  ******************//*!< CRC polynomial register *//*******************  Bit definition for SPI_CRCPR register  ******************//*!< Data Register *//********************  Bit definition for SPI_DR register  ********************//*!< FIFO Transmission Level   *//*!< FIFO Reception Level      *//*!< 0x00000600 *//*!< TI frame format error     *//*!< Busy flag                 *//*!< Overrun flag              *//*!< Mode fault                *//*!< CRC Error flag            *//*!< Underrun flag             *//*!< Channel side              *//*!< Transmit buffer Empty     *//*!< Receive buffer Not Empty  *//********************  Bit definition for SPI_SR register  ********************//*!< Last DMA transfer for transmission *//*!< Last DMA transfer for reception    *//*!< FIFO reception Threshold           *//*!< DS[3:0] Data Size                    *//*!< Tx buffer Empty Interrupt Enable     *//*!< RX buffer Not Empty Interrupt Enable *//*!< Error Interrupt Enable               *//*!< Frame Format Enable                  *//*!< NSS pulse management Enable          *//*!< SS Output Enable                     *//*!< Tx Buffer DMA Enable                 *//*!< Rx Buffer DMA Enable                 *//*******************  Bit definition for SPI_CR2 register  ********************//*!< Bidirectional data mode enable      *//*!< Output enable in bidirectional mode *//*!< Hardware CRC calculation enable     *//*!< Transmit CRC next                   *//*!< CRC Length                          *//*!< Receive only                        *//*!< Software slave management           *//*!< Internal slave select               *//*!< Frame Format                        *//*!< SPI Enable                          *//*!< BR[2:0] bits (Baud Rate Control)   *//*!< 0x00000038 *//*!< Master Selection                   *//*!< Clock Polarity                     *//*!< Clock Phase                        *//*******************  Bit definition for SPI_CR1 register  ********************//*                        Serial Peripheral Interface (SPI)                   *//*!<Receive and transmit FIFO data *//******************  Bit definition for SDMMC_FIFO register  *******************//*!<Remaining number of words to be written to or read from the FIFO *//*****************  Bit definition for SDMMC_FIFOCNT register  *****************//*!<SDMMC Mode Interrupt Received interrupt Enable *//*!<Data available in Rx FIFO interrupt Enable *//*!<Data available in Tx FIFO interrupt Enable *//*!<Rx FIFO Empty interrupt Enable             *//*!<Tx FIFO Empty interrupt Enable             *//*!<Rx FIFO Full interrupt Enable              *//*!<Tx FIFO Full interrupt Enable              *//*!<Rx FIFO Half Full interrupt Enable         *//*!<Tx FIFO Half Empty interrupt Enable        *//*!<Data receive acting interrupt enabled      *//*!<Data Transmit Acting Interrupt Enable      *//*!<CCommand Acting Interrupt Enable           *//*!<Data Block End Interrupt Enable            *//*!<Data End Interrupt Enable                  *//*!<Command Sent Interrupt Enable              *//*!<Command Response Received Interrupt Enable *//*!<Rx FIFO OverRun Error Interrupt Enable     *//*!<Tx FIFO UnderRun Error Interrupt Enable    *//*!<Data TimeOut Interrupt Enable              *//*!<Command TimeOut Interrupt Enable           *//*!<Data CRC Fail Interrupt Enable             *//*!<Command CRC Fail Interrupt Enable          *//******************  Bit definition for SDMMC_MASK register  *******************//*!<SDMMCIT flag clear bit   *//*!<DBCKEND flag clear bit  *//*!<DATAEND flag clear bit  *//*!<CMDSENT flag clear bit  *//*!<CMDREND flag clear bit  *//*!<RXOVERR flag clear bit  *//*!<TXUNDERR flag clear bit *//*!<DTIMEOUT flag clear bit *//*!<CTIMEOUT flag clear bit *//*!<DCRCFAIL flag clear bit *//*!<CCRCFAIL flag clear bit *//*******************  Bit definition for SDMMC_ICR register  *******************//*!<SDMMC interrupt received                       *//*!<Data available in receive FIFO                *//*!<Data available in transmit FIFO               *//*!<Receive FIFO empty                            *//*!<Transmit FIFO empty                           *//*!<Receive FIFO full                             *//*!<Transmit FIFO full                            *//*!<Receive FIFO Half Full: there are at least 8 words in the FIFO *//*!<Transmit FIFO Half Empty: at least 8 words can be written into the FIFO *//*!<Data receive in progress                      *//*!<Data transmit in progress                     *//*!<Command transfer in progress                  *//*!<Data block sent/received (CRC check passed)   *//*!<Data end (data counter, SDIDCOUNT, is zero)   *//*!<Command sent (no response required)           *//*!<Command response received (CRC check passed)  *//*!<Received FIFO overrun error                   *//*!<Transmit FIFO underrun error                  *//*!<Data timeout                                  *//*!<Command response timeout                      *//*!<Data block sent/received (CRC check failed)   *//*!<Command response received (CRC check failed)  *//******************  Bit definition for SDMMC_STA register  ********************//*!<Data count value *//*!< 0x01FFFFFF *//******************  Bit definition for SDMMC_DCOUNT register  *****************//*!<SD I/O enable functions *//*!<Read wait mode          *//*!<Read wait stop          *//*!<Read wait start         *//*!<DBLOCKSIZE[3:0] bits (Data block size) *//*!<DMA enabled bit                   *//*!<Data transfer mode selection      *//*!<Data transfer direction selection *//*!<Data transfer enabled bit         *//******************  Bit definition for SDMMC_DCTRL register  ******************//*!<Data length value    *//******************  Bit definition for SDMMC_DLEN register  *******************//*!<Data timeout period. *//******************  Bit definition for SDMMC_DTIMER register  *****************//*!<Card Status *//******************  Bit definition for SDMMC_RESP4 register  ******************//******************  Bit definition for SDMMC_RESP3 register  ******************//******************  Bit definition for SDMMC_RESP2 register  ******************//******************  Bit definition for SDMMC_RESP1 register  ******************//******************  Bit definition for SDMMC_RESP0 register  ******************//*!<Response command index *//*****************  Bit definition for SDMMC_RESPCMD register  *****************//*!<SD I/O suspend command                                         *//*!<Command path state machine (CPSM) Enable bit                   *//*!<CPSM Waits for ends of data transfer (CmdPend internal signal) *//*!<CPSM Waits for Interrupt Request                               *//*!<WAITRESP[1:0] bits (Wait for response bits) *//*!<Command Index                               *//*******************  Bit definition for SDMMC_CMD register  *******************//*!<Command argument *//*******************  Bit definition for SDMMC_ARG register  *******************//*!<HW Flow Control enable          *//*!<SDMMC_CK dephasing selection bit *//*!<WIDBUS[1:0] bits (Wide bus mode enable bit) *//*!<Clock divider bypass enable bit *//*!<Power saving configuration bit  *//*!<Clock enable bit                *//*!<Clock divide factor             *//******************  Bit definition for SDMMC_CLKCR register  ******************//*!<PWRCTRL[1:0] bits (Power supply control bits) *//******************  Bit definition for SDMMC_POWER register  ******************//*                          SD host Interface                                 *//*!<Threshold HIGH     *//*!< 0x1FFF0000 *//*!<Threshold LOW      *//*!< 0x000013FF *//*******************  Bit definition for SPDIFRX_DIR register    *******************//*!<Start Of Block                  *//*!<Channel A status information    *//*!<User data information           *//*******************  Bit definition for SPDIFRX_CSR register   *******************//*!<Data value Channel A      *//*!<Data value Channel B      *//*******************  Bit definition for SPDIFRX_DR register  (DRFMT = 0b10 case) *******************//*!<Parity Error bit      *//*!<Validity bit          *//*!<User bit              *//*!<Channel Status bit    *//*!<Preamble Type         *//*!<Data value            *//*!< 0xFFFFFF00 *//*******************  Bit definition for SPDIFRX_DR register  (DRFMT = 0b01 case) *******************//*!< 0x30000000 *//*******************  Bit definition for SPDIFRX_DR register  (DRFMT = 0b00 case) *******************//*!<Clears the Synchronization Done flag                 *//*!<Clears the Synchronization Block Detected flag       *//*!<Clears the Overrun error flag                        *//*!<Clears the Parity error flag                         *//*******************  Bit definition for SPDIFRX_IFCR register  *******************//*!<Duration of 5 symbols counted with spdif_clk          *//*!< 0x7FFF0000 *//*!<Time-out error                                        *//*!<Synchronization error                                 *//*!<Framing error                                         *//*!<Synchronization Done                                  *//*!<Synchronization Block Detected                        *//*!<Overrun error                                         *//*!<Parity error                                          *//*!<The Control Buffer register is not empty              *//*!<Read data register not empty                          *//*******************  Bit definition for SPDIFRX_SR register  *******************//*!<Serial Interface Error Interrupt Enable            *//*!<Synchronization Done                               *//*!<Synchronization Block Detected Interrupt Enable    *//*!<Overrun error Interrupt Enable                     *//*!<Parity error interrupt enable                      *//*!<Control Buffer Ready Interrupt Enable              *//*!<RXNE interrupt enable                              *//*******************  Bit definition for SPDIFRX_IMR register  *******************//*!<SPDIF input selection *//*!<Wait For Activity     *//*!<Maximum allowed re-tries during synchronization phase *//*!<Channel Selection                            *//*!<Control Buffer DMA ENable for control flow   *//*!<Mask of Preamble Type bits                   *//*!<Mask of channel status and user bits         *//*!<Mask of Validity bit                         *//*!<Mask Parity error bit                        *//*!<RX Data format                               *//*!<Stereo Mode                                  *//*!<Receiver DMA Enable for data flow            *//*!<Peripheral Block Enable                      *//********************  Bit definition for SPDIF_CR register  *******************//*                              SPDIF-RX Interface                            *//******************  Bit definition for SAI_xDR register  *********************//*!<Clear Late frame synchronization detection           *//*!<Clear Anticipated frame synchronization detection    *//*!<Clear Codec not ready                                *//*!<Clear FIFO request                                   *//*!<Clear Wrong Clock Configuration                      *//*!<Clear Mute detection                                 *//*!<Clear Overrun underrun                               *//******************  Bit definition for SAI_xCLRFR register  ******************//*!<FLVL[2:0] (FIFO Level Threshold)               *//*!<Late frame synchronization detection           *//*!<Anticipated frame synchronization detection    *//*!<Codec not ready                                *//*!<FIFO request                                   *//*!<Wrong Clock Configuration                      *//*!<Mute detection                                 *//*!<Overrun underrun                               *//********************  Bit definition for SAI_xSR register  *******************//*!<Late frame synchronization detection interrupt enable          *//*!<Anticipated frame synchronization detection interrupt enable   *//*!<Codec not ready interrupt enable                               *//*!<FIFO request interrupt enable                                  *//*!<Wrong Clock Configuration interrupt enable                     *//*!<Mute detection interrupt enable                                *//*!<Overrun underrun interrupt enable                              *//*******************  Bit definition for SAI_xIMR register  *******************//*!<SLOTEN[15:0] (Slot Enable)  *//*!<NBSLOT[3:0] (Number of Slot in audio Frame)  *//*!<SLOTSZ[1:0] (Slot size)  *//*!<FRL[4:0](First Bit Offset)  *//******************  Bit definition for SAI_xSLOTR register  *******************//*!<Frame Synchronization OFFset      *//*!<Frame Synchronization POLarity    *//*!<Frame Synchronization Definition  *//*!<FRL[6:0] (Frame synchronization active level length)  *//*!< 0x00007F00 *//*!<FRL[7:0](Frame length)  *//******************  Bit definition for SAI_xFRCR register  *******************//*!<COMP[1:0] (Companding mode) *//*!< Complement Bit             *//*!<MUTECNT[5:0] (MUTE counter) *//*!< 0x00001F80 *//*!<Muate value                      *//*!<Mute mode                        *//*!<TRIState Management on data line *//*!<Fifo FLUSH                       *//*!<FTH[2:0](Fifo THreshold)  *//*******************  Bit definition for SAI_xCR2 register  *******************//*!<MCKDIV[3:0] (Master ClocK Divider)  *//*!<No Divider Configuration   *//*!<DMA enable                 *//*!<Audio Block enable         *//*!<Output Drive               *//*!<Mono mode                  *//*!<SYNCEN[1:0](SYNChronization ENable) *//*!<ClocK STRobing edge      *//*!<LSB First Configuration  *//*!<DS[1:0] bits (Data Size) *//*!< 0x000000E0 *//*!<PRTCFG[1:0] bits (Protocol Configuration)   *//*!<MODE[1:0] bits (Audio Block Mode)           *//*******************  Bit definition for SAI_xCR1 register  *******************//*!<SYNCOUT[1:0] bits (Synchronization Outputs) *//*!<SYNCIN[1:0] bits (Synchronization Inputs)   *//********************  Bit definition for SAI_GCR register  *******************//*                          Serial Audio Interface                            *//******************** Number of backup registers ******************************//********************  Bits definition for RTC_BKP31R register  ***************//********************  Bits definition for RTC_BKP30R register  ***************//********************  Bits definition for RTC_BKP29R register  ***************//********************  Bits definition for RTC_BKP28R register  ***************//********************  Bits definition for RTC_BKP27R register  ***************//********************  Bits definition for RTC_BKP26R register  ***************//********************  Bits definition for RTC_BKP25R register  ***************//********************  Bits definition for RTC_BKP24R register  ***************//********************  Bits definition for RTC_BKP23R register  ***************//********************  Bits definition for RTC_BKP22R register  ***************//********************  Bits definition for RTC_BKP21R register  ***************//********************  Bits definition for RTC_BKP20R register  ***************//********************  Bits definition for RTC_BKP19R register  ***************//********************  Bits definition for RTC_BKP18R register  ***************//********************  Bits definition for RTC_BKP17R register  ***************//********************  Bits definition for RTC_BKP16R register  ***************//********************  Bits definition for RTC_BKP15R register  ***************//********************  Bits definition for RTC_BKP14R register  ***************//********************  Bits definition for RTC_BKP13R register  ***************//********************  Bits definition for RTC_BKP12R register  ***************//********************  Bits definition for RTC_BKP11R register  ***************//********************  Bits definition for RTC_BKP10R register  ***************//********************  Bits definition for RTC_BKP9R register  ****************//********************  Bits definition for RTC_BKP8R register  ****************//********************  Bits definition for RTC_BKP7R register  ****************//********************  Bits definition for RTC_BKP6R register  ****************//********************  Bits definition for RTC_BKP5R register  ****************//********************  Bits definition for RTC_BKP4R register  ****************//********************  Bits definition for RTC_BKP3R register  ****************//********************  Bits definition for RTC_BKP2R register  ****************//********************  Bits definition for RTC_BKP1R register  ****************//********************  Bits definition for RTC_BKP0R register  ****************//* Legacy defines*//********************  Bits definition for RTC_OR register  ****************//*!< 0x0F000000 *//********************  Bits definition for RTC_ALRMBSSR register  *************//********************  Bits definition for RTC_ALRMASSR register  *************//*!< 0x00000700 *//********************  Bits definition for RTC_TAMPCR register  ****************//********************  Bits definition for RTC_CAL register  *****************//********************  Bits definition for RTC_TSSSR register  ****************//********************  Bits definition for RTC_TSDR register  *****************//*!< 0x00007000 *//********************  Bits definition for RTC_TSTR register  *****************//********************  Bits definition for RTC_SHIFTR register  ***************//********************  Bits definition for RTC_SSR register  ******************//********************  Bits definition for RTC_WPR register  ******************//********************  Bits definition for RTC_ALRMBR register  ***************//********************  Bits definition for RTC_ALRMAR register  ***************//********************  Bits definition for RTC_WUTR register  *****************//*!< 0x007F0000 *//********************  Bits definition for RTC_PRER register  *****************//********************  Bits definition for RTC_ISR register  ******************//********************  Bits definition for RTC_CR register  *******************//********************  Bits definition for RTC_DR register  *******************//********************  Bits definition for RTC_TR register  *******************//*                           Real-Time Clock (RTC)                            *//********************  Bits definition for RNG_SR register  *******************//********************  Bits definition for RNG_CR register  *******************//*                                    RNG                                     *//*!< 0x00C00000 *//********************  Bit definition for RCC_DCKCFGR2 register  ***************//********************  Bit definition for RCC_DCKCFGR1 register  ***************//*!< 0x70000000 *//*!< 0x00007FC0 *//********************  Bit definition for RCC_PLLSAICFGR register  ************//********************  Bit definition for RCC_PLLI2SCFGR register  ************//*!< 0x0FFFE000 *//********************  Bit definition for RCC_SSCGR register  *****************//********************  Bit definition for RCC_CSR register  *******************//********************  Bit definition for RCC_BDCR register  ******************//********************  Bit definition for RCC_APB2LPENR register  *************//********************  Bit definition for RCC_APB1LPENR register  *************//********************  Bit definition for RCC_AHB3LPENR register  *************//********************  Bit definition for RCC_AHB2LPENR register  *************//********************  Bit definition for RCC_AHB1LPENR register  *************//********************  Bit definition for RCC_APB2ENR register  ***************//********************  Bit definition for RCC_APB1ENR register  ***************//********************  Bit definition for RCC_AHB3ENR register  ***************//********************  Bit definition for RCC_AHB2ENR register  ***************//********************  Bit definition for RCC_AHB1ENR register  ***************//********************  Bit definition for RCC_APB2RSTR register  **************//********************  Bit definition for RCC_APB1RSTR register  **************//********************  Bit definition for RCC_AHB3RSTR register  **************//********************  Bit definition for RCC_AHB2RSTR register  **************//********************  Bit definition for RCC_AHB1RSTR register  **************//********************  Bit definition for RCC_CIR register  *******************//*!< 0xC0000000 *//*!< 0x38000000 *//*!< 0x07000000 *//*!< MCO1 configuration *//*!< RTCPRE configuration *//*!< HCLK divided by 16 *//*!< HCLK divided by 8 *//*!< HCLK divided by 4 *//*!< HCLK divided by 2 *//*!< HCLK not divided *//*!< PRE2[2:0] bits (APB2 prescaler) *//*!< PPRE2 configuration *//*!< PRE1[2:0] bits (APB1 prescaler) *//*!< 0x00001C00 *//*!< PPRE1 configuration *//*!< SYSCLK divided by 512 *//*!< SYSCLK divided by 256 *//*!< SYSCLK divided by 128 *//*!< SYSCLK divided by 64 *//*!< SYSCLK divided by 16 *//*!< SYSCLK divided by 8 *//*!< SYSCLK divided by 4 *//*!< SYSCLK divided by 2 *//*!< SYSCLK not divided *//*!< HPRE[3:0] bits (AHB prescaler) *//*!< HPRE configuration *//*!< PLL used as system clock *//*!< HSE oscillator used as system clock *//*!< HSI oscillator used as system clock *//*!< SWS[1:0] bits (System Clock Switch Status) *//*!< SWS configuration *//*!< PLL selected as system clock *//*!< HSE selected as system clock *//*!< HSI selected as system clock *//*!< SW[1:0] bits (System clock Switch) *//*!< SW configuration *//********************  Bit definition for RCC_CFGR register  ******************//********************  Bit definition for RCC_PLLCFGR register  ***************//*!< 0x000000F8 *//********************  Bit definition for RCC_CR register  ********************//*                         Reset and Clock Control            *//*!< TIMEOUT[15:0]: Timeout period *//******************  Bit definition for QUADSPI_LPTR register  *****************//*!< INTERVAL[15:0]: Polling Interval *//******************  Bit definition for QUADSPI_PIR register  *****************//*!< MATCH[31:0]: Status Match *//******************  Bit definition for QUADSPI_PSMAR register  ****************//*!< MASK[31:0]: Status Mask *//******************  Bit definition for QUADSPI_PSMKR register  ****************//*!< DATA[31:0]: Data *//******************  Bit definition for QUADSPI_DR register  *******************//*!< ALTERNATE[31:0]: Alternate Bytes *//******************  Bit definition for QUADSPI_ABR register  ******************//*!< ADDRESS[31:0]: Address *//******************  Bit definition for QUADSPI_AR register  *******************//*!< DDRM: Double Data Rate Mode           *//*!< DHHC: Delay Half Hclk Cycle           *//*!< SIOO: Send Instruction Only Once Mode *//*!< FMODE[1:0]: Functional Mode        *//*!< 0x0C000000 *//*!< DMODE[1:0]: Data Mode              *//*!< DCYC[4:0]: Dummy Cycles           *//*!< 0x007C0000 *//*!< ABSIZE[1:0]: Instruction Mode     *//*!< ABMODE[1:0]: Alternate Bytes Mode *//*!< ADSIZE[1:0]: Address Size         *//*!< ADMODE[1:0]: Address Mode         *//*!< IMODE[1:0]: Instruction Mode      *//*!< INSTRUCTION[7:0]: Instruction    *//******************  Bit definition for QUADSPI_CCR register  ******************//*!< DL[31:0]: Data Length *//******************  Bit definition for QUADSPI_DLR register  ******************//*!< Clear Timeout Flag           *//*!< Clear Status Match Flag      *//*!< Clear Transfer Complete Flag *//*!< Clear Transfer Error Flag    *//******************  Bit definition for QUADSPI_FCR register  ******************//*!< FIFO Threshlod Flag    *//*!< Busy                   *//*!< Timeout Flag           *//*!< Status Match Flag      *//*!< Transfer Complete Flag *//*!< Transfer Error Flag    *//******************  Bit definition for QUADSPI_SR register  *******************//*!< FSIZE[4:0]: Flash Size          *//*!< CSHT[2:0]: ChipSelect High Time *//*!< Mode 0 / Mode 3                 *//*****************  Bit definition for QUADSPI_DCR register  ******************//*!< PRESCALER[7:0] Clock prescaler     *//*!< Polling Match Mode                 *//*!< Bit 1                              *//*!< TimeOut Interrupt Enable           *//*!< Status Match Interrupt Enable      *//*!< FIFO Threshold Interrupt Enable    *//*!< Transfer Complete Interrupt Enable *//*!< Transfer Error Interrupt Enable    *//*!< FTHRES[4:0] FIFO Level            *//*!< Flash Select                      *//*!< Dual Flash Mode                   *//*!< Sample Shift                      *//*!< Timeout Counter Enable            *//*!< DMA Enable                        *//*!< Abort request                     *//*!< Enable                            *//*****************  Bit definition for QUADSPI_CR register  *******************//*                                    QUADSPI                                 *//*!< Enable Wakeup Pin PI11             *//*!< Enable Wakeup Pin PI8              *//*!< Enable Wakeup Pin PC13             *//*!< Enable Wakeup Pin PC1              *//*!< Enable Wakeup Pin PA2              *//*!< Enable Wakeup Pin PA0              *//*!< Wakeup Pin Flag for PI11           *//*!< Wakeup Pin Flag for PI8            *//*!< Wakeup Pin Flag for PC13           *//*!< Wakeup Pin Flag for PC1            *//*!< Wakeup Pin Flag for PA2            *//*!< Wakeup Pin Flag for PA0            *//*******************  Bit definition for PWR_CSR2 register  ********************//*!< Wakeup Pin Polarity bit for PI11   *//*!< Wakeup Pin Polarity bit for PI8    *//*!< Wakeup Pin Polarity bit for PC13   *//*!< Wakeup Pin Polarity bit for PC1    *//*!< Wakeup Pin Polarity bit for PA2    *//*!< Wakeup Pin Polarity bit for PA0    *//*!< Clear Wakeup Pin Flag for PI11     *//*!< Clear Wakeup Pin Flag for PI8      *//*!< Clear Wakeup Pin Flag for PC13     *//*!< Clear Wakeup Pin Flag for PC1      *//*!< Clear Wakeup Pin Flag for PA2      *//*!< Clear Wakeup Pin Flag for PA0      *//********************  Bit definition for PWR_CR2 register  ********************//*!< Under Drive ready                                *//*!< Over Drive Switch ready                          *//*!< Over Drive generator ready                       *//*!< Regulator voltage scaling output selection ready *//*!< Backup regulator enable                          *//*!< Enable internal wakeup                           *//*!< Backup regulator ready                           *//*!< PVD Output                                       *//*!< Standby Flag                                     *//*!< Wake up internal Flag                            *//*******************  Bit definition for PWR_CSR1 register  ********************//*!< Under Drive enable in stop mode     *//*!< Over Drive switch enabled           *//*!< Over Drive enable                   *//*!< VOS[1:0] bits (Regulator voltage scaling output selection) *//*!< Refer to AN4073 on how to use this bit *//*!< Main regulator in deepsleep under-drive mode               *//*!< Low-power regulator in deepsleep under-drive mode          *//*!< Flash power down in Stop mode                              *//*!< Disable Backup Domain write protection                     *//*!< PVD level 7 *//*!< PVD level 6 *//*!< PVD level 5 *//*!< 0x000000A0 *//*!< PVD level 4 *//*!< PVD level 3 *//*!< PVD level 2 *//*!< PVD level 1 *//*!< PVD level 0 *//*!< PVD level configuration *//*!< PLS[2:0] bits (PVD Level Selection) *//*!< Power Voltage Detector Enable       *//*!< Clear Standby Flag                  *//*!< Power Down Deepsleep                *//*!< Low-Power Deepsleep                 *//********************  Bit definition for PWR_CR1 register  ********************//*                             Power Control                                  *//*!< CLUT address *//*!< Red value    *//*!< Green value  *//*!< Blue value   *//********************  Bit definition for LTDC_LxCLUTWR register  *************//*!< Frame Buffer Line Number *//********************  Bit definition for LTDC_LxCFBLNR register  *************//*!< Color Frame Buffer Pitch in bytes *//*!< Color Frame Buffer Line Length    *//********************  Bit definition for LTDC_LxCFBLR register  **************//*!< Color Frame Buffer Start Address *//********************  Bit definition for LTDC_LxCFBAR register  **************//*!< Blending Factor 1 *//*!< Blending Factor 2 *//********************  Bit definition for LTDC_LxBFCR register  ***************//*!< Default Color Alpha *//*!< Default Color Red   *//*!< Default Color Green *//*!< Default Color Blue  *//********************  Bit definition for LTDC_LxDCCR register  ***************//*!< Constant Alpha *//********************  Bit definition for LTDC_LxCACR register  ***************//*!< Pixel Format *//********************  Bit definition for LTDC_LxPFCR register  ***************//*!< Color Key Red value   *//*!< Color Key Green value *//*!< Color Key Blue value  *//********************  Bit definition for LTDC_LxCKCR register  ***************//*!< Window Vertical Stop Position  *//*!< Window Vertical Start Position *//********************  Bit definition for LTDC_LxWVPCR register  **************//*!< Window Horizontal Stop Position  *//*!< Window Horizontal Start Position *//********************  Bit definition for LTDC_LxWHPCR register  **************//*!< Color Lockup Table Enable *//*!< Color Keying Enable       *//*!< Layer Enable              *//********************  Bit definition for LTDC_LxCR register  *****************//*!< Horizontal Synchronization Status *//*!< Vertical Synchronization Status   *//*!< Horizontal Data Enable Status     *//*!< Vertical Data Enable Status       *//********************  Bit definition for LTDC_CDSR register  *****************//*!< Current X Position *//*!< Current Y Position *//********************  Bit definition for LTDC_CPSR register  *****************//*!< Line Interrupt Position *//********************  Bit definition for LTDC_LIPCR register  ****************//*!< Clears Register Reload interrupt Flag *//*!< Clears the Transfer Error Interrupt Flag *//*!< Clears the FIFO Underrun Interrupt Flag *//*!< Clears the Line Interrupt Flag *//********************  Bit definition for LTDC_ICR register  ******************//*!< Register Reload interrupt Flag *//*!< Transfer Error Interrupt Flag *//*!< FIFO Underrun Interrupt Flag *//*!< Line Interrupt Flag *//********************  Bit definition for LTDC_ISR register  ******************//*!< Register Reload interrupt enable *//*!< Transfer Error Interrupt Enable  *//*!< FIFO Underrun Interrupt Enable   *//*!< Line Interrupt Enable            *//********************  Bit definition for LTDC_IER register  ******************//*!< Background Red value   *//*!< Background Green value *//*!< Background Blue value  *//********************  Bit definition for LTDC_BCCR register  *****************//*!< Vertical Blanking Reload *//*!< Immediate Reload         *//********************  Bit definition for LTDC_SRCR register  *****************//*!< Horizontal Synchronization Polarity *//*!< Vertical Synchronization Polarity   *//*!< Data Enable Polarity                *//*!< Pixel Clock Polarity                *//*!< Dither Enable                       *//*!< Dither Red Width                    *//*!< Dither Green Width                  *//*!< Dither Blue Width                   *//*!< LCD-TFT controller enable bit       *//********************  Bit definition for LTDC_GCR register  ******************//*!< Total Width *//*!< 0x0FFF0000 *//*!< Total Heigh *//********************  Bit definition for LTDC_TWCR register  *****************//*!< Accumulated Active Width *//*!< Accumulated Active height *//********************  Bit definition for LTDC_AWCR register  *****************//*!< Accumulated Horizontal Back Porch *//*!< Accumulated Vertical Back Porch   *//********************  Bit definition for LTDC_BPCR register  *****************//*!< Horizontal Synchronization Width *//*!< Vertical Synchronization Height  *//********************  Bit definition for LTDC_SSCR register  *****************//*                      LCD-TFT Display Controller (LTDC)                     *//*!< Watchdog counter window value *//*******************  Bit definition for IWDG_KR register  ********************//*!< Watchdog counter window value update *//*!< Watchdog counter reload value update *//*!< Watchdog prescaler value update *//*******************  Bit definition for IWDG_SR register  ********************//*!<Watchdog counter reload value        *//*******************  Bit definition for IWDG_RLR register  *******************//*!<PR[2:0] (Prescaler divider)         *//*******************  Bit definition for IWDG_PR register  ********************//*!<Key value (write only, read 0000h)  *//*                           Independent WATCHDOG                             *//*!< 8-bit transmit data *//******************  Bit definition for I2C_TXDR register  *********************//*!< 8-bit receive data  *//******************  Bit definition for I2C_RXDR register  *********************//*!< PEC register        *//******************  Bit definition for I2C_PECR register  *********************//*!< Alert clear flag                *//*!< Timeout clear flag              *//*!< PAC error clear flag            *//*!< Overrun/Underrun clear flag     *//*!< Arbitration lost clear flag     *//*!< Bus error clear flag            *//*!< STOP detection clear flag       *//*!< NACK clear flag                 *//*!< Address matched clear flag      *//******************  Bit definition for I2C_ICR register  *********************//*!< Address match code (slave mode) *//*!< 0x00FE0000 *//*!< Transfer direction (slave mode) *//*!< Bus busy                        *//*!< SMBus alert                     *//*!< Timeout or Tlow detection flag  *//*!< PEC error in reception          *//*!< Overrun/Underrun                *//*!< Arbitration lost                *//*!< Bus error                       *//*!< Transfer complete reload        *//*!< Transfer complete (master mode) *//*!< STOP detection flag             *//*!< NACK received flag              *//*!< Address matched (slave mode)    *//*!< Receive data register not empty *//*!< Transmit interrupt status       *//*!< Transmit data register empty    *//******************  Bit definition for I2C_ISR register  *********************//*!< Extended clock timeout enable *//*!< Bus timeout B                 *//*!< Clock timeout enable          *//*!< Idle clock timeout detection  *//*!< Bus timeout A                 *//******************* Bit definition for I2C_TIMEOUTR register *******************//*!< Timings prescaler             *//*!< 0xF0000000 *//*!< Data setup time               *//*!< Data hold time                *//*!< SCL high period (master mode) *//*!< SCL low period (master mode)  *//*******************  Bit definition for I2C_TIMINGR register *******************//*!< Own address 2 enable    *//*!< OA2[7:1] is masked, No comparison is done *//*!< OA2[6:1] is masked, Only OA2[7] are compared *//*!< OA2[5:1] is masked, Only OA2[7:6] are compared *//*!< 0x00000500 *//*!< OA2[4:1] is masked, Only OA2[7:5] are compared *//*!< OA2[3:1] is masked, Only OA2[7:4] are compared *//*!< OA2[2:1] is masked, Only OA2[7:3] are compared *//*!< OA2[1] is masked, Only OA2[7:2] are compared *//*!< No mask *//*!< Own address 2 masks     *//*!< Interface own address 2 *//*!< 0x000000FE *//*******************  Bit definition for I2C_OAR2 register  ******************//*!< Own address 1 enable      *//*!< Own address 1 10-bit mode *//*!< Interface own address 1   *//*******************  Bit definition for I2C_OAR1 register  ******************//*!< Packet error checking byte                              *//*!< Automatic end mode (master mode)                        *//*!< NBYTES reload mode                                      *//*!< Number of bytes                                         *//*!< NACK generation (slave mode)                            *//*!< STOP generation (master mode)                           *//*!< START generation                                        *//*!< 10-bit address header only read direction (master mode) *//*!< 10-bit addressing mode (master mode)                    *//*!< Transfer direction (master mode)                        *//*!< Slave address (master mode)                             *//******************  Bit definition for I2C_CR2 register  ********************//*!< PEC enable                          *//*!< SMBus alert enable                  *//*!< SMBus device default address enable *//*!< SMBus host address enable           *//*!< General call enable                 *//*!< Clock stretching disable            *//*!< Slave byte control                  *//*!< DMA reception requests enable       *//*!< DMA transmission requests enable    *//*!< Analog noise filter OFF             *//*!< Digital noise filter                *//*!< Errors interrupt enable             *//*!< Transfer complete interrupt enable  *//*!< STOP detection interrupt enable     *//*!< NACK received interrupt enable      *//*!< Address match interrupt enable      *//*!< RX interrupt enable                 *//*!< TX interrupt enable                 *//*!< Peripheral enable                   *//*******************  Bit definition for I2C_CR1 register  *******************//*                      Inter-integrated Circuit Interface (I2C)              *//****************** Bit definition for GPIO_AFRH register *********************//****************** Bit definition for GPIO_AFRL register *********************//****************** Bit definition for GPIO_LCKR register *********************//******************  Bits definition for GPIO_BSRR register  ******************//******************  Bits definition for GPIO_ODR register  *******************//******************  Bits definition for GPIO_IDR register  *******************//******************  Bits definition for GPIO_PUPDR register  *****************//* legacy defines *//******************  Bits definition for GPIO_OSPEEDR register  ***************//******************  Bits definition for GPIO_OTYPER register  ****************//******************  Bits definition for GPIO_MODER register  *****************//*                            General Purpose I/O                             *//*!<Busy status *//*!<MODES2[1:0]bits (Status mode for bank 2) *//*!<MODES1[1:0]bits (Status mode for bank 1) *//*!<Refresh error flag *//******************  Bit definition for FMC_SDSR register  ******************//*!<RES interrupt enable *//*!<COUNT[12:0] bits (Refresh timer count) *//*!< 0x00003FFE *//*!<Clear refresh error flag *//******************  Bit definition for FMC_SDRTR register  ******************//*!<MRD[12:0] bits (Mode register definition) *//*!< 0x003FFE00 *//*!<NRFS[3:0] bits (Number of auto-refresh) *//*!< 0x000001E0 *//*!<Command target 1 *//*!<Command target 2 *//*!<MODE[2:0] bits (Command mode) *//******************  Bit definition for FMC_SDCMR register  ******************//*!<TRP[2:0] bits (Row to column delay) *//*!<TRP[2:0] bits (Row precharge delay) *//*!<TRC[2:0] bits (Write recovery delay) *//*!<TRC[2:0] bits (Row cycle delay) *//*!<TRAS[3:0] bits (Self refresh time) *//*!<TXSR[3:0] bits (Exit self refresh) *//*!<TMRD[3:0] bits (Load mode register to active) *//******************  Bit definition for FMC_SDTR2 register  ******************//******************  Bit definition for FMC_SDTR1 register  ******************//*!<RPIPE[1:0](Read pipe) *//*!<Read burst *//*!<SDCLK[1:0] (SDRAM clock configuration) *//*!<Write protection *//*!<CAS[1:0] bits (CAS latency) *//*!<Number of internal bank *//*!<NR[1:0] bits (Number of row bits) *//*!<NC[1:0] bits (Number of column bits) *//******************  Bit definition for FMC_SDCR2 register  ******************//*!<SDRAM clock configuration *//******************  Bit definition for FMC_SDCR1 register  ******************//*!<ECC result *//******************  Bit definition for FMC_ECCR register  ******************//*!<ATTHIZ3[7:0] bits (Attribute memory 3 databus HiZ time) *//*!<ATTHOLD3[7:0] bits (Attribute memory 3 hold time) *//*!<ATTWAIT3[7:0] bits (Attribute memory 3 wait time) *//*!<ATTSET3[7:0] bits (Attribute memory 3 setup time) *//******************  Bit definition for FMC_PATT register  ******************//*!<MEMHIZ3[7:0] bits (Common memory 3 databus HiZ time) *//*!<MEMHOLD3[7:0] bits (Common memory 3 hold time) *//*!<MEMWAIT3[7:0] bits (Common memory 3 wait time) *//*!<MEMSET3[7:0] bits (Common memory 3 setup time) *//******************  Bit definition for FMC_PMEM register  ******************//*!<FIFO empty                                  *//*!<Interrupt Falling Edge detection Enable bit *//*!<Interrupt Level detection Enable bit        *//*!<Interrupt Rising Edge detection Enable bit  *//*!<Interrupt Falling Edge status               *//*!<Interrupt Level status                      *//*!<Interrupt Rising Edge status                *//*******************  Bit definition for FMC_SR register  *******************//*!<ECCPS[2:0] bits (ECC page size)           *//*!<TAR[3:0] bits (ALE to RE delay)           *//*!<TCLR[3:0] bits (CLE to RE delay)          *//*!< 0x00001E00 *//*!<ECC computation logic enable bit          *//*!<PWID[1:0] bits (NAND Flash databus width) *//*!<Memory type                               *//*!<PC Card/NAND Flash memory bank enable bit *//*!<Wait feature enable bit                   *//******************  Bit definition for FMC_PCR register  *******************//*!<ACCMOD[1:0] bits (Access mode) *//*!<BUSTURN[3:0] bits (Bus turnaround phase duration) *//*!<DATAST [3:0] bits (Data-phase duration) *//*!<ADDHLD[3:0] bits (Address-hold phase duration) *//*!<ADDSET[3:0] bits (Address setup phase duration) *//******************  Bit definition for FMC_BWTR4 register  ******************//******************  Bit definition for FMC_BWTR3 register  ******************//******************  Bit definition for FMC_BWTR2 register  ******************//******************  Bit definition for FMC_BWTR1 register  ******************//*!<DATLA[3:0] bits (Data latency) *//*!<CLKDIV[3:0] bits (Clock divide ratio) *//******************  Bit definition for FMC_BTR4 register  *******************//*******************  Bit definition for FMC_BTR3 register  *******************//******************  Bit definition for FMC_BTR2 register  *******************//*!<ADDHLD[3:0] bits (Address-hold phase duration)  *//******************  Bit definition for FMC_BTR1 register  ******************//*!<Write burst enable         *//*!<CRAM page size             *//*!<Asynchronous wait          *//*!<Extended mode enable       *//*!<Wait enable bit            *//*!<Write enable bit           *//*!<Wait timing configuration  *//*!<Wrapped burst mode support *//*!<Wait signal polarity bit   *//*!<Burst enable bit           *//*!<Flash access enable        *//*!<MWID[1:0] bits (Memory data bus width) *//*!<MTYP[1:0] bits (Memory type)           *//*!<Address/data multiplexing enable bit   *//*!<Memory bank enable bit                 *//******************  Bit definition for FMC_BCR4 register  *******************//******************  Bit definition for FMC_BCR3 register  *******************//******************  Bit definition for FMC_BCR2 register  *******************//*!<Write FIFO Disable         *//*!<Continuous clock enable     *//******************  Bit definition for FMC_BCR1 register  *******************//*                          Flexible Memory Controller                        *//*******************  Bits definition for FLASH_OPTCR1 register  ***************//*******************  Bits definition for FLASH_OPTCR register  ***************//*******************  Bits definition for FLASH_CR register  ******************//*******************  Bits definition for FLASH_SR register  ******************//*******************  Bits definition for FLASH_ACR register  *****************//*
* @brief FLASH Total Sectors Number
*//*                                    FLASH                                   *//*!< Pending bit for line 24 *//*!< Pending bit for line 23 *//*!< Pending bit for line 22 *//*!< Pending bit for line 21 *//*!< Pending bit for line 20 *//*!< Pending bit for line 19 *//*!< Pending bit for line 18 *//*!< Pending bit for line 17 *//*!< Pending bit for line 16 *//*!< Pending bit for line 15 *//*!< Pending bit for line 14 *//*!< Pending bit for line 13 *//*!< Pending bit for line 12 *//*!< Pending bit for line 11 *//*!< Pending bit for line 10 *//*!< Pending bit for line 9 *//*!< Pending bit for line 8 *//*!< Pending bit for line 7 *//*!< Pending bit for line 6 *//*!< Pending bit for line 5 *//*!< Pending bit for line 4 *//*!< Pending bit for line 3 *//*!< Pending bit for line 2 *//*!< Pending bit for line 1 *//*!< Pending bit for line 0 *//*******************  Bit definition for EXTI_PR register  ********************//*!< Software Interrupt on line 24 *//*!< Software Interrupt on line 23 *//*!< Software Interrupt on line 22 *//*!< Software Interrupt on line 21 *//*!< Software Interrupt on line 20 *//*!< Software Interrupt on line 19 *//*!< Software Interrupt on line 18 *//*!< Software Interrupt on line 17 *//*!< Software Interrupt on line 16 *//*!< Software Interrupt on line 15 *//*!< Software Interrupt on line 14 *//*!< Software Interrupt on line 13 *//*!< Software Interrupt on line 12 *//*!< Software Interrupt on line 11 *//*!< Software Interrupt on line 10 *//*!< Software Interrupt on line 9 *//*!< Software Interrupt on line 8 *//*!< Software Interrupt on line 7 *//*!< Software Interrupt on line 6 *//*!< Software Interrupt on line 5 *//*!< Software Interrupt on line 4 *//*!< Software Interrupt on line 3 *//*!< Software Interrupt on line 2 *//*!< Software Interrupt on line 1 *//*!< Software Interrupt on line 0 *//******************  Bit definition for EXTI_SWIER register  ******************//*!< Falling trigger event configuration bit of line 24 *//*!< Falling trigger event configuration bit of line 23 *//*!< Falling trigger event configuration bit of line 22 *//*!< Falling trigger event configuration bit of line 21 *//*!< Falling trigger event configuration bit of line 20 *//*!< Falling trigger event configuration bit of line 19 *//*!< Falling trigger event configuration bit of line 18 *//*!< Falling trigger event configuration bit of line 17 *//*!< Falling trigger event configuration bit of line 16 *//*!< Falling trigger event configuration bit of line 15 *//*!< Falling trigger event configuration bit of line 14 *//*!< Falling trigger event configuration bit of line 13 *//*!< Falling trigger event configuration bit of line 12 *//*!< Falling trigger event configuration bit of line 11 *//*!< Falling trigger event configuration bit of line 10 *//*!< Falling trigger event configuration bit of line 9 *//*!< Falling trigger event configuration bit of line 8 *//*!< Falling trigger event configuration bit of line 7 *//*!< Falling trigger event configuration bit of line 6 *//*!< Falling trigger event configuration bit of line 5 *//*!< Falling trigger event configuration bit of line 4 *//*!< Falling trigger event configuration bit of line 3 *//*!< Falling trigger event configuration bit of line 2 *//*!< Falling trigger event configuration bit of line 1 *//*!< Falling trigger event configuration bit of line 0 *//******************  Bit definition for EXTI_FTSR register  *******************//*!< Rising trigger event configuration bit of line 24 *//*!< Rising trigger event configuration bit of line 23 *//*!< Rising trigger event configuration bit of line 22 *//*!< Rising trigger event configuration bit of line 21 *//*!< Rising trigger event configuration bit of line 20 *//*!< Rising trigger event configuration bit of line 19 *//*!< Rising trigger event configuration bit of line 18 *//*!< Rising trigger event configuration bit of line 17 *//*!< Rising trigger event configuration bit of line 16 *//*!< Rising trigger event configuration bit of line 15 *//*!< Rising trigger event configuration bit of line 14 *//*!< Rising trigger event configuration bit of line 13 *//*!< Rising trigger event configuration bit of line 12 *//*!< Rising trigger event configuration bit of line 11 *//*!< Rising trigger event configuration bit of line 10 *//*!< Rising trigger event configuration bit of line 9 *//*!< Rising trigger event configuration bit of line 8 *//*!< Rising trigger event configuration bit of line 7 *//*!< Rising trigger event configuration bit of line 6 *//*!< Rising trigger event configuration bit of line 5 *//*!< Rising trigger event configuration bit of line 4 *//*!< Rising trigger event configuration bit of line 3 *//*!< Rising trigger event configuration bit of line 2 *//*!< Rising trigger event configuration bit of line 1 *//*!< Rising trigger event configuration bit of line 0 *//******************  Bit definition for EXTI_RTSR register  *******************//* Reference Defines *//*!< Event Mask on line 24 *//*!< Event Mask on line 23 *//*!< Event Mask on line 22 *//*!< Event Mask on line 21 *//*!< Event Mask on line 20 *//*!< Event Mask on line 19 *//*!< Event Mask on line 18 *//*!< Event Mask on line 17 *//*!< Event Mask on line 16 *//*!< Event Mask on line 15 *//*!< Event Mask on line 14 *//*!< Event Mask on line 13 *//*!< Event Mask on line 12 *//*!< Event Mask on line 11 *//*!< Event Mask on line 10 *//*!< Event Mask on line 9 *//*!< Event Mask on line 8 *//*!< Event Mask on line 7 *//*!< Event Mask on line 6 *//*!< Event Mask on line 5 *//*!< Event Mask on line 4 *//*!< Event Mask on line 3 *//*!< Event Mask on line 2 *//*!< Event Mask on line 1 *//*!< Event Mask on line 0 *//*******************  Bit definition for EXTI_EMR register  *******************//*!< Interrupt Mask All *//*!< Interrupt Mask on line 24 *//*!< Interrupt Mask on line 23 *//*!< Interrupt Mask on line 22 *//*!< Interrupt Mask on line 21 *//*!< Interrupt Mask on line 20 *//*!< Interrupt Mask on line 19 *//*!< Interrupt Mask on line 18 *//*!< Interrupt Mask on line 17 *//*!< Interrupt Mask on line 16 *//*!< Interrupt Mask on line 15 *//*!< Interrupt Mask on line 14 *//*!< Interrupt Mask on line 13 *//*!< Interrupt Mask on line 12 *//*!< Interrupt Mask on line 11 *//*!< Interrupt Mask on line 10 *//*!< Interrupt Mask on line 9 *//*!< Interrupt Mask on line 8 *//*!< Interrupt Mask on line 7 *//*!< Interrupt Mask on line 6 *//*!< Interrupt Mask on line 5 *//*!< Interrupt Mask on line 4 *//*!< Interrupt Mask on line 3 *//*!< Interrupt Mask on line 2 *//*!< Interrupt Mask on line 1 *//*!< Interrupt Mask on line 0 *//*******************  Bit definition for EXTI_IMR register  *******************//*                    External Interrupt/Event Controller                     *//********************  Bit definition for DMA2D_BGCLUT register  **************//********************  Bit definition for DMA2D_FGCLUT register  **************//*!< Dead Time *//********************  Bit definition for DMA2D_AMTCR register  ***************//*!< Line Watermark *//********************  Bit definition for DMA2D_LWR register  *****************//*!< Pixel per Lines *//*!< 0x3FFF0000 *//*!< Number of Lines *//********************  Bit definition for DMA2D_NLR register  *****************//*!< Line Offset *//********************  Bit definition for DMA2D_OOR register  *****************//*!< Memory Address *//********************  Bit definition for DMA2D_OMAR register  ****************//*!< Alpha Channel Value *//*!< Red Value *//*!< GREEN Value  *//*!< BLUE Value *//*!<Mode_ARGB4444 *//*!<Mode_ARGB1555 *//*!<Mode_RGB565 *//*!<Mode_ARGB8888/RGB888 *//********************  Bit definition for DMA2D_OCOLR register  ***************//*!< Output Red Blue Swap *//*!< Output Alpha Inverted *//*!< Color mode CM[2:0] *//********************  Bit definition for DMA2D_OPFCCR register  **************//********************  Bit definition for DMA2D_BGCMAR register  **************//********************  Bit definition for DMA2D_FGCMAR register  **************//*!< Green Value *//*!< Blue Value *//********************  Bit definition for DMA2D_BGCOLR register  **************//*!< background Input Alpha value *//*!< Background Input Red Blue Swap *//*!< background Input Alpha Inverted *//*!< Alpha mode AM[1:0] *//*!< CLUT size *//*!< Start *//*!< CLUT Color mode *//*!< Input color mode CM bit 3 *//*!< Input color mode CM[3:0] *//********************  Bit definition for DMA2D_BGPFCCR register  *************//********************  Bit definition for DMA2D_FGCOLR register  **************//*!< Alpha value *//*!< Foreground Input Red Blue Swap *//*!< Foreground Input Alpha Inverted *//********************  Bit definition for DMA2D_FGPFCCR register  *************//********************  Bit definition for DMA2D_BGOR register  ****************//********************  Bit definition for DMA2D_BGMAR register  ***************//********************  Bit definition for DMA2D_FGOR register  ****************//********************  Bit definition for DMA2D_FGMAR register  ***************//*!< Clears Configuration Error Interrupt Flag    *//*!< Clears CLUT Transfer Complete Interrupt Flag *//*!< Clears CLUT Access Error Interrupt Flag      *//*!< Clears Transfer Watermark Interrupt Flag     *//*!< Clears Transfer Complete Interrupt Flag      *//*!< Clears Transfer Error Interrupt Flag         *//********************  Bit definition for DMA2D_IFCR register  ****************//*!< Configuration Error Interrupt Flag    *//*!< CLUT Transfer Complete Interrupt Flag *//*!< CLUT Access Error Interrupt Flag      *//*!< Transfer Watermark Interrupt Flag     *//*!< Transfer Complete Interrupt Flag      *//*!< Transfer Error Interrupt Flag         *//********************  Bit definition for DMA2D_ISR register  *****************//*!< DMA2D Mode[1:0]                         *//*!< Configuration Error Interrupt Enable    *//*!< CLUT Transfer Complete Interrupt Enable *//*!< CLUT Access Error Interrupt Enable      *//*!< Transfer Watermark Interrupt Enable     *//*!< Transfer Complete Interrupt Enable      *//*!< Transfer Error Interrupt Enable         *//*!< Abort transfer                          *//*!< Suspend transfer                        *//*!< Start transfer                          *//********************  Bit definition for DMA2D_CR register  ******************//*                         AHB Master DMA2D Controller (DMA2D)                *//******************  Bit definition for DMA_SxM1AR register  ********************//******************  Bit definition for DMA_SxM0AR register  ********************//*!< Peripheral Address *//******************  Bit definition for DMA_SxPAR register  ********************//********************  Bits definition for DMA_HIFCR  register  ****************//********************  Bits definition for DMA_LIFCR register  ****************//********************  Bits definition for DMA_HISR register  *****************//********************  Bits definition for DMA_LISR register  *****************//********************  Bits definition for DMA_SxFCR register  ****************//********************  Bits definition for DMA_SxCNDTR register  **************//*!< 0x01800000 *//*!< 0x1E000000 *//********************  Bits definition for DMA_SxCR register  *****************//*                             DMA Controller                                 *//********************  Bits definition for DCMI_DR register  ******************//********************  Bits definition for DCMI_CWSIZE register  ******************//********************  Bits definition for DCMI_CWSTRT register  ******************//********************  Bits definition for DCMI_ESUR register  ******************//********************  Bits definition for DCMI_ESCR register  ******************//********************  Bits definition for DCMI_ICR register  *****************//********************  Bits definition for DCMI_MIS register  *****************//********************  Bits definition for DCMI_IER register  *****************//********************  Bits definition for DCMI_RIS register   ****************//********************  Bits definition for DCMI_SR register  ******************//********************  Bits definition for DCMI_CR register  ******************//*                                    DCMI                                    *//*                                 Debug MCU                                  *//* Legacy Defines *//*!< CNVCNT[27:0]: 28-bit timer counting conversion time *//*!< 0xFFFFFFF0 *//******************  Bit definition for DFSDM_FLTCNVTIMR register ******************//*!< EXMINCH[2:0] Extreme detector minimum data channel *//*!< EXMIN[23:0] Extreme detector minimum value *//******************  Bit definition for DFSDM_FLTEXMIN register ******************//*!< EXMAXCH[2:0] Extreme detector maximum data channel *//*!< EXMAX[23:0] Extreme detector maximum value *//******************  Bit definition for DFSDM_FLTEXMAX register ******************//*!< CLRAWLTF[7:0] Clear the Analog watchdog low threshold flag *//*!< CLRAWHTF[15:8] Clear the Analog watchdog high threshold flag *//******************  Bit definition for DFSDM_FLTAWCFR register *****************//*!< AWLTF[7:0] Analog watchdog low threshold error on given channels *//*!< AWHTF[15:8] Analog watchdog high threshold error on given channels *//******************  Bit definition for DFSDM_FLTAWSR register ******************//*!< BKAWL[3:0] Break signal assignment to analog watchdog low threshold event *//*!< AWLT[23:0] Analog watchdog low threshold *//******************  Bit definition for DFSDM_FLTAWLTR register ******************//*!< BKAWH[3:0] Break signal assignment to analog watchdog high threshold event *//*!< AWHT[23:0] Analog watchdog high threshold *//******************  Bit definition for DFSDM_FLTAWHTR register ******************//*!< RDATACH[2:0] Regular channel most recently converted *//*!< RPEND Regular channel pending data *//*!< RDATA[23:0] Regular channel conversion data *//******************  Bit definition for DFSDM_FLTRDATAR register *****************//*!< JDATACH[2:0] Injected channel most recently converted *//*!< JDATA[23:0] Injected group conversion data *//******************  Bit definition for DFSDM_FLTJDATAR register *****************//*!< IOSR[7:0] Integrator oversampling ratio (averaging length) *//*!< FOSR[9:0] Sinc filter oversampling ratio (decimation rate) *//*!< FORD[2:0] Sinc filter order *//*!< 0xE0000000 *//********************  Bit definition for DFSDM_FLTFCR register *******************//*!< JCHG[7:0] Injected channel group selection *//*******************  Bit definition for DFSDM_FLTJCHGR register ******************//*!< Clear the injected conversion overrun flag *//*!< Clear the regular conversion overrun flag *//*!< CLRCKABF[7:0] Clear the clock absence flag *//*!< CLRSCSDF[7:0] Clear the short circuit detector flag *//********************  Bit definition for DFSDM_FLTICR register *******************//*!< End of injected conversion flag *//*!< End of regular conversion flag *//*!< Injected conversion overrun flag *//*!< Regular conversion overrun flag *//*!< Analog watchdog *//*!< Injected conversion in progress status *//*!< Regular conversion in progress status *//*!< CKABF[7:0] Clock absence flag *//*!< SCDF[7:0] Short circuit detector flag *//********************  Bit definition for DFSDM_FLTISR register *******************//*!< Injected end of conversion interrupt enable *//*!< Regular end of conversion interrupt enable *//*!< Injected data overrun interrupt enable *//*!< Regular data overrun interrupt enable *//*!< Analog watchdog interrupt enable *//*!< Short circuit detector interrupt enable *//*!< Clock absence interrupt enable *//*!< EXCH[7:0] Extreme detector channel selection *//*!< AWDCH[7:0] Analog watchdog channel selection *//********************  Bit definition for DFSDM_FLTCR2 register *******************//*!< DFSDM enable *//*!< Start the conversion of the injected group of channels *//*!< Launch an injected conversion synchronously with DFSDMx JSWSTART trigger  *//*!< Scanning conversion in continuous mode selection for injected conversions *//*!< DMA channel enabled to read data for the injected channel group *//*!< JEXTSEL[4:0]Trigger signal selection for launching injected conversions *//*!< JEXTEN[1:0] Trigger enable and trigger edge selection for injected conversions *//*!< Software start of a conversion on the regular channel *//*!< Continuous mode selection for regular conversions *//*!< Launch regular conversion synchronously with DFSDMx *//*!< DMA channel enabled to read data for the regular conversion *//*!< RCH[2:0] Regular channel selection *//*!< Fast conversion mode selection *//*!< Analog watchdog fast mode select *//********************  Bit definition for DFSDM_FLTCR1 register *******************//************************   DFSDM module registers  ****************************//*!< INDAT0[15:0] Input data for channel y *//*!< INDAT0[31:16] Input data for channel y or channel (y+1) *//****************  Bit definition for DFSDM_CHDATINR register *****************//*!< WDATA[15:0] Input channel y watchdog data *//****************  Bit definition for DFSDM_CHWDATR register *******************//*!< SCDT[7:0] Short circuit detector threshold for channel y *//*!< BKSCD[3:0] Break signal assignment for short circuit detector on channel y *//*!< AWFOSR[4:0] Analog watchdog filter oversampling ratio on channel y *//*!< AWFORD[1:0] Analog watchdog Sinc filter order on channel y *//******************  Bit definition for DFSDM_CHAWSCDR register *****************//*!< DTRBS[4:0] Data right bit-shift for channel y *//*!< OFFSET[23:0] 24-bit calibration offset for channel y *//***************  Bit definition for DFSDM_CHCFGR2 register  ******************//*!< SITP[1:0] Serial interface type for channel y *//*!< SPICKSEL[1:0] SPI clock select for channel y *//*!< Short circuit detector enable on channel y *//*!< Clock absence detector enable on channel y *//*!< Channel y enable *//*!< Serial inputs selection for channel y *//*!< DATMPX[1:0] Input data multiplexer for channel y *//*!< DATPACK[1:0] Data packing mode *//*!< CKOUTDIV[7:0] output serial clock divider *//*!< Output serial clock source selection *//*!< Global enable for DFSDM interface *//***************  Bit definition for DFSDM_CHCFGR1 register  ******************//****************   DFSDM channel configuration registers  ********************//*                 Digital Filter for Sigma Delta Modulators                  *//*!<DAC channel2 DMA underrun flag *//*!<DAC channel1 DMA underrun flag *//********************  Bit definition for DAC_SR register  ********************//*!<DAC channel2 data output *//*******************  Bit definition for DAC_DOR2 register  *******************//*!<DAC channel1 data output *//*******************  Bit definition for DAC_DOR1 register  *******************//*!<DAC channel2 8-bit Right aligned data *//*!<DAC channel1 8-bit Right aligned data *//******************  Bit definition for DAC_DHR8RD register  ******************//*!<DAC channel2 12-bit Left aligned data *//*!< 0xFFF00000 *//*!<DAC channel1 12-bit Left aligned data *//*****************  Bit definition for DAC_DHR12LD register  ******************//*!<DAC channel2 12-bit Right aligned data *//*!<DAC channel1 12-bit Right aligned data *//*****************  Bit definition for DAC_DHR12RD register  ******************//******************  Bit definition for DAC_DHR8R2 register  ******************//*****************  Bit definition for DAC_DHR12L2 register  ******************//*****************  Bit definition for DAC_DHR12R2 register  ******************//******************  Bit definition for DAC_DHR8R1 register  ******************//*****************  Bit definition for DAC_DHR12L1 register  ******************//*****************  Bit definition for DAC_DHR12R1 register  ******************//*!<DAC channel2 software trigger *//*!<DAC channel1 software trigger *//*****************  Bit definition for DAC_SWTRIGR register  ******************//*!<DAC channel2 DMA underrun interrupt enable *//*!<DAC channel2 DMA enable                    *//*!<MAMP2[3:0] (DAC channel2 Mask/Amplitude selector) *//*!<WAVE2[1:0] (DAC channel2 noise/triangle wave generation enable) *//*!<TSEL2[2:0] (DAC channel2 Trigger selection) *//*!< 0x00380000 *//*!<DAC channel2 Trigger enable                 *//*!<DAC channel2 output buffer disable          *//*!<DAC channel2 enable                         *//*!<DAC channel1 DMA underrun interrupt enable  *//*!<DAC channel1 DMA enable                     *//*!<MAMP1[3:0] (DAC channel1 Mask/Amplitude selector) *//*!<WAVE1[1:0] (DAC channel1 noise/triangle wave generation enablEU) *//*!<TSEL1[2:0] (DAC channel1 Trigger selection) *//*!<DAC channel1 Trigger enable                 *//*!<DAC channel1 output buffer disable          *//*!<DAC channel1 enable                         *//********************  Bit definition for DAC_CR register  ********************//*                      Digital to Analog Converter                           *//*!< Coefficients of the polynomial *//*******************  Bit definition for CRC_POL register  ********************//*!< Initial CRC value bits         *//*******************  Bit definition for CRC_INIT register  *******************//*!< REV_OUT Reverse Output Data bits   *//*!< REV_IN Reverse Input Data bits     *//*!< Polynomial size bits               *//*!< RESET the CRC computation unit bit *//********************  Bit definition for CRC_CR register  ********************//*!< General-purpose 8-bit data register bits *//*******************  Bit definition for CRC_IDR register  ********************//*!< Data register bits *//*******************  Bit definition for CRC_DR register  *********************//*                          CRC calculation unit                              *//*!< CEC Tx Missing Acknowledge IT Enable   *//*!< CEC Tx-Error IT Enable                 *//*!< CEC Tx-Buffer Underrun IT Enable       *//*!< CEC End of Transmission IT Enable      *//*!< CEC Tx Byte Request  IT Enable         *//*!< CEC Arbitration Lost IT Enable         *//*!< CEC Rx Missing Acknowledge IT Enable   *//*!< CEC Rx Long Bit period Error IT Enable *//*!< CEC Rx Short Bit period Error IT Enable*//*!< CEC Rx Bit Rising Error IT Enable      *//*!< CEC Rx-Overrun IT Enable               *//*!< CEC End Of Reception IT Enable         *//*!< CEC Rx-Byte Received IT Enable         *//*******************  Bit definition for CEC_IER register  ********************//*!< CEC Tx Missing Acknowledge             *//*!< CEC Tx-Error                           *//*!< CEC Tx-Buffer Underrun                 *//*!< CEC End of Transmission                *//*!< CEC Tx Byte Request                    *//*!< CEC Arbitration Lost                   *//*!< CEC Rx Missing Acknowledge             *//*!< CEC Rx Long Bit period Error           *//*!< CEC Rx Short Bit period Error          *//*!< CEC Rx Bit Rising Error                *//*!< CEC Rx-Overrun                         *//*!< CEC End Of Reception                   *//*!< CEC Rx-Byte Received                   *//*******************  Bit definition for CEC_ISR register  ********************//*!< CEC Rx Data                        *//*******************  Bit definition for CEC_RXDR register  *******************//*!< CEC Tx Data                        *//*******************  Bit definition for CEC_TXDR register  *******************//*!< CEC Listen mode                    *//*!< CEC Own Address                    *//*!< CEC Signal Free Time optional      *//*!< CEC Broadcast no Error generation  *//*!< CEC Long Period Error generation   *//*!< CEC Bit Rising Error generation    *//*!< CEC Rx Stop                        *//*!< CEC Tolerance                      *//*!< CEC Signal Free Time               *//*******************  Bit definition for CEC_CFGR register  *******************//*!< CEC Tx End Of Message              *//*!< CEC Tx Start Of Message            *//*!< CEC Enable                         *//*******************  Bit definition for CEC_CR register  *********************//*                                 HDMI-CEC (CEC)                             *//*!<Filter bit 31 *//*!<Filter bit 30 *//*!<Filter bit 29 *//*!<Filter bit 28 *//*!<Filter bit 27 *//*!<Filter bit 26 *//*!<Filter bit 25 *//*!<Filter bit 24 *//*!<Filter bit 23 *//*!<Filter bit 22 *//*!<Filter bit 21 *//*!<Filter bit 20 *//*!<Filter bit 19 *//*!<Filter bit 18 *//*!<Filter bit 17 *//*!<Filter bit 16 *//*!<Filter bit 15 *//*!<Filter bit 14 *//*!<Filter bit 13 *//*!<Filter bit 12 *//*!<Filter bit 11 *//*!<Filter bit 10 *//*!<Filter bit 9 *//*!<Filter bit 8 *//*!<Filter bit 7 *//*!<Filter bit 6 *//*!<Filter bit 5 *//*!<Filter bit 4 *//*!<Filter bit 3 *//*!<Filter bit 2 *//*!<Filter bit 1 *//*!<Filter bit 0 *//*******************  Bit definition for CAN_F13R2 register  ******************//*******************  Bit definition for CAN_F12R2 register  ******************//*******************  Bit definition for CAN_F11R2 register  ******************//*******************  Bit definition for CAN_F10R2 register  ******************//*******************  Bit definition for CAN_F9R2 register  *******************//*******************  Bit definition for CAN_F8R2 register  *******************//*******************  Bit definition for CAN_F7R2 register  *******************//*******************  Bit definition for CAN_F6R2 register  *******************//*******************  Bit definition for CAN_F5R2 register  *******************//*******************  Bit definition for CAN_F4R2 register  *******************//*******************  Bit definition for CAN_F3R2 register  *******************//*******************  Bit definition for CAN_F2R2 register  *******************//*******************  Bit definition for CAN_F1R2 register  *******************//*******************  Bit definition for CAN_F0R2 register  *******************//*******************  Bit definition for CAN_F13R1 register  ******************//*******************  Bit definition for CAN_F12R1 register  ******************//*******************  Bit definition for CAN_F11R1 register  ******************//*******************  Bit definition for CAN_F10R1 register  ******************//*******************  Bit definition for CAN_F9R1 register  *******************//*******************  Bit definition for CAN_F8R1 register  *******************//*******************  Bit definition for CAN_F7R1 register  *******************//*******************  Bit definition for CAN_F6R1 register  *******************//*******************  Bit definition for CAN_F5R1 register  *******************//*******************  Bit definition for CAN_F4R1 register  *******************//*******************  Bit definition for CAN_F3R1 register  *******************//*******************  Bit definition for CAN_F2R1 register  *******************//*******************  Bit definition for CAN_F1R1 register  *******************//*******************  Bit definition for CAN_F0R1 register  *******************//*!<Filter 13 Active *//*!<Filter 12 Active *//*!<Filter 11 Active *//*!<Filter 10 Active *//*!<Filter 9 Active  *//*!<Filter 8 Active  *//*!<Filter 7 Active  *//*!<Filter 6 Active  *//*!<Filter 5 Active  *//*!<Filter 4 Active  *//*!<Filter 3 Active  *//*!<Filter 2 Active  *//*!<Filter 1 Active  *//*!<Filter 0 Active  *//*!<Filter Active    *//*******************  Bit definition for CAN_FA1R register  *******************//*!<Filter FIFO Assignment for Filter 13 *//*!<Filter FIFO Assignment for Filter 12 *//*!<Filter FIFO Assignment for Filter 11 *//*!<Filter FIFO Assignment for Filter 10 *//*!<Filter FIFO Assignment for Filter 9 *//*!<Filter FIFO Assignment for Filter 8 *//*!<Filter FIFO Assignment for Filter 7 *//*!<Filter FIFO Assignment for Filter 6 *//*!<Filter FIFO Assignment for Filter 5 *//*!<Filter FIFO Assignment for Filter 4 *//*!<Filter FIFO Assignment for Filter 3 *//*!<Filter FIFO Assignment for Filter 2 *//*!<Filter FIFO Assignment for Filter 1 *//*!<Filter FIFO Assignment for Filter 0 *//*!<Filter FIFO Assignment *//******************  Bit definition for CAN_FFA1R register  *******************//*!<Filter Scale Configuration bit 13 *//*!<Filter Scale Configuration bit 12 *//*!<Filter Scale Configuration bit 11 *//*!<Filter Scale Configuration bit 10 *//*!<Filter Scale Configuration bit 9  *//*!<Filter Scale Configuration bit 8  *//*!<Filter Scale Configuration bit 7  *//*!<Filter Scale Configuration bit 6  *//*!<Filter Scale Configuration bit 5  *//*!<Filter Scale Configuration bit 4  *//*!<Filter Scale Configuration bit 3  *//*!<Filter Scale Configuration bit 2  *//*!<Filter Scale Configuration bit 1  *//*!<Filter Scale Configuration bit 0  *//*!<Filter Scale Configuration        *//*******************  Bit definition for CAN_FS1R register  *******************//*!<Filter Init Mode bit 13 *//*!<Filter Init Mode bit 12 *//*!<Filter Init Mode bit 11 *//*!<Filter Init Mode bit 10 *//*!<Filter Init Mode bit 9  *//*!<Filter Init Mode bit 8  *//*!<Filter Init Mode bit 7  *//*!<Filter Init Mode bit 6  *//*!<Filter Init Mode bit 5  *//*!<Filter Init Mode bit 4  *//*!<Filter Init Mode bit 3  *//*!<Filter Init Mode bit 2  *//*!<Filter Init Mode bit 1  *//*!<Filter Init Mode bit 0  *//*!<Filter Mode *//*******************  Bit definition for CAN_FM1R register  *******************//*!<CAN2 start bank *//*!<Filter Init Mode *//*******************  Bit definition for CAN_FMR register  ********************//*!<CAN filter registers *//*!<Data byte 7 *//*!<Data byte 6 *//*!<Data byte 5 *//*!<Data byte 4 *//*******************  Bit definition for CAN_RDH1R register  ******************//*!<Data byte 3 *//*!<Data byte 2 *//*!<Data byte 1 *//*!<Data byte 0 *//*******************  Bit definition for CAN_RDL1R register  ******************//*!<Message Time Stamp *//*!<Filter Match Index *//*!<Data Length Code   *//*******************  Bit definition for CAN_RDT1R register  ******************//*!<Standard Identifier or Extended Identifier *//*!< 0xFFE00000 *//*!<Extended identifier                        *//*!< 0x001FFFF8 *//*!<Identifier Extension                       *//*!<Remote Transmission Request                *//*******************  Bit definition for CAN_RI1R register  *******************//*******************  Bit definition for CAN_RDH0R register  ******************//*******************  Bit definition for CAN_RDL0R register  ******************//*!<Data Length Code *//*******************  Bit definition for CAN_RDT0R register  ******************//*!<Extended Identifier                        *//*******************  Bit definition for CAN_RI0R register  *******************//*******************  Bit definition for CAN_TDH2R register  ******************//*******************  Bit definition for CAN_TDL2R register  ******************//*!<Message Time Stamp    *//*!<Transmit Global Time  *//*!<Data Length Code      *//*******************  Bit definition for CAN_TDT2R register  ******************//*!<Transmit Mailbox Request                   *//*******************  Bit definition for CAN_TI2R register  *******************//*******************  Bit definition for CAN_TDH1R register  ******************//*******************  Bit definition for CAN_TDL1R register  ******************//*!<Message Time Stamp   *//*!<Transmit Global Time *//*!<Data Length Code     *//*******************  Bit definition for CAN_TDT1R register  ******************//*******************  Bit definition for CAN_TI1R register  *******************//******************  Bit definition for CAN_TDH0R register  *******************//******************  Bit definition for CAN_TDL0R register  *******************//******************  Bit definition for CAN_TDT0R register  *******************//******************  Bit definition for CAN_TI0R register  ********************//*!<Mailbox registers *//*!<Silent Mode                   *//*!<Loop Back Mode (Debug)        *//*!<Resynchronization Jump Width  *//*!<Time Segment 2                *//*!<Time Segment 1                *//*!<Baud Rate Prescaler           *//*******************  Bit definition for CAN_BTR register  ********************//*!<Receive Error Counter *//*!<Least significant byte of the 9-bit Transmit Error Counter *//*!<LEC[2:0] bits (Last Error Code) *//*!<Bus-Off Flag *//*!<Error Passive Flag *//*!<Error Warning Flag *//********************  Bit definition for CAN_ESR register  *******************//*!<Sleep Interrupt Enable                  *//*!<Wakeup Interrupt Enable                 *//*!<Error Interrupt Enable                  *//*!<Last Error Code Interrupt Enable        *//*!<Bus-Off Interrupt Enable                *//*!<Error Passive Interrupt Enable          *//*!<Error Warning Interrupt Enable          *//*!<FIFO Overrun Interrupt Enable           *//*!<FIFO Full Interrupt Enable              *//*!<FIFO Message Pending Interrupt Enable   *//*!<Transmit Mailbox Empty Interrupt Enable *//********************  Bit definition for CAN_IER register  *******************//*!<Release FIFO 1 Output Mailbox *//*!<FIFO 1 Overrun                *//*!<FIFO 1 Full                   *//*!<FIFO 1 Message Pending        *//*******************  Bit definition for CAN_RF1R register  *******************//*!<Release FIFO 0 Output Mailbox *//*!<FIFO 0 Overrun                *//*!<FIFO 0 Full                   *//*!<FIFO 0 Message Pending        *//*******************  Bit definition for CAN_RF0R register  *******************//*!<Lowest Priority Flag for Mailbox 2 *//*!<Lowest Priority Flag for Mailbox 1 *//*!<Lowest Priority Flag for Mailbox 0 *//*!<LOW[2:0] bits *//*!<Transmit Mailbox 2 Empty *//*!<Transmit Mailbox 1 Empty *//*!<Transmit Mailbox 0 Empty *//*!<TME[2:0] bits *//*!< 0x1C000000 *//*!<Mailbox Code                    *//*!<Abort Request for Mailbox 2     *//*!<Transmission Error of Mailbox 2 *//*!<Arbitration Lost for mailbox 2  *//*!<Transmission OK of Mailbox 2    *//*!<Request Completed Mailbox2      *//*!<Abort Request for Mailbox 1     *//*!<Transmission Error of Mailbox1  *//*!<Arbitration Lost for Mailbox1   *//*!<Transmission OK of Mailbox1     *//*!<Request Completed Mailbox1      *//*!<Abort Request for Mailbox0      *//*!<Transmission Error of Mailbox0  *//*!<Arbitration Lost for Mailbox0   *//*!<Transmission OK of Mailbox0     *//*!<Request Completed Mailbox0      *//*******************  Bit definition for CAN_TSR register  ********************//*!<CAN Rx Signal               *//*!<Last Sample Point           *//*!<Receive Mode                *//*!<Transmit Mode               *//*!<Sleep Acknowledge Interrupt *//*!<Wakeup Interrupt            *//*!<Error Interrupt             *//*!<Sleep Acknowledge           *//*!<Initialization Acknowledge  *//*******************  Bit definition for CAN_MSR register  ********************//*!<bxCAN software master reset       *//*!<Time Triggered Communication Mode *//*!<Automatic Bus-Off Management      *//*!<Automatic Wakeup Mode             *//*!<No Automatic Retransmission       *//*!<Receive FIFO Locked Mode          *//*!<Transmit FIFO Priority            *//*!<Sleep Mode Request                *//*!<Initialization Request            *//*******************  Bit definition for CAN_MCR register  ********************//*!<CAN control and status registers *//*                         Controller Area Network                            *//*!<2nd data of a pair of regular conversions *//*!<1st data of a pair of regular conversions *//*******************  Bit definition for ADC_CDR register  ********************//*!<Temperature Sensor and VREFINT Enable *//*!<VBAT Enable *//*!<ADCPRE[1:0] bits (ADC prescaler) *//*!<DMA[1:0] bits (Direct Memory Access mode for multimode) *//*!<DMA disable selection (Multi-ADC mode) *//*!<DELAY[3:0] bits (Delay between 2 sampling phases) *//*!<MULTI[4:0] bits (Multi-ADC mode selection) *//*******************  Bit definition for ADC_CCR register  ********************//*!<ADC3 Overrun flag                       *//*!<ADC3 Regular channel Start flag         *//*!<ADC3 Injected channel Start flag        *//*!<ADC3 Injected channel end of conversion *//*!<ADC3 End of conversion                  *//*!<ADC3 Analog watchdog flag               *//*!<ADC2 Overrun flag                       *//*!<ADC2 Regular channel Start flag         *//*!<ADC2 Injected channel Start flag        *//*!<ADC2 Injected channel end of conversion *//*!<ADC2 End of conversion                  *//*!<ADC2 Analog watchdog flag               *//*!<ADC1 Overrun flag                       *//*!<ADC1 Regular channel Start flag         *//*!<ADC1 Injected channel Start flag        *//*!<ADC1 Injected channel end of conversion *//*!<ADC1 End of conversion                  *//*!<ADC1 Analog watchdog flag               *//*******************  Bit definition for ADC_CSR register  ********************//*!<ADC2 data *//*!<Regular data *//********************  Bit definition for ADC_DR register  ********************//*!<Injected data *//*******************  Bit definition for ADC_JDR4 register  *******************//*******************  Bit definition for ADC_JDR3 register  *******************//*******************  Bit definition for ADC_JDR2 register  *******************//*******************  Bit definition for ADC_JDR1 register  *******************//*!<JL[1:0] bits (Injected Sequence length) *//*!<JSQ4[4:0] bits (4th conversion in injected sequence) *//*!< 0x000F8000 *//*!<JSQ3[4:0] bits (3rd conversion in injected sequence) *//*!< 0x00007C00 *//*!<JSQ2[4:0] bits (2nd conversion in injected sequence) *//*!< 0x000003E0 *//*!<JSQ1[4:0] bits (1st conversion in injected sequence) *//*******************  Bit definition for ADC_JSQR register  *******************//*!<SQ6[4:0] bits (6th conversion in regular sequence) *//*!< 0x3E000000 *//*!<SQ5[4:0] bits (5th conversion in regular sequence) *//*!< 0x01F00000 *//*!<SQ4[4:0] bits (4th conversion in regular sequence) *//*!<SQ3[4:0] bits (3rd conversion in regular sequence) *//*!<SQ2[4:0] bits (2nd conversion in regular sequence) *//*!<SQ1[4:0] bits (1st conversion in regular sequence) *//*******************  Bit definition for ADC_SQR3 register  *******************//*!<SQ12[4:0] bits (12th conversion in regular sequence) *//*!<SQ11[4:0] bits (11th conversion in regular sequence) *//*!<SQ10[4:0] bits (10th conversion in regular sequence) *//*!<SQ9[4:0] bits (9th conversion in regular sequence) *//*!<SQ8[4:0] bits (8th conversion in regular sequence) *//*!<SQ7[4:0] bits (7th conversion in regular sequence) *//*******************  Bit definition for ADC_SQR2 register  *******************//*!<L[3:0] bits (Regular channel sequence length) *//*!<SQ16[4:0] bits (16th conversion in regular sequence) *//*!<SQ15[4:0] bits (15th conversion in regular sequence) *//*!<SQ14[4:0] bits (14th conversion in regular sequence) *//*!<SQ13[4:0] bits (13th conversion in regular sequence) *//*******************  Bit definition for ADC_SQR1 register  *******************//*!<Analog watchdog low threshold *//*******************  Bit definition for ADC_LTR register  ********************//*!<Analog watchdog high threshold *//*******************  Bit definition for ADC_HTR register  ********************//*!<Data offset for injected channel 4 *//******************  Bit definition for ADC_JOFR4 register  *******************//*!<Data offset for injected channel 3 *//******************  Bit definition for ADC_JOFR3 register  *******************//*!<Data offset for injected channel 2 *//******************  Bit definition for ADC_JOFR2 register  *******************//*!<Data offset for injected channel 1 *//******************  Bit definition for ADC_JOFR1 register  *******************//*!<SMP9[2:0] bits (Channel 9 Sample time selection) *//*!<SMP8[2:0] bits (Channel 8 Sample time selection) *//*!<SMP7[2:0] bits (Channel 7 Sample time selection) *//*!<SMP6[2:0] bits (Channel 6 Sample time selection) *//*!< 0x001C0000 *//*!<SMP5[2:0] bits (Channel 5 Sample time selection) *//*!< 0x00038000 *//*!<SMP4[2:0] bits (Channel 4 Sample time selection) *//*!<SMP3[2:0] bits (Channel 3 Sample time selection) *//*!<SMP2[2:0] bits (Channel 2 Sample time selection) *//*!< 0x000001C0 *//*!<SMP1[2:0] bits (Channel 1 Sample time selection) *//*!<SMP0[2:0] bits (Channel 0 Sample time selection) *//******************  Bit definition for ADC_SMPR2 register  *******************//*!<SMP18[2:0] bits (Channel 18 Sample time selection) *//*!<SMP17[2:0] bits (Channel 17 Sample time selection) *//*!<SMP16[2:0] bits (Channel 16 Sample time selection) *//*!<SMP15[2:0] bits (Channel 15 Sample time selection) *//*!<SMP14[2:0] bits (Channel 14 Sample time selection) *//*!<SMP13[2:0] bits (Channel 13 Sample time selection) *//*!<SMP12[2:0] bits (Channel 12 Sample time selection) *//*!<SMP11[2:0] bits (Channel 11 Sample time selection) *//*!<SMP10[2:0] bits (Channel 10 Sample time selection) *//******************  Bit definition for ADC_SMPR1 register  *******************//*!<Start Conversion of regular channels *//*!<EXTEN[1:0] bits (External Trigger Conversion mode for regular channelsp) *//*!<EXTSEL[3:0] bits (External Event Select for regular group) *//*!<Start Conversion of injected channels *//*!<JEXTEN[1:0] bits (External Trigger Conversion mode for injected channelsp) *//*!<JEXTSEL[3:0] bits (External event select for injected group) *//*!<Data Alignment                                               *//*!<End of conversion selection                                  *//*!<DMA disable selection (Single ADC)                           *//*!<Direct Memory access mode                                    *//*!<Continuous Conversion                                        *//*!<A/D Converter ON / OFF                                       *//*******************  Bit definition for ADC_CR2 register  ********************//*!<overrun interrupt enable *//*!<RES[2:0] bits (Resolution)                           *//*!<Analog watchdog enable on regular channels           *//*!<Analog watchdog enable on injected channels          *//*!<DISCNUM[2:0] bits (Discontinuous mode channel count) *//*!<Discontinuous mode on injected channels              *//*!<Discontinuous mode on regular channels               *//*!<Automatic injected group conversion                  *//*!<Enable the watchdog on a single channel in scan mode *//*!<Scan mode *//*!<Interrupt enable for injected channels               *//*!<AAnalog Watchdog interrupt enable                    *//*!<Interrupt enable for EOC                             *//*!<AWDCH[4:0] bits (Analog watchdog channel select bits) *//*******************  Bit definition for ADC_CR1 register  ********************//*!<Overrun flag                                         *//*!<Regular channel Start flag                           *//*!<Injected channel Start flag                          *//*!<Injected channel end of conversion                   *//*!<End of conversion                                    *//*!<Analog watchdog flag                                 *//********************  Bit definition for ADC_SR register  ********************//*!<Internal temperature sensor, address of parameter TS_CAL2: On STM32F7, temperature sensor ADC raw data acquired at temperature 110 DegC (tolerance: +-5 DegC), Vref+ = 3.3 V (tolerance: +-10 mV). *//*!<Internal temperature sensor, address of parameter TS_CAL1: On STM32F7, temperature sensor ADC raw data acquired at temperature  30 DegC (tolerance: +-5 DegC), Vref+ = 3.3 V (tolerance: +-10 mV). *//*!<Internal voltage reference, address of parameter VREFINT_CAL: VrefInt ADC raw data acquired at temperature 30 DegC (tolerance: +-5 DegC), Vref+ = 3.3 V (tolerance: +-10 mV).                      *//*                        Analog to Digital Converter                         *//*                         Peripheral Registers_Bits_Definition               *//** @addtogroup Peripheral_Registers_Bits_Definition
  * @{
  *//**
    * @}
    *//*!< LSI Maximum startup time in us *//** @addtogroup Hardware_Constant_Definition
    * @{
    *//** @addtogroup Exported_constants
  * @{
  *//* Kept for legacy purpose *//** @addtogroup Peripheral_declaration
  * @{
  *//*!< USB registers base address *//* Debug MCU registers base address *//*!< FMC Bankx registers base address *//*!< AHB2 peripherals *//*!< Package size register base address *//*!< FLASH Size register base address *//*!< Unique device ID register base address *//*!< AHB1 peripherals *//*!< APB2 peripherals *//*!< APB1 peripherals *//*!< Peripheral memory map *//*!< End address of : (up to 1024 Bytes) embedded FLASH OTP Area                             *//*!< Base address of : (up to 1024 Bytes) embedded FLASH OTP Area                            *//*!< FLASH end address *//*!< Base address of : 16KB RAM2 accessible over AXI/AHB                                     *//*!< Base address of : 368KB RAM1 accessible over AXI/AHB                                    *//*!< Base address of : QSPI Control  registers                                               *//*!< Base address of : FMC Control registers                                                 *//*!< Base address of : QSPI memories  accessible over AXI                                    *//*!< Base address of : Backup SRAM(4 KB)                                                     *//*!< Base address of : AHB/ABP Peripherals                                                   *//*!< Base address of : 128KB system data RAM accessible over DTCM                            *//*!< Base address of : (up to 2 MB) embedded FLASH memory accessible over AXI                *//*!< Base address of : (up to 2 MB) embedded FLASH memory  accessible over ITCM              *//*!< Base address of : 16KB RAM reserved for CPU execution/instruction accessible over ITCM  *//** @addtogroup Peripheral_memory_map
  * @{
  *//*!< DSI Wrapper Regulator and PLL Control Register, Address offset: 0x430                 *//*!< Reserved, 0x42C                                                                       *//*!< DSI Wrapper PHY Configuration Register,                   Address offset: 0x418-0x42B *//*!< Reserved, 0x414                                                                       *//*!< DSI Wrapper Interrupt Flag Clear Register,                Address offset: 0x410       *//*!< DSI Wrapper Interrupt and Status Register,                Address offset: 0x40C       *//*!< DSI Wrapper Interrupt Enable Register,                    Address offset: 0x408       *//*!< DSI Wrapper Control Register,                             Address offset: 0x404       *//*!< DSI Wrapper Configuration Register,                       Address offset: 0x400       *//*!< Reserved, 0x194 - 0x3FF                                                               *//*!< DSI Host 3D Current Configuration Register,                Address offset: 0x190     *//*!< Reserved, 0x164 - 0x18F                                                              *//*!< DSI Host Video VA Current Configuration Register,          Address offset: 0x160     *//*!< DSI Host Video VFP Current Configuration Register,         Address offset: 0x15C     *//*!< DSI Host Video VBP Current Configuration Register,         Address offset: 0x158     *//*!< DSI Host Video VSA Current Configuration Register,         Address offset: 0x154     *//*!< DSI Host Video Line Current Configuration Register,        Address offset: 0x150     *//*!< DSI Host Video HBP Current Configuration Register,         Address offset: 0x14C     *//*!< DSI Host Video HSA Current Configuration Register,         Address offset: 0x148     *//*!< DSI Host Video Null Packet Current Configuration Register, Address offset: 0x144     *//*!< DSI Host Video Chunks Current Configuration Register,     Address offset: 0x140     *//*!< DSI Host Video Packet Current Configuration Register,      Address offset: 0x13C     *//*!< DSI Host Video Mode Current Configuration Register,        Address offset: 0x138     *//*!< Reserved, 0x11C - 0x137                                                              *//*!< DSI Host Low-power Mode Current Configuration Register,    Address offset: 0x118     *//*!< Reserved, 0x114                                                                      *//*!< DSI Host LTDC Current Color Coding Register,               Address offset: 0x110     *//*!< DSI Host LTDC Current VCID Register,                       Address offset: 0x10C     *//*!< Reserved, 0x104 - 0x10B                                                              *//*!< DSI Host Video Shadow Control Register,                    Address offset: 0x100     *//*!< Reserved, 0xE0 - 0xFF                                                                *//*!< DSI Host Force Interrupt Register,                         Address offset: 0xD8-0xDF *//*!< Reserved, 0xD0 - 0xD7                                                                *//*!< DSI Host Interrupt Enable Register,                        Address offset: 0xC4-0xCB *//*!< DSI Host Interrupt & Status Register,                      Address offset: 0xBC-0xC3 *//*!< Reserved, 0xB4 - 0xBB                                                                *//*!< DSI Host PHY Status Register,                              Address offset: 0xB0      *//*!< DSI Host PHY TX Triggers Configuration Register,           Address offset: 0xAC      *//*!< DSI Host PHY ULPS Control Register,                        Address offset: 0xA8      *//*!< DSI Host PHY Configuration Register,                       Address offset: 0xA4      *//*!< DSI Host PHY Control Register,                             Address offset: 0xA0      *//*!< DSI Host Data Lane Timer Configuration Register,           Address offset: 0x9C      *//*!< DSI Host Clock Lane Timer Configuration Register,          Address offset: 0x98      *//*!< DSI Host Clock Lane Configuration Register,                Address offset: 0x94      *//*!< DSI Host 3D Configuration Register,                        Address offset: 0x90      *//*!< DSI Host Timeout Counter Configuration Register,           Address offset: 0x78-0x8F *//*!< DSI Host Generic Packet Status Register,                   Address offset: 0x74      *//*!< DSI Host Generic Payload Data Register,                    Address offset: 0x70      *//*!< DSI Host Generic Header Configuration Register,            Address offset: 0x6C      *//*!< DSI Host Command Mode Configuration Register,              Address offset: 0x68      *//*!< DSI Host LTDC Command Configuration Register,              Address offset: 0x64      *//*!< DSI Host Video VA Configuration Register,                  Address offset: 0x60      *//*!< DSI Host Video VFP Configuration Register,                 Address offset: 0x5C      *//*!< DSI Host Video VBP Configuration Register,                 Address offset: 0x58      *//*!< DSI Host Video VSA Configuration Register,                 Address offset: 0x54      *//*!< DSI Host Video Line Configuration Register,                Address offset: 0x50      *//*!< DSI Host Video HBP Configuration Register,                 Address offset: 0x4C      *//*!< DSI Host Video HSA Configuration Register,                 Address offset: 0x48      *//*!< DSI Host Video Null Packet Configuration Register,         Address offset: 0x44      *//*!< DSI Host Video Chunks Configuration Register,              Address offset: 0x40      *//*!< DSI Host Video Packet Configuration Register,              Address offset: 0x3C      *//*!< DSI Host Video Mode Configuration Register,                Address offset: 0x38      *//*!< DSI Host Mode Configuration Register,                      Address offset: 0x34      *//*!< DSI Host Generic VCID Register,                            Address offset: 0x30      *//*!< DSI Host Protocol Configuration Register,                  Address offset: 0x2C      *//*!< Reserved, 0x1C - 0x2B                                                                *//*!< DSI Host Low-Power Mode Configuration Register,            Address offset: 0x18      *//*!< DSI Host LTDC Polarity Configuration Register,             Address offset: 0x14      *//*!< DSI Host LTDC Color Coding Register,                       Address offset: 0x10      *//*!< DSI Host LTDC VCID Register,                               Address offset: 0x0C      *//*!< DSI HOST Clock Control Register,                           Address offset: 0x08      *//*!< DSI Host Control Register,                                 Address offset: 0x04      *//*!< DSI Host Version Register,                                 Address offset: 0x00      *//**
  * @brief DSI Controller
  *//*!< MDIOS Output Data Register (MDIOS_DOUTR31),     Address offset: 1FCh      *//*!< MDIOS Output Data Register (MDIOS_DOUTR30),     Address offset: 1F8h      *//*!< MDIOS Output Data Register (MDIOS_DOUTR29),     Address offset: 1F4h      *//*!< MDIOS Output Data Register (MDIOS_DOUTR28),     Address offset: 1F0h      *//*!< MDIOS Output Data Register (MDIOS_DOUTR27),     Address offset: 1ECh      *//*!< MDIOS Output Data Register (MDIOS_DOUTR26),     Address offset: 1E8h      *//*!< MDIOS Output Data Register (MDIOS_DOUTR25),     Address offset: 1E4h      *//*!< MDIOS Output Data Register (MDIOS_DOUTR24),     Address offset: 1E0h      *//*!< MDIOS Output Data Register (MDIOS_DOUTR23),     Address offset: 1DCh      *//*!< MDIOS Output Data Register (MDIOS_DOUTR22),     Address offset: 1D8h      *//*!< MDIOS Output Data Register (MDIOS_DOUTR21),     Address offset: 1D4h      *//*!< MDIOS Output Data Register (MDIOS_DOUTR20),     Address offset: 1D0h      *//*!< MDIOS Output Data Register (MDIOS_DOUTR19),     Address offset: 1CCh      *//*!< MDIOS Output Data Register (MDIOS_DOUTR18),     Address offset: 1C8h      *//*!< MDIOS Output Data Register (MDIOS_DOUTR17),     Address offset: 1C4h      *//*!< MDIOS Output Data Register (MDIOS_DOUTR16),     Address offset: 1C0h      *//*!< MDIOS Output Data Register (MDIOS_DOUTR15),     Address offset: 1BCh      *//*!< MDIOS Output Data Register (MDIOS_DOUTR14),     Address offset: 1B8h      *//*!< MDIOS Output Data Register (MDIOS_DOUTR13),     Address offset: 1B4h      *//*!< MDIOS Output Data Register (MDIOS_DOUTR12),     Address offset: 1B0h      *//*!< MDIOS Output Data Register (MDIOS_DOUTR11),     Address offset: 1ACh      *//*!< MDIOS Output Data Register (MDIOS_DOUTR10),     Address offset: 1A8h      *//*!< MDIOS Output Data Register (MDIOS_DOUTR9),      Address offset: 1A4h      *//*!< MDIOS Output Data Register (MDIOS_DOUTR8),      Address offset: 1A0h      *//*!< MDIOS Output Data Register (MDIOS_DOUTR7),      Address offset: 19Ch      *//*!< MDIOS Output Data Register (MDIOS_DOUTR6),      Address offset: 198h      *//*!< MDIOS Output Data Register (MDIOS_DOUTR5),      Address offset: 194h      *//*!< MDIOS Output Data Register (MDIOS_DOUTR4),      Address offset: 190h      *//*!< MDIOS Output Data Register (MDIOS_DOUTR3),      Address offset: 18Ch      *//*!< MDIOS Output Data Register (MDIOS_DOUTR2),      Address offset: 188h      *//*!< MDIOS Output Data Register (MDIOS_DOUTR1),      Address offset: 184h      *//*!< MDIOS Output Data Register (MDIOS_DOUTR0),      Address offset: 180h      *//*!< MDIOS Input Data Register (MDIOS_DINR31),       Address offset: 17Ch      *//*!< MDIOS Input Data Register (MDIOS_DINR30),       Address offset: 178h      *//*!< MDIOS Input Data Register (MDIOS_DINR29),       Address offset: 174h      *//*!< MDIOS Input Data Register (MDIOS_DINR28),       Address offset: 170h      *//*!< MDIOS Input Data Register (MDIOS_DINR27),       Address offset: 16Ch      *//*!< MDIOS Input Data Register (MDIOS_DINR26),       Address offset: 168h      *//*!< MDIOS Input Data Register (MDIOS_DINR25),       Address offset: 164h      *//*!< MDIOS Input Data Register (MDIOS_DINR24),       Address offset: 160h      *//*!< MDIOS Input Data Register (MDIOS_DINR23),       Address offset: 15Ch      *//*!< MDIOS Input Data Register (MDIOS_DINR22),       Address offset: 158h      *//*!< MDIOS Input Data Register (MDIOS_DINR21),       Address offset: 154h      *//*!< MDIOS Input Data Register (MDIOS_DINR20),       Address offset: 150h      *//*!< MDIOS Input Data Register (MDIOS_DINR19),       Address offset: 14Ch      *//*!< MDIOS Input Data Register (MDIOS_DINR18),       Address offset: 148h      *//*!< MDIOS Input Data Register (MDIOS_DINR17),       Address offset: 144h      *//*!< MDIOS Input Data Register (MDIOS_DINR16),       Address offset: 140h      *//*!< MDIOS Input Data Register (MDIOS_DINR15),       Address offset: 13Ch      *//*!< MDIOS Input Data Register (MDIOS_DINR14),       Address offset: 138h      *//*!< MDIOS Input Data Register (MDIOS_DINR13),       Address offset: 134h      *//*!< MDIOS Input Data Register (MDIOS_DINR12),       Address offset: 130h      *//*!< MDIOS Input Data Register (MDIOS_DINR11),       Address offset: 12Ch      *//*!< MDIOS Input Data Register (MDIOS_DINR10),       Address offset: 128h      *//*!< MDIOS Input Data Register (MDIOS_DINR9),        Address offset: 124h      *//*!< MDIOS Input Data Register (MDIOS_DINR8),        Address offset: 120h      *//*!< MDIOS Input Data Register (MDIOS_DINR7),        Address offset: 11Ch      *//*!< MDIOS Input Data Register (MDIOS_DINR6),        Address offset: 118h      *//*!< MDIOS Input Data Register (MDIOS_DINR5),        Address offset: 114h      *//*!< MDIOS Input Data Register (MDIOS_DINR4),        Address offset: 110h      *//*!< MDIOS Input Data Register (MDIOS_DINR3),        Address offset: 10Ch      *//*!< MDIOS Input Data Register (MDIOS_DINR2),        Address offset: 108h      *//*!< MDIOS Input Data Register (MDIOS_DINR1),        Address offset: 104h      *//*!< MDIOS Input Data Register (MDIOS_DINR0),        Address offset: 100h      *//* Reserved                                          Address offset: 1Ch       *//*!< MDIOS Configuration Register (MDIOS_CR),        Address offset: 18h       *//*!< MDIOS Configuration Register (MDIOS_CR),        Address offset: 14h       *//*!< MDIOS Configuration Register (MDIOS_CR),        Address offset: 10h       *//*!< MDIOS Configuration Register (MDIOS_CR),        Address offset: 0Ch       *//*!< MDIOS Configuration Register (MDIOS_CR),        Address offset: 08h       *//*!< MDIOS Configuration Register (MDIOS_CR),        Address offset: 04h       *//*!< MDIOS Configuration Register (MDIOS_CR),        Address offset: 00h       *//**
  * @brief MDIOS
  *//*!< JPEG encoder, DC Huffman table 1,                 Address offset: 7E0h-7FCh *//*!< JPEG encoder, DC Huffman table 0,                 Address offset: 7C0h-7DCh *//*!< JPEG encoder, AC Huffman table 1,                 Address offset: 660h-7BCh *//*!< JPEG encoder, AC Huffman table 0,                 Address offset: 500h-65Ch *//* Reserved                                            Address offset: 4FCh      *//*!< JPEG DHTMem tables,                               Address offset: 360h-4F8h *//*!< JPEG HUFFSYMB tables,                             Address offset: 210h-35Ch *//*!< JPEG HuffSymb tables,                             Address offset: 190h-20Ch *//*!< JPEG HuffMin tables,                              Address offset: 150h-18Ch *//*!< JPEG quantization tables 3,                       Address offset: 110h-14Ch *//*!< JPEG quantization tables 2,                       Address offset: D0h-10Ch  *//*!< JPEG quantization tables 1,                       Address offset: 90h-CCh   *//*!< JPEG quantization tables 0,                       Address offset: 50h-8Ch   *//* Reserved                                            Address offset: 48h-4Ch   *//*!< JPEG Data Output Register (JPEG_DOR),             Address offset: 44h       *//*!< JPEG Data Input Register (JPEG_DIR),              Address offset: 40h       *//* Reserved                                            Address offset: 3Ch       *//*!< JPEG Clear Flag Register (JPEG_CFR),              Address offset: 38h       *//*!< JPEG Status Register (JPEG_SR),                   Address offset: 34h       *//*!< JPEG Control Register (JPEG_CR),                  Address offset: 30h       *//* Reserved                                            Address offset: 20h-2Ch   *//*!< JPEG Codec Control Register (JPEG_CONFR7),        Address offset: 1Ch       *//*!< JPEG Codec Control Register (JPEG_CONFR6),        Address offset: 18h       *//*!< JPEG Codec Control Register (JPEG_CONFR5),        Address offset: 14h       *//*!< JPEG Codec Control Register (JPEG_CONFR4),        Address offset: 10h       *//*!< JPEG Codec Control Register (JPEG_CONFR3),        Address offset: 0Ch       *//*!< JPEG Codec Control Register (JPEG_CONFR2),        Address offset: 08h       *//*!< JPEG Codec Control Register (JPEG_CONFR1),        Address offset: 04h       *//*!< JPEG Codec Control Register (JPEG_CONFR0),        Address offset: 00h       *//**
  * @brief JPEG Codec
  *//*!< Reserved                                      *//*!< Host Channel DMA Address Register        514h *//*!< Host Channel Transfer Size Register      510h *//*!< Host Channel Interrupt Mask Register     50Ch *//*!< Host Channel Interrupt Register          508h *//*!< Host Channel Split Control Register      504h *//*!< Host Channel Characteristics Register    500h *//**
  * @brief USB_OTG_Host_Channel_Specific_Registers
  *//*!< Host All Channels Interrupt Mask     418h *//*!< Host All Channels Interrupt Register 414h *//*!< Host Periodic Tx FIFO/ Queue Status  410h *//*!< Reserved                             40Ch *//*!< Host Frame Nbr/Frame Remaining       408h *//*!< Host Frame Interval Register         404h *//*!< Host Configuration Register          400h *//**
  * @brief USB_OTG_Host_Mode_Register_Structures
  *//*!< Reserved B00h + (ep_num * 20h) + 18h - B00h + (ep_num * 20h) + 1Ch *//*!< dev OUT Endpoint DMA Address           B00h + (ep_num * 20h) + 14h *//*!< dev OUT Endpoint Txfer Size            B00h + (ep_num * 20h) + 10h *//*!< Reserved                               B00h + (ep_num * 20h) + 0Ch *//*!< dev OUT Endpoint Itr Reg               B00h + (ep_num * 20h) + 08h *//*!< Reserved                               B00h + (ep_num * 20h) + 04h *//*!< dev OUT Endpoint Control Reg           B00h + (ep_num * 20h) + 00h *//**
  * @brief USB_OTG_OUT_Endpoint-Specific_Registers
  *//*!< Reserved  900h+(ep_num*20h)+1Ch-900h+ (ep_num * 20h) + 1Ch *//*!< IN Endpoint Tx FIFO Status Reg 900h + (ep_num * 20h) + 18h *//*!< IN Endpoint DMA Address Reg    900h + (ep_num * 20h) + 14h *//*!< IN Endpoint Txfer Size         900h + (ep_num * 20h) + 10h *//*!< Reserved                       900h + (ep_num * 20h) + 0Ch *//*!< dev IN Endpoint Itr Reg        900h + (ep_num * 20h) + 08h *//*!< Reserved                       900h + (ep_num * 20h) + 04h *//*!< dev IN Endpoint Control Reg    900h + (ep_num * 20h) + 00h *//**
  * @brief USB_OTG_IN_Endpoint-Specific_Register
  *//*!< dedicated EP msk             884h *//*!< Reserved                 844-87Ch *//*!< dedicated EP mask            844h *//*!< dedicated EP mask            840h *//*!< dedicated EP msk             83Ch *//*!< dedicated EP interrupt       838h *//*!< dev empty msk                834h *//*!< dev threshold                830h *//*!< dev VBUS Pulse Register      82Ch *//*!< dev VBUS discharge Register  828h *//*!< Reserved                     824h *//*!< Reserved                     820h *//*!< dev All Endpoints Itr Mask   81Ch *//*!< dev All Endpoints Itr Reg    818h *//*!< dev OUT Endpoint Mask        814h *//*!< dev IN Endpoint Mask         810h *//*!< Reserved                     80Ch *//*!< dev Status Register (RO)     808h *//*!< dev Control Register         804h *//*!< dev Configuration Register   800h *//**
  * @brief USB_OTG_device_Registers
  *//*!< dev Periodic Transmit FIFO              104h-13Ch *//*!< Host Periodic Tx FIFO Size Reg               100h *//*!< Reserved                                 60h-0FFh *//*!< DFIFO Software Config Register               05Ch *//*!< Reserved                                     058h *//*!< LPM Register                                 054h *//*!< Reserved                                     050h *//*!< User HW config3                              04Ch *//*!< Reserved                                040h-048h *//*!< User ID Register                             03Ch *//*!< General Purpose IO Register                  038h *//*!< Reserved                                     030h *//*!< Non Periodic Tx FIFO/Queue Sts reg           02Ch *//*!< EP0 / Non Periodic Tx FIFO Size Register     028h *//*!< Receive FIFO Size Register                   024h *//*!< Receive Sts Q Read & POP Register            020h *//*!< Receive Sts Q Read Register                  01Ch *//*!< Core Interrupt Mask Register                 018h *//*!< Core Interrupt Register                      014h *//*!< Core Reset Register                          010h *//*!< Core USB Configuration Register              00Ch *//*!< Core AHB Configuration Register              008h *//*!< USB_OTG Interrupt Register                   004h *//*!< USB_OTG Control and Status Register          000h *//**
  * @brief USB_OTG_Core_Registers
  *//*!< RNG data register,    Address offset: 0x08 *//*!< RNG status register,  Address offset: 0x04 *//*!< RNG control register, Address offset: 0x00 *//**
  * @brief RNG
  *//*!< WWDG Status register,        Address offset: 0x08 *//*!< WWDG Configuration register, Address offset: 0x04 *//*!< WWDG Control register,       Address offset: 0x00 *//**
  * @brief Window WATCHDOG
  *//*!< USART Transmit Data register,             Address offset: 0x28 *//*!< USART Receive Data register,              Address offset: 0x24 *//*!< USART Interrupt flag Clear register,      Address offset: 0x20 *//*!< USART Interrupt and status register,      Address offset: 0x1C *//*!< USART Request register,                   Address offset: 0x18 *//*!< USART Receiver Time Out register,         Address offset: 0x14 *//*!< USART Guard time and prescaler register,  Address offset: 0x10 *//*!< USART Baud rate register,                 Address offset: 0x0C *//*!< USART Control register 3,                 Address offset: 0x08 *//*!< USART Control register 2,                 Address offset: 0x04 *//*!< USART Control register 1,                 Address offset: 0x00 *//**
  * @brief Universal Synchronous Asynchronous Receiver Transmitter
  *//*!< LPTIM Counter register,                             Address offset: 0x1C *//*!< LPTIM Autoreload register,                          Address offset: 0x18 *//*!< LPTIM Compare register,                             Address offset: 0x14 *//*!< LPTIM Control register,                             Address offset: 0x10 *//*!< LPTIM Configuration register,                       Address offset: 0x0C *//*!< LPTIM Interrupt Enable register,                    Address offset: 0x08 *//*!< LPTIM Interrupt Clear register,                     Address offset: 0x04 *//*!< LPTIM Interrupt and Status register,                Address offset: 0x00 *//**
  * @brief LPTIMIMER
  *//*!< TIM Alternate function option register 2, Address offset: 0x64 *//*!< TIM Alternate function option register 1, Address offset: 0x60 *//*!< TIM capture/compare mode register6,       Address offset: 0x5C *//*!< TIM capture/compare mode register5,       Address offset: 0x58 *//*!< TIM capture/compare mode register 3,      Address offset: 0x54 *//*!< TIM option register,                 Address offset: 0x50 *//*!< TIM DMA address for full transfer,   Address offset: 0x4C *//*!< TIM DMA control register,            Address offset: 0x48 *//*!< TIM break and dead-time register,    Address offset: 0x44 *//*!< TIM capture/compare register 4,      Address offset: 0x40 *//*!< TIM capture/compare register 3,      Address offset: 0x3C *//*!< TIM capture/compare register 2,      Address offset: 0x38 *//*!< TIM capture/compare register 1,      Address offset: 0x34 *//*!< TIM repetition counter register,     Address offset: 0x30 *//*!< TIM auto-reload register,            Address offset: 0x2C *//*!< TIM prescaler,                       Address offset: 0x28 *//*!< TIM counter register,                Address offset: 0x24 *//*!< TIM capture/compare enable register, Address offset: 0x20 *//*!< TIM capture/compare mode register 2, Address offset: 0x1C *//*!< TIM capture/compare mode register 1, Address offset: 0x18 *//*!< TIM event generation register,       Address offset: 0x14 *//*!< TIM status register,                 Address offset: 0x10 *//*!< TIM DMA/interrupt enable register,   Address offset: 0x0C *//*!< TIM slave mode control register,     Address offset: 0x08 *//*!< TIM control register 2,              Address offset: 0x04 *//*!< TIM control register 1,              Address offset: 0x00 *//**
  * @brief TIM
  *//*!< QUADSPI Low Power Timeout register,                 Address offset: 0x30 *//*!< QUADSPI Polling Interval register,                  Address offset: 0x2C *//*!< QUADSPI Polling Status Match register,              Address offset: 0x28 *//*!< QUADSPI Polling Status Mask register,               Address offset: 0x24 *//*!< QUADSPI Data register,                              Address offset: 0x20 *//*!< QUADSPI Alternate Bytes register,                   Address offset: 0x1C *//*!< QUADSPI Address register,                           Address offset: 0x18 *//*!< QUADSPI Communication Configuration register,       Address offset: 0x14 *//*!< QUADSPI Data Length register,                       Address offset: 0x10 *//*!< QUADSPI Flag Clear register,                        Address offset: 0x0C *//*!< QUADSPI Status register,                            Address offset: 0x08 *//*!< QUADSPI Device Configuration register,              Address offset: 0x04 *//*!< QUADSPI Control register,                           Address offset: 0x00 *//**
  * @brief QUAD Serial Peripheral Interface
  *//*!< SPI_I2S prescaler register,                         Address offset: 0x20 *//*!< SPI_I2S configuration register,                     Address offset: 0x1C *//*!< SPI TX CRC register (not used in I2S mode),         Address offset: 0x18 *//*!< SPI RX CRC register (not used in I2S mode),         Address offset: 0x14 *//*!< SPI CRC polynomial register (not used in I2S mode), Address offset: 0x10 *//*!< SPI data register,                                  Address offset: 0x0C *//*!< SPI status register,                                Address offset: 0x08 *//*!< SPI control register 2,                             Address offset: 0x04 *//*!< SPI control register 1 (not used in I2S mode),      Address offset: 0x00 *//**
  * @brief Serial Peripheral Interface
  *//*!< SDMMC data FIFO register,        Address offset: 0x80 *//*!< Reserved, 0x4C-0x7C                                  *//*!< SDMMC FIFO counter register,     Address offset: 0x48 *//*!< Reserved, 0x40-0x44                                  *//*!< SDMMC mask register,             Address offset: 0x3C *//*!< SDMMC interrupt clear register,  Address offset: 0x38 *//*!< SDMMC status register,           Address offset: 0x34 *//*!< SDMMC data counter register,     Address offset: 0x30 *//*!< SDMMC data control register,     Address offset: 0x2C *//*!< SDMMC data length register,      Address offset: 0x28 *//*!< SDMMC data timer register,       Address offset: 0x24 *//*!< SDMMC response 4 register,       Address offset: 0x20 *//*!< SDMMC response 3 register,       Address offset: 0x1C *//*!< SDMMC response 2 register,       Address offset: 0x18 *//*!< SDMMC response 1 register,       Address offset: 0x14 *//*!< SDMMC command response register, Address offset: 0x10 *//*!< SDMMC command register,          Address offset: 0x0C *//*!< SDMMC argument register,         Address offset: 0x08 *//*!< SDMMClock control register,     Address offset: 0x04 *//*!< SDMMC power control register,    Address offset: 0x00 *//**
  * @brief SD host Interface
  *//*!< Debug Information register,         Address offset: 0x18 *//*!< Channel Status register,            Address offset: 0x14 *//*!< Data input register,                Address offset: 0x10 *//*!< Interrupt Flag Clear register,      Address offset: 0x0C *//*!< Status register,                    Address offset: 0x08 *//*!< Interrupt mask register,            Address offset: 0x04 *//*!< Control register,                   Address offset: 0x00 *//**
  * @brief SPDIF-RX Interface
  *//*!< SAI block x data register,                Address offset: 0x20 *//*!< SAI block x clear flag register,          Address offset: 0x1C *//*!< SAI block x status register,              Address offset: 0x18 *//*!< SAI block x interrupt mask register,      Address offset: 0x14 *//*!< SAI block x slot register,                Address offset: 0x10 *//*!< SAI block x frame configuration register, Address offset: 0x0C *//*!< SAI block x configuration register 2,     Address offset: 0x08 *//*!< SAI block x configuration register 1,     Address offset: 0x04 *//*!< SAI global configuration register,        Address offset: 0x00 *//**
  * @brief Serial Audio Interface
  *//*!< RTC backup register 31,                                    Address offset: 0xCC *//*!< RTC backup register 30,                                    Address offset: 0xC8 *//*!< RTC backup register 29,                                    Address offset: 0xC4 *//*!< RTC backup register 28,                                    Address offset: 0xC0 *//*!< RTC backup register 27,                                    Address offset: 0xBC *//*!< RTC backup register 26,                                    Address offset: 0xB8 *//*!< RTC backup register 25,                                    Address offset: 0xB4 *//*!< RTC backup register 24,                                    Address offset: 0xB0 *//*!< RTC backup register 23,                                    Address offset: 0xAC *//*!< RTC backup register 22,                                    Address offset: 0xA8 *//*!< RTC backup register 21,                                    Address offset: 0xA4 *//*!< RTC backup register 20,                                    Address offset: 0xA0 *//*!< RTC backup register 19,                                    Address offset: 0x9C *//*!< RTC backup register 18,                                    Address offset: 0x98 *//*!< RTC backup register 17,                                    Address offset: 0x94 *//*!< RTC backup register 16,                                    Address offset: 0x90 *//*!< RTC backup register 15,                                    Address offset: 0x8C *//*!< RTC backup register 14,                                    Address offset: 0x88 *//*!< RTC backup register 13,                                    Address offset: 0x84 *//*!< RTC backup register 12,                                    Address offset: 0x80 *//*!< RTC backup register 11,                                    Address offset: 0x7C *//*!< RTC backup register 10,                                    Address offset: 0x78 *//*!< RTC backup register 9,                                     Address offset: 0x74 *//*!< RTC backup register 8,                                     Address offset: 0x70 *//*!< RTC backup register 7,                                     Address offset: 0x6C *//*!< RTC backup register 6,                                     Address offset: 0x68 *//*!< RTC backup register 5,                                     Address offset: 0x64 *//*!< RTC backup register 4,                                     Address offset: 0x60 *//*!< RTC backup register 3,                                     Address offset: 0x5C *//*!< RTC backup register 2,                                     Address offset: 0x58 *//*!< RTC backup register 1,                                     Address offset: 0x54 *//*!< RTC backup register 0,                                     Address offset: 0x50 *//*!< RTC option register,                                       Address offset: 0x4C *//*!< RTC alarm B sub second register,                           Address offset: 0x48 *//*!< RTC alarm A sub second register,                           Address offset: 0x44 *//*!< RTC tamper configuration register,                         Address offset: 0x40 *//*!< RTC calibration register,                                  Address offset: 0x3C *//*!< RTC time-stamp sub second register,                        Address offset: 0x38 *//*!< RTC time stamp date register,                              Address offset: 0x34 *//*!< RTC time stamp time register,                              Address offset: 0x30 *//*!< RTC shift control register,                                Address offset: 0x2C *//*!< RTC sub second register,                                   Address offset: 0x28 *//*!< RTC write protection register,                             Address offset: 0x24 *//*!< RTC alarm B register,                                      Address offset: 0x20 *//*!< RTC alarm A register,                                      Address offset: 0x1C *//*!< Reserved  *//*!< RTC wakeup timer register,                                 Address offset: 0x14 *//*!< RTC prescaler register,                                    Address offset: 0x10 *//*!< RTC initialization and status register,                    Address offset: 0x0C *//*!< RTC control register,                                      Address offset: 0x08 *//*!< RTC date register,                                         Address offset: 0x04 *//*!< RTC time register,                                         Address offset: 0x00 *//**
  * @brief Real-Time Clock
  *//*!< RCC Dedicated Clocks configuration register 2,               Address offset: 0x90 *//*!< RCC Dedicated Clocks configuration register1,                 Address offset: 0x8C *//*!< RCC PLLSAI configuration register,                           Address offset: 0x88 *//*!< RCC PLLI2S configuration register,                           Address offset: 0x84 *//*!< RCC spread spectrum clock generation register,               Address offset: 0x80 *//*!< Reserved, 0x78-0x7C                                                               *//*!< RCC clock control & status register,                         Address offset: 0x74 *//*!< RCC Backup domain control register,                          Address offset: 0x70 *//*!< Reserved, 0x68-0x6C                                                               *//*!< RCC APB2 peripheral clock enable in low power mode register, Address offset: 0x64 *//*!< RCC APB1 peripheral clock enable in low power mode register, Address offset: 0x60 *//*!< Reserved, 0x5C                                                                    *//*!< RCC AHB3 peripheral clock enable in low power mode register, Address offset: 0x58 *//*!< RCC AHB2 peripheral clock enable in low power mode register, Address offset: 0x54 *//*!< RCC AHB1 peripheral clock enable in low power mode register, Address offset: 0x50 *//*!< Reserved, 0x48-0x4C                                                               *//*!< RCC APB2 peripheral clock enable register,                   Address offset: 0x44 *//*!< RCC APB1 peripheral clock enable register,                   Address offset: 0x40 *//*!< Reserved, 0x3C                                                                    *//*!< RCC AHB3 peripheral clock register,                          Address offset: 0x38 *//*!< RCC AHB2 peripheral clock register,                          Address offset: 0x34 *//*!< RCC AHB1 peripheral clock register,                          Address offset: 0x30 *//*!< Reserved, 0x28-0x2C                                                               *//*!< RCC APB2 peripheral reset register,                          Address offset: 0x24 *//*!< RCC APB1 peripheral reset register,                          Address offset: 0x20 *//*!< Reserved, 0x1C                                                                    *//*!< RCC AHB3 peripheral reset register,                          Address offset: 0x18 *//*!< RCC AHB2 peripheral reset register,                          Address offset: 0x14 *//*!< RCC AHB1 peripheral reset register,                          Address offset: 0x10 *//*!< RCC clock interrupt register,                                Address offset: 0x0C *//*!< RCC clock configuration register,                            Address offset: 0x08 *//*!< RCC PLL configuration register,                              Address offset: 0x04 *//*!< RCC clock control register,                                  Address offset: 0x00 *//**
  * @brief Reset and Clock Control
  *//*!< PWR power control/status register 2, Address offset: 0x0C *//*!< PWR power control register 2,        Address offset: 0x08 *//*!< PWR power control/status register 2, Address offset: 0x04 *//*!< PWR power control register 1,        Address offset: 0x00 *//**
  * @brief Power Control
  *//*!< LTDC Layerx CLUT Write Register                               Address offset: 0x144 *//*!< Reserved *//*!< LTDC Layerx ColorFrame Buffer Line Number Register            Address offset: 0xB4 *//*!< LTDC Layerx Color Frame Buffer Length Register                Address offset: 0xB0 *//*!< LTDC Layerx Color Frame Buffer Address Register               Address offset: 0xAC *//*!< LTDC Layerx Blending Factors Configuration Register           Address offset: 0xA0 *//*!< LTDC Layerx Default Color Configuration Register              Address offset: 0x9C *//*!< LTDC Layerx Constant Alpha Configuration Register             Address offset: 0x98 *//*!< LTDC Layerx Pixel Format Configuration Register               Address offset: 0x94 *//*!< LTDC Layerx Color Keying Configuration Register               Address offset: 0x90 *//*!< LTDC Layerx Window Vertical Position Configuration Register   Address offset: 0x8C *//*!< LTDC Layerx Window Horizontal Position Configuration Register Address offset: 0x88 *//*!< LTDC Layerx Control Register                                  Address offset: 0x84 *//**
  * @brief LCD-TFT Display layer x Controller
  *//*!< LTDC Current Display Status Register,                 Address offset: 0x48 *//*!< LTDC Current Position Status Register,               Address offset: 0x44 *//*!< LTDC Line Interrupt Position Configuration Register, Address offset: 0x40 *//*!< LTDC Interrupt Clear Register,                       Address offset: 0x3C *//*!< LTDC Interrupt Status Register,                      Address offset: 0x38 *//*!< LTDC Interrupt Enable Register,                      Address offset: 0x34 *//*!< Reserved, 0x30 *//*!< LTDC Background Color Configuration Register,        Address offset: 0x2C *//*!< Reserved, 0x28 *//*!< LTDC Shadow Reload Configuration Register,           Address offset: 0x24 *//*!< Reserved, 0x1C-0x20 *//*!< LTDC Global Control Register,                        Address offset: 0x18 *//*!< LTDC Total Width Configuration Register,             Address offset: 0x14 *//*!< LTDC Active Width Configuration Register,            Address offset: 0x10 *//*!< LTDC Back Porch Configuration Register,              Address offset: 0x0C *//*!< LTDC Synchronization Size Configuration Register,    Address offset: 0x08 *//*!< Reserved, 0x00-0x04 *//**
  * @brief LCD-TFT Display Controller
  *//*!< IWDG Window register,    Address offset: 0x10 *//*!< IWDG Status register,    Address offset: 0x0C *//*!< IWDG Reload register,    Address offset: 0x08 *//*!< IWDG Prescaler register, Address offset: 0x04 *//*!< IWDG Key register,       Address offset: 0x00 *//**
  * @brief Independent WATCHDOG
  *//*!< I2C Transmit data register,        Address offset: 0x28 *//*!< I2C Receive data register,         Address offset: 0x24 *//*!< I2C PEC register,                  Address offset: 0x20 *//*!< I2C Interrupt clear register,      Address offset: 0x1C *//*!< I2C Interrupt and status register, Address offset: 0x18 *//*!< I2C Timeout register,              Address offset: 0x14 *//*!< I2C Timing register,               Address offset: 0x10 *//*!< I2C Own address 2 register,        Address offset: 0x0C *//*!< I2C Own address 1 register,        Address offset: 0x08 *//*!< I2C Control register 2,            Address offset: 0x04 *//*!< I2C Control register 1,            Address offset: 0x00 *//**
  * @brief Inter-integrated Circuit Interface
  *//*!< SYSCFG Compensation cell control register,         Address offset: 0x20      *//*!< SYSCFG Class B register,                           Address offset: 0x1C      *//*!< Reserved, 0x18                                                               *//*!< SYSCFG external interrupt configuration registers, Address offset: 0x08-0x14 *//*!< SYSCFG peripheral mode configuration register,     Address offset: 0x04      *//*!< SYSCFG memory remap register,                      Address offset: 0x00      *//**
  * @brief System configuration controller
  *//*!< GPIO alternate function registers,     Address offset: 0x20-0x24 *//*!< GPIO port configuration lock register, Address offset: 0x1C      *//*!< GPIO port bit set/reset register,      Address offset: 0x18      *//*!< GPIO port output data register,        Address offset: 0x14      *//*!< GPIO port input data register,         Address offset: 0x10      *//*!< GPIO port pull-up/pull-down register,  Address offset: 0x0C      *//*!< GPIO port output speed register,       Address offset: 0x08      *//*!< GPIO port output type register,        Address offset: 0x04      *//*!< GPIO port mode register,               Address offset: 0x00      *//**
  * @brief General Purpose I/O
  *//*!< SDRAM Status register,          Address offset: 0x158  *//*!< SDRAM Refresh Timer register,   Address offset: 0x154  *//*!< SDRAM Command Mode register,    Address offset: 0x150  *//*!< SDRAM Timing registers ,       Address offset: 0x148-0x14C  *//*!< SDRAM Control registers ,      Address offset: 0x140-0x144  *//**
  * @brief Flexible Memory Controller Bank5_6
  *//*!< NAND Flash ECC result registers,                   Address offset: 0x94 *//*!< Reserved, 0x90                                                          *//*!< NAND Flash Attribute memory space timing register, Address offset: 0x8C *//*!< NAND Flash Common memory space timing register,    Address offset: 0x88 *//*!< NAND Flash FIFO status and interrupt register,     Address offset: 0x84 *//*!< NAND Flash control register,                       Address offset: 0x80 *//**
  * @brief Flexible Memory Controller Bank3
  *//*!< NOR/PSRAM write timing registers, Address offset: 0x104-0x11C *//**
  * @brief Flexible Memory Controller Bank1E
  *//*!< NOR/PSRAM chip-select control register(BCR) and chip-select timing register(BTR), Address offset: 0x00-1C *//**
  * @brief Flexible Memory Controller
  *//*!< FLASH option control register 1 ,  Address offset: 0x18 *//*!< FLASH option control register ,    Address offset: 0x14 *//*!< FLASH control register,            Address offset: 0x10 *//*!< FLASH status register,             Address offset: 0x0C *//*!< FLASH option key register,         Address offset: 0x08 *//*!< FLASH key register,                Address offset: 0x04 *//*!< FLASH access control register,     Address offset: 0x00 *//**
  * @brief FLASH Registers
  *//*!< EXTI Pending register,                   Address offset: 0x14 *//*!< EXTI Software interrupt event register,  Address offset: 0x10 *//*!< EXTI Falling trigger selection register, Address offset: 0x0C *//*!< EXTI Rising trigger selection register,  Address offset: 0x08 *//*!< EXTI Event mask register,                Address offset: 0x04 *//*!< EXTI Interrupt mask register,            Address offset: 0x00 *//**
  * @brief External Interrupt/Event Controller
  *//*   84 *//*   69 *//*   65 *//*   24 *//*   15 *//*   11 *//*    8 *//**
  * @brief Ethernet MAC
  *//*!< DMA2D Background CLUT,                          Address offset:800-BFF *//*!< DMA2D Foreground CLUT,                          Address offset:400-7FF *//*!< Reserved, 0x50-0x3FF *//*!< DMA2D AHB Master Timer Configuration Register,  Address offset: 0x4C *//*!< DMA2D Line Watermark Register,                  Address offset: 0x48 *//*!< DMA2D Number of Line Register,                  Address offset: 0x44 *//*!< DMA2D Output Offset Register,                   Address offset: 0x40 *//*!< DMA2D Output Memory Address Register,           Address offset: 0x3C *//*!< DMA2D Output Color Register,                    Address offset: 0x38 *//*!< DMA2D Output PFC Control Register,              Address offset: 0x34 *//*!< DMA2D Background CLUT Memory Address Register,  Address offset: 0x30 *//*!< DMA2D Foreground CLUT Memory Address Register,  Address offset: 0x2C *//*!< DMA2D Background Color Register,                Address offset: 0x28 *//*!< DMA2D Background PFC Control Register,          Address offset: 0x24 *//*!< DMA2D Foreground Color Register,                Address offset: 0x20 *//*!< DMA2D Foreground PFC Control Register,          Address offset: 0x1C *//*!< DMA2D Background Offset Register,               Address offset: 0x18 *//*!< DMA2D Background Memory Address Register,       Address offset: 0x14 *//*!< DMA2D Foreground Offset Register,               Address offset: 0x10 *//*!< DMA2D Foreground Memory Address Register,       Address offset: 0x0C *//*!< DMA2D Interrupt Flag Clear Register,            Address offset: 0x08 *//*!< DMA2D Interrupt Status Register,                Address offset: 0x04 *//*!< DMA2D Control Register,                         Address offset: 0x00 *//**
  * @brief DMA2D Controller
  *//*!< DMA high interrupt flag clear register, Address offset: 0x0C *//*!< DMA low interrupt flag clear register,  Address offset: 0x08 *//*!< DMA high interrupt status register,     Address offset: 0x04 *//*!< DMA low interrupt status register,      Address offset: 0x00 *//*!< DMA stream x FIFO control register       *//*!< DMA stream x memory 1 address register   *//*!< DMA stream x memory 0 address register   *//*!< DMA stream x peripheral address register *//*!< DMA stream x number of data register     *//*!< DMA stream x configuration register      *//**
  * @brief DMA Controller
  *//*!< DCMI data register,                            Address offset: 0x28 *//*!< DCMI crop window size,                         Address offset: 0x24 *//*!< DCMI crop window start,                        Address offset: 0x20 *//*!< DCMI embedded synchronization unmask register, Address offset: 0x1C *//*!< DCMI embedded synchronization code register,   Address offset: 0x18 *//*!< DCMI interrupt clear register,                 Address offset: 0x14 *//*!< DCMI masked interrupt status register,         Address offset: 0x10 *//*!< DCMI interrupt enable register,                Address offset: 0x0C *//*!< DCMI raw interrupt status register,            Address offset: 0x08 *//*!< DCMI status register,                          Address offset: 0x04 *//*!< DCMI control register 1,                       Address offset: 0x00 *//**
  * @brief DCMI
  *//*!< Debug MCU APB2 freeze register,   Address offset: 0x0C *//*!< Debug MCU APB1 freeze register,   Address offset: 0x08 *//*!< Debug MCU configuration register, Address offset: 0x04 *//*!< MCU device ID code,               Address offset: 0x00 *//**
  * @brief Debug MCU
  *//*!< DFSDM channel data input register,                Address offset: 0x10 *//*!< DFSDM channel watchdog filter data register,      Address offset: 0x0C *//*!< DFSDM channel analog watchdog and
                                  short circuit detector register,                  Address offset: 0x08 *//*!< DFSDM channel configuration register2,            Address offset: 0x04 *//*!< DFSDM channel configuration register1,            Address offset: 0x00 *//**
  * @brief DFSDM channel configuration registers
  *//*!< DFSDM conversion timer,                           Address offset: 0x138 *//*!< DFSDM extreme detector minimum register           Address offset: 0x134 *//*!< DFSDM extreme detector maximum register,          Address offset: 0x130 *//*!< DFSDM analog watchdog clear flag register         Address offset: 0x12C *//*!< DFSDM analog watchdog status register             Address offset: 0x128 *//*!< DFSDM analog watchdog low threshold register,     Address offset: 0x124 *//*!< DFSDM analog watchdog high threshold register,    Address offset: 0x120 *//*!< DFSDM data register for regular group,            Address offset: 0x11C *//*!< DFSDM data register for injected group,           Address offset: 0x118 *//*!< DFSDM filter control register,                    Address offset: 0x114 *//*!< DFSDM injected channel group selection register,  Address offset: 0x110 *//*!< DFSDM interrupt flag clear register,              Address offset: 0x10C *//*!< DFSDM interrupt and status register,              Address offset: 0x108 *//*!< DFSDM control register2,                          Address offset: 0x104 *//*!< DFSDM control register1,                          Address offset: 0x100 *//**
  * @brief DFSDM module registers
  *//*!< DAC status register,                                     Address offset: 0x34 *//*!< DAC channel2 data output register,                       Address offset: 0x30 *//*!< DAC channel1 data output register,                       Address offset: 0x2C *//*!< DUAL DAC 8-bit right aligned data holding register,      Address offset: 0x28 *//*!< DUAL DAC 12-bit left aligned data holding register,      Address offset: 0x24 *//*!< Dual DAC 12-bit right-aligned data holding register,     Address offset: 0x20 *//*!< DAC channel2 8-bit right-aligned data holding register,  Address offset: 0x1C *//*!< DAC channel2 12-bit left aligned data holding register,  Address offset: 0x18 *//*!< DAC channel2 12-bit right aligned data holding register, Address offset: 0x14 *//*!< DAC channel1 8-bit right aligned data holding register,  Address offset: 0x10 *//*!< DAC channel1 12-bit left aligned data holding register,  Address offset: 0x0C *//*!< DAC channel1 12-bit right-aligned data holding register, Address offset: 0x08 *//*!< DAC software trigger register,                           Address offset: 0x04 *//*!< DAC control register,                                    Address offset: 0x00 *//**
  * @brief Digital to Analog Converter
  *//*!< CRC polynomial register,                     Address offset: 0x14 *//*!< Initial CRC value register,                  Address offset: 0x10 *//*!< Reserved,                                                    0x0C *//*!< CRC Control register,                        Address offset: 0x08 *//*!< Reserved, 0x06                                                    *//*!< Reserved, 0x05                                                    *//*!< CRC Independent data register,               Address offset: 0x04 *//*!< CRC Data register,                           Address offset: 0x00 *//**
  * @brief CRC calculation unit
  *//*!< CEC interrupt enable register,                              Address offset:0x14 *//*!< CEC Interrupt and Status Register,                          Address offset:0x10 *//*!< CEC Rx Data Register,                                       Address offset:0x0C *//*!< CEC Tx data register ,                                      Address offset:0x08 *//*!< CEC configuration register,                                 Address offset:0x04 *//*!< CEC control register,                                       Address offset:0x00 *//**
  * @brief HDMI-CEC
  *//*!< CAN Filter Register,                 Address offset: 0x240-0x31C   *//*!< Reserved, 0x220-0x23F                                              *//*!< CAN filter activation register,      Address offset: 0x21C         *//*!< Reserved, 0x218                                                    *//*!< CAN filter FIFO assignment register, Address offset: 0x214         *//*!< Reserved, 0x210                                                    *//*!< CAN filter scale register,           Address offset: 0x20C         *//*!< Reserved, 0x208                                                    *//*!< CAN filter mode register,            Address offset: 0x204         *//*!< CAN filter master register,          Address offset: 0x200         *//*!< Reserved, 0x1D0 - 0x1FF                                            *//*!< CAN FIFO MailBox,                    Address offset: 0x1B0 - 0x1CC *//*!< CAN Tx MailBox,                      Address offset: 0x180 - 0x1AC *//*!< Reserved, 0x020 - 0x17F                                            *//*!< CAN bit timing register,             Address offset: 0x1C          *//*!< CAN error status register,           Address offset: 0x18          *//*!< CAN interrupt enable register,       Address offset: 0x14          *//*!< CAN receive FIFO 1 register,         Address offset: 0x10          *//*!< CAN receive FIFO 0 register,         Address offset: 0x0C          *//*!< CAN transmit status register,        Address offset: 0x08          *//*!< CAN master status register,          Address offset: 0x04          *//*!< CAN master control register,         Address offset: 0x00          *//**
  * @brief Controller Area Network
  *//*!< CAN Filter bank register 1 *//**
  * @brief Controller Area Network FilterRegister
  *//*!< CAN receive FIFO mailbox data high register *//*!< CAN receive FIFO mailbox data low register *//*!< CAN receive FIFO mailbox data length control and time stamp register *//*!< CAN receive FIFO mailbox identifier register *//**
  * @brief Controller Area Network FIFOMailBox
  *//*!< CAN mailbox data high register *//*!< CAN mailbox data low register *//*!< CAN mailbox data length control and time stamp register *//*!< CAN TX mailbox identifier register *//**
  * @brief Controller Area Network TxMailBox
  *//*!< ADC common regular data register for dual
                             AND triple modes,                            Address offset: ADC1 base address + 0x308 *//*!< ADC common control register,                 Address offset: ADC1 base address + 0x304 *//*!< ADC Common status register,                  Address offset: ADC1 base address + 0x300 *//*!< ADC regular data register,                   Address offset: 0x4C *//*!< ADC injected data register 4,                Address offset: 0x48 *//*!< ADC injected data register 3,                Address offset: 0x44 *//*!< ADC injected data register 2,                Address offset: 0x40 *//*!< ADC injected data register 1,                Address offset: 0x3C *//*!< ADC injected sequence register,              Address offset: 0x38*//*!< ADC regular sequence register 3,             Address offset: 0x34 *//*!< ADC regular sequence register 2,             Address offset: 0x30 *//*!< ADC regular sequence register 1,             Address offset: 0x2C *//*!< ADC watchdog lower threshold register,       Address offset: 0x28 *//*!< ADC watchdog higher threshold register,      Address offset: 0x24 *//*!< ADC injected channel data offset register 4, Address offset: 0x20 *//*!< ADC injected channel data offset register 3, Address offset: 0x1C *//*!< ADC injected channel data offset register 2, Address offset: 0x18 *//*!< ADC injected channel data offset register 1, Address offset: 0x14 *//*!< ADC sample time register 2,                  Address offset: 0x10 *//*!< ADC sample time register 1,                  Address offset: 0x0C *//*!< ADC control register 2,                      Address offset: 0x08 *//*!< ADC control register 1,                      Address offset: 0x04 *//*!< ADC status register,                         Address offset: 0x00 *//**
  * @brief Analog to Digital Converter
  *//** @addtogroup Peripheral_registers_structures
  * @{
  *//*!< Cortex-M7 processor and core peripherals      *//*!< CM7 data cache present                        *//*!< CM7 instruction cache present                 *//*!< FPU present                                   *//*!< Set to 1 if different SysTick Config is used  *//*!< CM7 uses 4 Bits for the Priority Levels       *//*!< CM7 provides an MPU                           *//*!< Cortex-M7 revision r1p0                       *//**
 * @brief Configuration of the Cortex-M7 Processor and Core Peripherals
 *//*!< MDIO Slave global Interrupt                                       *//*!< JPEG global Interrupt                                             *//*!< CAN3 SCE Interrupt                                                *//*!< CAN3 RX1 Interrupt                                                *//*!< CAN3 RX0 Interrupt                                                *//*!< CAN3 TX Interrupt                                                 *//*!< SDMMC2 global Interrupt                                           *//*!< DFSDM1 Filter 3 global Interrupt                                  *//*!< DFSDM1 Filter 2 global Interrupt                                  *//*!< DFSDM1 Filter 1 global Interrupt                                  *//*!< DFSDM1 Filter 0 global Interrupt                                  *//*!< DSI global Interrupt                                              *//*!< SPDIF-RX global Interrupt                                         *//*!< I2C4 Error Interrupt                                              *//*!< I2C4 Event Interrupt                                              *//*!< HDMI-CEC global Interrupt                                         *//*!< LP TIM1 interrupt                                                 *//*!< Quad SPI global interrupt                                         *//*!< SAI2 global Interrupt                                             *//*!< DMA2D global Interrupt                                            *//*!< LTDC Error global Interrupt                                       *//*!< LTDC global Interrupt                                             *//*!< SAI1 global Interrupt                                             *//*!< SPI6 global Interrupt                                             *//*!< SPI5 global Interrupt                                             *//*!< SPI4 global Interrupt                                             *//*!< UART8 global interrupt                                            *//*!< UART7 global interrupt                                            *//*!< FPU global interrupt                                              *//*!< RNG global interrupt                                              *//*!< DCMI global interrupt                                             *//*!< USB OTG HS global interrupt                                       *//*!< USB OTG HS Wakeup through EXTI interrupt                          *//*!< USB OTG HS End Point 1 In global interrupt                        *//*!< USB OTG HS End Point 1 Out global interrupt                       *//*!< I2C3 error interrupt                                              *//*!< I2C3 event interrupt                                              *//*!< USART6 global interrupt                                           *//*!< DMA2 Stream 7 global interrupt                                    *//*!< DMA2 Stream 6 global interrupt                                    *//*!< DMA2 Stream 5 global interrupt                                    *//*!< USB OTG FS global Interrupt                                       *//*!< CAN2 SCE Interrupt                                                *//*!< CAN2 RX1 Interrupt                                                *//*!< CAN2 RX0 Interrupt                                                *//*!< CAN2 TX Interrupt                                                 *//*!< Ethernet Wakeup through EXTI line Interrupt                       *//*!< Ethernet global Interrupt                                         *//*!< DMA2 Stream 4 global Interrupt                                    *//*!< DMA2 Stream 3 global Interrupt                                    *//*!< DMA2 Stream 2 global Interrupt                                    *//*!< DMA2 Stream 1 global Interrupt                                    *//*!< DMA2 Stream 0 global Interrupt                                    *//*!< TIM7 global interrupt                                             *//*!< TIM6 global and DAC1&2 underrun error  interrupts                 *//*!< UART5 global Interrupt                                            *//*!< UART4 global Interrupt                                            *//*!< SPI3 global Interrupt                                             *//*!< TIM5 global Interrupt                                             *//*!< SDMMC1 global Interrupt                                           *//*!< FMC global Interrupt                                              *//*!< DMA1 Stream7 Interrupt                                            *//*!< TIM8 Capture Compare Interrupt                                    *//*!< TIM8 Trigger and Commutation Interrupt and TIM14 global interrupt *//*!< TIM8 Update Interrupt and TIM13 global interrupt                  *//*!< TIM8 Break Interrupt and TIM12 global interrupt                   *//*!< USB OTG FS Wakeup through EXTI line interrupt                     *//*!< RTC Alarm (A and B) through EXTI Line Interrupt                   *//*!< External Line[15:10] Interrupts                                   *//*!< USART3 global Interrupt                                           *//*!< USART2 global Interrupt                                           *//*!< USART1 global Interrupt                                           *//*!< SPI2 global Interrupt                                             *//*!< SPI1 global Interrupt                                             *//*!< I2C2 Error Interrupt                                              *//*!< I2C2 Event Interrupt                                              *//*!< I2C1 Error Interrupt                                              *//*!< I2C1 Event Interrupt                                              *//*!< TIM4 global Interrupt                                             *//*!< TIM3 global Interrupt                                             *//*!< TIM2 global Interrupt                                             *//*!< TIM1 Capture Compare Interrupt                                    *//*!< TIM1 Trigger and Commutation Interrupt and TIM11 global interrupt *//*!< TIM1 Update Interrupt and TIM10 global interrupt                  *//*!< TIM1 Break interrupt and TIM9 global interrupt                    *//*!< External Line[9:5] Interrupts                                     *//*!< CAN1 SCE Interrupt                                                *//*!< CAN1 RX1 Interrupt                                                *//*!< CAN1 RX0 Interrupt                                                *//*!< CAN1 TX Interrupt                                                 *//*!< ADC1, ADC2 and ADC3 global Interrupts                             *//*!< DMA1 Stream 6 global Interrupt                                    *//*!< DMA1 Stream 5 global Interrupt                                    *//*!< DMA1 Stream 4 global Interrupt                                    *//*!< DMA1 Stream 3 global Interrupt                                    *//*!< DMA1 Stream 2 global Interrupt                                    *//*!< DMA1 Stream 1 global Interrupt                                    *//*!< DMA1 Stream 0 global Interrupt                                    *//*!< EXTI Line4 Interrupt                                              *//*!< EXTI Line3 Interrupt                                              *//*!< EXTI Line2 Interrupt                                              *//*!< EXTI Line1 Interrupt                                              *//*!< EXTI Line0 Interrupt                                              *//*!< RCC global Interrupt                                              *//*!< FLASH global Interrupt                                            *//*!< RTC Wakeup interrupt through the EXTI line                        *//*!< Tamper and TimeStamp interrupts through the EXTI line             *//*!< PVD through EXTI Line detection Interrupt                         *//*!< Window WatchDog Interrupt                                         *//******  STM32 specific Interrupt Numbers **********************************************************************//*!< 15 Cortex-M7 System Tick Interrupt                                *//*!< 14 Cortex-M7 Pend SV Interrupt                                    *//*!< 12 Cortex-M7 Debug Monitor Interrupt                              *//*!< 11 Cortex-M7 SV Call Interrupt                                    *//*!< 6 Cortex-M7 Usage Fault Interrupt                                 *//*!< 5 Cortex-M7 Bus Fault Interrupt                                   *//*!< 4 Cortex-M7 Memory Management Interrupt                           *//*!< 2 Non Maskable Interrupt                                          *//******  Cortex-M7 Processor Exceptions Numbers ****************************************************************//**
 * @brief STM32F7xx Interrupt Number Definition, according to the selected device
 *        in @ref Library_configuration_section
 *//** @addtogroup Configuration_section_for_CMSIS
  * @{
  *//** @addtogroup stm32f769xx
  * @{
  *//** @addtogroup CMSIS_Device
  * @{
  *//**
  ******************************************************************************
  * @file    stm32f769xx.h
  * @author  MCD Application Team
  * @brief   CMSIS Cortex-M7 Device Peripheral Access Layer Header File.
  *
  *          This file contains:
  *           - Data structures and the address mapping for all peripherals
  *           - Peripheral's registers declarations and bits definition
  *           - Macros to access peripheral's registers hardware
  *
  ******************************************************************************
  * @attention
  *
  * Copyright (c) 2016 STMicroelectronics.
  * All rights reserved.
  *
  * This software is licensed under terms that can be found in the LICENSE file
  * in the root directory of this software component.
  * If no LICENSE file comes with this software, it is provided AS-IS.
  *
  ******************************************************************************
  */__STM32F7xx_HAL_Hdefined (STM32F765xx) || defined (STM32F767xx) || defined (STM32F769xx) || defined (STM32F777xx) || defined (STM32F779xx)/* __STM32F7xx_HAL_H *//** @defgroup HAL_Private_Constants HAL Private Constants
  * @{
  *//** @defgroup HAL_Private_Variables HAL Private Variables
  * @{
  *//* STM32F765xx || STM32F767xx || STM32F769xx || STM32F777xx || STM32F779xx *//* Peripheral Control functions  ************************************************//** @addtogroup HAL_Exported_Functions_Group2
  * @{
  *//** @addtogroup HAL_Exported_Variables
  * @{
  *//* Exported variables ---------------------------------------------------------*//* Initialization and Configuration functions  ******************************//** @addtogroup HAL_Exported_Functions_Group1
  * @{
  *//** @addtogroup HAL_Exported_Functions
  * @{
  *//** @defgroup HAL_Private_Macros HAL Private Macros
  * @{
  *//** @brief  SYSCFG Break PVD lock.
  *         Enable and lock the PVD connection to Timer1/8 Break input, as well as the PVDE and PLS[2:0] in the PWR_CR1 register.
  * @note   The selected configuration is locked and can be unlocked only by system reset.
  *//** @brief  SYSCFG Break Cortex-M7 Lockup lock.
  *         Enable and lock the connection of Cortex-M7 LOCKUP (Hardfault) output to TIM1/8 Break input.
  * @note   The selected configuration is locked and can be unlocked only by system reset.
  *//**
  * @brief  Return the memory boot mapping as configured by user.
  * @retval The boot mode as configured by user. The returned value can be one
  *         of the following values:
  *           @arg @ref SYSCFG_MEM_BOOT_ADD0
  *           @arg @ref SYSCFG_MEM_BOOT_ADD1
  *//** @brief  FMC/SDRAM  mapped at 0x60000000 (NOR/RAM) mapped at 0xC0000000
  *//** @brief  FMC (NOR/RAM) mapped at 0x60000000 and SDRAM mapped at 0xC0000000
  *//** @brief  Freeze/Unfreeze Peripherals in Debug mode 
  *//** @defgroup HAL_Exported_Macros HAL Exported Macros
  * @{
  *//** @defgroup SYSCFG_BootMode Boot Mode
  * @{
  *//** @defgroup HAL_TICK_FREQ Tick Frequency
  * @{
  *//** @defgroup HAL_Exported_Constants HAL Exported Constants
  * @{
  *//** @addtogroup HAL
  * @{
  *//** @addtogroup STM32F7xx_HAL_Driver
  * @{
  *//**
  ******************************************************************************
  * @file    stm32f7xx_hal.h
  * @author  MCD Application Team
  * @brief   This file contains all the functions prototypes for the HAL 
  *          module driver.
  ******************************************************************************
  * @attention
  *
  * Copyright (c) 2017 STMicroelectronics.
  * All rights reserved.
  *
  * This software is licensed under terms that can be found in the LICENSE file
  * in the root directory of this software component.
  * If no LICENSE file comes with this software, it is provided AS-IS.
  *
  ******************************************************************************
  */"stm32f769xx.h"ErrorStatusSUCCESSERROR!SUCCESSFunctionalState!DISABLEFlagStatusRESETSET!RESETATOMIC_MODIFYH_REG(REG,CLEARMSK,SETMASK)do { uint16_t val; do { val = (__LDREXH((__IO uint16_t *)&(REG)) & ~(CLEARMSK)) | (SETMASK); } while ((__STREXH(val,(__IO uint16_t *)&(REG))) != 0U); } while(0)ATOMIC_CLEARH_BIT(REG,BIT)do { uint16_t val; do { val = __LDREXH((__IO uint16_t *)&(REG)) & ~(BIT); } while ((__STREXH(val,(__IO uint16_t *)&(REG))) != 0U); } while(0)ATOMIC_SETH_BIT(REG,BIT)do { uint16_t val; do { val = __LDREXH((__IO uint16_t *)&(REG)) | (BIT); } while ((__STREXH(val,(__IO uint16_t *)&(REG))) != 0U); } while(0)ATOMIC_MODIFY_REG(REG,CLEARMSK,SETMASK)do { uint32_t val; do { val = (__LDREXW((__IO uint32_t *)&(REG)) & ~(CLEARMSK)) | (SETMASK); } while ((__STREXW(val,(__IO uint32_t *)&(REG))) != 0U); } while(0)ATOMIC_CLEAR_BIT(REG,BIT)do { uint32_t val; do { val = __LDREXW((__IO uint32_t *)&(REG)) & ~(BIT); } while ((__STREXW(val,(__IO uint32_t *)&(REG))) != 0U); } while(0)ATOMIC_SET_BIT(REG,BIT)do { uint32_t val; do { val = __LDREXW((__IO uint32_t *)&(REG)) | (BIT); } while ((__STREXW(val,(__IO uint32_t *)&(REG))) != 0U); } while(0)POSITION_VAL(VAL)(__CLZ(__RBIT(VAL)))MODIFY_REG(REG,CLEARMASK,SETMASK)WRITE_REG((REG), (((READ_REG(REG)) & (~(CLEARMASK))) | (SETMASK)))READ_REG(REG)((REG))WRITE_REG(REG,VAL)((REG) = (VAL))CLEAR_REG(REG)((REG) = (0x0))READ_BIT(REG,BIT)((REG) & (BIT))CLEAR_BIT(REG,BIT)((REG) &= ~(BIT))SET_BIT(REG,BIT)((REG) |= (BIT))IS_FUNCTIONAL_STATE(STATE)(((STATE) == DISABLE) || ((STATE) == ENABLE))__STM32F7_CMSIS_VERSION((__STM32F7_CMSIS_VERSION_MAIN << 24) |(__STM32F7_CMSIS_VERSION_SUB1 << 16) |(__STM32F7_CMSIS_VERSION_SUB2 << 8 ) |(__STM32F7_CMSIS_VERSION_RC))__STM32F7_CMSIS_VERSION_RC__STM32F7_CMSIS_VERSION_SUB2(0x09)__STM32F7_CMSIS_VERSION_SUB1__STM32F7_CMSIS_VERSION_MAINSTM32F7__STM32F7xx_H!defined (STM32F7)!defined (STM32F756xx) && !defined (STM32F746xx) && !defined (STM32F745xx) && !defined (STM32F765xx) && !defined (STM32F767xx) && !defined (STM32F769xx) && !defined (STM32F777xx) && !defined (STM32F779xx) && !defined (STM32F722xx) && !defined (STM32F723xx) && !defined (STM32F732xx) && !defined (STM32F733xx) && !defined (STM32F730xx) && !defined (STM32F750xx)!defined (USE_HAL_DRIVER)defined(STM32F722xx)defined(STM32F723xx)defined(STM32F732xx)defined(STM32F733xx)defined(STM32F756xx)defined(STM32F746xx)defined(STM32F745xx)defined(STM32F765xx)defined(STM32F767xx)defined(STM32F769xx)defined(STM32F777xx)defined(STM32F779xx)defined(STM32F730xx)defined(STM32F750xx)USE_HAL_DRIVERSTM32F769xx/* __STM32F7xx_H *//* USE_HAL_DRIVER *//* Atomic 16-bit register access macro to clear and set one or several bits *//* Atomic 16-bit register access macro to clear one or several bits *//* Atomic 16-bit register access macro to set one or several bits *//* Atomic 32-bit register access macro to clear and set one or several bits *//* Atomic 32-bit register access macro to clear one or several bits *//* Atomic 32-bit register access macro to set one or several bits *//* Use of CMSIS compiler intrinsics for register exclusive access *//** @addtogroup Exported_macro
  * @{
  *//** @addtogroup Exported_types
  * @{
  *//** @addtogroup Device_Included
  * @{
  *//**
  * @brief CMSIS Device version number V1.2.9
  *//*#define USE_HAL_DRIVER *//**
 * @brief Comment the line below if you will not use the peripherals drivers.
   In this case, these drivers will not be included and the application code will
   be based on direct access to peripherals registers
   *//*  Tip: To avoid modifying this file each time you need to switch between these
        devices, you can define the device in your toolchain compiler preprocessor.
  *//*!< STM32F750V, STM32F750Z, STM32F750N Devices *//* #define STM32F750xx *//*!< STM32F730R, STM32F730V, STM32F730Z, STM32F730I Devices *//* #define STM32F730xx *//*!< STM32F733IE, STM32F733ZE, STM32F733VE Devices *//* #define STM32F733xx *//*!< STM32F732IE, STM32F732ZE, STM32F732VE, STM32F732RE Devices *//* #define STM32F732xx *//*!< STM32F723IE, STM32F723ZE, STM32F723VE, STM32F723IC, STM32F723ZC, STM32F723VC Devices *//* #define STM32F723xx *//*!< STM32F722IE, STM32F722ZE, STM32F722VE, STM32F722RE, STM32F722IC, STM32F722ZC,
                                   STM32F722VC, STM32F722RC Devices *//* #define STM32F722xx *//*!< STM32F779II, STM32F779BI, STM32F779NI, STM32F779AI, STM32F778AI Devices *//* #define STM32F779xx *//*!< STM32F777VI, STM32F777ZI, STM32F777II, STM32F777BI, STM32F777NI Devices *//* #define STM32F777xx *//*!< STM32F769AG, STM32F769AI, STM32F769BG, STM32F769BI, STM32F769IG, STM32F769II,
                                   STM32F769NG, STM32F769NI, STM32F768AI Devices *//* #define STM32F769xx *//*!< STM32F767BG, STM32F767BI, STM32F767IG, STM32F767II, STM32F767NG, STM32F767NI,
                                   STM32F767VG, STM32F767VI, STM32F767ZG, STM32F767ZI Devices *//* #define STM32F767xx *//*!< STM32F765BI, STM32F765BG, STM32F765NI, STM32F765NG, STM32F765II, STM32F765IG,
                                   STM32F765ZI, STM32F765ZG, STM32F765VI, STM32F765VG Devices *//* #define STM32F765xx *//*!< STM32F745VE, STM32F745VG, STM32F745ZG, STM32F745ZE, STM32F745IE, STM32F745IG Devices *//* #define STM32F745xx *//*!< STM32F746VE, STM32F746VG, STM32F746ZE, STM32F746ZG, STM32F746IE, STM32F746IG,
                                   STM32F746BE, STM32F746BG, STM32F746NE, STM32F746NG Devices *//* #define STM32F746xx *//*!< STM32F756VG, STM32F756ZG, STM32F756ZG, STM32F756IG, STM32F756BG,
                                   STM32F756NG Devices *//* #define STM32F756xx *//* Uncomment the line below according to the target STM32 device used in your
   application
  *//* STM32F7 *//**
  * @brief STM32 Family
  *//** @addtogroup Library_configuration_section
  * @{
  *//** @addtogroup stm32f7xx
  * @{
  *//**
  ******************************************************************************
  * @file    stm32f7xx.h
  * @author  MCD Application Team
  * @brief   CMSIS STM32F7xx Device Peripheral Access Layer Header File.
  *
  *          The file is the unique include file that the application programmer
  *          is using in the C source code, usually in main.c. This file contains:
  *           - Configuration section that allows to select:
  *              - The STM32F7xx device used in the target application
  *              - To use or not the peripheral's drivers in application code(i.e.
  *                code will be based on direct access to peripheral's registers
  *                rather than drivers API), this option is controlled by
  *                "#define USE_HAL_DRIVER"
  *
  ******************************************************************************
  * @attention
  *
  * Copyright (c) 2016 STMicroelectronics.
  * All rights reserved.
  *
  * This software is licensed under terms that can be found in the LICENSE file
  * in the root directory of this software component.
  * If no LICENSE file comes with this software, it is provided AS-IS.
  *
  ******************************************************************************
  */ART_ACCLERATOR_ENABLEART_ACCELERATOR_ENABLEHAL_QPSI_TIMEOUT_DEFAULT_VALUEHAL_QSPI_TIMEOUT_DEFAULT_VALUESAI_SYNCEXT_IN_ENABLESAI_SYNCEXT_OUTBLOCKA_ENABLESAI_SYNCHRONOUS_EXTSAI_SYNCHRONOUS_EXT_SAI1IS_SAI_BLOCK_MONO_STREO_MODEIS_SAI_BLOCK_MONO_STEREO_MODESAI_FIFOStatus_FullSAI_FIFOSTATUS_FULLSAI_FIFOStatus_3QuartersFullSAI_FIFOSTATUS_3QUARTERFULLSAI_FIFOStatus_HalfFullSAI_FIFOSTATUS_HALFFULLSAI_FIFOStatus_1QuarterFullSAI_FIFOSTATUS_1QUARTERFULLSAI_FIFOStatus_Less1QuarterFullSAI_FIFOSTATUS_LESS1QUARTERFULLSAI_FIFOStatus_EmptySAI_FIFOSTATUS_EMPTYSAI_STREOMODESAI_STEREOMODESAI_MASTERDIVIDER_DISABLEDSAI_MASTERDIVIDER_DISABLESAI_MASTERDIVIDER_ENABLEDSAI_MASTERDIVIDER_ENABLESAI_OUTPUTDRIVE_ENABLEDSAI_OUTPUTDRIVE_ENABLESAI_OUTPUTDRIVE_DISABLEDSAI_OUTPUTDRIVE_DISABLE__HAL_LTDC_RELOAD_CONFIG__HAL_LTDC_RELOAD_IMMEDIATE_CONFIG__HAL_LTDC_LAYERLTDC_LAYERIS_ETH_PROMISCIOUS_MODEIS_ETH_PROMISCUOUS_MODEETH_PROMISCIOUSMODE_DISABLEETH_PROMISCUOUS_MODE_DISABLEETH_PROMISCIOUSMODE_ENABLEETH_PROMISCUOUS_MODE_ENABLE__HAL_ETH_EXTI_SET_FALLINGRISING_TRIGGER__HAL_ETH_WAKEUP_EXTI_ENABLE_FALLINGRISING_TRIGGER__HAL_ETH_EXTI_SET_FALLING_EGDE_TRIGGER__HAL_ETH_WAKEUP_EXTI_ENABLE_FALLING_EDGE_TRIGGER__HAL_ETH_EXTI_SET_RISING_EGDE_TRIGGER__HAL_ETH_WAKEUP_EXTI_ENABLE_RISING_EDGE_TRIGGER__HAL_ETH_EXTI_CLEAR_FLAG__HAL_ETH_WAKEUP_EXTI_CLEAR_FLAG__HAL_ETH_EXTI_GET_FLAG__HAL_ETH_WAKEUP_EXTI_GET_FLAG__HAL_ETH_EXTI_DISABLE_IT__HAL_ETH_WAKEUP_EXTI_DISABLE_IT__HAL_ETH_EXTI_ENABLE_IT__HAL_ETH_WAKEUP_EXTI_ENABLE_ITTIM_OCMODE_ASSYMETRIC_PWM2TIM_OCMODE_ASYMMETRIC_PWM2TIM_OCMODE_ASSYMETRIC_PWM1TIM_OCMODE_ASYMMETRIC_PWM1TIM_BREAKINPUTSOURCE_DFSDMTIM_BREAKINPUTSOURCE_DFSDM1__HAL_TIM_GetCompare__HAL_TIM_GET_COMPARE__HAL_TIM_SetCompare__HAL_TIM_SET_COMPARE__HAL_TIM_GetICPrescaler__HAL_TIM_GET_ICPRESCALER__HAL_TIM_SetICPrescaler__HAL_TIM_SET_ICPRESCALER__HAL_TIM_GetClockDivision__HAL_TIM_GET_CLOCKDIVISION__HAL_TIM_SetClockDivision__HAL_TIM_SET_CLOCKDIVISION__HAL_TIM_GetAutoreload__HAL_TIM_GET_AUTORELOAD__HAL_TIM_SetAutoreload__HAL_TIM_SET_AUTORELOAD__HAL_TIM_GetCounter__HAL_TIM_GET_COUNTER__HAL_TIM_SetCounter__HAL_TIM_SET_COUNTER__HAL_TIM_PRESCALER__HAL_TIM_SET_PRESCALER__HAL_TIM_DIRECTION_STATUS__HAL_TIM_IS_TIM_COUNTING_DOWN__HAL_TIM_GET_ITSTATUS__HAL_TIM_GET_IT_SOURCETIM_GET_CLEAR_IT__HAL_TIM_CLEAR_ITTIM_GET_ITSTATUS__HAL_TIM_ResetICPrescalerValueTIM_RESET_ICPRESCALERVALUE__HAL_TIM_SetICPrescalerValueTIM_SET_ICPRESCALERVALUEHAL_PCD_SetRxFiFoHAL_PCDEx_SetRxFiFoHAL_PCD_SetTxFiFoHAL_PCDEx_SetTxFiFoHAL_PCD_DeActiveRemoteWakeupHAL_PCD_DeActivateRemoteWakeupHAL_PCD_ActiveRemoteWakeupHAL_PCD_ActivateRemoteWakeup__HAL_USB_HS_EXTI_GENERATE_SWIT__HAL_USB_OTG_HS_WAKEUP_EXTI_GENERATE_SWIT__HAL_USB_HS_EXTI_SET_FALLINGRISING_TRIGGER__HAL_USB_OTG_HS_WAKEUP_EXTI_ENABLE_RISING_FALLING_EDGE__HAL_USB_HS_EXTI_SET_FALLING_EGDE_TRIGGER__HAL_USB_OTG_HS_WAKEUP_EXTI_ENABLE_FALLING_EDGE__HAL_USB_HS_EXTI_SET_RISING_EGDE_TRIGGER__HAL_USB_OTG_HS_WAKEUP_EXTI_ENABLE_RISING_EDGE__HAL_USB_HS_EXTI_CLEAR_FLAG__HAL_USB_OTG_HS_WAKEUP_EXTI_CLEAR_FLAG__HAL_USB_HS_EXTI_GET_FLAG__HAL_USB_OTG_HS_WAKEUP_EXTI_GET_FLAG__HAL_USB_HS_EXTI_DISABLE_IT__HAL_USB_OTG_HS_WAKEUP_EXTI_DISABLE_IT__HAL_USB_HS_EXTI_ENABLE_IT__HAL_USB_OTG_HS_WAKEUP_EXTI_ENABLE_IT__HAL_USB_FS_EXTI_GENERATE_SWIT__HAL_USB_OTG_FS_WAKEUP_EXTI_GENERATE_SWIT__HAL_USB_FS_EXTI_SET_FALLINGRISING_TRIGGER__HAL_USB_OTG_FS_WAKEUP_EXTI_ENABLE_RISING_FALLING_EDGE__HAL_USB_FS_EXTI_SET_FALLING_EGDE_TRIGGER__HAL_USB_OTG_FS_WAKEUP_EXTI_ENABLE_FALLING_EDGE__HAL_USB_FS_EXTI_SET_RISING_EGDE_TRIGGER__HAL_USB_OTG_FS_WAKEUP_EXTI_ENABLE_RISING_EDGE__HAL_USB_FS_EXTI_CLEAR_FLAG__HAL_USB_OTG_FS_WAKEUP_EXTI_CLEAR_FLAG__HAL_USB_FS_EXTI_GET_FLAG__HAL_USB_OTG_FS_WAKEUP_EXTI_GET_FLAG__HAL_USB_FS_EXTI_DISABLE_IT__HAL_USB_OTG_FS_WAKEUP_EXTI_DISABLE_IT__HAL_USB_FS_EXTI_ENABLE_IT__HAL_USB_OTG_FS_WAKEUP_EXTI_ENABLE_IT__HAL_USB_EXTI_SET_FALLINGRISING_TRIGGER__HAL_USB_WAKEUP_EXTI_ENABLE_RISING_FALLING_EDGE__HAL_USB_EXTI_SET_FALLING_EDGE_TRIGGER__HAL_USB_WAKEUP_EXTI_ENABLE_FALLING_EDGE__HAL_USB_EXTI_SET_RISING_EDGE_TRIGGER__HAL_USB_WAKEUP_EXTI_ENABLE_RISING_EDGE__HAL_USB_EXTI_CLEAR_FLAG__HAL_USB_WAKEUP_EXTI_CLEAR_FLAG__HAL_USB_EXTI_GET_FLAG__HAL_USB_WAKEUP_EXTI_GET_FLAG__HAL_USB_EXTI_DISABLE_IT__HAL_USB_WAKEUP_EXTI_DISABLE_IT__HAL_USB_EXTI_ENABLE_IT__HAL_USB_WAKEUP_EXTI_ENABLE_ITUSB_HS_EXTI_LINE_WAKEUPUSB_OTG_HS_WAKEUP_EXTI_LINEUSB_HS_EXTI_TRIGGER_BOTH_EDGEUSB_OTG_HS_WAKEUP_EXTI_RISING_FALLING_EDGEUSB_HS_EXTI_TRIGGER_FALLING_EDGEUSB_OTG_HS_WAKEUP_EXTI_FALLING_EDGEUSB_HS_EXTI_TRIGGER_RISING_EDGEUSB_OTG_HS_WAKEUP_EXTI_RISING_EDGEUSB_FS_EXTI_LINE_WAKEUPUSB_OTG_FS_WAKEUP_EXTI_LINEUSB_FS_EXTI_TRIGGER_BOTH_EDGEUSB_OTG_FS_WAKEUP_EXTI_RISING_FALLING_EDGEUSB_FS_EXTI_TRIGGER_FALLING_EDGEUSB_OTG_FS_WAKEUP_EXTI_FALLING_EDGEUSB_FS_EXTI_TRIGGER_RISING_EDGEUSB_OTG_FS_WAKEUP_EXTI_RISING_EDGEUSB_EXTI_LINE_WAKEUPUSB_WAKEUP_EXTI_LINEIS_USART_OVERSAMPLING(__SAMPLING__)(((__SAMPLING__) == USART_OVERSAMPLING_16) || ((__SAMPLING__) == USART_OVERSAMPLING_8))USART_OVERSAMPLING_8USART_OVERSAMPLING_16__USART_GETCLOCKSOURCEUSART_GETCLOCKSOURCE__HAL_USART_GETCLOCKSOURCE__USART_DISABLE__HAL_USART_DISABLE__USART_ENABLE__HAL_USART_ENABLE__USART_DISABLE_IT__HAL_USART_DISABLE_IT__USART_ENABLE_IT__HAL_USART_ENABLE_ITIS_UART_ONEBIT_SAMPLINGIS_UART_ONE_BIT_SAMPLEIS_UART_ONEBIT_SAMPLEIS_UART_WAKEUPMETHODEIS_UART_WAKEUPMETHOD__UART_MASK_COMPUTATIONUART_MASK_COMPUTATION__UART_GETCLOCKSOURCEUART_GETCLOCKSOURCE__HAL_UART_MASK_COMPUTATION__HAL_UART_GETCLOCKSOURCE__HAL_SPI_RESET_CRCSPI_RESET_CRC__HAL_SPI_1LINE_RXSPI_1LINE_RX__HAL_SPI_1LINE_TXSPI_1LINE_TX__HAL_SMBUS_GET_ALERT_ENABLEDSMBUS_GET_ALERT_ENABLED__HAL_SMBUS_GET_PEC_MODESMBUS_GET_PEC_MODE__HAL_SMBUS_GET_STOP_MODESMBUS_GET_STOP_MODE__HAL_SMBUS_GET_DIRSMBUS_GET_DIR__HAL_SMBUS_GET_ADDR_MATCHSMBUS_GET_ADDR_MATCH__HAL_SMBUS_GENERATE_STARTSMBUS_GENERATE_START__HAL_SMBUS_RESET_CR2SMBUS_RESET_CR2__HAL_SMBUS_RESET_CR1SMBUS_RESET_CR1IS_SMARTCARD_ONEBIT_SAMPLINGIS_SMARTCARD_ONE_BIT_SAMPLE__SMARTCARD_GETCLOCKSOURCESMARTCARD_GETCLOCKSOURCE__HAL_SMARTCARD_GETCLOCKSOURCE__SMARTCARD_DMA_REQUEST_DISABLE__HAL_SMARTCARD_DMA_REQUEST_DISABLE__SMARTCARD_DMA_REQUEST_ENABLE__HAL_SMARTCARD_DMA_REQUEST_ENABLE__SMARTCARD_DISABLE__HAL_SMARTCARD_DISABLE__SMARTCARD_ENABLE__HAL_SMARTCARD_ENABLE__SMARTCARD_DISABLE_IT__HAL_SMARTCARD_DISABLE_IT__SMARTCARD_ENABLE_IT__HAL_SMARTCARD_ENABLE_ITHAL_SD_CardStateTypedefHAL_SD_CardStateTypeDefHAL_SD_CardStatusTypedefHAL_SD_CardStatusTypeDefHAL_SD_CardCSDTypedefHAL_SD_CardCSDTypeDefHAL_SD_CardCIDTypedefHAL_SD_CardCIDTypeDefSDIO_IRQHandlerSDIO_IRQnSD_SDIO_SEND_IF_CONDSD_SDMMC_SEND_IF_CONDSDIO_CMD0TIMEOUTSDMMC_CMD0TIMEOUTSDIO_STATIC_FLAGSSDMMC_STATIC_FLAGS__HAL_SD_SDIO_CLEAR_IT__HAL_SD_SDMMC_CLEAR_IT__HAL_SD_SDIO_GET_IT__HAL_SD_SDMMC_GET_IT__HAL_SD_SDIO_CLEAR_FLAG__HAL_SD_SDMMC_CLEAR_FLAG__HAL_SD_SDIO_GET_FLAG__HAL_SD_SDMMC_GET_FLAG__HAL_SD_SDIO_DISABLE_IT__HAL_SD_SDMMC_DISABLE_IT__HAL_SD_SDIO_ENABLE_IT__HAL_SD_SDMMC_ENABLE_IT__HAL_SD_SDIO_DMA_DISABL__HAL_SD_SDMMC_DMA_DISABLE__HAL_SD_SDIO_DMA_ENABLE__HAL_SD_SDMMC_DMA_ENABLE__HAL_SD_SDIO_DISABLE__HAL_SD_SDMMC_DISABLE__HAL_SD_SDIO_ENABLE__HAL_SD_SDMMC_ENABLESD_CMD_SDIO_RW_EXTENDEDSD_CMD_SDMMC_RW_EXTENDEDSD_CMD_SDIO_RW_DIRECTSD_CMD_SDMMC_RW_DIRECTSD_CMD_SDIO_SEN_OP_CONDSD_CMD_SDMMC_SEN_OP_CONDSD_SDIO_UNKNOWN_FUNCTIONSD_SDMMC_UNKNOWN_FUNCTIONSD_SDIO_FUNCTION_FAILEDSD_SDMMC_FUNCTION_FAILEDSD_SDIO_FUNCTION_BUSYSD_SDMMC_FUNCTION_BUSYSD_SDIO_DISABLEDSD_SDMMC_DISABLEDSDMMC_HSpeed_CLK_DIVSDMMC_HSPEED_CLK_DIVSDMMC_NSpeed_CLK_DIVSDMMC_NSPEED_CLK_DIVeMMC_LOW_VOLTAGE_RANGEEMMC_LOW_VOLTAGE_RANGEeMMC_DUAL_VOLTAGE_RANGEEMMC_DUAL_VOLTAGE_RANGEeMMC_HIGH_VOLTAGE_RANGEEMMC_HIGH_VOLTAGE_RANGESD_CMD_SD_APP_STAUSSD_CMD_SD_APP_STATUSSD_OCR_CID_CSD_OVERWRIETESD_OCR_CID_CSD_OVERWRITE__RTC_WRITEPROTECTION_DISABLE__HAL_RTC_WRITEPROTECTION_DISABLE__RTC_WRITEPROTECTION_ENABLE__HAL_RTC_WRITEPROTECTION_ENABLEIS_WAKEUP_COUNTERIS_RTC_WAKEUP_COUNTERIS_WAKEUP_CLOCKIS_RTC_WAKEUP_CLOCKIS_TAMPER_TRIGGERIS_RTC_TAMPER_TRIGGERIS_TAMPER_TIMESTAMPONTAMPER_DETECTIONIS_RTC_TAMPER_TIMESTAMPONTAMPER_DETECTIONIS_TAMPER_SAMPLING_FREQIS_RTC_TAMPER_SAMPLING_FREQIS_TAMPER_PULLUP_STATEIS_RTC_TAMPER_PULLUP_STATEIS_TAMPER_PRECHARGE_DURATIONIS_RTC_TAMPER_PRECHARGE_DURATIONIS_TAMPER_MASKFLAG_STATEIS_RTC_TAMPER_MASKFLAG_STATEIS_TAMPER_INTERRUPTIS_RTC_TAMPER_INTERRUPTIS_TAMPER_FILTERIS_RTC_TAMPER_FILTERIS_TAMPER_ERASE_MODEIS_RTC_TAMPER_ERASE_MODEIS_TAMPERIS_RTC_TAMPERIS_ALARM_MASKIS_RTC_ALARM_MASKIS_ALARMIS_RTC_ALARM__HAL_RTC_TAMPER_GET_IT__HAL_RTC_TAMPER_GET_FLAG__HAL_RTC_EXTI_GENERATE_SWIT(__EXTI_LINE__)(((__EXTI_LINE__) == RTC_EXTI_LINE_ALARM_EVENT) ? __HAL_RTC_ALARM_EXTI_GENERATE_SWIT() : (((__EXTI_LINE__) == RTC_EXTI_LINE_WAKEUPTIMER_EVENT) ? __HAL_RTC_WAKEUPTIMER_EXTI_GENERATE_SWIT() : __HAL_RTC_TAMPER_TIMESTAMP_EXTI_GENERATE_SWIT()))__HAL_RTC_EXTI_GET_FLAG(__EXTI_LINE__)(((__EXTI_LINE__) == RTC_EXTI_LINE_ALARM_EVENT) ? __HAL_RTC_ALARM_EXTI_GET_FLAG() : (((__EXTI_LINE__) == RTC_EXTI_LINE_WAKEUPTIMER_EVENT) ? __HAL_RTC_WAKEUPTIMER_EXTI_GET_FLAG() : __HAL_RTC_TAMPER_TIMESTAMP_EXTI_GET_FLAG()))__HAL_RTC_EXTI_DISABLE_IT(__EXTI_LINE__)(((__EXTI_LINE__) == RTC_EXTI_LINE_ALARM_EVENT) ? __HAL_RTC_ALARM_EXTI_DISABLE_IT() : (((__EXTI_LINE__) == RTC_EXTI_LINE_WAKEUPTIMER_EVENT) ? __HAL_RTC_WAKEUPTIMER_EXTI_DISABLE_IT() : __HAL_RTC_TAMPER_TIMESTAMP_EXTI_DISABLE_IT()))__HAL_RTC_EXTI_ENABLE_IT(__EXTI_LINE__)(((__EXTI_LINE__) == RTC_EXTI_LINE_ALARM_EVENT) ? __HAL_RTC_ALARM_EXTI_ENABLE_IT() : (((__EXTI_LINE__) == RTC_EXTI_LINE_WAKEUPTIMER_EVENT) ? __HAL_RTC_WAKEUPTIMER_EXTI_ENABLE_IT() : __HAL_RTC_TAMPER_TIMESTAMP_EXTI_ENABLE_IT()))__HAL_RTC_EXTI_CLEAR_FLAG(__EXTI_LINE__)(((__EXTI_LINE__) == RTC_EXTI_LINE_ALARM_EVENT) ? __HAL_RTC_ALARM_EXTI_CLEAR_FLAG() : (((__EXTI_LINE__) == RTC_EXTI_LINE_WAKEUPTIMER_EVENT) ? __HAL_RTC_WAKEUPTIMER_EXTI_CLEAR_FLAG() : __HAL_RTC_TAMPER_TIMESTAMP_EXTI_CLEAR_FLAG()))__HAL_RTC_ENABLE_IT__HAL_RTC_EXTI_ENABLE_IT__HAL_RTC_DISABLE_IT__HAL_RTC_EXTI_DISABLE_IT__HAL_RTC_CLEAR_FLAG__HAL_RTC_EXTI_CLEAR_FLAGHAL_RNG_ReadyCallback(__HANDLE__)HAL_RNG_ReadyDataCallback((__HANDLE__), uint32_t random32bit)RCC_FMPI2C1CLKSOURCE_APBRCC_FMPI2C1CLKSOURCE_PCLK1RCC_DFSDM2CLKSOURCE_APB2RCC_DFSDM2CLKSOURCE_PCLK2RCC_DFSDM1CLKSOURCE_APB2RCC_DFSDM1CLKSOURCE_PCLK2RCC_DFSDM2AUDIOCLKSOURCE_I2SAPB2RCC_DFSDM2AUDIOCLKSOURCE_I2S2RCC_DFSDM2AUDIOCLKSOURCE_I2SAPB1RCC_DFSDM2AUDIOCLKSOURCE_I2S1RCC_DFSDM1AUDIOCLKSOURCE_I2SAPB2RCC_DFSDM1AUDIOCLKSOURCE_I2S2RCC_DFSDM1AUDIOCLKSOURCE_I2SAPB1RCC_DFSDM1AUDIOCLKSOURCE_I2S1RCC_LPTIM2CLKSOURCE_PCLKRCC_LPTIM2CLKSOURCE_PCLK1RCC_LPTIM1CLKSOURCE_PCLKRCC_LPTIM1CLKSOURCE_PCLK1RCC_SWPMI1CLKSOURCE_PCLKRCC_SWPMI1CLKSOURCE_PCLK1RCC_DFSDM1CLKSOURCE_PCLK__HAL_RCC_GET_DFSDM_SOURCE__HAL_RCC_GET_DFSDM1_SOURCE__HAL_RCC_DFSDM_CONFIG__HAL_RCC_DFSDM1_CONFIGRCC_DFSDMCLKSOURCE_SYSCLKRCC_DFSDM1CLKSOURCE_SYSCLKRCC_DFSDMCLKSOURCE_PCLKRCC_PERIPHCLK_DFSDMRCC_PERIPHCLK_DFSDM1DfsdmClockSelectionDfsdm1ClockSelection__HAL_RCC_DFSDM_IS_CLK_SLEEP_DISABLED__HAL_RCC_DFSDM1_IS_CLK_SLEEP_DISABLED__HAL_RCC_DFSDM_IS_CLK_SLEEP_ENABLED__HAL_RCC_DFSDM1_IS_CLK_SLEEP_ENABLED__HAL_RCC_DFSDM_CLK_SLEEP_DISABLE__HAL_RCC_DFSDM1_CLK_SLEEP_DISABLE__HAL_RCC_DFSDM_CLK_SLEEP_ENABLE__HAL_RCC_DFSDM1_CLK_SLEEP_ENABLE__HAL_RCC_DFSDM_RELEASE_RESET__HAL_RCC_DFSDM1_RELEASE_RESET__HAL_RCC_DFSDM_FORCE_RESET__HAL_RCC_DFSDM1_FORCE_RESET__HAL_RCC_DFSDM_IS_CLK_DISABLED__HAL_RCC_DFSDM1_IS_CLK_DISABLED__HAL_RCC_DFSDM_IS_CLK_ENABLED__HAL_RCC_DFSDM1_IS_CLK_ENABLED__HAL_RCC_DFSDM_CLK_DISABLE__HAL_RCC_DFSDM1_CLK_DISABLE__HAL_RCC_DFSDM_CLK_ENABLE__HAL_RCC_DFSDM1_CLK_ENABLERCC_SDIOCLKSOURCE_CK48RCC_SDIOCLKSOURCE_CLK48IS_RCC_CK48CLKSOURCEIS_RCC_CLK48CLKSOURCERCC_CK48CLKSOURCE_PLLI2SQRCC_CLK48CLKSOURCE_PLLI2SQRCC_CK48CLKSOURCE_PLLSAIPRCC_CLK48CLKSOURCE_PLLSAIPRCC_CK48CLKSOURCE_PLLQRCC_CLK48CLKSOURCE_PLLQRCC_PERIPHCLK_CK48RCC_PERIPHCLK_CLK48RCC_CRS_TRIMOVRCC_CRS_TRIMOVFRCC_CRS_SYNCWARMRCC_CRS_SYNCWARN__HAL_RCC_GET_IT_SOURCE__HAL_RCC_GET_IT__HAL_RCC_CRS_CALCULATE_RELOADVALUE__HAL_RCC_CRS_RELOADVALUE_CALCULATE__HAL_RCC_CRS_DISABLE_AUTOMATIC_CALIB__HAL_RCC_CRS_AUTOMATIC_CALIB_DISABLE__HAL_RCC_CRS_ENABLE_AUTOMATIC_CALIB__HAL_RCC_CRS_AUTOMATIC_CALIB_ENABLE__HAL_RCC_CRS_DISABLE_FREQ_ERROR_COUNTER__HAL_RCC_CRS_FREQ_ERROR_COUNTER_DISABLE__HAL_RCC_CRS_ENABLE_FREQ_ERROR_COUNTER__HAL_RCC_CRS_FREQ_ERROR_COUNTER_ENABLEDCKCFGR_TIMPRE_BBRCC_DCKCFGR_TIMPRE_BBCR_PLLSAION_BBRCC_CR_PLLSAION_BBCSR_RMVF_BBRCC_CSR_RMVF_BBCR_HSEON_BBRCC_CR_HSEON_BBBDCR_BDRST_BBRCC_BDCR_BDRST_BBBDCR_RTCEN_BBRCC_BDCR_RTCEN_BBCFGR_I2SSRC_BBRCC_CFGR_I2SSRC_BBCSR_RTCRST_BBRCC_CSR_RTCRST_BBCSR_RTCEN_BBRCC_CSR_RTCEN_BBCSR_LSEBYP_BBRCC_CSR_LSEBYP_BBCSR_LSEON_BBRCC_CSR_LSEON_BBCSR_LSION_BBRCC_CSR_LSION_BBCR_MSION_BBRCC_CR_MSION_BBCR_PLLI2SON_BBRCC_CR_PLLI2SON_BBCR_PLLON_BBRCC_CR_PLLON_BBCR_CSSON_BBRCC_CR_CSSON_BBCR_HSION_BBRCC_CR_HSION_BBLSE_TIMEOUT_VALUERCC_LSE_TIMEOUT_VALUEDBP_TIMEOUT_VALUERCC_DBP_TIMEOUT_VALUEBDCR_BYTE0_ADDRESSRCC_BDCR_BYTE0_ADDRESSCIR_BYTE2_ADDRESSRCC_CIR_BYTE2_ADDRESSCIR_BYTE1_ADDRESSRCC_CIR_BYTE1_ADDRESSCR_BYTE2_ADDRESSRCC_CR_BYTE2_ADDRESSRCC_CR2_HSI14TRIM_BitNumberRCC_HSI14TRIM_BIT_NUMBERRMVF_BITNUMBERRCC_RMVF_BIT_NUMBERRMVF_BitNumberTIMPRE_BitNumberRCC_TIMPRE_BIT_NUMBERPLLSAION_BitNumberRCC_PLLSAION_BIT_NUMBERLSEBYP_BITNUMBERRCC_LSEBYP_BIT_NUMBERLSEON_BITNUMBERRCC_LSEON_BIT_NUMBERLSEON_BitNumberLSION_BITNUMBERRCC_LSION_BIT_NUMBERLSION_BitNumberRTCRST_BITNUMBERRCC_RTCRST_BIT_NUMBERBDRST_BITNUMBERRCC_BDRST_BIT_NUMBERBDRST_BitNumberRTCEN_BITNUMBERRCC_RTCEN_BIT_NUMBERRTCEN_BitNumberI2SSRC_BitNumberRCC_I2SSRC_BIT_NUMBERPLLI2SON_BitNumberRCC_PLLI2SON_BIT_NUMBERPLLON_BITNUMBERRCC_PLLON_BIT_NUMBERPLLON_BitNumberCSSON_BITNUMBERRCC_CSSON_BIT_NUMBERCSSON_BitNumberMSION_BITNUMBERRCC_MSION_BIT_NUMBERHSEON_BITNUMBERRCC_HSEON_BIT_NUMBERHSEON_BitNumberHSION_BITNUMBERRCC_HSION_BIT_NUMBERHSION_BitNumberRCC_USBPLLCLK_DIV3RCC_USBCLKSOURCE_PLL_DIV3RCC_USBPLLCLK_DIV2RCC_USBCLKSOURCE_PLL_DIV2RCC_USBPLLCLK_DIV1_5RCC_USBCLKSOURCE_PLL_DIV1_5RCC_USBPLLCLK_DIV1RCC_USBCLKSOURCE_PLLRCC_USBCLKSOURCE_PLLCLKRCC_USBCLK_MSIRCC_USBCLKSOURCE_MSIRCC_USBCLK_PLLRCC_USBCLK_PLLSAI1RCC_USBCLKSOURCE_PLLSAI1RCC_RTCCLKSOURCE_NONERCC_RTCCLKSOURCE_NO_CLKRCC_MCOSOURCE_PLLCLK_DIV2RCC_MCO1SOURCE_PLLCLK_DIV2RCC_MCOSOURCE_PLLCLK_NODIVRCC_MCO1SOURCE_PLLCLKRCC_MCOSOURCE_PLLCLK_DIV1RCC_MCOSOURCE_HSERCC_MCO1SOURCE_HSERCC_MCOSOURCE_HSI48RCC_MCO1SOURCE_HSI48RCC_MCOSOURCE_HSI14RCC_MCO1SOURCE_HSI14RCC_MCOSOURCE_HSIRCC_MCO1SOURCE_HSIRCC_MCOSOURCE_SYSCLKRCC_MCO1SOURCE_SYSCLKRCC_MCOSOURCE_LSERCC_MCO1SOURCE_LSERCC_MCOSOURCE_LSIRCC_MCO1SOURCE_LSIRCC_MCOSOURCE_NONERCC_MCO1SOURCE_NOCLOCKRCC_MCO_DIV128RCC_MCODIV_128RCC_MCO_DIV64RCC_MCODIV_64RCC_MCO_DIV32RCC_MCODIV_32RCC_MCO_DIV16RCC_MCODIV_16RCC_MCO_DIV8RCC_MCODIV_8RCC_MCO_DIV4RCC_MCODIV_4RCC_MCO_DIV2RCC_MCODIV_2RCC_MCO_DIV1RCC_MCODIV_1RCC_MCO_NODIV__HAL_RCC_MCO_CONFIG__HAL_RCC_MCO1_CONFIGIS_RCC_MCOSOURCEIS_RCC_MCO1SOURCERCC_PLLDIV_4RCC_PLL_DIV4RCC_PLLDIV_3RCC_PLL_DIV3RCC_PLLDIV_2RCC_PLL_DIV2RCC_PLLMUL_48RCC_PLL_MUL48RCC_PLLMUL_32RCC_PLL_MUL32RCC_PLLMUL_24RCC_PLL_MUL24RCC_PLLMUL_16RCC_PLL_MUL16RCC_PLLMUL_12RCC_PLL_MUL12RCC_PLLMUL_8RCC_PLL_MUL8RCC_PLLMUL_6RCC_PLL_MUL6RCC_PLLMUL_4RCC_PLL_MUL4RCC_PLLMUL_3RCC_PLL_MUL3RCC_IT_CSSHSERCC_IT_CSSRCC_IT_CSSLSERCC_IT_LSECSSRCC_IT_HSI14RCC_IT_HSI14RDYIS_RCC_PERIPHCLKIS_RCC_PERIPHCLOCKIS_RCC_HCLK_DIVIS_RCC_PCLKIS_RCC_SYSCLK_DIVIS_RCC_HCLKIS_RCC_RTCCLK_SOURCEIS_RCC_RTCCLKSOURCEIS_RCC_MSIRANGEIS_RCC_MSI_CLOCK_RANGE__RCC_PLLSRCRCC_GET_PLL_OSCSOURCE__HAL_RCC_I2SCLK_CONFIG__HAL_RCC_I2S_CONFIG__HAL_RCC_I2SCLKRCC_SDIOCLKSOURCE_SYSCLKRCC_SDMMC1CLKSOURCE_SYSCLKRCC_SDMMC1CLKSOURCE_CLK48__HAL_RCC_GET_SDIO_SOURCE__HAL_RCC_GET_SDMMC1_SOURCE__HAL_RCC_SDIO_CONFIG__HAL_RCC_SDMMC1_CONFIGRCC_PERIPHCLK_SDIORCC_PERIPHCLK_SDMMC1SdioClockSelectionSdmmc1ClockSelection__HAL_RCC_SDIO_IS_CLK_DISABLED__HAL_RCC_SDMMC1_IS_CLK_DISABLED__HAL_RCC_SDIO_IS_CLK_ENABLED__HAL_RCC_SDMMC1_IS_CLK_ENABLED__HAL_RCC_SDIO_CLK_DISABLE__HAL_RCC_SDMMC1_CLK_DISABLE__HAL_RCC_SDIO_CLK_ENABLE__HAL_RCC_SDMMC1_CLK_ENABLE__HAL_RCC_SDIO_CLK_SLEEP_DISABLE__HAL_RCC_SDMMC1_CLK_SLEEP_DISABLE__HAL_RCC_SDIO_CLK_SLEEP_ENABLE__HAL_RCC_SDMMC1_CLK_SLEEP_ENABLE__HAL_RCC_SDIO_RELEASE_RESET__HAL_RCC_SDMMC1_RELEASE_RESET__HAL_RCC_SDIO_FORCE_RESET__HAL_RCC_SDMMC1_FORCE_RESET__WWDG_IS_CLK_DISABLED__HAL_RCC_WWDG_IS_CLK_DISABLED__WWDG_IS_CLK_ENABLED__HAL_RCC_WWDG_IS_CLK_ENABLED__USB_IS_CLK_DISABLED__HAL_RCC_USB_IS_CLK_DISABLED__USB_IS_CLK_ENABLED__HAL_RCC_USB_IS_CLK_ENABLED__USART3_IS_CLK_DISABLED__HAL_RCC_USART3_IS_CLK_DISABLED__USART3_IS_CLK_ENABLED__HAL_RCC_USART3_IS_CLK_ENABLED__USART2_IS_CLK_DISABLED__HAL_RCC_USART2_IS_CLK_DISABLED__USART2_IS_CLK_ENABLED__HAL_RCC_USART2_IS_CLK_ENABLED__USART1_IS_CLK_DISABLED__HAL_RCC_USART1_IS_CLK_DISABLED__USART1_IS_CLK_ENABLED__HAL_RCC_USART1_IS_CLK_ENABLED__UART5_IS_CLK_DISABLED__HAL_RCC_UART5_IS_CLK_DISABLED__UART5_IS_CLK_ENABLED__HAL_RCC_UART5_IS_CLK_ENABLED__UART4_IS_CLK_DISABLED__HAL_RCC_UART4_IS_CLK_DISABLED__UART4_IS_CLK_ENABLED__HAL_RCC_UART4_IS_CLK_ENABLED__TSC_IS_CLK_DISABLED__HAL_RCC_TSC_IS_CLK_DISABLED__TSC_IS_CLK_ENABLED__HAL_RCC_TSC_IS_CLK_ENABLED__TIM20_IS_CLK_DISABLED__HAL_RCC_TIM20_IS_CLK_DISABLED__TIM20_IS_CLK_ENABLED__HAL_RCC_TIM20_IS_CLK_ENABLED__TIM19_IS_CLK_DISABLED__HAL_RCC_TIM19_IS_CLK_DISABLED__TIM19_IS_CLK_ENABLED__HAL_RCC_TIM19_IS_CLK_ENABLED__TIM18_IS_CLK_DISABLED__HAL_RCC_TIM18_IS_CLK_DISABLED__TIM18_IS_CLK_ENABLED__HAL_RCC_TIM18_IS_CLK_ENABLED__TIM17_IS_CLK_DISABLED__HAL_RCC_TIM17_IS_CLK_DISABLED__TIM17_IS_CLK_ENABLED__HAL_RCC_TIM17_IS_CLK_ENABLED__TIM16_IS_CLK_DISABLED__HAL_RCC_TIM16_IS_CLK_DISABLED__TIM16_IS_CLK_ENABLED__HAL_RCC_TIM16_IS_CLK_ENABLED__TIM15_IS_CLK_DISABLED__HAL_RCC_TIM15_IS_CLK_DISABLED__TIM15_IS_CLK_ENABLED__HAL_RCC_TIM15_IS_CLK_ENABLED__TIM14_IS_CLK_DISABLED__HAL_RCC_TIM14_IS_CLK_DISABLED__TIM14_IS_CLK_ENABLED__HAL_RCC_TIM14_IS_CLK_ENABLED__TIM13_IS_CLK_DISABLED__HAL_RCC_TIM13_IS_CLK_DISABLED__TIM13_IS_CLK_ENABLED__HAL_RCC_TIM13_IS_CLK_ENABLED__TIM12_IS_CLK_DISABLED__HAL_RCC_TIM12_IS_CLK_DISABLED__TIM12_IS_CLK_ENABLED__HAL_RCC_TIM12_IS_CLK_ENABLED__TIM8_IS_CLK_DISABLED__HAL_RCC_TIM8_IS_CLK_DISABLED__TIM8_IS_CLK_ENABLED__HAL_RCC_TIM8_IS_CLK_ENABLED__TIM7_IS_CLK_DISABLED__HAL_RCC_TIM7_IS_CLK_DISABLED__TIM7_IS_CLK_ENABLED__HAL_RCC_TIM7_IS_CLK_ENABLED__TIM6_IS_CLK_DISABLED__HAL_RCC_TIM6_IS_CLK_DISABLED__TIM6_IS_CLK_ENABLED__HAL_RCC_TIM6_IS_CLK_ENABLED__TIM5_IS_CLK_DISABLED__HAL_RCC_TIM5_IS_CLK_DISABLED__TIM5_IS_CLK_ENABLED__HAL_RCC_TIM5_IS_CLK_ENABLED__TIM4_IS_CLK_DISABLED__HAL_RCC_TIM4_IS_CLK_DISABLED__TIM4_IS_CLK_ENABLED__HAL_RCC_TIM4_IS_CLK_ENABLED__TIM3_IS_CLK_DISABLED__HAL_RCC_TIM3_IS_CLK_DISABLED__TIM3_IS_CLK_ENABLED__HAL_RCC_TIM3_IS_CLK_ENABLED__TIM2_IS_CLK_DISABLED__HAL_RCC_TIM2_IS_CLK_DISABLED__TIM2_IS_CLK_ENABLED__HAL_RCC_TIM2_IS_CLK_ENABLED__TIM1_IS_CLK_DISABLED__HAL_RCC_TIM1_IS_CLK_DISABLED__TIM1_IS_CLK_ENABLED__HAL_RCC_TIM1_IS_CLK_ENABLED__SRAM_IS_CLK_DISABLED__HAL_RCC_SRAM_IS_CLK_DISABLED__SRAM_IS_CLK_ENABLED__HAL_RCC_SRAM_IS_CLK_ENABLED__SDADC3_IS_CLK_DISABLED__HAL_RCC_SDADC3_IS_CLK_DISABLED__SDADC3_IS_CLK_ENABLED__HAL_RCC_SDADC3_IS_CLK_ENABLED__SDADC2_IS_CLK_DISABLED__HAL_RCC_SDADC2_IS_CLK_DISABLED__SDADC2_IS_CLK_ENABLED__HAL_RCC_SDADC2_IS_CLK_ENABLED__SDADC1_IS_CLK_DISABLED__HAL_RCC_SDADC1_IS_CLK_DISABLED__SDADC1_IS_CLK_ENABLED__HAL_RCC_SDADC1_IS_CLK_ENABLED__SPI4_IS_CLK_DISABLED__HAL_RCC_SPI4_IS_CLK_DISABLED__SPI4_IS_CLK_ENABLED__HAL_RCC_SPI4_IS_CLK_ENABLED__SPI3_IS_CLK_DISABLED__HAL_RCC_SPI3_IS_CLK_DISABLED__SPI3_IS_CLK_ENABLED__HAL_RCC_SPI3_IS_CLK_ENABLED__SPI2_IS_CLK_DISABLED__HAL_RCC_SPI2_IS_CLK_DISABLED__SPI2_IS_CLK_ENABLED__HAL_RCC_SPI2_IS_CLK_ENABLED__SPI1_IS_CLK_DISABLED__HAL_RCC_SPI1_IS_CLK_DISABLED__SPI1_IS_CLK_ENABLED__HAL_RCC_SPI1_IS_CLK_ENABLED__SYSCFG_IS_CLK_DISABLED__HAL_RCC_SYSCFG_IS_CLK_DISABLED__SYSCFG_IS_CLK_ENABLED__HAL_RCC_SYSCFG_IS_CLK_ENABLED__PWR_IS_CLK_DISABLED__HAL_RCC_PWR_IS_CLK_DISABLED__PWR_IS_CLK_ENABLED__HAL_RCC_PWR_IS_CLK_ENABLED__I2C3_IS_CLK_DISABLED__HAL_RCC_I2C3_IS_CLK_DISABLED__I2C3_IS_CLK_ENABLED__HAL_RCC_I2C3_IS_CLK_ENABLED__I2C2_IS_CLK_DISABLED__HAL_RCC_I2C2_IS_CLK_DISABLED__I2C2_IS_CLK_ENABLED__HAL_RCC_I2C2_IS_CLK_ENABLED__I2C1_IS_CLK_DISABLED__HAL_RCC_I2C1_IS_CLK_DISABLED__I2C1_IS_CLK_ENABLED__HAL_RCC_I2C1_IS_CLK_ENABLED__HRTIM1_IS_CLK_DISABLED__HAL_RCC_HRTIM1_IS_CLK_DISABLED__HRTIM1_IS_CLK_ENABLED__HAL_RCC_HRTIM1_IS_CLK_ENABLED__GPIOH_IS_CLK_DISABLED__HAL_RCC_GPIOH_IS_CLK_DISABLED__GPIOH_IS_CLK_ENABLED__HAL_RCC_GPIOH_IS_CLK_ENABLED__GPIOG_IS_CLK_DISABLED__HAL_RCC_GPIOG_IS_CLK_DISABLED__GPIOG_IS_CLK_ENABLED__HAL_RCC_GPIOG_IS_CLK_ENABLED__GPIOF_IS_CLK_DISABLED__HAL_RCC_GPIOF_IS_CLK_DISABLED__GPIOF_IS_CLK_ENABLED__HAL_RCC_GPIOF_IS_CLK_ENABLED__GPIOE_IS_CLK_DISABLED__HAL_RCC_GPIOE_IS_CLK_DISABLED__GPIOE_IS_CLK_ENABLED__HAL_RCC_GPIOE_IS_CLK_ENABLED__GPIOD_IS_CLK_DISABLED__HAL_RCC_GPIOD_IS_CLK_DISABLED__GPIOD_IS_CLK_ENABLED__HAL_RCC_GPIOD_IS_CLK_ENABLED__GPIOC_IS_CLK_DISABLED__HAL_RCC_GPIOC_IS_CLK_DISABLED__GPIOC_IS_CLK_ENABLED__HAL_RCC_GPIOC_IS_CLK_ENABLED__GPIOB_IS_CLK_DISABLED__HAL_RCC_GPIOB_IS_CLK_DISABLED__GPIOB_IS_CLK_ENABLED__HAL_RCC_GPIOB_IS_CLK_ENABLED__GPIOA_IS_CLK_DISABLED__HAL_RCC_GPIOA_IS_CLK_DISABLED__GPIOA_IS_CLK_ENABLED__HAL_RCC_GPIOA_IS_CLK_ENABLED__FMC_IS_CLK_DISABLED__HAL_RCC_FMC_IS_CLK_DISABLED__FMC_IS_CLK_ENABLED__HAL_RCC_FMC_IS_CLK_ENABLED__FLITF_IS_CLK_DISABLED__HAL_RCC_FLITF_IS_CLK_DISABLED__FLITF_IS_CLK_ENABLED__HAL_RCC_FLITF_IS_CLK_ENABLED__DMA2_IS_CLK_DISABLED__HAL_RCC_DMA2_IS_CLK_DISABLED__DMA2_IS_CLK_ENABLED__HAL_RCC_DMA2_IS_CLK_ENABLED__DMA1_IS_CLK_DISABLED__HAL_RCC_DMA1_IS_CLK_DISABLED__DMA1_IS_CLK_ENABLED__HAL_RCC_DMA1_IS_CLK_ENABLED__DAC2_IS_CLK_DISABLED__HAL_RCC_DAC2_IS_CLK_DISABLED__DAC2_IS_CLK_ENABLED__HAL_RCC_DAC2_IS_CLK_ENABLED__DAC1_IS_CLK_DISABLED__HAL_RCC_DAC1_IS_CLK_DISABLED__DAC1_IS_CLK_ENABLED__HAL_RCC_DAC1_IS_CLK_ENABLED__CRC_IS_CLK_DISABLED__HAL_RCC_CRC_IS_CLK_DISABLED__CRC_IS_CLK_ENABLED__HAL_RCC_CRC_IS_CLK_ENABLED__CEC_IS_CLK_DISABLED__HAL_RCC_CEC_IS_CLK_DISABLED__CEC_IS_CLK_ENABLED__HAL_RCC_CEC_IS_CLK_ENABLED__ADC34_IS_CLK_DISABLED__HAL_RCC_ADC34_IS_CLK_DISABLED__ADC34_IS_CLK_ENABLED__HAL_RCC_ADC34_IS_CLK_ENABLED__ADC12_IS_CLK_DISABLED__HAL_RCC_ADC12_IS_CLK_DISABLED__ADC12_IS_CLK_ENABLED__HAL_RCC_ADC12_IS_CLK_ENABLED__ADC1_IS_CLK_DISABLED__HAL_RCC_ADC1_IS_CLK_DISABLED__ADC1_IS_CLK_ENABLED__HAL_RCC_ADC1_IS_CLK_ENABLED__SDADC3_RELEASE_RESET__HAL_RCC_SDADC3_RELEASE_RESET__SDADC2_RELEASE_RESET__HAL_RCC_SDADC2_RELEASE_RESET__SDADC1_RELEASE_RESET__HAL_RCC_SDADC1_RELEASE_RESET__SDADC3_FORCE_RESET__HAL_RCC_SDADC3_FORCE_RESET__SDADC2_FORCE_RESET__HAL_RCC_SDADC2_FORCE_RESET__SDADC1_FORCE_RESET__HAL_RCC_SDADC1_FORCE_RESET__HRTIM1_RELEASE_RESET__HAL_RCC_HRTIM1_RELEASE_RESET__HRTIM1_FORCE_RESET__HAL_RCC_HRTIM1_FORCE_RESET__TIM20_RELEASE_RESET__HAL_RCC_TIM20_RELEASE_RESET__TIM20_FORCE_RESET__HAL_RCC_TIM20_FORCE_RESET__TIM19_RELEASE_RESET__HAL_RCC_TIM19_RELEASE_RESET__TIM19_FORCE_RESET__HAL_RCC_TIM19_FORCE_RESET__TIM18_RELEASE_RESET__HAL_RCC_TIM18_RELEASE_RESET__TIM18_FORCE_RESET__HAL_RCC_TIM18_FORCE_RESET__DAC2_RELEASE_RESET__HAL_RCC_DAC2_RELEASE_RESET__DAC2_FORCE_RESET__HAL_RCC_DAC2_FORCE_RESET__ADC34_RELEASE_RESET__HAL_RCC_ADC34_RELEASE_RESET__ADC34_FORCE_RESET__HAL_RCC_ADC34_FORCE_RESET__ADC12_RELEASE_RESET__HAL_RCC_ADC12_RELEASE_RESET__ADC12_FORCE_RESET__HAL_RCC_ADC12_FORCE_RESET__SDADC3_CLK_DISABLE__HAL_RCC_SDADC3_CLK_DISABLE__SDADC2_CLK_DISABLE__HAL_RCC_SDADC2_CLK_DISABLE__SDADC1_CLK_DISABLE__HAL_RCC_SDADC1_CLK_DISABLE__SDADC3_CLK_ENABLE__HAL_RCC_SDADC3_CLK_ENABLE__SDADC2_CLK_ENABLE__HAL_RCC_SDADC2_CLK_ENABLE__SDADC1_CLK_ENABLE__HAL_RCC_SDADC1_CLK_ENABLE__HRTIM1_CLK_DISABLE__HAL_RCC_HRTIM1_CLK_DISABLE__HRTIM1_CLK_ENABLE__HAL_RCC_HRTIM1_CLK_ENABLE__TIM20_CLK_DISABLE__HAL_RCC_TIM20_CLK_DISABLE__TIM20_CLK_ENABLE__HAL_RCC_TIM20_CLK_ENABLE__TIM19_CLK_DISABLE__HAL_RCC_TIM19_CLK_DISABLE__TIM19_CLK_ENABLE__HAL_RCC_TIM19_CLK_ENABLE__TIM18_CLK_DISABLE__HAL_RCC_TIM18_CLK_DISABLE__TIM18_CLK_ENABLE__HAL_RCC_TIM18_CLK_ENABLE__DAC2_CLK_DISABLE__HAL_RCC_DAC2_CLK_DISABLE__DAC2_CLK_ENABLE__HAL_RCC_DAC2_CLK_ENABLE__ADC34_CLK_DISABLE__HAL_RCC_ADC34_CLK_DISABLE__ADC34_CLK_ENABLE__HAL_RCC_ADC34_CLK_ENABLE__ADC12_CLK_DISABLE__HAL_RCC_ADC12_CLK_DISABLE__ADC12_CLK_ENABLE__HAL_RCC_ADC12_CLK_ENABLE__HAL_RCC_OTGFS_RELEASE_RESET__HAL_RCC_USB_OTG_FS_RELEASE_RESET__HAL_RCC_OTGFS_FORCE_RESET__HAL_RCC_USB_OTG_FS_FORCE_RESET__DMA2D_CLK_SLEEP_DISABLE__HAL_RCC_DMA2D_CLK_SLEEP_DISABLE__DMA2D_CLK_SLEEP_ENABLE__HAL_RCC_DMA2D_CLK_SLEEP_ENABLE__DMA2D_RELEASE_RESET__HAL_RCC_DMA2D_RELEASE_RESET__DMA2D_FORCE_RESET__HAL_RCC_DMA2D_FORCE_RESET__DMA2D_CLK_DISABLE__HAL_RCC_DMA2D_CLK_DISABLE__DMA2D_CLK_ENABLE__HAL_RCC_DMA2D_CLK_ENABLE__SDIO_CLK_SLEEP_ENABLE__SDIO_CLK_SLEEP_DISABLE__SDIO_RELEASE_RESET__SDIO_FORCE_RESET__FSMC_CLK_SLEEP_DISABLE__HAL_RCC_FSMC_CLK_SLEEP_DISABLE__FSMC_CLK_SLEEP_ENABLE__HAL_RCC_FSMC_CLK_SLEEP_ENABLE__FSMC_RELEASE_RESET__HAL_RCC_FSMC_RELEASE_RESET__FSMC_FORCE_RESET__HAL_RCC_FSMC_FORCE_RESET__ADC3_CLK_SLEEP_DISABLE__HAL_RCC_ADC3_CLK_SLEEP_DISABLE__ADC3_CLK_SLEEP_ENABLE__HAL_RCC_ADC3_CLK_SLEEP_ENABLE__ADC2_CLK_SLEEP_DISABLE__HAL_RCC_ADC2_CLK_SLEEP_DISABLE__ADC2_CLK_SLEEP_ENABLE__HAL_RCC_ADC2_CLK_SLEEP_ENABLE__DAC_CLK_SLEEP_DISABLE__HAL_RCC_DAC_CLK_SLEEP_DISABLE__DAC_CLK_SLEEP_ENABLE__HAL_RCC_DAC_CLK_SLEEP_ENABLE__CAN2_CLK_SLEEP_DISABLE__HAL_RCC_CAN2_CLK_SLEEP_DISABLE__CAN2_CLK_SLEEP_ENABLE__HAL_RCC_CAN2_CLK_SLEEP_ENABLE__SRAM3_CLK_SLEEP_ENABLE__HAL_RCC_SRAM3_CLK_SLEEP_ENABLE__HAL_RCC_OTGHSULPI_IS_CLK_SLEEP_DISABLED__HAL_RCC_USB_OTG_HS_ULPI_IS_CLK_SLEEP_DISABLED__HAL_RCC_OTGHSULPI_IS_CLK_SLEEP_ENABLED__HAL_RCC_USB_OTG_HS_ULPI_IS_CLK_SLEEP_ENABLED__HAL_RCC_OTGHSULPI_CLK_SLEEP_DISABLE__HAL_RCC_USB_OTG_HS_ULPI_CLK_SLEEP_DISABLE__HAL_RCC_OTGHSULPI_CLK_SLEEP_ENABLE__HAL_RCC_USB_OTG_HS_ULPI_CLK_SLEEP_ENABLE__HAL_RCC_OTGHS_RELEASE_RESET__HAL_RCC_USB_OTG_HS_RELEASE_RESET__HAL_RCC_OTGHS_FORCE_RESET__HAL_RCC_USB_OTG_HS_FORCE_RESET__HAL_RCC_OTGHS_IS_CLK_SLEEP_DISABLED__HAL_RCC_USB_OTG_HS_IS_CLK_SLEEP_DISABLED__HAL_RCC_OTGHS_IS_CLK_SLEEP_ENABLED__HAL_RCC_USB_OTG_HS_IS_CLK_SLEEP_ENABLED__HAL_RCC_OTGHS_CLK_SLEEP_DISABLE__HAL_RCC_USB_OTG_HS_CLK_SLEEP_DISABLE__HAL_RCC_OTGHS_CLK_SLEEP_ENABLE__HAL_RCC_USB_OTG_HS_CLK_SLEEP_ENABLE__OTGHSULPI_CLK_SLEEP_DISABLE__OTGHSULPI_CLK_SLEEP_ENABLE__OTGHS_RELEASE_RESET__OTGHS_FORCE_RESET__OTGHS_CLK_SLEEP_DISABLE__OTGHS_CLK_SLEEP_ENABLE__UART8_CLK_SLEEP_DISABLE__HAL_RCC_UART8_CLK_SLEEP_DISABLE__UART8_CLK_SLEEP_ENABLE__HAL_RCC_UART8_CLK_SLEEP_ENABLE__UART8_RELEASE_RESET__HAL_RCC_UART8_RELEASE_RESET__UART8_FORCE_RESET__HAL_RCC_UART8_FORCE_RESET__UART8_CLK_DISABLE__HAL_RCC_UART8_CLK_DISABLE__UART8_CLK_ENABLE__HAL_RCC_UART8_CLK_ENABLE__UART7_CLK_SLEEP_DISABLE__HAL_RCC_UART7_CLK_SLEEP_DISABLE__UART7_CLK_SLEEP_ENABLE__HAL_RCC_UART7_CLK_SLEEP_ENABLE__UART7_FORCE_RESET__HAL_RCC_UART7_FORCE_RESET__UART7_RELEASE_RESET__HAL_RCC_UART7_RELEASE_RESET__UART7_CLK_DISABLE__HAL_RCC_UART7_CLK_DISABLE__UART7_CLK_ENABLE__HAL_RCC_UART7_CLK_ENABLE__DCMI_CLK_SLEEP_DISABLE__HAL_RCC_DCMI_CLK_SLEEP_DISABLE__DCMI_CLK_SLEEP_ENABLE__HAL_RCC_DCMI_CLK_SLEEP_ENABLE__DCMI_RELEASE_RESET__HAL_RCC_DCMI_RELEASE_RESET__DCMI_FORCE_RESET__HAL_RCC_DCMI_FORCE_RESET__DCMI_CLK_DISABLE__HAL_RCC_DCMI_CLK_DISABLE__DCMI_CLK_ENABLE__HAL_RCC_DCMI_CLK_ENABLE__ETH_CLK_DISABLE__HAL_RCC_ETH_CLK_DISABLE__ETH_CLK_ENABLE__HAL_RCC_ETH_CLK_ENABLE__GPIOK_CLK_SLEEP_DISABLE__HAL_RCC_GPIOK_CLK_SLEEP_DISABLE__GPIOK_CLK_SLEEP_ENABLE__HAL_RCC_GPIOK_CLK_SLEEP_ENABLE__GPIOK_RELEASE_RESET__HAL_RCC_GPIOK_RELEASE_RESET__GPIOK_CLK_DISABLE__HAL_RCC_GPIOK_CLK_DISABLE__GPIOK_CLK_ENABLE__HAL_RCC_GPIOK_CLK_ENABLE__GPIOJ_CLK_SLEEP_DISABLE__HAL_RCC_GPIOJ_CLK_SLEEP_DISABLE__GPIOJ_CLK_SLEEP_ENABLE__HAL_RCC_GPIOJ_CLK_SLEEP_ENABLE__GPIOJ_RELEASE_RESET__HAL_RCC_GPIOJ_RELEASE_RESET__GPIOJ_FORCE_RESET__HAL_RCC_GPIOJ_FORCE_RESET__GPIOJ_CLK_DISABLE__HAL_RCC_GPIOJ_CLK_DISABLE__GPIOJ_CLK_ENABLE__HAL_RCC_GPIOJ_CLK_ENABLE__GPIOI_CLK_SLEEP_DISABLE__HAL_RCC_GPIOI_CLK_SLEEP_DISABLE__GPIOI_CLK_SLEEP_ENABLE__HAL_RCC_GPIOI_CLK_SLEEP_ENABLE__GPIOI_RELEASE_RESET__HAL_RCC_GPIOI_RELEASE_RESET__GPIOI_FORCE_RESET__HAL_RCC_GPIOI_FORCE_RESET__GPIOI_CLK_DISABLE__HAL_RCC_GPIOI_CLK_DISABLE__GPIOI_CLK_ENABLE__HAL_RCC_GPIOI_CLK_ENABLE__SPI4_CLK_SLEEP_DISABLE__HAL_RCC_SPI4_CLK_SLEEP_DISABLE__SPI4_CLK_SLEEP_ENABLE__HAL_RCC_SPI4_CLK_SLEEP_ENABLE__SPI4_RELEASE_RESET__HAL_RCC_SPI4_RELEASE_RESET__SPI4_FORCE_RESET__HAL_RCC_SPI4_FORCE_RESET__SPI4_CLK_DISABLE__HAL_RCC_SPI4_CLK_DISABLE__SPI4_CLK_ENABLE__HAL_RCC_SPI4_CLK_ENABLE__USART6_CLK_SLEEP_DISABLE__HAL_RCC_USART6_CLK_SLEEP_DISABLE__USART6_CLK_SLEEP_ENABLE__HAL_RCC_USART6_CLK_SLEEP_ENABLE__USART6_RELEASE_RESET__HAL_RCC_USART6_RELEASE_RESET__USART6_FORCE_RESET__HAL_RCC_USART6_FORCE_RESET__USART6_CLK_DISABLE__HAL_RCC_USART6_CLK_DISABLE__USART6_CLK_ENABLE__HAL_RCC_USART6_CLK_ENABLE__CCMDATARAMEN_CLK_DISABLE__HAL_RCC_CCMDATARAMEN_CLK_DISABLE__CCMDATARAMEN_CLK_ENABLE__HAL_RCC_CCMDATARAMEN_CLK_ENABLE__BKPSRAM_CLK_SLEEP_DISABLE__HAL_RCC_BKPSRAM_CLK_SLEEP_DISABLE__BKPSRAM_CLK_SLEEP_ENABLE__HAL_RCC_BKPSRAM_CLK_SLEEP_ENABLE__BKPSRAM_CLK_DISABLE__HAL_RCC_BKPSRAM_CLK_DISABLE__BKPSRAM_CLK_ENABLE__HAL_RCC_BKPSRAM_CLK_ENABLE__TIM14_CLK_SLEEP_DISABLE__HAL_RCC_TIM14_CLK_SLEEP_DISABLE__TIM14_CLK_SLEEP_ENABLE__HAL_RCC_TIM14_CLK_SLEEP_ENABLE__TIM13_CLK_SLEEP_DISABLE__HAL_RCC_TIM13_CLK_SLEEP_DISABLE__TIM13_CLK_SLEEP_ENABLE__HAL_RCC_TIM13_CLK_SLEEP_ENABLE__TIM12_CLK_SLEEP_DISABLE__HAL_RCC_TIM12_CLK_SLEEP_DISABLE__TIM12_CLK_SLEEP_ENABLE__HAL_RCC_TIM12_CLK_SLEEP_ENABLE__ETHMACRX_CLK_SLEEP_DISABLE__HAL_RCC_ETHMACRX_CLK_SLEEP_DISABLE__ETHMACRX_CLK_SLEEP_ENABLE__HAL_RCC_ETHMACRX_CLK_SLEEP_ENABLE__ETHMACTX_CLK_SLEEP_DISABLE__HAL_RCC_ETHMACTX_CLK_SLEEP_DISABLE__ETHMACTX_CLK_SLEEP_ENABLE__HAL_RCC_ETHMACTX_CLK_SLEEP_ENABLE__ETHMAC_CLK_SLEEP_DISABLE__HAL_RCC_ETHMAC_CLK_SLEEP_DISABLE__ETHMAC_CLK_SLEEP_ENABLE__HAL_RCC_ETHMAC_CLK_SLEEP_ENABLE__LTDC_CLK_SLEEP_ENABLE__HAL_RCC_LTDC_CLK_SLEEP_ENABLE__LTDC_RELEASE_RESET__HAL_RCC_LTDC_RELEASE_RESET__LTDC_FORCE_RESET__HAL_RCC_LTDC_FORCE_RESET__LTDC_CLK_DISABLE__HAL_RCC_LTDC_CLK_DISABLE__LTDC_CLK_ENABLE__HAL_RCC_LTDC_CLK_ENABLE__SPI6_CLK_SLEEP_DISABLE__HAL_RCC_SPI6_CLK_SLEEP_DISABLE__SPI6_CLK_SLEEP_ENABLE__HAL_RCC_SPI6_CLK_SLEEP_ENABLE__SPI6_RELEASE_RESET__HAL_RCC_SPI6_RELEASE_RESET__SPI6_FORCE_RESET__HAL_RCC_SPI6_FORCE_RESET__SPI6_CLK_DISABLE__HAL_RCC_SPI6_CLK_DISABLE__SPI6_CLK_ENABLE__HAL_RCC_SPI6_CLK_ENABLE__SPI5_CLK_SLEEP_DISABLE__HAL_RCC_SPI5_CLK_SLEEP_DISABLE__SPI5_CLK_SLEEP_ENABLE__HAL_RCC_SPI5_CLK_SLEEP_ENABLE__SPI5_RELEASE_RESET__HAL_RCC_SPI5_RELEASE_RESET__SPI5_FORCE_RESET__HAL_RCC_SPI5_FORCE_RESET__SPI5_CLK_DISABLE__HAL_RCC_SPI5_CLK_DISABLE__SPI5_CLK_ENABLE__HAL_RCC_SPI5_CLK_ENABLE__HASH_CLK_DISABLE__HAL_RCC_HASH_CLK_DISABLE__HASH_CLK_SLEEP_DISABLE__HAL_RCC_HASH_CLK_SLEEP_DISABLE__HASH_CLK_SLEEP_ENABLE__HAL_RCC_HASH_CLK_SLEEP_ENABLE__HASH_RELEASE_RESET__HAL_RCC_HASH_RELEASE_RESET__HASH_FORCE_RESET__HAL_RCC_HASH_FORCE_RESET__HASH_CLK_ENABLE__HAL_RCC_HASH_CLK_ENABLE__ETHMACPTP_CLK_DISABLE__HAL_RCC_ETHMACPTP_CLK_DISABLE__ETHMACPTP_CLK_ENABLE__HAL_RCC_ETHMACPTP_CLK_ENABLE__ETHMACPTP_CLK_SLEEP_DISABLE__HAL_RCC_ETHMACPTP_CLK_SLEEP_DISABLE__ETHMACPTP_CLK_SLEEP_ENABLE__HAL_RCC_ETHMACPTP_CLK_SLEEP_ENABLE__TIM11_CLK_SLEEP_DISABLE__HAL_RCC_TIM11_CLK_SLEEP_DISABLE__TIM11_CLK_SLEEP_ENABLE__HAL_RCC_TIM11_CLK_SLEEP_ENABLE__TIM10_CLK_SLEEP_DISABLE__HAL_RCC_TIM10_CLK_SLEEP_DISABLE__TIM10_CLK_SLEEP_ENABLE__HAL_RCC_TIM10_CLK_SLEEP_ENABLE__TIM9_CLK_SLEEP_DISABLE__HAL_RCC_TIM9_CLK_SLEEP_DISABLE__TIM9_CLK_SLEEP_ENABLE__HAL_RCC_TIM9_CLK_SLEEP_ENABLE__USB_OTG_HS_ULPI_CLK_DISABLE__HAL_RCC_USB_OTG_HS_ULPI_CLK_DISABLE__USB_OTG_HS_ULPI_CLK_ENABLE__HAL_RCC_USB_OTG_HS_ULPI_CLK_ENABLE__USB_OTG_HS_CLK_ENABLE__HAL_RCC_USB_OTG_HS_CLK_ENABLE__USB_OTG_HS_CLK_DISABLE__HAL_RCC_USB_OTG_HS_CLK_DISABLE__USB_OTG_FS_CLK_SLEEP_DISABLE__HAL_RCC_USB_OTG_FS_CLK_SLEEP_DISABLE__USB_OTG_FS_CLK_SLEEP_ENABLE__HAL_RCC_USB_OTG_FS_CLK_SLEEP_ENABLE__USB_OTG_FS_RELEASE_RESET__USB_OTG_FS_FORCE_RESET__RCC_BACKUPRESET_RELEASE__HAL_RCC_BACKUPRESET_RELEASE__RCC_BACKUPRESET_FORCE__HAL_RCC_BACKUPRESET_FORCE__CRS_RELEASE_RESET__HAL_RCC_CRS_RELEASE_RESET__CRS_FORCE_RESET__HAL_RCC_CRS_FORCE_RESET__CRS_CLK_SLEEP_ENABLE__HAL_RCC_CRS_CLK_SLEEP_ENABLE__CRS_CLK_SLEEP_DISABLE__HAL_RCC_CRS_CLK_SLEEP_DISABLE__CRS_CLK_ENABLE__HAL_RCC_CRS_CLK_ENABLE__CRS_CLK_DISABLE__HAL_RCC_CRS_CLK_DISABLE__TIM22_CLK_SLEEP_DISABLE__HAL_RCC_TIM22_CLK_SLEEP_DISABLE__TIM22_CLK_SLEEP_ENABLE__HAL_RCC_TIM22_CLK_SLEEP_ENABLE__TIM22_RELEASE_RESET__HAL_RCC_TIM22_RELEASE_RESET__TIM22_FORCE_RESET__HAL_RCC_TIM22_FORCE_RESET__TIM22_CLK_DISABLE__HAL_RCC_TIM22_CLK_DISABLE__TIM22_CLK_ENABLE__HAL_RCC_TIM22_CLK_ENABLE__TIM21_CLK_SLEEP_DISABLE__HAL_RCC_TIM21_CLK_SLEEP_DISABLE__TIM21_CLK_SLEEP_ENABLE__HAL_RCC_TIM21_CLK_SLEEP_ENABLE__TIM21_RELEASE_RESET__HAL_RCC_TIM21_RELEASE_RESET__TIM21_FORCE_RESET__HAL_RCC_TIM21_FORCE_RESET__TIM21_CLK_DISABLE__HAL_RCC_TIM21_CLK_DISABLE__TIM21_CLK_ENABLE__HAL_RCC_TIM21_CLK_ENABLE__WWDG_RELEASE_RESET__HAL_RCC_WWDG_RELEASE_RESET__WWDG_FORCE_RESET__HAL_RCC_WWDG_FORCE_RESET__WWDG_CLK_SLEEP_ENABLE__HAL_RCC_WWDG_CLK_SLEEP_ENABLE__WWDG_CLK_SLEEP_DISABLE__HAL_RCC_WWDG_CLK_SLEEP_DISABLE__WWDG_CLK_ENABLE__HAL_RCC_WWDG_CLK_ENABLE__WWDG_CLK_DISABLE__HAL_RCC_WWDG_CLK_DISABLE__USB_RELEASE_RESET__HAL_RCC_USB_RELEASE_RESET__USB_OTG_FS_CLK_ENABLE__HAL_RCC_USB_OTG_FS_CLK_ENABLE__USB_OTG_FS_CLK_DISABLE__HAL_RCC_USB_OTG_FS_CLK_DISABLE__USB_CLK_SLEEP_DISABLE__HAL_RCC_USB_CLK_SLEEP_DISABLE__USB_CLK_SLEEP_ENABLE__HAL_RCC_USB_CLK_SLEEP_ENABLE__USB_FORCE_RESET__HAL_RCC_USB_FORCE_RESET__USB_CLK_ENABLE__HAL_RCC_USB_CLK_ENABLE__USB_CLK_DISABLE__HAL_RCC_USB_CLK_DISABLE__USART8_RELEASE_RESET__USART8_FORCE_RESET__USART8_CLK_ENABLE__USART8_CLK_DISABLE__USART7_RELEASE_RESET__USART7_FORCE_RESET__USART7_CLK_ENABLE__USART7_CLK_DISABLE__USART5_RELEASE_RESET__HAL_RCC_UART5_RELEASE_RESET__USART5_FORCE_RESET__HAL_RCC_UART5_FORCE_RESET__USART5_CLK_SLEEP_DISABLE__HAL_RCC_UART5_CLK_SLEEP_DISABLE__USART5_CLK_SLEEP_ENABLE__HAL_RCC_UART5_CLK_SLEEP_ENABLE__USART5_CLK_ENABLE__HAL_RCC_UART5_CLK_ENABLE__USART5_CLK_DISABLE__HAL_RCC_UART5_CLK_DISABLE__USART4_RELEASE_RESET__HAL_RCC_UART4_RELEASE_RESET__USART4_FORCE_RESET__HAL_RCC_UART4_FORCE_RESET__USART4_CLK_SLEEP_DISABLE__HAL_RCC_UART4_CLK_SLEEP_DISABLE__USART4_CLK_SLEEP_ENABLE__HAL_RCC_UART4_CLK_SLEEP_ENABLE__USART4_CLK_ENABLE__HAL_RCC_UART4_CLK_ENABLE__USART4_CLK_DISABLE__HAL_RCC_UART4_CLK_DISABLE__USART3_RELEASE_RESET__HAL_RCC_USART3_RELEASE_RESET__USART3_FORCE_RESET__HAL_RCC_USART3_FORCE_RESET__USART3_CLK_SLEEP_ENABLE__HAL_RCC_USART3_CLK_SLEEP_ENABLE__USART3_CLK_SLEEP_DISABLE__HAL_RCC_USART3_CLK_SLEEP_DISABLE__USART3_CLK_ENABLE__HAL_RCC_USART3_CLK_ENABLE__USART3_CLK_DISABLE__HAL_RCC_USART3_CLK_DISABLE__USART2_RELEASE_RESET__HAL_RCC_USART2_RELEASE_RESET__USART2_FORCE_RESET__HAL_RCC_USART2_FORCE_RESET__USART2_CLK_SLEEP_ENABLE__HAL_RCC_USART2_CLK_SLEEP_ENABLE__USART2_CLK_SLEEP_DISABLE__HAL_RCC_USART2_CLK_SLEEP_DISABLE__USART2_CLK_ENABLE__HAL_RCC_USART2_CLK_ENABLE__USART2_CLK_DISABLE__HAL_RCC_USART2_CLK_DISABLE__USART1_RELEASE_RESET__HAL_RCC_USART1_RELEASE_RESET__USART1_FORCE_RESET__HAL_RCC_USART1_FORCE_RESET__USART1_CLK_SLEEP_ENABLE__HAL_RCC_USART1_CLK_SLEEP_ENABLE__USART1_CLK_SLEEP_DISABLE__HAL_RCC_USART1_CLK_SLEEP_DISABLE__USART1_CLK_ENABLE__HAL_RCC_USART1_CLK_ENABLE__USART1_CLK_DISABLE__HAL_RCC_USART1_CLK_DISABLE__UART5_RELEASE_RESET__UART5_FORCE_RESET__UART5_CLK_SLEEP_ENABLE__UART5_CLK_SLEEP_DISABLE__UART5_CLK_ENABLE__UART5_CLK_DISABLE__UART4_RELEASE_RESET__UART4_FORCE_RESET__UART4_CLK_SLEEP_ENABLE__UART4_CLK_SLEEP_DISABLE__UART4_CLK_ENABLE__UART4_CLK_DISABLE__TSC_RELEASE_RESET__HAL_RCC_TSC_RELEASE_RESET__TSC_FORCE_RESET__HAL_RCC_TSC_FORCE_RESET__TSC_CLK_SLEEP_ENABLE__HAL_RCC_TSC_CLK_SLEEP_ENABLE__TSC_CLK_SLEEP_DISABLE__HAL_RCC_TSC_CLK_SLEEP_DISABLE__TSC_CLK_ENABLE__HAL_RCC_TSC_CLK_ENABLE__TSC_CLK_DISABLE__HAL_RCC_TSC_CLK_DISABLE__TIM9_RELEASE_RESET__HAL_RCC_TIM9_RELEASE_RESET__TIM9_FORCE_RESET__HAL_RCC_TIM9_FORCE_RESET__TIM9_CLK_ENABLE__HAL_RCC_TIM9_CLK_ENABLE__TIM9_CLK_DISABLE__HAL_RCC_TIM9_CLK_DISABLE__TIM8_RELEASE_RESET__HAL_RCC_TIM8_RELEASE_RESET__TIM8_FORCE_RESET__HAL_RCC_TIM8_FORCE_RESET__TIM8_CLK_SLEEP_ENABLE__HAL_RCC_TIM8_CLK_SLEEP_ENABLE__TIM8_CLK_SLEEP_DISABLE__HAL_RCC_TIM8_CLK_SLEEP_DISABLE__TIM8_CLK_ENABLE__HAL_RCC_TIM8_CLK_ENABLE__TIM8_CLK_DISABLE__HAL_RCC_TIM8_CLK_DISABLE__TIM7_RELEASE_RESET__HAL_RCC_TIM7_RELEASE_RESET__TIM7_FORCE_RESET__HAL_RCC_TIM7_FORCE_RESET__TIM7_CLK_SLEEP_ENABLE__HAL_RCC_TIM7_CLK_SLEEP_ENABLE__TIM7_CLK_SLEEP_DISABLE__HAL_RCC_TIM7_CLK_SLEEP_DISABLE__TIM7_CLK_ENABLE__HAL_RCC_TIM7_CLK_ENABLE__TIM7_CLK_DISABLE__HAL_RCC_TIM7_CLK_DISABLE__TIM6_RELEASE_RESET__HAL_RCC_TIM6_RELEASE_RESET__TIM6_FORCE_RESET__HAL_RCC_TIM6_FORCE_RESET__TIM6_CLK_SLEEP_ENABLE__HAL_RCC_TIM6_CLK_SLEEP_ENABLE__TIM6_CLK_SLEEP_DISABLE__HAL_RCC_TIM6_CLK_SLEEP_DISABLE__TIM6_CLK_ENABLE__HAL_RCC_TIM6_CLK_ENABLE__TIM6_CLK_DISABLE__HAL_RCC_TIM6_CLK_DISABLE__TIM5_RELEASE_RESET__HAL_RCC_TIM5_RELEASE_RESET__TIM5_FORCE_RESET__HAL_RCC_TIM5_FORCE_RESET__TIM5_CLK_SLEEP_ENABLE__HAL_RCC_TIM5_CLK_SLEEP_ENABLE__TIM5_CLK_SLEEP_DISABLE__HAL_RCC_TIM5_CLK_SLEEP_DISABLE__TIM5_CLK_ENABLE__HAL_RCC_TIM5_CLK_ENABLE__TIM5_CLK_DISABLE__HAL_RCC_TIM5_CLK_DISABLE__TIM4_RELEASE_RESET__HAL_RCC_TIM4_RELEASE_RESET__TIM4_FORCE_RESET__HAL_RCC_TIM4_FORCE_RESET__TIM4_CLK_SLEEP_ENABLE__HAL_RCC_TIM4_CLK_SLEEP_ENABLE__TIM4_CLK_SLEEP_DISABLE__HAL_RCC_TIM4_CLK_SLEEP_DISABLE__TIM4_CLK_ENABLE__HAL_RCC_TIM4_CLK_ENABLE__TIM4_CLK_DISABLE__HAL_RCC_TIM4_CLK_DISABLE__TIM3_RELEASE_RESET__HAL_RCC_TIM3_RELEASE_RESET__TIM3_FORCE_RESET__HAL_RCC_TIM3_FORCE_RESET__TIM3_CLK_SLEEP_ENABLE__HAL_RCC_TIM3_CLK_SLEEP_ENABLE__TIM3_CLK_SLEEP_DISABLE__HAL_RCC_TIM3_CLK_SLEEP_DISABLE__TIM3_CLK_ENABLE__HAL_RCC_TIM3_CLK_ENABLE__TIM3_CLK_DISABLE__HAL_RCC_TIM3_CLK_DISABLE__TIM2_RELEASE_RESET__HAL_RCC_TIM2_RELEASE_RESET__TIM2_FORCE_RESET__HAL_RCC_TIM2_FORCE_RESET__TIM2_CLK_SLEEP_ENABLE__HAL_RCC_TIM2_CLK_SLEEP_ENABLE__TIM2_CLK_SLEEP_DISABLE__HAL_RCC_TIM2_CLK_SLEEP_DISABLE__TIM2_CLK_ENABLE__HAL_RCC_TIM2_CLK_ENABLE__TIM2_CLK_DISABLE__HAL_RCC_TIM2_CLK_DISABLE__TIM17_RELEASE_RESET__HAL_RCC_TIM17_RELEASE_RESET__TIM17_FORCE_RESET__HAL_RCC_TIM17_FORCE_RESET__TIM17_CLK_SLEEP_ENABLE__HAL_RCC_TIM17_CLK_SLEEP_ENABLE__TIM17_CLK_SLEEP_DISABLE__HAL_RCC_TIM17_CLK_SLEEP_DISABLE__TIM17_CLK_ENABLE__HAL_RCC_TIM17_CLK_ENABLE__TIM17_CLK_DISABLE__HAL_RCC_TIM17_CLK_DISABLE__TIM16_RELEASE_RESET__HAL_RCC_TIM16_RELEASE_RESET__TIM16_FORCE_RESET__HAL_RCC_TIM16_FORCE_RESET__TIM16_CLK_SLEEP_ENABLE__HAL_RCC_TIM16_CLK_SLEEP_ENABLE__TIM16_CLK_SLEEP_DISABLE__HAL_RCC_TIM16_CLK_SLEEP_DISABLE__TIM16_CLK_ENABLE__HAL_RCC_TIM16_CLK_ENABLE__TIM16_CLK_DISABLE__HAL_RCC_TIM16_CLK_DISABLE__TIM15_RELEASE_RESET__HAL_RCC_TIM15_RELEASE_RESET__TIM15_FORCE_RESET__HAL_RCC_TIM15_FORCE_RESET__TIM15_CLK_SLEEP_ENABLE__HAL_RCC_TIM15_CLK_SLEEP_ENABLE__TIM15_CLK_SLEEP_DISABLE__HAL_RCC_TIM15_CLK_SLEEP_DISABLE__TIM15_CLK_ENABLE__HAL_RCC_TIM15_CLK_ENABLE__TIM15_CLK_DISABLE__HAL_RCC_TIM15_CLK_DISABLE__TIM14_RELEASE_RESET__HAL_RCC_TIM14_RELEASE_RESET__TIM14_FORCE_RESET__HAL_RCC_TIM14_FORCE_RESET__TIM14_CLK_ENABLE__HAL_RCC_TIM14_CLK_ENABLE__TIM14_CLK_DISABLE__HAL_RCC_TIM14_CLK_DISABLE__TIM13_RELEASE_RESET__HAL_RCC_TIM13_RELEASE_RESET__TIM13_FORCE_RESET__HAL_RCC_TIM13_FORCE_RESET__TIM13_CLK_ENABLE__HAL_RCC_TIM13_CLK_ENABLE__TIM13_CLK_DISABLE__HAL_RCC_TIM13_CLK_DISABLE__TIM12_RELEASE_RESET__HAL_RCC_TIM12_RELEASE_RESET__TIM12_FORCE_RESET__HAL_RCC_TIM12_FORCE_RESET__TIM12_CLK_ENABLE__HAL_RCC_TIM12_CLK_ENABLE__TIM12_CLK_DISABLE__HAL_RCC_TIM12_CLK_DISABLE__TIM11_RELEASE_RESET__HAL_RCC_TIM11_RELEASE_RESET__TIM11_FORCE_RESET__HAL_RCC_TIM11_FORCE_RESET__TIM11_CLK_ENABLE__HAL_RCC_TIM11_CLK_ENABLE__TIM11_CLK_DISABLE__HAL_RCC_TIM11_CLK_DISABLE__TIM10_RELEASE_RESET__HAL_RCC_TIM10_RELEASE_RESET__TIM10_FORCE_RESET__HAL_RCC_TIM10_FORCE_RESET__TIM10_CLK_ENABLE__HAL_RCC_TIM10_CLK_ENABLE__TIM10_CLK_DISABLE__HAL_RCC_TIM10_CLK_DISABLE__TIM1_RELEASE_RESET__HAL_RCC_TIM1_RELEASE_RESET__TIM1_FORCE_RESET__HAL_RCC_TIM1_FORCE_RESET__TIM1_CLK_SLEEP_ENABLE__HAL_RCC_TIM1_CLK_SLEEP_ENABLE__TIM1_CLK_SLEEP_DISABLE__HAL_RCC_TIM1_CLK_SLEEP_DISABLE__TIM1_CLK_ENABLE__HAL_RCC_TIM1_CLK_ENABLE__TIM1_CLK_DISABLE__HAL_RCC_TIM1_CLK_DISABLE__SYSCFG_RELEASE_RESET__HAL_RCC_SYSCFG_RELEASE_RESET__SYSCFG_FORCE_RESET__HAL_RCC_SYSCFG_FORCE_RESET__SYSCFG_CLK_SLEEP_ENABLE__HAL_RCC_SYSCFG_CLK_SLEEP_ENABLE__SYSCFG_CLK_SLEEP_DISABLE__HAL_RCC_SYSCFG_CLK_SLEEP_DISABLE__SYSCFG_CLK_ENABLE__HAL_RCC_SYSCFG_CLK_ENABLE__SYSCFG_CLK_DISABLE__HAL_RCC_SYSCFG_CLK_DISABLE__SWPMI1_RELEASE_RESET__HAL_RCC_SWPMI1_RELEASE_RESET__SWPMI1_FORCE_RESET__HAL_RCC_SWPMI1_FORCE_RESET__SWPMI1_CLK_SLEEP_ENABLE__HAL_RCC_SWPMI1_CLK_SLEEP_ENABLE__SWPMI1_CLK_SLEEP_DISABLE__HAL_RCC_SWPMI1_CLK_SLEEP_DISABLE__SWPMI1_CLK_ENABLE__HAL_RCC_SWPMI1_CLK_ENABLE__SWPMI1_CLK_DISABLE__HAL_RCC_SWPMI1_CLK_DISABLE__SRAM2_CLK_SLEEP_ENABLE__HAL_RCC_SRAM2_CLK_SLEEP_ENABLE__SRAM2_CLK_SLEEP_DISABLE__HAL_RCC_SRAM2_CLK_SLEEP_DISABLE__SRAM1_CLK_SLEEP_ENABLE__HAL_RCC_SRAM1_CLK_SLEEP_ENABLE__SRAM1_CLK_SLEEP_DISABLE__HAL_RCC_SRAM1_CLK_SLEEP_DISABLE__SRAM_CLK_ENABLE__HAL_RCC_SRAM_CLK_ENABLE__SRAM_CLK_DISABLE__HAL_RCC_SRAM_CLK_DISABLE__SPI3_RELEASE_RESET__HAL_RCC_SPI3_RELEASE_RESET__SPI3_FORCE_RESET__HAL_RCC_SPI3_FORCE_RESET__SPI3_CLK_SLEEP_ENABLE__HAL_RCC_SPI3_CLK_SLEEP_ENABLE__SPI3_CLK_SLEEP_DISABLE__HAL_RCC_SPI3_CLK_SLEEP_DISABLE__SPI3_CLK_ENABLE__HAL_RCC_SPI3_CLK_ENABLE__SPI3_CLK_DISABLE__HAL_RCC_SPI3_CLK_DISABLE__SPI2_RELEASE_RESET__HAL_RCC_SPI2_RELEASE_RESET__SPI2_FORCE_RESET__HAL_RCC_SPI2_FORCE_RESET__SPI2_CLK_SLEEP_ENABLE__HAL_RCC_SPI2_CLK_SLEEP_ENABLE__SPI2_CLK_SLEEP_DISABLE__HAL_RCC_SPI2_CLK_SLEEP_DISABLE__SPI2_CLK_ENABLE__HAL_RCC_SPI2_CLK_ENABLE__SPI2_CLK_DISABLE__HAL_RCC_SPI2_CLK_DISABLE__SPI1_RELEASE_RESET__HAL_RCC_SPI1_RELEASE_RESET__SPI1_FORCE_RESET__HAL_RCC_SPI1_FORCE_RESET__SPI1_CLK_SLEEP_ENABLE__HAL_RCC_SPI1_CLK_SLEEP_ENABLE__SPI1_CLK_SLEEP_DISABLE__HAL_RCC_SPI1_CLK_SLEEP_DISABLE__SPI1_CLK_ENABLE__HAL_RCC_SPI1_CLK_ENABLE__SPI1_CLK_DISABLE__HAL_RCC_SPI1_CLK_DISABLE__SDMMC_RELEASE_RESET__HAL_RCC_SDMMC_RELEASE_RESET__SDMMC_FORCE_RESET__HAL_RCC_SDMMC_FORCE_RESET__SDMMC_CLK_SLEEP_ENABLE__HAL_RCC_SDMMC_CLK_SLEEP_ENABLE__SDMMC_CLK_SLEEP_DISABLE__HAL_RCC_SDMMC_CLK_SLEEP_DISABLE__SDMMC_CLK_ENABLE__HAL_RCC_SDMMC_CLK_ENABLE__SDMMC_CLK_DISABLE__HAL_RCC_SDMMC_CLK_DISABLE__SDIO_CLK_ENABLE__SDIO_CLK_DISABLE__SAI2_RELEASE_RESET__HAL_RCC_SAI2_RELEASE_RESET__SAI2_FORCE_RESET__HAL_RCC_SAI2_FORCE_RESET__SAI2_CLK_SLEEP_ENABLE__HAL_RCC_SAI2_CLK_SLEEP_ENABLE__SAI2_CLK_SLEEP_DISABLE__HAL_RCC_SAI2_CLK_SLEEP_DISABLE__SAI2_CLK_ENABLE__HAL_RCC_SAI2_CLK_ENABLE__SAI2_CLK_DISABLE__HAL_RCC_SAI2_CLK_DISABLE__SAI1_RELEASE_RESET__HAL_RCC_SAI1_RELEASE_RESET__SAI1_FORCE_RESET__HAL_RCC_SAI1_FORCE_RESET__SAI1_CLK_SLEEP_ENABLE__HAL_RCC_SAI1_CLK_SLEEP_ENABLE__SAI1_CLK_SLEEP_DISABLE__HAL_RCC_SAI1_CLK_SLEEP_DISABLE__SAI1_CLK_ENABLE__HAL_RCC_SAI1_CLK_ENABLE__SAI1_CLK_DISABLE__HAL_RCC_SAI1_CLK_DISABLE__RNG_RELEASE_RESET__HAL_RCC_RNG_RELEASE_RESET__RNG_FORCE_RESET__HAL_RCC_RNG_FORCE_RESET__RNG_CLK_SLEEP_ENABLE__HAL_RCC_RNG_CLK_SLEEP_ENABLE__RNG_CLK_SLEEP_DISABLE__HAL_RCC_RNG_CLK_SLEEP_DISABLE__RNG_CLK_ENABLE__HAL_RCC_RNG_CLK_ENABLE__RNG_CLK_DISABLE__HAL_RCC_RNG_CLK_DISABLE__QSPI_RELEASE_RESET__HAL_RCC_QSPI_RELEASE_RESET__QSPI_FORCE_RESET__HAL_RCC_QSPI_FORCE_RESET__QSPI_CLK_SLEEP_ENABLE__HAL_RCC_QSPI_CLK_SLEEP_ENABLE__QSPI_CLK_SLEEP_DISABLE__HAL_RCC_QSPI_CLK_SLEEP_DISABLE__QSPI_CLK_ENABLE__HAL_RCC_QSPI_CLK_ENABLE__QSPI_CLK_DISABLE__HAL_RCC_QSPI_CLK_DISABLE__PWR_RELEASE_RESET__HAL_RCC_PWR_RELEASE_RESET__PWR_FORCE_RESET__HAL_RCC_PWR_FORCE_RESET__PWR_CLK_SLEEP_ENABLE__HAL_RCC_PWR_CLK_SLEEP_ENABLE__PWR_CLK_SLEEP_DISABLE__HAL_RCC_PWR_CLK_SLEEP_DISABLE__PWR_CLK_ENABLE__HAL_RCC_PWR_CLK_ENABLE__PWR_CLK_DISABLE__HAL_RCC_PWR_CLK_DISABLE__OTGFS_RELEASE_RESET__OTGFS_FORCE_RESET__OTGFS_CLK_SLEEP_ENABLE__HAL_RCC_OTGFS_CLK_SLEEP_ENABLE__OTGFS_CLK_SLEEP_DISABLE__HAL_RCC_OTGFS_CLK_SLEEP_DISABLE__OTGFS_CLK_ENABLE__HAL_RCC_OTGFS_CLK_ENABLE__OTGFS_CLK_DISABLE__HAL_RCC_OTGFS_CLK_DISABLE__OPAMP_RELEASE_RESET__HAL_RCC_OPAMP_RELEASE_RESET__OPAMP_FORCE_RESET__HAL_RCC_OPAMP_FORCE_RESET__OPAMP_CLK_SLEEP_ENABLE__HAL_RCC_OPAMP_CLK_SLEEP_ENABLE__OPAMP_CLK_SLEEP_DISABLE__HAL_RCC_OPAMP_CLK_SLEEP_DISABLE__OPAMP_CLK_ENABLE__HAL_RCC_OPAMP_CLK_ENABLE__OPAMP_CLK_DISABLE__HAL_RCC_OPAMP_CLK_DISABLE__LPUART1_RELEASE_RESET__HAL_RCC_LPUART1_RELEASE_RESET__LPUART1_FORCE_RESET__HAL_RCC_LPUART1_FORCE_RESET__LPUART1_CLK_SLEEP_ENABLE__HAL_RCC_LPUART1_CLK_SLEEP_ENABLE__LPUART1_CLK_SLEEP_DISABLE__HAL_RCC_LPUART1_CLK_SLEEP_DISABLE__LPUART1_CLK_ENABLE__HAL_RCC_LPUART1_CLK_ENABLE__LPUART1_CLK_DISABLE__HAL_RCC_LPUART1_CLK_DISABLE__LPTIM2_RELEASE_RESET__HAL_RCC_LPTIM2_RELEASE_RESET__LPTIM2_FORCE_RESET__HAL_RCC_LPTIM2_FORCE_RESET__LPTIM2_CLK_SLEEP_ENABLE__HAL_RCC_LPTIM2_CLK_SLEEP_ENABLE__LPTIM2_CLK_SLEEP_DISABLE__HAL_RCC_LPTIM2_CLK_SLEEP_DISABLE__LPTIM2_CLK_ENABLE__HAL_RCC_LPTIM2_CLK_ENABLE__LPTIM2_CLK_DISABLE__HAL_RCC_LPTIM2_CLK_DISABLE__LPTIM1_RELEASE_RESET__HAL_RCC_LPTIM1_RELEASE_RESET__LPTIM1_FORCE_RESET__HAL_RCC_LPTIM1_FORCE_RESET__LPTIM1_CLK_SLEEP_ENABLE__HAL_RCC_LPTIM1_CLK_SLEEP_ENABLE__LPTIM1_CLK_SLEEP_DISABLE__HAL_RCC_LPTIM1_CLK_SLEEP_DISABLE__LPTIM1_CLK_ENABLE__HAL_RCC_LPTIM1_CLK_ENABLE__LPTIM1_CLK_DISABLE__HAL_RCC_LPTIM1_CLK_DISABLE__LCD_RELEASE_RESET__HAL_RCC_LCD_RELEASE_RESET__LCD_FORCE_RESET__HAL_RCC_LCD_FORCE_RESET__LCD_CLK_SLEEP_ENABLE__HAL_RCC_LCD_CLK_SLEEP_ENABLE__LCD_CLK_SLEEP_DISABLE__HAL_RCC_LCD_CLK_SLEEP_DISABLE__LCD_CLK_ENABLE__HAL_RCC_LCD_CLK_ENABLE__LCD_CLK_DISABLE__HAL_RCC_LCD_CLK_DISABLE__I2C3_RELEASE_RESET__HAL_RCC_I2C3_RELEASE_RESET__I2C3_FORCE_RESET__HAL_RCC_I2C3_FORCE_RESET__I2C3_CLK_SLEEP_ENABLE__HAL_RCC_I2C3_CLK_SLEEP_ENABLE__I2C3_CLK_SLEEP_DISABLE__HAL_RCC_I2C3_CLK_SLEEP_DISABLE__I2C3_CLK_ENABLE__HAL_RCC_I2C3_CLK_ENABLE__I2C3_CLK_DISABLE__HAL_RCC_I2C3_CLK_DISABLE__I2C2_RELEASE_RESET__HAL_RCC_I2C2_RELEASE_RESET__I2C2_FORCE_RESET__HAL_RCC_I2C2_FORCE_RESET__I2C2_CLK_SLEEP_ENABLE__HAL_RCC_I2C2_CLK_SLEEP_ENABLE__I2C2_CLK_SLEEP_DISABLE__HAL_RCC_I2C2_CLK_SLEEP_DISABLE__I2C2_CLK_ENABLE__HAL_RCC_I2C2_CLK_ENABLE__I2C2_CLK_DISABLE__HAL_RCC_I2C2_CLK_DISABLE__I2C1_RELEASE_RESET__HAL_RCC_I2C1_RELEASE_RESET__I2C1_FORCE_RESET__HAL_RCC_I2C1_FORCE_RESET__I2C1_CLK_SLEEP_ENABLE__HAL_RCC_I2C1_CLK_SLEEP_ENABLE__I2C1_CLK_SLEEP_DISABLE__HAL_RCC_I2C1_CLK_SLEEP_DISABLE__I2C1_CLK_ENABLE__HAL_RCC_I2C1_CLK_ENABLE__I2C1_CLK_DISABLE__HAL_RCC_I2C1_CLK_DISABLE__GPIOH_RELEASE_RESET__HAL_RCC_GPIOH_RELEASE_RESET__GPIOH_FORCE_RESET__HAL_RCC_GPIOH_FORCE_RESET__GPIOH_CLK_SLEEP_ENABLE__HAL_RCC_GPIOH_CLK_SLEEP_ENABLE__GPIOH_CLK_SLEEP_DISABLE__HAL_RCC_GPIOH_CLK_SLEEP_DISABLE__GPIOH_CLK_ENABLE__HAL_RCC_GPIOH_CLK_ENABLE__GPIOH_CLK_DISABLE__HAL_RCC_GPIOH_CLK_DISABLE__GPIOG_RELEASE_RESET__HAL_RCC_GPIOG_RELEASE_RESET__GPIOG_FORCE_RESET__HAL_RCC_GPIOG_FORCE_RESET__GPIOG_CLK_SLEEP_ENABLE__HAL_RCC_GPIOG_CLK_SLEEP_ENABLE__GPIOG_CLK_SLEEP_DISABLE__HAL_RCC_GPIOG_CLK_SLEEP_DISABLE__GPIOG_CLK_ENABLE__HAL_RCC_GPIOG_CLK_ENABLE__GPIOG_CLK_DISABLE__HAL_RCC_GPIOG_CLK_DISABLE__GPIOF_RELEASE_RESET__HAL_RCC_GPIOF_RELEASE_RESET__GPIOF_FORCE_RESET__HAL_RCC_GPIOF_FORCE_RESET__GPIOF_CLK_SLEEP_ENABLE__HAL_RCC_GPIOF_CLK_SLEEP_ENABLE__GPIOF_CLK_SLEEP_DISABLE__HAL_RCC_GPIOF_CLK_SLEEP_DISABLE__GPIOF_CLK_ENABLE__HAL_RCC_GPIOF_CLK_ENABLE__GPIOF_CLK_DISABLE__HAL_RCC_GPIOF_CLK_DISABLE__GPIOE_RELEASE_RESET__HAL_RCC_GPIOE_RELEASE_RESET__GPIOE_FORCE_RESET__HAL_RCC_GPIOE_FORCE_RESET__GPIOE_CLK_SLEEP_ENABLE__HAL_RCC_GPIOE_CLK_SLEEP_ENABLE__GPIOE_CLK_SLEEP_DISABLE__HAL_RCC_GPIOE_CLK_SLEEP_DISABLE__GPIOE_CLK_ENABLE__HAL_RCC_GPIOE_CLK_ENABLE__GPIOE_CLK_DISABLE__HAL_RCC_GPIOE_CLK_DISABLE__GPIOD_RELEASE_RESET__HAL_RCC_GPIOD_RELEASE_RESET__GPIOD_FORCE_RESET__HAL_RCC_GPIOD_FORCE_RESET__GPIOD_CLK_SLEEP_ENABLE__HAL_RCC_GPIOD_CLK_SLEEP_ENABLE__GPIOD_CLK_SLEEP_DISABLE__HAL_RCC_GPIOD_CLK_SLEEP_DISABLE__GPIOD_CLK_ENABLE__HAL_RCC_GPIOD_CLK_ENABLE__GPIOD_CLK_DISABLE__HAL_RCC_GPIOD_CLK_DISABLE__GPIOC_RELEASE_RESET__HAL_RCC_GPIOC_RELEASE_RESET__GPIOC_FORCE_RESET__HAL_RCC_GPIOC_FORCE_RESET__GPIOC_CLK_SLEEP_ENABLE__HAL_RCC_GPIOC_CLK_SLEEP_ENABLE__GPIOC_CLK_SLEEP_DISABLE__HAL_RCC_GPIOC_CLK_SLEEP_DISABLE__GPIOC_CLK_ENABLE__HAL_RCC_GPIOC_CLK_ENABLE__GPIOC_CLK_DISABLE__HAL_RCC_GPIOC_CLK_DISABLE__GPIOB_RELEASE_RESET__HAL_RCC_GPIOB_RELEASE_RESET__GPIOB_FORCE_RESET__HAL_RCC_GPIOB_FORCE_RESET__GPIOB_CLK_SLEEP_ENABLE__HAL_RCC_GPIOB_CLK_SLEEP_ENABLE__GPIOB_CLK_SLEEP_DISABLE__HAL_RCC_GPIOB_CLK_SLEEP_DISABLE__GPIOB_CLK_ENABLE__HAL_RCC_GPIOB_CLK_ENABLE__GPIOB_CLK_DISABLE__HAL_RCC_GPIOB_CLK_DISABLE__GPIOA_RELEASE_RESET__HAL_RCC_GPIOA_RELEASE_RESET__GPIOA_FORCE_RESET__HAL_RCC_GPIOA_FORCE_RESET__GPIOA_CLK_SLEEP_ENABLE__HAL_RCC_GPIOA_CLK_SLEEP_ENABLE__GPIOA_CLK_SLEEP_DISABLE__HAL_RCC_GPIOA_CLK_SLEEP_DISABLE__GPIOA_CLK_ENABLE__HAL_RCC_GPIOA_CLK_ENABLE__GPIOA_CLK_DISABLE__HAL_RCC_GPIOA_CLK_DISABLE__FSMC_CLK_ENABLE__HAL_RCC_FSMC_CLK_ENABLE__FSMC_CLK_DISABLE__HAL_RCC_FSMC_CLK_DISABLE__FMC_RELEASE_RESET__HAL_RCC_FMC_RELEASE_RESET__FMC_FORCE_RESET__HAL_RCC_FMC_FORCE_RESET__FMC_CLK_SLEEP_ENABLE__HAL_RCC_FMC_CLK_SLEEP_ENABLE__FMC_CLK_SLEEP_DISABLE__HAL_RCC_FMC_CLK_SLEEP_DISABLE__FMC_CLK_ENABLE__HAL_RCC_FMC_CLK_ENABLE__FMC_CLK_DISABLE__HAL_RCC_FMC_CLK_DISABLE__FLITF_CLK_SLEEP_DISABLE__HAL_RCC_FLITF_CLK_SLEEP_DISABLE__FLITF_CLK_SLEEP_ENABLE__HAL_RCC_FLITF_CLK_SLEEP_ENABLE__FLITF_RELEASE_RESET__HAL_RCC_FLITF_RELEASE_RESET__FLITF_FORCE_RESET__HAL_RCC_FLITF_FORCE_RESET__FLITF_CLK_ENABLE__HAL_RCC_FLITF_CLK_ENABLE__FLITF_CLK_DISABLE__HAL_RCC_FLITF_CLK_DISABLE__FLASH_RELEASE_RESET__HAL_RCC_FLASH_RELEASE_RESET__FLASH_FORCE_RESET__HAL_RCC_FLASH_FORCE_RESET__FLASH_CLK_SLEEP_ENABLE__HAL_RCC_FLASH_CLK_SLEEP_ENABLE__FLASH_CLK_SLEEP_DISABLE__HAL_RCC_FLASH_CLK_SLEEP_DISABLE__FLASH_CLK_ENABLE__HAL_RCC_FLASH_CLK_ENABLE__FLASH_CLK_DISABLE__HAL_RCC_FLASH_CLK_DISABLE__FIREWALL_CLK_ENABLE__HAL_RCC_FIREWALL_CLK_ENABLE__FIREWALL_CLK_DISABLE__HAL_RCC_FIREWALL_CLK_DISABLE__ETHMACTX_CLK_ENABLE__HAL_RCC_ETHMACTX_CLK_ENABLE__ETHMACTX_CLK_DISABLE__HAL_RCC_ETHMACTX_CLK_DISABLE__ETHMACRX_CLK_ENABLE__HAL_RCC_ETHMACRX_CLK_ENABLE__ETHMACRX_CLK_DISABLE__HAL_RCC_ETHMACRX_CLK_DISABLE__ETHMAC_RELEASE_RESET__HAL_RCC_ETHMAC_RELEASE_RESET__ETHMAC_FORCE_RESET__HAL_RCC_ETHMAC_FORCE_RESET__ETHMAC_CLK_ENABLE__HAL_RCC_ETHMAC_CLK_ENABLE__ETHMAC_CLK_DISABLE__HAL_RCC_ETHMAC_CLK_DISABLE__DMA2_RELEASE_RESET__HAL_RCC_DMA2_RELEASE_RESET__DMA2_FORCE_RESET__HAL_RCC_DMA2_FORCE_RESET__DMA2_CLK_SLEEP_ENABLE__HAL_RCC_DMA2_CLK_SLEEP_ENABLE__DMA2_CLK_SLEEP_DISABLE__HAL_RCC_DMA2_CLK_SLEEP_DISABLE__DMA2_CLK_ENABLE__DMA2_CLK_DISABLE__DMA1_RELEASE_RESET__HAL_RCC_DMA1_RELEASE_RESET__DMA1_FORCE_RESET__HAL_RCC_DMA1_FORCE_RESET__DMA1_CLK_SLEEP_ENABLE__HAL_RCC_DMA1_CLK_SLEEP_ENABLE__DMA1_CLK_SLEEP_DISABLE__HAL_RCC_DMA1_CLK_SLEEP_DISABLE__DMA1_CLK_ENABLE__HAL_RCC_DMA1_CLK_ENABLE__DMA1_CLK_DISABLE__HAL_RCC_DMA1_CLK_DISABLE__DFSDM_RELEASE_RESET__DFSDM_FORCE_RESET__DFSDM_CLK_SLEEP_ENABLE__DFSDM_CLK_SLEEP_DISABLE__DFSDM_CLK_ENABLE__DFSDM_CLK_DISABLE__DBGMCU_RELEASE_RESET__HAL_RCC_DBGMCU_RELEASE_RESET__DBGMCU_FORCE_RESET__HAL_RCC_DBGMCU_FORCE_RESET__DBGMCU_CLK_DISABLE__HAL_RCC_DBGMCU_CLK_DISABLE__DBGMCU_CLK_ENABLE__HAL_RCC_DBGMCU_CLK_ENABLE__DAC1_RELEASE_RESET__HAL_RCC_DAC1_RELEASE_RESET__DAC1_FORCE_RESET__HAL_RCC_DAC1_FORCE_RESET__DAC1_CLK_SLEEP_ENABLE__HAL_RCC_DAC1_CLK_SLEEP_ENABLE__DAC1_CLK_SLEEP_DISABLE__HAL_RCC_DAC1_CLK_SLEEP_DISABLE__DAC1_CLK_ENABLE__HAL_RCC_DAC1_CLK_ENABLE__DAC1_CLK_DISABLE__HAL_RCC_DAC1_CLK_DISABLE__DAC_RELEASE_RESET__HAL_RCC_DAC_RELEASE_RESET__DAC_FORCE_RESET__HAL_RCC_DAC_FORCE_RESET__DAC_CLK_ENABLE__HAL_RCC_DAC_CLK_ENABLE__DAC_CLK_DISABLE__HAL_RCC_DAC_CLK_DISABLE__CRC_RELEASE_RESET__HAL_RCC_CRC_RELEASE_RESET__CRC_FORCE_RESET__HAL_RCC_CRC_FORCE_RESET__CRC_CLK_SLEEP_ENABLE__HAL_RCC_CRC_CLK_SLEEP_ENABLE__CRC_CLK_SLEEP_DISABLE__HAL_RCC_CRC_CLK_SLEEP_DISABLE__CRC_CLK_ENABLE__HAL_RCC_CRC_CLK_ENABLE__CRC_CLK_DISABLE__HAL_RCC_CRC_CLK_DISABLE__CEC_RELEASE_RESET__HAL_RCC_CEC_RELEASE_RESET__CEC_FORCE_RESET__HAL_RCC_CEC_FORCE_RESET__COMP_CLK_SLEEP_DISABLE__HAL_RCC_COMP_CLK_SLEEP_DISABLE__COMP_CLK_SLEEP_ENABLE__HAL_RCC_COMP_CLK_SLEEP_ENABLE__COMP_RELEASE_RESET__HAL_RCC_COMP_RELEASE_RESET__COMP_FORCE_RESET__HAL_RCC_COMP_FORCE_RESET__COMP_CLK_ENABLE__HAL_RCC_COMP_CLK_ENABLE__COMP_CLK_DISABLE__HAL_RCC_COMP_CLK_DISABLE__CEC_CLK_ENABLE__HAL_RCC_CEC_CLK_ENABLE__CEC_CLK_DISABLE__HAL_RCC_CEC_CLK_DISABLE__CAN2_RELEASE_RESET__HAL_RCC_CAN2_RELEASE_RESET__CAN2_FORCE_RESET__HAL_RCC_CAN2_FORCE_RESET__CAN2_CLK_ENABLE__HAL_RCC_CAN2_CLK_ENABLE__CAN2_CLK_DISABLE__HAL_RCC_CAN2_CLK_DISABLE__CAN_RELEASE_RESET__HAL_RCC_CAN1_RELEASE_RESET__CAN_FORCE_RESET__HAL_RCC_CAN1_FORCE_RESET__CAN_CLK_ENABLE__HAL_RCC_CAN1_CLK_ENABLE__CAN_CLK_DISABLE__HAL_RCC_CAN1_CLK_DISABLE__CAN1_RELEASE_RESET__CAN1_FORCE_RESET__CAN1_CLK_SLEEP_ENABLE__HAL_RCC_CAN1_CLK_SLEEP_ENABLE__CAN1_CLK_SLEEP_DISABLE__HAL_RCC_CAN1_CLK_SLEEP_DISABLE__CAN1_CLK_ENABLE__CAN1_CLK_DISABLE__BKP_RELEASE_RESET__HAL_RCC_BKP_RELEASE_RESET__BKP_FORCE_RESET__HAL_RCC_BKP_FORCE_RESET__BKP_CLK_ENABLE__HAL_RCC_BKP_CLK_ENABLE__BKP_CLK_DISABLE__HAL_RCC_BKP_CLK_DISABLE__APB2_RELEASE_RESET__HAL_RCC_APB2_RELEASE_RESET__APB2_FORCE_RESET__HAL_RCC_APB2_FORCE_RESET__APB1_RELEASE_RESET__HAL_RCC_APB1_RELEASE_RESET__APB1_FORCE_RESET__HAL_RCC_APB1_FORCE_RESET__AHB3_RELEASE_RESET__HAL_RCC_AHB3_RELEASE_RESET__AHB3_FORCE_RESET__HAL_RCC_AHB3_FORCE_RESET__AHB2_RELEASE_RESET__HAL_RCC_AHB2_RELEASE_RESET__AHB2_FORCE_RESET__HAL_RCC_AHB2_FORCE_RESET__AHB1_RELEASE_RESET__HAL_RCC_AHB1_RELEASE_RESET__AHB1_FORCE_RESET__HAL_RCC_AHB1_FORCE_RESET__AHB_RELEASE_RESET__HAL_RCC_AHB_RELEASE_RESET__AHB_FORCE_RESET__HAL_RCC_AHB_FORCE_RESET__AFIO_RELEASE_RESET__HAL_RCC_AFIO_RELEASE_RESET__AFIO_FORCE_RESET__HAL_RCC_AFIO_FORCE_RESET__AFIO_CLK_ENABLE__HAL_RCC_AFIO_CLK_ENABLE__AFIO_CLK_DISABLE__HAL_RCC_AFIO_CLK_DISABLE__CRYP_RELEASE_RESET__HAL_RCC_CRYP_RELEASE_RESET__CRYP_FORCE_RESET__HAL_RCC_CRYP_FORCE_RESET__CRYP_CLK_DISABLE__HAL_RCC_CRYP_CLK_DISABLE__CRYP_CLK_ENABLE__HAL_RCC_CRYP_CLK_ENABLE__CRYP_CLK_SLEEP_DISABLE__HAL_RCC_CRYP_CLK_SLEEP_DISABLE__CRYP_CLK_SLEEP_ENABLE__HAL_RCC_CRYP_CLK_SLEEP_ENABLE__AES_RELEASE_RESET__HAL_RCC_AES_RELEASE_RESET__AES_FORCE_RESET__HAL_RCC_AES_FORCE_RESET__AES_CLK_SLEEP_ENABLE__HAL_RCC_AES_CLK_SLEEP_ENABLE__AES_CLK_SLEEP_DISABLE__HAL_RCC_AES_CLK_SLEEP_DISABLE__AES_CLK_ENABLE__HAL_RCC_AES_CLK_ENABLE__AES_CLK_DISABLE__HAL_RCC_AES_CLK_DISABLE__ADC3_RELEASE_RESET__HAL_RCC_ADC3_RELEASE_RESET__ADC3_FORCE_RESET__HAL_RCC_ADC3_FORCE_RESET__ADC3_CLK_ENABLE__HAL_RCC_ADC3_CLK_ENABLE__ADC3_CLK_DISABLE__HAL_RCC_ADC3_CLK_DISABLE__ADC2_RELEASE_RESET__HAL_RCC_ADC2_RELEASE_RESET__ADC2_FORCE_RESET__HAL_RCC_ADC2_FORCE_RESET__ADC2_CLK_ENABLE__HAL_RCC_ADC2_CLK_ENABLE__ADC2_CLK_DISABLE__HAL_RCC_ADC2_CLK_DISABLE__ADC1_CLK_SLEEP_DISABLE__HAL_RCC_ADC1_CLK_SLEEP_DISABLE__ADC1_CLK_SLEEP_ENABLE__HAL_RCC_ADC1_CLK_SLEEP_ENABLE__ADC1_RELEASE_RESET__HAL_RCC_ADC1_RELEASE_RESET__ADC1_FORCE_RESET__HAL_RCC_ADC1_FORCE_RESET__ADC1_CLK_ENABLE__HAL_RCC_ADC1_CLK_ENABLE__ADC1_CLK_DISABLE__HAL_RCC_ADC1_CLK_DISABLE__ADC_RELEASE_RESET__HAL_RCC_ADC_RELEASE_RESET__ADC_FORCE_RESET__HAL_RCC_ADC_FORCE_RESET__ADC_CLK_SLEEP_ENABLE__HAL_RCC_ADC_CLK_SLEEP_ENABLE__ADC_CLK_SLEEP_DISABLE__HAL_RCC_ADC_CLK_SLEEP_DISABLE__ADC_CLK_ENABLE__HAL_RCC_ADC_CLK_ENABLE__ADC_CLK_DISABLE__HAL_RCC_ADC_CLK_DISABLEHAL_RC48_EnableBuffer_Cmd(cmd)(((cmd)==ENABLE) ? HAL_RCCEx_EnableHSI48_VREFINT() : HAL_RCCEx_DisableHSI48_VREFINT())HAL_RCC_CCSCallbackHAL_RCC_CSSCallbackRCC_StopWakeUpClock_HSIRCC_STOP_WAKEUPCLOCK_HSIRCC_StopWakeUpClock_MSIRCC_STOP_WAKEUPCLOCK_MSI__HAL_PVD_EXTI_GET_FLAG__HAL_PWR_PVD_EXTI_GET_FLAG__HAL_PVD_EXTI_GENERATE_SWIT__HAL_PWR_PVD_EXTI_GENERATE_SWIT__HAL_PVD_EXTI_ENABLE_IT__HAL_PWR_PVD_EXTI_ENABLE_IT__HAL_PVD_EXTI_DISABLE_IT__HAL_PWR_PVD_EXTI_DISABLE_IT__HAL_PVD_EXTI_CLEAR_FLAG__HAL_PWR_PVD_EXTI_CLEAR_FLAG__HAL_PWR_VDDUSB_ENABLEHAL_PWREx_EnableVddUSB__HAL_PWR_VDDUSB_DISABLEHAL_PWREx_DisableVddUSB__HAL_PWR_VDDIO2_EXTI_SET_FALLING_EGDE_TRIGGER__HAL_PWR_VDDIO2_EXTI_ENABLE_FALLING_EDGE__HAL_PWR_VDDIO2_EXTI_CLEAR_EGDE_TRIGGER__HAL_PWR_VDDIO2_EXTI_DISABLE_FALLING_EDGE__HAL_PWR_VDDIO2_ENABLEHAL_PWREx_EnableVddIO2__HAL_PWR_VDDIO2_DISABLEHAL_PWREx_DisableVddIO2__HAL_PWR_SRAM2CONTENT_PRESERVE_ENABLEHAL_PWREx_EnableSRAM2ContentRetention__HAL_PWR_SRAM2CONTENT_PRESERVE_DISABLEHAL_PWREx_DisableSRAM2ContentRetention__HAL_PWR_PVM_ENABLE()do { HAL_PWREx_EnablePVM1();HAL_PWREx_EnablePVM2(); HAL_PWREx_EnablePVM3();HAL_PWREx_EnablePVM4(); } while(0)__HAL_PWR_PVM_DISABLE()do { HAL_PWREx_DisablePVM1();HAL_PWREx_DisablePVM2(); HAL_PWREx_DisablePVM3();HAL_PWREx_DisablePVM4(); } while(0)__HAL_PWR_PVD_EXTI_SET_RISING_EDGE_TRIGGER__HAL_PWR_PVD_EXTI_ENABLE_RISING_EDGE__HAL_PWR_PVD_EXTI_SET_FALLING_EGDE_TRIGGER__HAL_PWR_PVD_EXTI_ENABLE_FALLING_EDGE__HAL_PWR_PVD_EXTI_RISINGTRIGGER_ENABLE__HAL_PWR_PVD_EXTI_RISINGTRIGGER_DISABLE__HAL_PWR_PVD_EXTI_DISABLE_RISING_EDGE__HAL_PWR_PVD_EXTI_FALLINGTRIGGER_ENABLE__HAL_PWR_PVD_EXTI_FALLINGTRIGGER_DISABLE__HAL_PWR_PVD_EXTI_DISABLE_FALLING_EDGE__HAL_PWR_PVD_EXTI_EVENT_ENABLE__HAL_PWR_PVD_EXTI_ENABLE_EVENT__HAL_PWR_PVD_EXTI_EVENT_DISABLE__HAL_PWR_PVD_EXTI_DISABLE_EVENT__HAL_PWR_PVD_EXTI_CLEAR_EGDE_TRIGGER()do { __HAL_PWR_PVD_EXTI_DISABLE_RISING_EDGE(); __HAL_PWR_PVD_EXTI_DISABLE_FALLING_EDGE(); } while(0)__HAL_PWR_PULL_UP_DOWN_CONFIG_ENABLEHAL_PWREx_EnablePullUpPullDownConfig__HAL_PWR_PULL_UP_DOWN_CONFIG_DISABLEHAL_PWREx_DisablePullUpPullDownConfig__HAL_PWR_INTERNALWAKEUP_ENABLEHAL_PWREx_EnableInternalWakeUpLine__HAL_PWR_INTERNALWAKEUP_DISABLEHAL_PWREx_DisableInternalWakeUpLine__HAL_PVM_EXTI_RISINGTRIGGER_ENABLE__HAL_PWR_PVM_EXTI_RISINGTRIGGER_ENABLE__HAL_PVM_EXTI_RISINGTRIGGER_DISABLE__HAL_PWR_PVM_EXTI_RISINGTRIGGER_DISABLE__HAL_PVM_EXTI_FALLINGTRIGGER_ENABLE__HAL_PWR_PVM_EXTI_FALLINGTRIGGER_ENABLE__HAL_PVM_EXTI_FALLINGTRIGGER_DISABLE__HAL_PWR_PVM_EXTI_FALLINGTRIGGER_DISABLE__HAL_PVM_EVENT_ENABLE__HAL_PWR_PVM_EVENT_ENABLE__HAL_PVM_EVENT_DISABLE__HAL_PWR_PVM_EVENT_DISABLE__HAL_PVD_EXTI_RISINGTRIGGER_ENABLE__HAL_PVD_EXTI_RISINGTRIGGER_DISABLE__HAL_PVD_EXTI_FALLINGTRIGGER_ENABLE__HAL_PVD_EXTI_FALLINGTRIGGER_DISABLE__HAL_PVD_EVENT_ENABLE__HAL_PVD_EVENT_DISABLE__OPAMP_OFFSET_TRIM_SETOPAMP_OFFSET_TRIM_SET__OPAMP_OFFSET_TRIM_BITSPOSITIONOPAMP_OFFSET_TRIM_BITSPOSITION__OPAMP_CSR_OPAXCALOUTOPAMP_CSR_OPAXCALOUT__OPAMP_CSR_ANAWSELXOPAMP_CSR_ANAWSELX__OPAMP_CSR_ALL_SWITCHESOPAMP_CSR_ALL_SWITCHES__OPAMP_CSR_OPAXLPMOPAMP_CSR_OPAXLPM__OPAMP_CSR_OPAXCAL_HOPAMP_CSR_OPAXCAL_H__OPAMP_CSR_OPAXCAL_LOPAMP_CSR_OPAXCAL_L__OPAMP_CSR_S6SELXOPAMP_CSR_S6SELX__OPAMP_CSR_S5SELXOPAMP_CSR_S5SELX__OPAMP_CSR_S4SELXOPAMP_CSR_S4SELX__OPAMP_CSR_S3SELXOPAMP_CSR_S3SELX__OPAMP_CSR_OPAXPDOPAMP_CSR_OPAXPD__HAL_LPTIM_GET_ITSTATUS__HAL_LPTIM_GET_IT_SOURCE__HAL_LPTIM_DISABLE_INTERRUPT__HAL_LPTIM_DISABLE_IT__HAL_LPTIM_ENABLE_INTERRUPT__HAL_LPTIM_ENABLE_IT__HAL_IWDG_DISABLE_WRITE_ACCESSIWDG_DISABLE_WRITE_ACCESS__HAL_IWDG_ENABLE_WRITE_ACCESSIWDG_ENABLE_WRITE_ACCESSIS_IRDA_ONEBIT_SAMPLEIS_IRDA_ONE_BIT_SAMPLE__IRDA_MASK_COMPUTATIONIRDA_MASK_COMPUTATION__IRDA_GETCLOCKSOURCEIRDA_GETCLOCKSOURCE__HAL_IRDA_MASK_COMPUTATION__HAL_IRDA_GETCLOCKSOURCE__IRDA_ENABLE__HAL_IRDA_ENABLE__IRDA_DISABLE__HAL_IRDA_DISABLEIS_I2S_INSTANCE_EXTIS_I2S_ALL_INSTANCE_EXTIS_I2S_INSTANCEIS_I2S_ALL_INSTANCE__HAL_I2C_FREQRANGEI2C_FREQRANGE__HAL_I2C_MEM_ADD_LSBI2C_MEM_ADD_LSB__HAL_I2C_MEM_ADD_MSBI2C_MEM_ADD_MSB__HAL_I2C_10BIT_HEADER_READI2C_10BIT_HEADER_READ__HAL_I2C_10BIT_HEADER_WRITEI2C_10BIT_HEADER_WRITE__HAL_I2C_10BIT_ADDRESSI2C_10BIT_ADDRESS__HAL_I2C_7BIT_ADD_READI2C_7BIT_ADD_READ__HAL_I2C_7BIT_ADD_WRITEI2C_7BIT_ADD_WRITE__HAL_I2C_SPEED__HAL_I2C_SPEED_FASTI2C_SPEED_FAST__HAL_I2C_SPEED_STANDARDI2C_SPEED_STANDARD__HAL_I2C_RISE_TIMEI2C_RISE_TIME__HAL_I2C_FREQ_RANGEI2C_FREQ_RANGE__HAL_I2C_GENERATE_STARTI2C_GENERATE_START__HAL_I2C_RESET_CR2I2C_RESET_CR2IS_OB_WDG_SOURCEIS_OB_IWDG_SOURCEIS_NBSECTORSIS_FLASH_NBSECTORSIS_TYPEERASEIS_FLASH_TYPEERASEIS_TYPEPROGRAMFLASHIS_FLASH_TYPEPROGRAMIS_TYPEPROGRAMIS_WRPAREAIS_OB_WRPAREAIS_DAC_WAVE(WAVE)(((WAVE) == DAC_WAVE_NONE) || ((WAVE) == DAC_WAVE_NOISE)|| ((WAVE) == DAC_WAVE_TRIANGLE))__HAL_COMP_GET_EXTI_LINECOMP_GET_EXTI_LINE__HAL_COMP_EXTI_CLEAR_FLAG(__FLAG__)(((__FLAG__) == COMP_EXTI_LINE_COMP1) ? __HAL_COMP_COMP1_EXTI_CLEAR_FLAG() : __HAL_COMP_COMP2_EXTI_CLEAR_FLAG())__HAL_COMP_EXTI_GET_FLAG(__FLAG__)(((__FLAG__) == COMP_EXTI_LINE_COMP1) ? __HAL_COMP_COMP1_EXTI_GET_FLAG() : __HAL_COMP_COMP2_EXTI_GET_FLAG())__HAL_COMP_EXTI_DISABLE_IT(__EXTILINE__)(((__EXTILINE__) == COMP_EXTI_LINE_COMP1) ? __HAL_COMP_COMP1_EXTI_DISABLE_IT() : __HAL_COMP_COMP2_EXTI_DISABLE_IT())__HAL_COMP_EXTI_ENABLE_IT(__EXTILINE__)(((__EXTILINE__) == COMP_EXTI_LINE_COMP1) ? __HAL_COMP_COMP1_EXTI_ENABLE_IT() : __HAL_COMP_COMP2_EXTI_ENABLE_IT())__HAL_COMP_EXTI_FALLING_IT_DISABLE(__EXTILINE__)(((__EXTILINE__) == COMP_EXTI_LINE_COMP1) ? __HAL_COMP_COMP1_EXTI_DISABLE_FALLING_EDGE() : __HAL_COMP_COMP2_EXTI_DISABLE_FALLING_EDGE())__HAL_COMP_EXTI_FALLING_IT_ENABLE(__EXTILINE__)(((__EXTILINE__) == COMP_EXTI_LINE_COMP1) ? __HAL_COMP_COMP1_EXTI_ENABLE_FALLING_EDGE() : __HAL_COMP_COMP2_EXTI_ENABLE_FALLING_EDGE())__HAL_COMP_EXTI_RISING_IT_DISABLE(__EXTILINE__)(((__EXTILINE__) == COMP_EXTI_LINE_COMP1) ? __HAL_COMP_COMP1_EXTI_DISABLE_RISING_EDGE() : __HAL_COMP_COMP2_EXTI_DISABLE_RISING_EDGE())__HAL_COMP_EXTI_RISING_IT_ENABLE(__EXTILINE__)(((__EXTILINE__) == COMP_EXTI_LINE_COMP1) ? __HAL_COMP_COMP1_EXTI_ENABLE_RISING_EDGE() : __HAL_COMP_COMP2_EXTI_ENABLE_RISING_EDGE())__HAL_UNFREEZE_LPTIM2_DBGMCU__HAL_DBGMCU_UNFREEZE_LPTIM2__HAL_FREEZE_LPTIM2_DBGMCU__HAL_DBGMCU_FREEZE_LPTIM2__HAL_UNFREEZE_LPTIM1_DBGMCU__HAL_DBGMCU_UNFREEZE_LPTIM1__HAL_FREEZE_LPTIM1_DBGMCU__HAL_DBGMCU_FREEZE_LPTIM1__HAL_UNFREEZE_CAN1_DBGMCU__HAL_DBGMCU_UNFREEZE_CAN1__HAL_FREEZE_CAN1_DBGMCU__HAL_DBGMCU_FREEZE_CAN1__HAL_UNFREEZE_I2C3_TIMEOUT_DBGMCU__HAL_DBGMCU_UNFREEZE_I2C3_TIMEOUT__HAL_FREEZE_I2C3_TIMEOUT_DBGMCU__HAL_DBGMCU_FREEZE_I2C3_TIMEOUT__HAL_UNFREEZE_I2C2_TIMEOUT_DBGMCU__HAL_DBGMCU_UNFREEZE_I2C2_TIMEOUT__HAL_FREEZE_I2C2_TIMEOUT_DBGMCU__HAL_DBGMCU_FREEZE_I2C2_TIMEOUT__HAL_UNFREEZE_I2C1_TIMEOUT_DBGMCU__HAL_DBGMCU_UNFREEZE_I2C1_TIMEOUT__HAL_FREEZE_I2C1_TIMEOUT_DBGMCU__HAL_DBGMCU_FREEZE_I2C1_TIMEOUT__HAL_UNFREEZE_IWDG_DBGMCU__HAL_DBGMCU_UNFREEZE_IWDG__HAL_FREEZE_IWDG_DBGMCU__HAL_DBGMCU_FREEZE_IWDG__HAL_UNFREEZE_WWDG_DBGMCU__HAL_DBGMCU_UNFREEZE_WWDG__HAL_FREEZE_WWDG_DBGMCU__HAL_DBGMCU_FREEZE_WWDG__HAL_UNFREEZE_RTC_DBGMCU__HAL_DBGMCU_UNFREEZE_RTC__HAL_FREEZE_RTC_DBGMCU__HAL_DBGMCU_FREEZE_RTC__HAL_UNFREEZE_TIM17_DBGMCU__HAL_DBGMCU_UNFREEZE_TIM17__HAL_FREEZE_TIM17_DBGMCU__HAL_DBGMCU_FREEZE_TIM17__HAL_UNFREEZE_TIM16_DBGMCU__HAL_DBGMCU_UNFREEZE_TIM16__HAL_FREEZE_TIM16_DBGMCU__HAL_DBGMCU_FREEZE_TIM16__HAL_UNFREEZE_TIM15_DBGMCU__HAL_DBGMCU_UNFREEZE_TIM15__HAL_FREEZE_TIM15_DBGMCU__HAL_DBGMCU_FREEZE_TIM15__HAL_UNFREEZE_CAN2_DBGMCU__HAL_DBGMCU_UNFREEZE_CAN2__HAL_FREEZE_CAN2_DBGMCU__HAL_DBGMCU_FREEZE_CAN2__HAL_UNFREEZE_TIM14_DBGMCU__HAL_DBGMCU_UNFREEZE_TIM14__HAL_FREEZE_TIM14_DBGMCU__HAL_DBGMCU_FREEZE_TIM14__HAL_UNFREEZE_TIM13_DBGMCU__HAL_DBGMCU_UNFREEZE_TIM13__HAL_FREEZE_TIM13_DBGMCU__HAL_DBGMCU_FREEZE_TIM13__HAL_UNFREEZE_TIM12_DBGMCU__HAL_DBGMCU_UNFREEZE_TIM12__HAL_FREEZE_TIM12_DBGMCU__HAL_DBGMCU_FREEZE_TIM12__HAL_UNFREEZE_TIM11_DBGMCU__HAL_DBGMCU_UNFREEZE_TIM11__HAL_FREEZE_TIM11_DBGMCU__HAL_DBGMCU_FREEZE_TIM11__HAL_UNFREEZE_TIM10_DBGMCU__HAL_DBGMCU_UNFREEZE_TIM10__HAL_FREEZE_TIM10_DBGMCU__HAL_DBGMCU_FREEZE_TIM10__HAL_UNFREEZE_TIM9_DBGMCU__HAL_DBGMCU_UNFREEZE_TIM9__HAL_FREEZE_TIM9_DBGMCU__HAL_DBGMCU_FREEZE_TIM9__HAL_UNFREEZE_TIM8_DBGMCU__HAL_DBGMCU_UNFREEZE_TIM8__HAL_FREEZE_TIM8_DBGMCU__HAL_DBGMCU_FREEZE_TIM8__HAL_UNFREEZE_TIM7_DBGMCU__HAL_DBGMCU_UNFREEZE_TIM7__HAL_FREEZE_TIM7_DBGMCU__HAL_DBGMCU_FREEZE_TIM7__HAL_UNFREEZE_TIM6_DBGMCU__HAL_DBGMCU_UNFREEZE_TIM6__HAL_FREEZE_TIM6_DBGMCU__HAL_DBGMCU_FREEZE_TIM6__HAL_UNFREEZE_TIM5_DBGMCU__HAL_DBGMCU_UNFREEZE_TIM5__HAL_FREEZE_TIM5_DBGMCU__HAL_DBGMCU_FREEZE_TIM5__HAL_UNFREEZE_TIM4_DBGMCU__HAL_DBGMCU_UNFREEZE_TIM4__HAL_FREEZE_TIM4_DBGMCU__HAL_DBGMCU_FREEZE_TIM4__HAL_UNFREEZE_TIM3_DBGMCU__HAL_DBGMCU_UNFREEZE_TIM3__HAL_FREEZE_TIM3_DBGMCU__HAL_DBGMCU_FREEZE_TIM3__HAL_UNFREEZE_TIM2_DBGMCU__HAL_DBGMCU_UNFREEZE_TIM2__HAL_FREEZE_TIM2_DBGMCU__HAL_DBGMCU_FREEZE_TIM2__HAL_UNFREEZE_TIM1_DBGMCU__HAL_DBGMCU_UNFREEZE_TIM1__HAL_FREEZE_TIM1_DBGMCU__HAL_DBGMCU_FREEZE_TIM1IS_DAC_GENERATE_WAVEIS_DAC_WAVE__HAL_DHR12RD_ALIGNEMENTDAC_DHR12RD_ALIGNMENT__HAL_DHR12R2_ALIGNEMENTDAC_DHR12R2_ALIGNMENT__HAL_DHR12R1_ALIGNEMENTDAC_DHR12R1_ALIGNMENT__HAL_ADC_CFGR1_DMACONTREQADC_CFGR1_DMACONTREQ__HAL_ADC_CFGR1_SCANDIRADC_CFGR1_SCANDIR__HAL_ADC_CFGR1_OVERRUNADC_CFGR1_OVERRUN__HAL_ADC_CFGR1_CONTINUOUSADC_CFGR1_CONTINUOUS__HAL_ADC_CFGR1_AUTOWAITADC_CFGR1_AUTOWAIT__HAL_ADC_CFGR1_AUTOOFFADC_CFGR1_AUTOOFF__HAL_ADC_CFGR1_REG_DISCCONTINUOUSADC_CFGR1_REG_DISCCONTINUOUS__HAL_ADC_CHSELR_CHANNELADC_CHSELR_CHANNEL__HAL_ADC_JSQRADC_JSQR__HAL_ADC_CR2_DMAContReqADC_CR2_DMAContReq__HAL_ADC_CR2_EOCSelectionADC_CR2_EOCSelection__HAL_ADC_CR1_SCANCONVADC_CR1_SCANCONV__HAL_ADC_CR1_DISCONTINUOUSADC_CR1_DISCONTINUOUS__HAL_ADC_CR2_CONTINUOUSADC_CR2_CONTINUOUS__HAL_ADC_SQR1_RKADC_SQR1_RK__HAL_ADC_SQR2_RKADC_SQR2_RK__HAL_ADC_SQR3_RKADC_SQR3_RK__HAL_ADC_SMPR2ADC_SMPR2__HAL_ADC_SMPR1ADC_SMPR1__HAL_ADC_SQR1ADC_SQR1__HAL_ADC_GET_CLOCK_PRESCALERADC_GET_CLOCK_PRESCALER__HAL_ADC_CLOCK_PRESCALER_RANGEADC_CLOCK_PRESCALER_RANGE__HAL_ADC_CONVCYCLES_MAX_RANGEADC_CONVCYCLES_MAX_RANGE__HAL_ADC_CR1_SCANADC_CR1_SCAN_SET__HAL_ADC_CR1_DISCONTINUOUS_NUMADC_CR1_DISCONTINUOUS_NUM__HAL_ADC_JSQR_RK_JLADC_JSQR_RK_JL__HAL_ADC_JSQR_JLADC_JSQR_JL_SHIFT__HAL_ADC_SQR1_LADC_SQR1_L_SHIFT__HAL_ADC_MULTI_SLAVEADC_MULTI_SLAVE__HAL_ADC_COMMON_ADC_OTHERADC_COMMON_ADC_OTHER__HAL_ADC_NONMULTIMODE_OR_MULTIMODEMASTERADC_NONMULTIMODE_OR_MULTIMODEMASTER__ADC_MULTIMODE_IS_ENABLEDADC_MULTIMODE_IS_ENABLE__HAL_ADC_MULTIMODE_IS_ENABLED__HAL_ADC_COMMON_CCR_MULTIADC_COMMON_CCR_MULTI__HAL_ADC_COMMON_REGISTERADC_COMMON_REGISTER__HAL_ADC_AWD23THRESHOLD_SHIFT_RESOLUTIONADC_AWD23THRESHOLD_SHIFT_RESOLUTION__HAL_ADC_AWD1THRESHOLD_SHIFT_RESOLUTIONADC_AWD1THRESHOLD_SHIFT_RESOLUTION__HAL_ADC_OFFSET_SHIFT_RESOLUTIONADC_OFFSET_SHIFT_RESOLUTION__HAL_ADC_TRX_HIGHTHRESHOLDADC_TRX_HIGHTHRESHOLD__HAL_ADC_CALFACT_DIFF_GETADC_CALFACT_DIFF_GET__HAL_ADC_CALFACT_DIFF_SETADC_CALFACT_DIFF_SET__HAL_ADC_DIFSEL_CHANNELADC_DIFSEL_CHANNEL__HAL_ADC_OFR_CHANNELADC_OFR_CHANNEL__HAL_ADC_JSQR_JEXTSELADC_JSQR_JEXTSEL_SET__HAL_ADC_CFGR_EXTSELADC_CFGR_EXTSEL_SET__HAL_ADC_CFGR_DMACONTREQADC_CFGR_DMACONTREQ__HAL_ADC_CFGR_OVERRUNADC_CFGR_OVERRUN__HAL_ADC_CFGR_CONTINUOUSADC_CFGR_CONTINUOUS__HAL_ADC_CFGR_AUTOWAITADC_CFGR_AUTOWAIT__HAL_ADC_CFGR_DISCONTINUOUS_NUMADC_CFGR_DISCONTINUOUS_NUM__HAL_ADC_CFGR_REG_DISCCONTINUOUSADC_CFGR_REG_DISCCONTINUOUS__HAL_ADC_CFGR_INJECT_DISCCONTINUOUSADC_CFGR_INJECT_DISCCONTINUOUS__HAL_ADC_CFGR_INJECT_CONTEXT_QUEUEADC_CFGR_INJECT_CONTEXT_QUEUE__HAL_ADC_CFGR_INJECT_AUTO_CONVERSIONADC_CFGR_INJECT_AUTO_CONVERSION__HAL_ADC_CFGR_AWD23CRADC_CFGR_AWD23CR__HAL_ADC_CFGR_AWD1CHADC_CFGR_AWD1CH_SHIFT__HAL_ADC_JSQR_RKADC_JSQR_RK__HAL_ADC_GET_RESOLUTIONADC_GET_RESOLUTION__HAL_ADC_CLEAR_ERRORCODEADC_CLEAR_ERRORCODE__HAL_ADC_IS_CONVERSION_ONGOINGADC_IS_CONVERSION_ONGOING__HAL_ADC_IS_CONVERSION_ONGOING_INJECTEDADC_IS_CONVERSION_ONGOING_INJECTED__HAL_ADC_IS_CONVERSION_ONGOING_REGULARADC_IS_CONVERSION_ONGOING_REGULAR__HAL_ADC_IS_CONVERSION_ONGOING_REGULAR_INJECTEDADC_IS_CONVERSION_ONGOING_REGULAR_INJECTED__HAL_ADC_IS_SOFTWARE_START_INJECTEDADC_IS_SOFTWARE_START_INJECTED__HAL_ADC_IS_SOFTWARE_START_REGULARADC_IS_SOFTWARE_START_REGULAR__ADC_IS_ENABLEDADC_IS_ENABLE__HAL_ADC_IS_ENABLED__HAL_ADC_DISABLING_CONDITIONSADC_DISABLING_CONDITIONS__HAL_ADC_ENABLING_CONDITIONSADC_ENABLING_CONDITIONS__ADC_DISABLE__HAL_ADC_DISABLE__ADC_ENABLE__HAL_ADC_ENABLECMP_PD_BitNumberCMP_PD_BIT_NUMBERUFB_MODE_BitNumberUFB_MODE_BIT_NUMBERIS_SYSCFG_FASTMODEPLUS_CONFIGIS_I2C_FASTMODEPLUSSYSCFG_FLAG_RC48RCC_FLAG_HSI48SYSCFG_FLAG_VREF_READYSYSCFG_FLAG_VREFINT_READY__HAL_SYSCFG_SRAM2_WRP_ENABLE__HAL_SYSCFG_SRAM2_WRP_0_31_ENABLE__HAL_VREFINT_OUT_DISABLE__HAL_SYSCFG_VREFINT_OUT_DISABLE__HAL_VREFINT_OUT_ENABLE__HAL_SYSCFG_VREFINT_OUT_ENABLE__HAL_CLEAR_FLAG__HAL_SYSCFG_CLEAR_FLAG__HAL_GET_FLAG__HAL_SYSCFG_GET_FLAG__HAL_FMC_BANK__HAL_SYSCFG_FMC_BANK__HAL_REMAPMEMORY_QUADSPI__HAL_SYSCFG_REMAPMEMORY_QUADSPI__HAL_REMAPMEMORY_FSMC__HAL_SYSCFG_REMAPMEMORY_FSMC__HAL_REMAPMEMORY_FMC_SDRAM__HAL_SYSCFG_REMAPMEMORY_FMC_SDRAM__HAL_REMAPMEMORY_FMC__HAL_SYSCFG_REMAPMEMORY_FMC__HAL_REMAPMEMORY_SRAM__HAL_SYSCFG_REMAPMEMORY_SRAM__HAL_REMAPMEMORY_SYSTEMFLASH__HAL_SYSCFG_REMAPMEMORY_SYSTEMFLASH__HAL_REMAPMEMORY_FLASH__HAL_SYSCFG_REMAPMEMORY_FLASH__HAL_GET_BOOT_MODE__HAL_SYSCFG_GET_BOOT_MODEAES_FLAG_CCFCRYP_FLAG_CCFAES_IT_ERRCRYP_IT_ERRAES_IT_CCCRYP_IT_CCHAL_LTDC_StructInitFromAdaptedCommandConfigHAL_LTDCEx_StructInitFromAdaptedCommandConfigHAL_LTDC_StructInitFromVideoConfigHAL_LTDCEx_StructInitFromVideoConfigHAL_LTDC_RelaodHAL_LTDC_ReloadHAL_LTDC_LineEvenCallbackHAL_LTDC_LineEventCallbackHAL_UART_WakeupCallbackHAL_UARTEx_WakeupCallbackHAL_TIMEx_ConfigCommutationEvent_DMAHAL_TIMEx_ConfigCommutEvent_DMAHAL_TIMEx_ConfigCommutationEvent_ITHAL_TIMEx_ConfigCommutEvent_ITHAL_TIMEx_ConfigCommutationEventHAL_TIMEx_ConfigCommutEventHAL_TIMEx_CommutationCallbackHAL_TIMEx_CommutCallbackHAL_TIM_SlaveConfigSynchronization_ITHAL_TIM_SlaveConfigSynchro_ITHAL_TIM_SlaveConfigSynchronizationHAL_TIM_SlaveConfigSynchroHAL_TIMEx_DMACommutationCpltTIMEx_DMACommutationCpltHAL_TIM_DMACaptureCpltTIM_DMACaptureCpltHAL_TIM_DMAErrorTIM_DMAErrorHAL_TIM_DMADelayPulseCpltTIM_DMADelayPulseCpltHAL_SPI_FlushRxFifoHAL_SPIEx_FlushRxFifoHAL_SMBUS_SlaveListenCpltCallbackHAL_SMBUS_ListenCpltCallbackHAL_SMBUS_SlaveAddrCallbackHAL_SMBUS_AddrCallbackHAL_SMBUS_Slave_Listen_ITHAL_SMBUS_EnableListen_ITPWR_MODE_EVTPWR_PVD_MODE_NORMALBRE_BitNumberBRE_BIT_NUMBERLPLVDS_BitNumberLPLVDS_BIT_NUMBERMRLVDS_BitNumberMRLVDS_BIT_NUMBERODSWEN_BitNumberODSWEN_BIT_NUMBERODEN_BitNumberODEN_BIT_NUMBERFPDS_BitNumberFPDS_BIT_NUMBEREWUP_BitNumberEWUP_BIT_NUMBERPMODE_BitNumberPMODE_BIT_NUMBERPVDE_BitNumberPVDE_BIT_NUMBERDBP_BitNumberDBP_BIT_NUMBERCR_PMODE_BBCR_VOS_BBVOS_BIT_NUMBERCSR_OFFSET_BBPWR_CSR_OFFSET_BBCR_OFFSET_BBPWR_CR_OFFSET_BBPWR_MODE_EVENT_RISING_FALLINGPWR_PVD_MODE_EVENT_RISING_FALLINGPWR_MODE_EVENT_FALLINGPWR_PVD_MODE_EVENT_FALLINGPWR_MODE_EVENT_RISINGPWR_PVD_MODE_EVENT_RISINGPWR_MODE_IT_RISING_FALLINGPWR_PVD_MODE_IT_RISING_FALLINGPWR_MODE_IT_FALLINGPWR_PVD_MODE_IT_FALLINGPWR_MODE_IT_RISINGPWR_PVD_MODE_IT_RISINGPWR_MODE_NORMALHAL_PWREx_PVMConfigHAL_PWREx_ConfigPVMHAL_PWREx_EnableSDADCAnalogHAL_PWREx_EnableSDADCHAL_PWREx_DisableSDADCAnalogHAL_PWREx_DisableSDADCHAL_PWREx_DeactivateOverDriveHAL_PWREx_DisableOverDriveHAL_PWREx_ActivateOverDriveHAL_PWREx_EnableOverDriveHAL_PWR_Vddio2MonitorCallbackHAL_PWREx_Vddio2MonitorCallbackHAL_PWR_Vddio2Monitor_IRQHandlerHAL_PWREx_Vddio2Monitor_IRQHandlerHAL_PWR_PVDLevelConfigHAL_PWR_ConfigPVDHAL_PWR_PVD_PVM_IRQHandlerHAL_PWREx_PVD_PVM_IRQHandlerHAL_PWR_EnableVddio2MonitorHAL_PWREx_EnableVddio2MonitorHAL_PWR_EnableFlashPowerDownHAL_PWREx_EnableFlashPowerDownHAL_PWR_EnableBkUpRegHAL_PWREx_EnableBkUpRegHAL_PWR_DisableVddio2MonitorHAL_PWREx_DisableVddio2MonitorHAL_PWR_DisableFlashPowerDownHAL_PWREx_DisableFlashPowerDownHAL_PWR_DisableBkUpRegHAL_PWREx_DisableBkUpRegHAL_PWR_PVDConfigHAL_I2C_Slave_Sequential_Receive_DMAHAL_I2C_Slave_Seq_Receive_DMAHAL_I2C_Slave_Sequential_Transmit_DMAHAL_I2C_Slave_Seq_Transmit_DMAHAL_I2C_Master_Sequential_Receive_DMAHAL_I2C_Master_Seq_Receive_DMAHAL_I2C_Master_Sequential_Transmit_DMAHAL_I2C_Master_Seq_Transmit_DMAHAL_I2C_Slave_Sequential_Receive_ITHAL_I2C_Slave_Seq_Receive_ITHAL_I2C_Slave_Sequential_Transmit_ITHAL_I2C_Slave_Seq_Transmit_ITHAL_I2C_Master_Sequential_Receive_ITHAL_I2C_Master_Seq_Receive_ITHAL_I2C_Master_Sequential_Transmit_ITHAL_I2C_Master_Seq_Transmit_ITHAL_I2CFastModePlusConfig(SYSCFG_I2CFastModePlus,cmd)((cmd == ENABLE)? HAL_I2CEx_EnableFastModePlus(SYSCFG_I2CFastModePlus): HAL_I2CEx_DisableFastModePlus(SYSCFG_I2CFastModePlus))HAL_FMPI2CEx_DigitalFilter_ConfigHAL_FMPI2CEx_ConfigDigitalFilterHAL_FMPI2CEx_AnalogFilter_ConfigHAL_FMPI2CEx_ConfigAnalogFilterHAL_I2CEx_DigitalFilter_ConfigHAL_I2CEx_ConfigDigitalFilterHAL_I2CEx_AnalogFilter_ConfigHAL_I2CEx_ConfigAnalogFilterHAL_DATA_EEPROMEx_ProgramHAL_FLASHEx_DATAEEPROM_ProgramHAL_DATA_EEPROMEx_EraseHAL_FLASHEx_DATAEEPROM_EraseHAL_DATA_EEPROMEx_LockHAL_FLASHEx_DATAEEPROM_LockHAL_DATA_EEPROMEx_UnlockHAL_FLASHEx_DATAEEPROM_UnlockFLASH_DisableRunPowerDownHAL_FLASHEx_DisableRunPowerDownFLASH_EnableRunPowerDownHAL_FLASHEx_EnableRunPowerDownFLASH_HalfPageProgramHAL_FLASHEx_HalfPageProgramHAL_ADC_EnableBufferSensor_Cmd(cmd)(((cmd )==ENABLE) ? HAL_ADCEx_EnableVREFINTTempSensor() : HAL_ADCEx_DisableVREFINTTempSensor())HAL_ADC_EnableBuffer_Cmd(cmd)(((cmd)==ENABLE) ? HAL_ADCEx_EnableVREFINT() : HAL_ADCEx_DisableVREFINT())HAL_VREFINT_Cmd(cmd)(((cmd)==ENABLE)? HAL_SYSCFG_EnableVREFINT() : HAL_SYSCFG_DisableVREFINT())HAL_Lock_Cmd(cmd)(((cmd)==ENABLE) ? HAL_SYSCFG_Enable_Lock_VREFINT() : HAL_SYSCFG_Disable_Lock_VREFINT())HAL_VREFINT_OutputSelectHAL_SYSCFG_VREFINT_OutputSelectHAL_DBG_LowPowerConfig(Periph,cmd)(((cmd )==ENABLE)? HAL_DBGMCU_DBG_EnableLowPowerConfig(Periph) : HAL_DBGMCU_DBG_DisableLowPowerConfig(Periph))HAL_DisableDBGStandbyModeHAL_DBGMCU_DisableDBGStandbyModeHAL_EnableDBGStandbyModeHAL_DBGMCU_EnableDBGStandbyModeHAL_DisableDBGStopModeHAL_DBGMCU_DisableDBGStopModeHAL_EnableDBGStopModeHAL_DBGMCU_EnableDBGStopModeHAL_DisableDBGSleepModeHAL_DBGMCU_DisableDBGSleepModeHAL_EnableDBGSleepModeHAL_DBGMCU_EnableDBGSleepModeHAL_HASHEx_SHA256_Accumulate_End_ITHAL_HASHEx_SHA256_Accmlt_End_ITHAL_HASHEx_SHA256_Accumulate_ITHAL_HASHEx_SHA256_Accmlt_ITHAL_HASHEx_SHA256_Accumulate_EndHAL_HASHEx_SHA256_Accmlt_EndHAL_HASHEx_SHA256_AccumulateHAL_HASHEx_SHA256_AccmltHAL_HASHEx_SHA224_Accumulate_End_ITHAL_HASHEx_SHA224_Accmlt_End_ITHAL_HASHEx_SHA224_Accumulate_ITHAL_HASHEx_SHA224_Accmlt_ITHAL_HASHEx_SHA224_Accumulate_EndHAL_HASHEx_SHA224_Accmlt_EndHAL_HASHEx_SHA224_AccumulateHAL_HASHEx_SHA224_AccmltHAL_HASH_SHA1_Accumulate_End_ITHAL_HASH_SHA1_Accmlt_End_ITHAL_HASH_SHA1_Accumulate_ITHAL_HASH_SHA1_Accmlt_ITHAL_HASH_SHA1_Accumulate_EndHAL_HASH_SHA1_Accmlt_EndHAL_HASH_SHA1_AccumulateHAL_HASH_SHA1_AccmltHAL_HASH_MD5_Accumulate_End_ITHAL_HASH_MD5_Accmlt_End_ITHAL_HASH_MD5_Accumulate_ITHAL_HASH_MD5_Accmlt_ITHAL_HASH_MD5_Accumulate_EndHAL_HASH_MD5_Accmlt_EndHAL_HASH_MD5_AccumulateHAL_HASH_MD5_AccmltHASH_HMACKeyType_LongKeyHASH_HMAC_KEYTYPE_LONGKEYHASH_HMACKeyType_ShortKeyHASH_HMAC_KEYTYPE_SHORTKEYHASH_AlgoMode_HMACHASH_ALGOMODE_HMACHASH_AlgoMode_HASHHASH_ALGOMODE_HASHHASH_AlgoSelection_MD5HASH_ALGOSELECTION_MD5HASH_AlgoSelection_SHA256HASH_ALGOSELECTION_SHA256HASH_AlgoSelection_SHA224HASH_ALGOSELECTION_SHA224HASH_AlgoSelection_SHA1HASH_ALGOSELECTION_SHA1HAL_HMAC_SHA256_FinishHAL_HASH_SHA256_FinishHAL_HMAC_SHA224_FinishHAL_HASH_SHA224_FinishHAL_HMAC_SHA1_FinishHAL_HASH_SHA1_FinishHAL_HMAC_MD5_FinishHAL_HASH_MD5_FinishHAL_HASHPhaseTypeDefHAL_HASH_PhaseTypeDefHAL_HASH_STATETypeDefHAL_HASH_StateTypeDefHAL_HASHEx_IRQHandlerHAL_HASH_IRQHandlerHAL_CRYP_ComputationCpltCallbackHAL_CRYPEx_ComputationCpltCallbackHAL_DMA2D_DisableCLUTHAL_DMA2D_CLUTLoading_AbortCM_A4DMA2D_INPUT_A4CM_A8DMA2D_INPUT_A8CM_L4DMA2D_INPUT_L4CM_AL88DMA2D_INPUT_AL88CM_AL44DMA2D_INPUT_AL44CM_L8DMA2D_INPUT_L8CM_ARGB4444DMA2D_INPUT_ARGB4444CM_ARGB1555DMA2D_INPUT_ARGB1555CM_RGB565CM_RGB888CM_ARGB8888DMA2D_ARGB4444DMA2D_OUTPUT_ARGB4444DMA2D_ARGB1555DMA2D_OUTPUT_ARGB1555DMA2D_RGB565DMA2D_OUTPUT_RGB565DMA2D_RGB888DMA2D_OUTPUT_RGB888DMA2D_ARGB8888HAL_DCMI_DisableCROPHAL_DCMI_DisableCropHAL_DCMI_EnableCROPHAL_DCMI_EnableCropHAL_DCMI_ConfigCROPHAL_DCMI_ConfigCropDCMI_FLAG_OVFMIDCMI_FLAG_OVRMIDCMI_FLAG_OVFRIDCMI_FLAG_OVRRIDCMI_IT_OVFDCMI_IT_OVRHAL_DCMI_ERROR_OVFHAL_DCMI_ERROR_OVRETH_TxPacketConfigETH_TxPacketConfigTypeDefETH_MAC_MII_RECEIVE_PROTOCOL_ACTIVEETH_MAC_SMALL_FIFO_RW_ACTIVEETH_MAC_SMALL_FIFO_WRITE_ACTIVEETH_MAC_SMALL_FIFO_READ_ACTIVEETH_MAC_SMALL_FIFO_NOTACTIVEETH_MAC_RXFIFO_WRITE_ACTIVEETH_MAC_READCONTROLLER_FLUSHINGETH_MAC_READCONTROLLER_READING_STATUSETH_MAC_READCONTROLLER_READING_DATAETH_MAC_READCONTROLLER_IDLEETH_MAC_RXFIFO_FULL0x00000300UETH_MAC_RXFIFO_ABOVE_THRESHOLDETH_MAC_RXFIFO_BELOW_THRESHOLDETH_MAC_RXFIFO_EMPTYETH_MAC_MII_TRANSMIT_ACTIVEETH_MAC_TRANSMITFRAMECONTROLLER_TRANSFERRINGETH_MAC_TRANSMITFRAMECONTROLLER_GENRATING_PCFETH_MAC_TRANSMITFRAMECONTROLLER_WAITINGETH_MAC_TRANSMITFRAMECONTROLLER_IDLEETH_MAC_TRANSMISSION_PAUSEETH_MAC_TXFIFO_WRITING0x00300000UETH_MAC_TXFIFO_WAITINGETH_MAC_TXFIFO_READETH_MAC_TXFIFO_IDLEETH_MAC_TXFIFO_WRITE_ACTIVEETH_MAC_TXFIFONOT_EMPTYETH_MAC_TXFIFO_FULLETH_MMCRGUFCR0x000001C4UETH_MMCRFAECR0x00000198UETH_MMCRFCECR0x00000194UETH_MMCTGFCR0x00000168UETH_MMCTGFMSCCR0x00000150UETH_MMCTGFSCCR0x0000014CUETH_MMCTIMR0x00000110UETH_MMCRIMR0x0000010CUETH_MMCTIR0x00000108UETH_MMCRIR0x00000104UETH_MMCCRDMAOMR_CLEAR_MASKETH_DMAOMR_CLEAR_MASKMACFCR_CLEAR_MASKETH_MACFCR_CLEAR_MASKMACCR_CLEAR_MASKETH_MACCR_CLEAR_MASKMACMIIAR_CR_MASKETH_MACMIIAR_CR_MASKJUMBO_FRAME_PAYLOADETH_JUMBO_FRAME_PAYLOADMAX_ETH_PAYLOADETH_MAX_ETH_PAYLOADMIN_ETH_PAYLOADETH_MIN_ETH_PAYLOADVLAN_TAGETH_VLAN_TAGCAN_TXSTATUS_PENDING((uint8_t)0x02U)CAN_TXSTATUS_OKCAN_TXSTATUS_FAILED((uint8_t)0x00U)SLAK_TIMEOUTCAN_TIMEOUT_VALUEINAK_TIMEOUTCAN_IT_RQCP2CAN_IT_TMECAN_IT_RQCP1CAN_IT_RQCP0CAN_FilterFIFO1CAN_FILTER_FIFO1CAN_FilterFIFO0CAN_FILTER_FIFO0CFR_BASEWWDG_CFR_BASEUSARTNACK_DISABLEDUSART_NACK_DISABLEUSARTNACK_ENABLEDUSART_NACK_ENABLEUSART_CLOCK_ENABLEDUSART_CLOCK_ENABLEUSART_CLOCK_DISABLEDUSART_CLOCK_DISABLEUART_WAKEUPMETHODE_ADDRESSMARKUART_WAKEUPMETHOD_ADDRESSMARKUART_WAKEUPMETHODE_IDLELINEUART_WAKEUPMETHOD_IDLELINE__DIV_LPUARTUART_DIV_LPUART__UART_BRR_SAMPLING8UART_BRR_SAMPLING8__DIVFRAQ_SAMPLING8UART_DIVFRAQ_SAMPLING8__DIVMANT_SAMPLING8UART_DIVMANT_SAMPLING8__DIV_SAMPLING8UART_DIV_SAMPLING8__UART_BRR_SAMPLING16UART_BRR_SAMPLING16__DIVFRAQ_SAMPLING16UART_DIVFRAQ_SAMPLING16__DIVMANT_SAMPLING16UART_DIVMANT_SAMPLING16__DIV_SAMPLING16UART_DIV_SAMPLING16__HAL_UART_ONEBIT_DISABLE__HAL_UART_ONE_BIT_SAMPLE_DISABLE__HAL_UART_ONEBIT_ENABLE__HAL_UART_ONE_BIT_SAMPLE_ENABLEUART_ONE_BIT_SAMPLE_ENABLEDUART_ONE_BIT_SAMPLE_ENABLEUART_ONE_BIT_SAMPLE_DISABLEDUART_ONE_BIT_SAMPLE_DISABLEUART_ONEBIT_SAMPLING_ENABLEDUART_ONEBIT_SAMPLING_DISABLEDTSC_SYNC_POL_RISE_HIGHTSC_SYNC_POLARITY_RISINGTSC_SYNC_POL_FALLTSC_SYNC_POLARITY_FALLINGTIM_DMABurstLength_18TransfersTIM_DMABURSTLENGTH_18TRANSFERSTIM_DMABurstLength_17TransfersTIM_DMABURSTLENGTH_17TRANSFERSTIM_DMABurstLength_16TransfersTIM_DMABURSTLENGTH_16TRANSFERSTIM_DMABurstLength_15TransfersTIM_DMABURSTLENGTH_15TRANSFERSTIM_DMABurstLength_14TransfersTIM_DMABURSTLENGTH_14TRANSFERSTIM_DMABurstLength_13TransfersTIM_DMABURSTLENGTH_13TRANSFERSTIM_DMABurstLength_12TransfersTIM_DMABURSTLENGTH_12TRANSFERSTIM_DMABurstLength_11TransfersTIM_DMABURSTLENGTH_11TRANSFERSTIM_DMABurstLength_10TransfersTIM_DMABURSTLENGTH_10TRANSFERSTIM_DMABurstLength_9TransfersTIM_DMABURSTLENGTH_9TRANSFERSTIM_DMABurstLength_8TransfersTIM_DMABURSTLENGTH_8TRANSFERSTIM_DMABurstLength_7TransfersTIM_DMABURSTLENGTH_7TRANSFERSTIM_DMABurstLength_6TransfersTIM_DMABURSTLENGTH_6TRANSFERSTIM_DMABurstLength_5TransfersTIM_DMABURSTLENGTH_5TRANSFERSTIM_DMABurstLength_4TransfersTIM_DMABURSTLENGTH_4TRANSFERSTIM_DMABurstLength_3TransfersTIM_DMABURSTLENGTH_3TRANSFERSTIM_DMABurstLength_2TransfersTIM_DMABURSTLENGTH_2TRANSFERSTIM_DMABurstLength_1TransferTIM_DMABURSTLENGTH_1TRANSFERTIM_EventSource_Break2TIM_EVENTSOURCE_BREAK2TIM_EventSource_BreakTIM_EVENTSOURCE_BREAKTIM_EventSource_TriggerTIM_EVENTSOURCE_TRIGGERTIM_EventSource_COMTIM_EVENTSOURCE_COMTIM_EventSource_CC4TIM_EVENTSOURCE_CC4TIM_EventSource_CC3TIM_EVENTSOURCE_CC3TIM_EventSource_CC2TIM_EVENTSOURCE_CC2TIM_EventSource_CC1TIM_EVENTSOURCE_CC1TIM_EventSource_UpdateTIM_EVENTSOURCE_UPDATETIM_DMABase_ORTIM_DMABASE_ORTIM_DMABase_OR3TIM_DMABASE_OR3TIM_DMABase_OR2TIM_DMABASE_OR2TIM_DMABase_CCR6TIM_DMABASE_CCR6TIM_DMABase_CCR5TIM_DMABASE_CCR5TIM_DMABase_CCMR3TIM_DMABASE_CCMR3TIM_DMABase_OR1TIM_DMABASE_OR1TIM_DMABase_DMARTIM_DMABASE_DMARTIM_DMABase_DCRTIM_DMABASE_DCRTIM_DMABase_BDTRTIM_DMABASE_BDTRTIM_DMABase_CCR4TIM_DMABASE_CCR4TIM_DMABase_CCR3TIM_DMABASE_CCR3TIM_DMABase_CCR2TIM_DMABASE_CCR2TIM_DMABase_CCR1TIM_DMABASE_CCR1TIM_DMABase_RCRTIM_DMABASE_RCRTIM_DMABase_ARRTIM_DMABASE_ARRTIM_DMABase_PSCTIM_DMABASE_PSCTIM_DMABase_CNTTIM_DMABASE_CNTTIM_DMABase_CCERTIM_DMABASE_CCERTIM_DMABase_CCMR2TIM_DMABASE_CCMR2TIM_DMABase_CCMR1TIM_DMABASE_CCMR1TIM_DMABase_EGRTIM_DMABASE_EGRTIM_DMABase_SRTIM_DMABASE_SRTIM_DMABase_DIERTIM_DMABASE_DIERTIM_DMABase_SMCRTIM_DMABASE_SMCRTIM_DMABase_CR2TIM_DMABASE_CR2TIM_DMABase_CR1TIM_DMABASE_CR1CCER_CCxNE_MASKTIM_CCER_CCxNE_MASKCCER_CCxE_MASKTIM_CCER_CCxE_MASKSPI_NSS_PULSE_ENABLEDSPI_NSS_PULSE_ENABLESPI_NSS_PULSE_DISABLEDSPI_NSS_PULSE_DISABLESPI_CRCCALCULATION_ENABLEDSPI_CRCCALCULATION_ENABLESPI_CRCCALCULATION_DISABLEDSPI_CRCCALCULATION_DISABLESPI_TIMODE_ENABLEDSPI_TIMODE_ENABLESPI_TIMODE_DISABLEDSPI_TIMODE_DISABLEHAL_SMBUS_STATE_SLAVE_LISTENHAL_SMBUS_STATE_LISTENSMBUS_PEC_ENABLEDSMBUS_PEC_ENABLESMBUS_PEC_DISABLEDSMBUS_PEC_DISABLESMBUS_ANALOGFILTER_DISABLEDSMBUS_ANALOGFILTER_DISABLESMBUS_ANALOGFILTER_ENABLEDSMBUS_ANALOGFILTER_ENABLESMBUS_NOSTRETCH_ENABLEDSMBUS_NOSTRETCH_ENABLESMBUS_NOSTRETCH_DISABLEDSMBUS_NOSTRETCH_DISABLESMBUS_GENERALCALL_ENABLEDSMBUS_GENERALCALL_ENABLESMBUS_GENERALCALL_DISABLEDSMBUS_GENERALCALL_DISABLESMBUS_DUALADDRESS_ENABLEDSMBUS_DUALADDRESS_ENABLESMBUS_DUALADDRESS_DISABLEDSMBUS_DUALADDRESS_DISABLESMARTCARD_LASTBIT_ENABLEDSMARTCARD_LASTBIT_ENABLESMARTCARD_LASTBIT_DISABLEDSMARTCARD_LASTBIT_DISABLESMARTCARD_TIMEOUT_ENABLEDSMARTCARD_TIMEOUT_ENABLESMARTCARD_TIMEOUT_DISABLEDSMARTCARD_TIMEOUT_DISABLESMARTCARD_ONEBIT_SAMPLING_ENABLESMARTCARD_ONE_BIT_SAMPLE_ENABLESMARTCARD_ONEBIT_SAMPLING_DISABLESMARTCARD_ONE_BIT_SAMPLE_DISABLESMARTCARD_ONEBIT_SAMPLING_ENABLEDSMARTCARD_ONEBIT_SAMPLING_DISABLEDSMARTCARD_NACK_DISABLEDSMARTCARD_NACK_DISABLESMARTCARD_NACK_ENABLEDSMARTCARD_NACK_ENABLERTC_ALL_TAMPER_INTERRUPTRTC_IT_TAMPRTC_TAMPER3_INTERRUPTRTC_IT_TAMP3RTC_TAMPER2_INTERRUPTRTC_IT_TAMP2RTC_TAMPER1_INTERRUPTRTC_IT_TAMP1RTC_TAMPCR_TAMPXIERTC_TAMPER_IT_ENABLE_BITS_MASKRTC_TAMPCR_TAMPXERTC_TAMPER_ENABLE_BITS_MASKRTC_TAMPERPIN_PI8RTC_TAMPERPIN_POS1RTC_TAMPERPIN_PA0RTC_TAMPERPIN_PC13RTC_TAMPERPIN_DEFAULTRTC_OUTPUT_REMAP_PB2RTC_OUTPUT_REMAP_POS1RTC_OUTPUT_REMAP_PB14RTC_OUTPUT_REMAP_PC13RTC_OUTPUT_REMAP_NONERTC_TIMESTAMPPIN_PC1RTC_TIMESTAMPPIN_POS2RTC_TIMESTAMPPIN_PI8RTC_TIMESTAMPPIN_POS1RTC_TIMESTAMPPIN_PA0RTC_TIMESTAMPPIN_PC13RTC_TIMESTAMPPIN_DEFAULTRTC_TAMPER1_2_3_INTERRUPTRTC_TAMPER1_2_INTERRUPTRTC_TAMPERERASEBACKUP_ENABLEDRTC_TAMPER_ERASE_BACKUP_ENABLERTC_MASKTAMPERFLAG_ENABLEDRTC_TAMPERMASK_FLAG_ENABLERTC_MASKTAMPERFLAG_DISABLEDRTC_TAMPERMASK_FLAG_DISABLERTC_TAMPERMASK_FLAG_ENABLEDRTC_TAMPERMASK_FLAG_DISABLEDRTC_TAMPERERASEBACKUP_DISABLEDRTC_TAMPER_ERASE_BACKUP_DISABLERTC_ALARMSUBSECONDMASK_NoneRTC_ALARMSUBSECONDMASK_NONEFORMAT_BCDRTC_FORMAT_BCDFORMAT_BINRTC_FORMAT_BINPCCARD_TIMEOUTHAL_PCCARD_STATUS_TIMEOUTPCCARD_ERRORHAL_PCCARD_STATUS_ERRORPCCARD_ONGOINGHAL_PCCARD_STATUS_ONGOINGPCCARD_SUCCESSHAL_PCCARD_STATUS_SUCCESSPCCARD_StatusTypedefHAL_PCCARD_StatusTypeDefCF_IDENTIFY_CMDATA_IDENTIFY_CMDCF_ERASE_SECTOR_CMDATA_ERASE_SECTOR_CMDCF_WRITE_SECTOR_CMDATA_WRITE_SECTOR_CMDCF_READ_SECTOR_CMDATA_READ_SECTOR_CMDCF_COMMON_DATA_AREAATA_COMMON_DATA_AREACF_STATUS_CMD_ALTERNATEATA_STATUS_CMD_ALTERNATECF_STATUS_CMDATA_STATUS_CMDCF_CARD_HEADATA_CARD_HEADCF_CYLINDER_HIGHATA_CYLINDER_HIGHCF_CYLINDER_LOWATA_CYLINDER_LOWCF_SECTOR_NUMBERATA_SECTOR_NUMBERCF_SECTOR_COUNTATA_SECTOR_COUNTCF_DATAATA_DATAI2S_CLOCK_SYSCLKI2S_CLOCK_PLLI2S_STANDARD_PHILLIPSI2S_STANDARD_PHILIPSOPAMP_PGACONNECT_VM1OPAMP_PGA_CONNECT_INVERTINGINPUT_IO1OPAMP_PGACONNECT_VM0OPAMP_PGA_CONNECT_INVERTINGINPUT_IO0OPAMP_PGACONNECT_NOOPAMP_PGA_CONNECT_INVERTINGINPUT_NOOPAMP_INVERTINGINPUT_VINMOPAMP_SEC_INVERTINGINPUT_IO1OPAMP_SEC_INVERTINGINPUT_VM1OPAMP_SEC_INVERTINGINPUT_VM0OPAMP_SEC_INVERTINGINPUT_IO0IOPAMP_INVERTINGINPUT_VM1OPAMP_INVERTINGINPUT_IO1IOPAMP_INVERTINGINPUT_VM0OPAMP_INVERTINGINPUT_IO0OPAMP_INVERTINGINPUT_VM1OPAMP_INVERTINGINPUT_VM0OPAMP_SEC_NONINVERTINGINPUT_VP3OPAMP_SEC_NONINVERTINGINPUT_IO3OPAMP_SEC_NONINVERTINGINPUT_VP2OPAMP_SEC_NONINVERTINGINPUT_IO2OPAMP_SEC_NONINVERTINGINPUT_VP1OPAMP_SEC_NONINVERTINGINPUT_IO1OPAMP_SEC_NONINVERTINGINPUT_VP0OPAMP_SEC_NONINVERTINGINPUT_IO0OPAMP_NONINVERTINGINPUT_VP3OPAMP_NONINVERTINGINPUT_IO3OPAMP_NONINVERTINGINPUT_VP2OPAMP_NONINVERTINGINPUT_IO2OPAMP_NONINVERTINGINPUT_VP1OPAMP_NONINVERTINGINPUT_IO1OPAMP_NONINVERTINGINPUT_VP0OPAMP_NONINVERTINGINPUT_IO0__NOR_ADDR_SHIFTNOR_ADDR_SHIFT__NOR_WRITENOR_WRITENOR_TIMEOUTHAL_NOR_STATUS_TIMEOUTNOR_ERRORHAL_NOR_STATUS_ERRORNOR_ONGOINGHAL_NOR_STATUS_ONGOINGNOR_SUCCESSHAL_NOR_STATUS_SUCCESSNOR_StatusTypedefHAL_NOR_StatusTypeDef__ADDR_4th_CYCLEADDR_4TH_CYCLE__ADDR_3rd_CYCLEADDR_3RD_CYCLE__ADDR_2nd_CYCLEADDR_2ND_CYCLE__ADDR_1st_CYCLEADDR_1ST_CYCLE__ARRAY_ADDRESSARRAY_ADDRESSNAND_AddressTypedefNAND_AddressTypeDefHAL_NAND_Write_SpareAreaHAL_NAND_Write_SpareArea_8bHAL_NAND_Read_SpareAreaHAL_NAND_Read_SpareArea_8bHAL_NAND_Write_PageHAL_NAND_Write_Page_8bHAL_NAND_Read_PageHAL_NAND_Read_Page_8bHAL_LPTIM_ReadCompareHAL_LPTIM_ReadCapturedValueLPTIM_TRIGSAMPLETIME_8TRANSITIONLPTIM_TRIGSAMPLETIME_8TRANSITIONSLPTIM_TRIGSAMPLETIME_4TRANSITIONLPTIM_TRIGSAMPLETIME_4TRANSITIONSLPTIM_TRIGSAMPLETIME_2TRANSITIONLPTIM_TRIGSAMPLETIME_2TRANSITIONSLPTIM_TRIGSAMPLETIME_8TRANSISTIONSLPTIM_TRIGSAMPLETIME_4TRANSISTIONSLPTIM_TRIGSAMPLETIME_2TRANSISTIONSLPTIM_TRIGSAMPLETIME_DIRECTTRANSISTIONLPTIM_TRIGSAMPLETIME_DIRECTTRANSITIONLPTIM_CLOCKPOLARITY_BOTHEDGESLPTIM_CLOCKPOLARITY_RISING_FALLINGLPTIM_CLOCKPOLARITY_FALLINGEDGELPTIM_CLOCKPOLARITY_FALLINGLPTIM_CLOCKPOLARITY_RISINGEDGELPTIM_CLOCKPOLARITY_RISINGLPTIM_CLOCKSAMPLETIME_8TRANSISTIONSLPTIM_CLOCKSAMPLETIME_8TRANSITIONSLPTIM_CLOCKSAMPLETIME_4TRANSISTIONSLPTIM_CLOCKSAMPLETIME_4TRANSITIONSLPTIM_CLOCKSAMPLETIME_2TRANSISTIONSLPTIM_CLOCKSAMPLETIME_2TRANSITIONSLPTIM_CLOCKSAMPLETIME_DIRECTTRANSISTIONLPTIM_CLOCKSAMPLETIME_DIRECTTRANSITIONKR_KEY_DWAIWDG_KEY_WRITE_ACCESS_DISABLEKR_KEY_EWAIWDG_KEY_WRITE_ACCESS_ENABLEKR_KEY_ENABLEIWDG_KEY_ENABLEKR_KEY_RELOADIWDG_KEY_RELOADIRDA_ONE_BIT_SAMPLE_ENABLEDIRDA_ONE_BIT_SAMPLE_ENABLEIRDA_ONE_BIT_SAMPLE_DISABLEDIRDA_ONE_BIT_SAMPLE_DISABLEHAL_I2C_STATE_SLAVE_BUSY_RXHAL_I2C_STATE_BUSY_RXHAL_I2C_STATE_SLAVE_BUSY_TXHAL_I2C_STATE_BUSY_TXHAL_I2C_STATE_MASTER_BUSY_RXHAL_I2C_STATE_MASTER_BUSY_TXHAL_I2C_STATE_MEM_BUSY_RXHAL_I2C_STATE_MEM_BUSY_TXI2C_ANALOGFILTER_DISABLEDI2C_ANALOGFILTER_DISABLEI2C_ANALOGFILTER_ENABLEDI2C_ANALOGFILTER_ENABLEI2C_NOSTRETCH_ENABLEDI2C_NOSTRETCH_ENABLEI2C_NOSTRETCH_DISABLEDI2C_GENERALCALL_ENABLEDI2C_GENERALCALL_ENABLEI2C_GENERALCALL_DISABLEDI2C_DUALADDRESS_ENABLEDI2C_DUALADDRESS_ENABLEI2C_DUALADDRESS_DISABLED__HAL_HRTIM_GetCompare__HAL_HRTIM_GETCOMPARE__HAL_HRTIM_SetCompare__HAL_HRTIM_SETCOMPARE__HAL_HRTIM_GetClockPrescaler__HAL_HRTIM_GETCLOCKPRESCALER__HAL_HRTIM_SetClockPrescaler__HAL_HRTIM_SETCLOCKPRESCALER__HAL_HRTIM_GetPeriod__HAL_HRTIM_GETPERIOD__HAL_HRTIM_SetPeriod__HAL_HRTIM_SETPERIOD__HAL_HRTIM_GetCounter__HAL_HRTIM_GETCOUNTER__HAL_HRTIM_SetCounter__HAL_HRTIM_SETCOUNTERHRTIM_TIMDELAYEDPROTECTION_BALANCED_EEV79HRTIM_TIMER_A_B_C_DELAYEDPROTECTION_BALANCED_EEV7HRTIM_TIMDELAYEDPROTECTION_DELAYEDBOTH_EEV79HRTIM_TIMER_A_B_C_DELAYEDPROTECTION_DELAYEDBOTH_EEV7HRTIM_TIMDELAYEDPROTECTION_DELAYEDOUT2_DEEV79HRTIM_TIMER_A_B_C_DELAYEDPROTECTION_DELAYEDOUT2_DEEV7HRTIM_TIMDELAYEDPROTECTION_DELAYEDOUT1_DEEV79HRTIM_TIMER_A_B_C_DELAYEDPROTECTION_DELAYEDOUT1_DEEV7HRTIM_TIMDELAYEDPROTECTION_BALANCED_EEV68HRTIM_TIMER_A_B_C_DELAYEDPROTECTION_BALANCED_EEV6HRTIM_TIMDELAYEDPROTECTION_DELAYEDBOTH_EEV68HRTIM_TIMER_A_B_C_DELAYEDPROTECTION_DELAYEDBOTH_EEV6HRTIM_TIMDELAYEDPROTECTION_DELAYEDOUT2_EEV68HRTIM_TIMER_A_B_C_DELAYEDPROTECTION_DELAYEDOUT2_EEV6HRTIM_TIMDELAYEDPROTECTION_DELAYEDOUT1_EEV68HRTIM_TIMER_A_B_C_DELAYEDPROTECTION_DELAYEDOUT1_EEV6HRTIM_TIMDELAYEDPROTECTION_DISABLEDHRTIM_TIMER_A_B_C_DELAYEDPROTECTION_DISABLEDGPIO_AF6_DFSDMGPIO_AF6_DFSDM1GPIO_SPEED_HIGHGPIO_SPEED_FASTGPIO_SPEED_MEDIUMGPIO_SPEED_FREQ_MEDIUMGPIO_SPEED_LOWGPIO_AF2_LPTIMGPIO_AF2_LPTIM1GPIO_AF1_LPTIMGPIO_AF1_LPTIM1GPIO_AF0_LPTIMGPIO_AF0_LPTIM1GPIO_AF12_SDMMCGPIO_AF12_SDIOGET_GPIO_INDEXGPIO_GET_INDEXGET_GPIO_SOURCEFSMC_NORSRAM_EXTENDED_TYPEDEFFSMC_NORSRAM_EXTENDED_TypeDefFSMC_NORSRAM_TYPEDEFFSMC_NORSRAM_TypeDefFMC_NAND_PCC_MEM_BUS_WIDTH_16FMC_NAND_MEM_BUS_WIDTH_16FMC_NAND_PCC_MEM_BUS_WIDTH_8FMC_NAND_MEM_BUS_WIDTH_8FMC_NAND_PCC_WAIT_FEATURE_ENABLEFMC_NAND_WAIT_FEATURE_ENABLEFMC_NAND_PCC_WAIT_FEATURE_DISABLEFMC_NAND_WAIT_FEATURE_DISABLEHAL_SYSCFG_FASTMODEPLUS_I2C3I2C_FASTMODEPLUS_I2C3HAL_SYSCFG_FASTMODEPLUS_I2C2I2C_FASTMODEPLUS_I2C2HAL_SYSCFG_FASTMODEPLUS_I2C1I2C_FASTMODEPLUS_I2C1HAL_SYSCFG_FASTMODEPLUS_I2C_PB9I2C_FASTMODEPLUS_PB9HAL_SYSCFG_FASTMODEPLUS_I2C_PB8I2C_FASTMODEPLUS_PB8HAL_SYSCFG_FASTMODEPLUS_I2C_PB7I2C_FASTMODEPLUS_PB7HAL_SYSCFG_FASTMODEPLUS_I2C_PB6I2C_FASTMODEPLUS_PB6HAL_SYSCFG_FASTMODEPLUS_I2C_PA10I2C_FASTMODEPLUS_PA10HAL_SYSCFG_FASTMODEPLUS_I2C_PA9I2C_FASTMODEPLUS_PA9OB_BOOT_ENTRY_FORCED_FLASHOB_BOOT_LOCK_ENABLEOB_BOOT_ENTRY_FORCED_NONEOB_BOOT_LOCK_DISABLEOB_RDP_LEVEL2OB_RDP_LEVEL_2OB_RDP_LEVEL1OB_RDP_LEVEL_1OB_RDP_LEVEL0OB_RDP_LEVEL_0IS_OB_SDADC12_VDD_MONITORIS_OB_SDACD_VDD_MONITOROB_RAM_PARITY_CHECK_RESETOB_SRAM_PARITY_RESETOB_RAM_PARITY_CHECK_SETOB_SRAM_PARITY_SETOB_SDADC12_VDD_MONITOR_RESETOB_SDACD_VDD_MONITOR_RESETOB_SDADC12_VDD_MONITOR_SETOB_SDACD_VDD_MONITOR_SETOB_WDG_HWOB_IWDG_HWOB_WDG_SWOB_IWDG_SWFLASH_ERROR_ERSHAL_FLASH_ERROR_ERSFLASH_ERROR_OPERATIONHAL_FLASH_ERROR_OPERATIONFLASH_ERROR_NOTZEROHAL_FLASH_ERROR_NOTZEROFLASH_ERROR_FWWERRHAL_FLASH_ERROR_FWWERRFLASH_ERROR_FASTHAL_FLASH_ERROR_FASTFLASH_ERROR_MISHAL_FLASH_ERROR_MISFLASH_ERROR_PGSHAL_FLASH_ERROR_PGSFLASH_ERROR_SIZHAL_FLASH_ERROR_SIZEFLASH_ERROR_SIZEFLASH_ERROR_PGAHAL_FLASH_ERROR_PGAFLASH_ERROR_OPFLASH_ERROR_PROGHAL_FLASH_ERROR_PROGFLASH_ERROR_OPTVUSRHAL_FLASH_ERROR_OPTVUSRFLASH_ERROR_OPTVHAL_FLASH_ERROR_OPTVFLASH_ERROR_WRPHAL_FLASH_ERROR_WRPFLASH_ERROR_PGPFLASH_ERROR_PGFLASH_ERROR_RDHAL_FLASH_ERROR_RDFLASH_ERROR_NONEHAL_FLASH_ERROR_NONEIWDG_STOP_ACTIVEOB_IWDG_STOP_RUNIWDG_STOP_FREEZEOB_IWDG_STOP_FREEZEIWDG_STDBY_ACTIVEOB_IWDG_STDBY_RUNIWDG_STDBY_FREEZEOB_IWDG_STDBY_FREEZEWRPAREA_BANK2_AREABOB_WRPAREA_BANK2_AREABWRPAREA_BANK2_AREAAOB_WRPAREA_BANK2_AREAAWRPAREA_BANK1_AREABOB_WRPAREA_BANK1_AREABWRPAREA_BANK1_AREAAOB_WRPAREA_BANK1_AREAATYPEPROGRAM_FAST_AND_LASTFLASH_TYPEPROGRAM_FAST_AND_LASTTYPEPROGRAM_FASTFLASH_TYPEPROGRAM_FASTVOLTAGE_RANGE_4FLASH_VOLTAGE_RANGE_4VOLTAGE_RANGE_3FLASH_VOLTAGE_RANGE_3VOLTAGE_RANGE_2FLASH_VOLTAGE_RANGE_2VOLTAGE_RANGE_1FLASH_VOLTAGE_RANGE_1TYPEPROGRAM_FASTWORDFLASH_TYPEPROGRAM_WORDTYPEPROGRAM_FASTHALFWORDFLASH_TYPEPROGRAM_HALFWORDTYPEPROGRAM_FASTBYTEFLASH_TYPEPROGRAM_BYTEPAGESIZEFLASH_PAGE_SIZETYPEPROGRAMDATA_FASTWORDFLASH_TYPEPROGRAMDATA_FASTWORDTYPEPROGRAMDATA_FASTHALFWORDFLASH_TYPEPROGRAMDATA_FASTHALFWORDTYPEPROGRAMDATA_FASTBYTEFLASH_TYPEPROGRAMDATA_FASTBYTETYPEPROGRAMDATA_WORDFLASH_TYPEPROGRAMDATA_WORDTYPEPROGRAMDATA_HALFWORDFLASH_TYPEPROGRAMDATA_HALFWORDTYPEPROGRAMDATA_BYTEFLASH_TYPEPROGRAMDATA_BYTETYPEERASEDATA_WORDFLASH_TYPEERASEDATA_WORDTYPEERASEDATA_HALFWORDFLASH_TYPEERASEDATA_HALFWORDTYPEERASEDATA_BYTEFLASH_TYPEERASEDATA_BYTEPCROPSTATE_ENABLEOB_PCROP_STATE_ENABLEPCROPSTATE_DISABLEOB_PCROP_STATE_DISABLEOBEX_BOOTCONFIGOPTIONBYTE_BOOTCONFIGOBEX_PCROPOPTIONBYTE_PCROPHAL_FLASH_TIMEOUT_VALUEFLASH_TIMEOUT_VALUEWRPSTATE_ENABLEOB_WRPSTATE_ENABLEWRPSTATE_DISABLEOB_WRPSTATE_DISABLETYPEERASE_MASSERASEFLASH_TYPEERASE_MASSERASETYPEERASE_PAGEERASEFLASH_TYPEERASE_PAGESTYPEERASE_PAGESTYPEERASE_SECTORSFLASH_TYPEERASE_SECTORSTYPEPROGRAM_DOUBLEWORDFLASH_TYPEPROGRAM_DOUBLEWORDTYPEPROGRAM_WORDTYPEPROGRAM_HALFWORDTYPEPROGRAM_BYTE__HAL_REMAPDMA_CHANNEL_DISABLE__HAL_DMA_REMAP_CHANNEL_DISABLE__HAL_REMAPDMA_CHANNEL_ENABLE__HAL_DMA_REMAP_CHANNEL_ENABLEIS_HAL_REMAPDMAIS_DMA_REMAPHAL_REMAPDMA_TIM3_DMA_CH6DMA_REMAP_TIM3_DMA_CH6HAL_REMAPDMA_TIM2_DMA_CH7DMA_REMAP_TIM2_DMA_CH7HAL_REMAPDMA_TIM1_DMA_CH6DMA_REMAP_TIM1_DMA_CH6HAL_REMAPDMA_I2C1_DMA_CH76DMA_REMAP_I2C1_DMA_CH76HAL_REMAPDMA_USART2_DMA_CH67DMA_REMAP_USART2_DMA_CH67HAL_REMAPDMA_SPI2_DMA_CH67DMA_REMAP_SPI2_DMA_CH67HAL_REMAPDMA_TIM17_DMA_CH7DMA_REMAP_TIM17_DMA_CH7HAL_REMAPDMA_TIM16_DMA_CH6DMA_REMAP_TIM16_DMA_CH6HAL_REMAPDMA_USART3_DMA_CH32DMA_REMAP_USART3_DMA_CH32HAL_REMAPDMA_TIM17_DMA_CH2DMA_REMAP_TIM17_DMA_CH2HAL_REMAPDMA_TIM16_DMA_CH4DMA_REMAP_TIM16_DMA_CH4HAL_REMAPDMA_USART1_RX_DMA_CH5DMA_REMAP_USART1_RX_DMA_CH5HAL_REMAPDMA_USART1_TX_DMA_CH4DMA_REMAP_USART1_TX_DMA_CH4HAL_REMAPDMA_ADC_DMA_CH2DMA_REMAP_ADC_DMA_CH2DAC_WAVEGENERATION_TRIANGLEDAC_WAVE_TRIANGLEDAC_WAVEGENERATION_NOISEDAC_WAVE_NOISEDAC_WAVEGENERATION_NONEDAC_WAVE_NONEDAC2_CHANNEL_1DAC_CHANNEL_1DAC1_CHANNEL_2DAC_CHANNEL_2DAC1_CHANNEL_1CRC_OUTPUTDATA_INVERSION_ENABLEDCRC_OUTPUTDATA_INVERSION_ENABLECRC_OUTPUTDATA_INVERSION_DISABLEDCRC_OUTPUTDATA_INVERSION_DISABLEHAL_CRC_Output_Data_ReverseHAL_CRCEx_Output_Data_ReverseHAL_CRC_Input_Data_ReverseHAL_CRCEx_Input_Data_Reverse__HAL_CORTEX_SYSTICKCLK_CONFIGHAL_SYSTICK_CLKSourceConfigCOMP_OUTPUT_COMP6TIM2OCREFCLRCOMP_OUTPUT_COMP6_TIM2OCREFCLRCOMP_EXTI_LINE_COMP7_EVENTCOMP_EXTI_LINE_COMP7COMP_EXTI_LINE_COMP6_EVENTCOMP_EXTI_LINE_COMP6COMP_EXTI_LINE_COMP5_EVENTCOMP_EXTI_LINE_COMP5COMP_EXTI_LINE_COMP4_EVENTCOMP_EXTI_LINE_COMP4COMP_EXTI_LINE_COMP3_EVENTCOMP_EXTI_LINE_COMP3COMP_EXTI_LINE_COMP2_EVENTCOMP_EXTI_LINE_COMP2COMP_EXTI_LINE_COMP1_EVENTCOMP_EXTI_LINE_COMP1COMP_WINDOWMODE_ENABLEDCOMP_WINDOWMODE_ENABLECOMP_WINDOWMODE_DISABLEDCOMP_WINDOWMODE_DISABLE__HAL_CEC_GET_IT__HAL_CEC_GET_FLAGHAL_ADC_STATE_AWDHAL_ADC_STATE_AWD1HAL_ADC_STATE_BUSYHAL_ADC_STATE_BUSY_INTERNALHAL_ADC_STATE_ERRORHAL_ADC_STATE_ERROR_INTERNALHAL_ADC_STATE_EOC_INJHAL_ADC_STATE_INJ_EOCHAL_ADC_STATE_EOC_REGHAL_ADC_STATE_REG_EOCHAL_ADC_STATE_BUSY_INJHAL_ADC_STATE_INJ_BUSYHAL_ADC_STATE_BUSY_REGHAL_ADC_STATE_REG_BUSYADC_SAMPLETIME_2CYCLE_5ADC_SAMPLETIME_2CYCLES_5ADC_EXTERNALTRIG_EDGE_RISINGFALLINGADC_EXTERNALTRIGCONVEDGE_RISINGFALLINGADC_EXTERNALTRIG_EDGE_FALLINGADC_EXTERNALTRIGCONVEDGE_FALLINGADC_EXTERNALTRIG_EDGE_RISINGADC_EXTERNALTRIGCONVEDGE_RISINGADC_EXTERNALTRIG_EDGE_NONEADC_CLOCK_ASYNCADC_CLOCK_ASYNC_DIV1ADC_EXTERNALTRIG7_EXT_IT11ADC_EXTERNALTRIGCONV_EXT_IT11ADC_EXTERNALTRIG4_T22_TRGOADC_EXTERNALTRIGCONV_T22_TRGOADC_EXTERNALTRIG3_T2_CC4ADC_EXTERNALTRIGCONV_T2_CC4ADC_EXTERNALTRIG2_T2_TRGOADC_EXTERNALTRIGCONV_T2_TRGOADC_EXTERNALTRIG1_T21_CC2ADC_EXTERNALTRIGCONV_T21_CC2ADC_EXTERNALTRIG0_T6_TRGOADC_EXTERNALTRIGCONV_T6_TRGOADC_CLOCKPRESCALER_PCLK_DIV8ADC_CLOCK_SYNC_PCLK_DIV8ADC_CLOCKPRESCALER_PCLK_DIV6ADC_CLOCK_SYNC_PCLK_DIV6ADC_CLOCKPRESCALER_PCLK_DIV4ADC_CLOCK_SYNC_PCLK_DIV4ADC_CLOCKPRESCALER_PCLK_DIV2ADC_CLOCK_SYNC_PCLK_DIV2ADC_CLOCKPRESCALER_PCLK_DIV1ADC_CLOCK_SYNC_PCLK_DIV1SYSCFG_FLAG_VREF_ADCADC_FLAG_VREFINTSYSCFG_FLAG_SENSOR_ADCADC_FLAG_SENSORINJECTED_CHANNELSADC_INJECTED_CHANNELSREGULAR_CHANNELSADC_REGULAR_CHANNELSALL_CHANNELSADC_ALL_CHANNELSJQOVF_EVENTADC_JQOVF_EVENTOVR_EVENTADC_OVR_EVENTAWD3_EVENTADC_AWD3_EVENTAWD2_EVENTADC_AWD2_EVENTAWD1_EVENTADC_AWD1_EVENTAWD_EVENTADC_AWD_EVENTREGULAR_INJECTED_GROUPADC_REGULAR_INJECTED_GROUPINJECTED_GROUPADC_INJECTED_GROUPREGULAR_GROUPADC_REGULAR_GROUPEOC_SINGLE_SEQ_CONVADC_EOC_SINGLE_SEQ_CONVEOC_SEQ_CONVADC_EOC_SEQ_CONVEOC_SINGLE_CONVADC_EOC_SINGLE_CONVOVR_DATA_PRESERVEDADC_OVR_DATA_PRESERVEDOVR_DATA_OVERWRITTENADC_OVR_DATA_OVERWRITTENADC_RESOLUTION6bADC_RESOLUTION_6BADC_RESOLUTION8bADC_RESOLUTION_8BADC_RESOLUTION10bADC_RESOLUTION_10BADC_RESOLUTION12bAES_CLEARFLAG_WRERRCRYP_CLEARFLAG_WRERRAES_CLEARFLAG_RDERRCRYP_CLEARFLAG_RDERRAES_CLEARFLAG_CCFCRYP_CLEARFLAG_CCFAES_FLAG_WRERRCRYP_FLAG_WRERRAES_FLAG_RDERRCRYP_FLAG_RDERRSTM32_HAL_LEGACYdefined(STM32H7) || defined(STM32MP1)defined(STM32H7)defined(STM32U5)defined(STM32H5)defined(STM32L0)defined(STM32F373xC) || defined(STM32F378xx)defined(STM32L0) || defined(STM32L4)defined(COMP_CSR_LOCK)defined(COMP_CSR_COMP1LOCK)defined(COMP_CSR_COMPxLOCK)defined(STM32L4)defined(STM32H5) || defined(STM32C0)defined(STM32G4) || defined(STM32H7) || defined (STM32U5)defined(STM32L1) || defined(STM32L4) || defined(STM32G0) || defined(STM32L5) || defined(STM32H7) || defined(STM32F4) || defined(STM32G4)defined(STM32L4R5xx) || defined(STM32L4R9xx) || defined(STM32L4R9xx) || defined(STM32L4S5xx) || defined(STM32L4S7xx) || defined(STM32L4S9xx)defined(STM32G0)defined(STM32G0) || defined(STM32C0)defined(STM32U0)defined(STM32G4)defined (__ARM_FEATURE_CMSE) && (__ARM_FEATURE_CMSE == 3U)defined(STM32L4) || defined(STM32F7) || defined(STM32H7) || defined(STM32G4)defined(STM32F1) || defined(STM32F2) || defined(STM32F3) || defined(STM32F4)defined(STM32F4)defined(STM32F7)defined (STM32H743xx) || defined (STM32H753xx) || defined (STM32H750xx) || defined (STM32H742xx) || defined (STM32H745xx) || defined (STM32H755xx) || defined (STM32H747xx) || defined (STM32H757xx)defined(STM32L0) || defined(STM32L4) || defined(STM32F4) || defined(STM32F2) || defined(STM32F7) || defined(STM32G4) || defined(STM32H7) || defined(STM32WB) || defined(STM32U5)defined(STM32L1)defined(STM32F0) || defined(STM32F3) || defined(STM32F1)defined(STM32U5) || defined(STM32H5)defined(STM32H5) || defined(STM32U5)defined(STM32F3)defined(STM32F0) || defined(STM32F1) || defined(STM32F3) || defined(STM32G0) || defined(STM32L4) || defined(STM32L1) || defined(STM32F7)defined(STM32L1) || defined(STM32L4) || defined(STM32L5) || defined(STM32H7) || defined(STM32G4) || defined(STM32U5)defined(STM32L4) || defined(STM32L5)defined(STM32H5) || defined(STM32H7RS)defined(STM32WBA)defined(STM32H5) || defined(STM32WBA) || defined(STM32H7RS)defined(STM32F7) || defined(STM32H7) || defined(STM32L0)defined(STM32F1)defined(STM32L4) || defined(STM32F7) || defined(STM32F427xx) || defined(STM32F437xx) || defined(STM32F429xx) || defined(STM32F439xx) || defined(STM32F469xx) || defined(STM32F479xx) || defined(STM32H7)defined(STM32L4) || defined(STM32F7) || defined(STM32F427xx) || defined(STM32F437xx) || defined(STM32F429xx) || defined(STM32F439xx) || defined(STM32F469xx) || defined(STM32F479xx) || defined(STM32H7) || defined(STM32U5)!defined(STM32F2)defined(STM32L4) || defined(STM32L5) || defined(STM32F2) || defined(STM32F4) || defined(STM32F7) || defined(STM32H7)defined(STM32H7A3xx) || defined(STM32H7B3xx) || defined(STM32H7B0xx) || defined(STM32H7A3xxQ) || defined(STM32H7B3xxQ) || defined(STM32H7B0xxQ)defined(STM32H7) || defined(STM32WB) || defined(STM32G0) || defined(STM32F0) || defined(STM32F1) || defined(STM32F2) || defined(STM32F3) || defined(STM32F4) || defined(STM32F7) || defined(STM32L0) || defined(STM32L4) || defined(STM32L5) || defined(STM32G4) || defined(STM32L1)defined(STM32H7) || defined(STM32WB) || defined(STM32G0) || defined(STM32F4) || defined(STM32F7) || defined(STM32L0) || defined(STM32L4) || defined(STM32L5) || defined(STM32G4)|| defined(STM32L1)defined (STM32U5)defined(STM32H7) || defined(STM32G0) || defined(STM32F0) || defined(STM32F1) || defined(STM32F2) || defined(STM32F3) || defined(STM32F4) || defined(STM32F7) || defined(STM32L0) || defined(STM32L4)defined(STM32F301x8) || defined(STM32F302x8) || defined(STM32F318xx) || defined(STM32F303x8) || defined(STM32F334x8) || defined(STM32F328xx)defined(STM32F302xE) || defined(STM32F302xC)defined(STM32F303xE) || defined(STM32F398xx) || defined(STM32F303xC) || defined(STM32F358xx)defined(STM32F373xC) ||defined(STM32F378xx)defined (STM32F4)defined(STM32WB)defined(STM32F7) || defined(STM32L4)defined(STM32L4) || defined(STM32WB) || defined(STM32G0) || defined(STM32G4) || defined(STM32L5) || defined(STM32WL) || defined(STM32C0) || defined(STM32H7RS) || defined(STM32U0)!defined(STM32U0)defined (STM32G0) || defined (STM32L5) || defined (STM32L412xx) || defined (STM32L422xx) || defined (STM32L4P5xx)|| defined (STM32L4Q5xx) || defined (STM32G4) || defined (STM32WL) || defined (STM32U5) || defined (STM32WBA) || defined (STM32H5) || defined (STM32C0) || defined (STM32H7RS) || defined (STM32U0)defined (STM32F1)defined (STM32F0) || defined (STM32F2) || defined (STM32F3) || defined (STM32F4) || defined (STM32F7) || defined (STM32H7) || defined (STM32L0) || defined (STM32L1) || defined (STM32WB)defined (STM32H5)!defined(STM32F1) && !defined(STM32F2) && !defined(STM32F4) && !defined(STM32L1)defined(STM32F4) || defined(STM32F2)defined(STM32F7) || defined(STM32F4) || defined(STM32F2) || defined(STM32L4) || defined(STM32H7)defined(STM32H7) || defined(STM32L5)defined(STM32F0) || defined(STM32F3) || defined(STM32F7)defined (STM32H7) || defined (STM32G4) || defined (STM32F3)defined (STM32L4) || defined (STM32F4) || defined (STM32F7) || defined(STM32H7)defined (STM32F7)/* STM32_HAL_LEGACY *//** @defgroup HAL_PPP_Aliased_Macros HAL PPP Aliased Macros maintained for legacy purpose
  * @{
  *//** @defgroup HAL_Generic_Aliased_Macros HAL Generic Aliased Macros maintained for legacy purpose
  * @{
  *//* STM32L4 || STM32F4 || STM32F7 *//** @defgroup HAL_QSPI_Aliased_Macros HAL QSPI Aliased Macros maintained for legacy purpose
  * @{
  *//** @defgroup HAL_HRTIM_Aliased_Functions HAL HRTIM Aliased Functions maintained for legacy purpose
  * @{
  *//** @defgroup HAL_SPDIFRX_Aliased_Macros HAL SPDIFRX Aliased Macros maintained for legacy purpose
  * @{
  *//** @defgroup HAL_SAI_Aliased_Macros HAL SAI Aliased Macros maintained for legacy purpose
  * @{
  *//** @defgroup HAL_LTDC_Aliased_Macros HAL LTDC Aliased Macros maintained for legacy purpose
  * @{
  *//** @defgroup HAL_ETH_Aliased_Macros HAL ETH Aliased Macros maintained for legacy purpose
  * @{
  *//** @defgroup HAL_TIM_Aliased_Macros HAL TIM Aliased Macros maintained for legacy purpose
  * @{
  *//** @defgroup HAL_USB_Aliased_Macros HAL USB Aliased Macros maintained for legacy purpose
  * @{
  *//* STM32F0 || STM32F3 || STM32F7 *//** @defgroup HAL_USART_Aliased_Macros HAL USART Aliased Macros maintained for legacy purpose
  * @{
  *//** @defgroup HAL_UART_Aliased_Macros HAL UART Aliased Macros maintained for legacy purpose
  * @{
  *//** @defgroup HAL_SPI_Aliased_Macros HAL SPI Aliased Macros maintained for legacy purpose
  * @{
  *//** @defgroup HAL_SMBUS_Aliased_Macros HAL SMBUS Aliased Macros maintained for legacy purpose
  * @{
  *//** @defgroup HAL_SMARTCARD_Aliased_Macros HAL SMARTCARD Aliased Macros maintained for legacy purpose
  * @{
  *//* alias CMSIS for compatibilities *//* alias CMSIS *//** @defgroup HAL_SD_Aliased_Macros HAL SD/MMC Aliased Macros maintained for legacy purpose
  * @{
  *//* STM32H5 *//* STM32F1 *//** @defgroup HAL_RTC_Aliased_Macros HAL RTC Aliased Macros maintained for legacy purpose
  * @{
  *//** @defgroup HAL_RNG_Aliased_Macros HAL RNG Aliased Macros maintained for legacy purpose
  * @{
  *//* STM32U5 *//* STM32L1 *//* alias define maintained for legacy *//* Not available on the STM32H7*//* __HAL_RCC_QUADSPI_CLK_ENABLE *//** @defgroup HAL_RCC_Aliased HAL RCC Aliased maintained for legacy purpose
  * @{
  *//* STM32F4 *//** @defgroup HAL_PWR_Aliased_Macros HAL PWR Aliased Macros maintained for legacy purpose
  * @{
  *//** @defgroup HAL_OPAMP_Aliased_Macros HAL OPAMP Aliased Macros maintained for legacy purpose
  * @{
  *//** @defgroup HAL_LPTIM_Aliased_Macros HAL LPTIM Aliased Macros maintained for legacy purpose
  * @{
  *//** @defgroup HAL_IWDG_Aliased_Macros HAL IWDG Aliased Macros maintained for legacy purpose
  * @{
  *//** @defgroup HAL_IRDA_Aliased_Macros HAL IRDA Aliased Macros maintained for legacy purpose
  * @{
  *//** @defgroup HAL_I2S_Aliased_Macros HAL I2S Aliased Macros maintained for legacy purpose
  * @{
  *//** @defgroup HAL_I2C_Aliased_Macros HAL I2C Aliased Macros maintained for legacy purpose
  * @{
  *//** @defgroup HAL_FLASH_Aliased_Macros HAL FLASH Aliased Macros maintained for legacy purpose
  * @{
  *//** @defgroup HAL_DAC_Aliased_Macros HAL DAC Aliased Macros maintained for legacy purpose
  * @{
  *//* Function considered as legacy as EXTI event or IT configuration is 
                                                  done into HAL_COMP_Init() *//** @defgroup HAL_COMP_Aliased_Functions HAL COMP Aliased Functions maintained for legacy purpose
  * @{
  *//*       argument.                                                            *//*       This macro is replaced by __HAL_COMP_IS_LOCKED with only HAL handle  *//*       is COMP_FLAG_LOCK.                                                   *//* Note: On these STM32 families, the only argument of this macro             *//** @defgroup HAL_COMP_Aliased_Macros HAL COMP Aliased Macros maintained for legacy purpose
  * @{
  *//* STM32H7 *//** @defgroup HAL_DBGMCU_Aliased_Macros HAL DBGMCU Aliased Macros maintained for legacy purpose
  * @{
  *//** @defgroup HAL_ADC_Aliased_Macros HAL ADC Aliased Macros maintained for legacy purpose
  * @{
  *//** @defgroup HAL_Aliased_Macros HAL Generic Aliased Macros maintained for legacy purpose
  * @{
  *//** @defgroup HAL_AES_Aliased_Macros HAL CRYP Aliased Macros maintained for legacy purpose
  * @{
  *//* Exported macros ------------------------------------------------------------*//** @defgroup HAL_PPP_Aliased_Functions HAL PPP Aliased Functions maintained for legacy purpose
  * @{
  *//** @defgroup HAL_LTDC_Aliased_Functions HAL LTDC Aliased Functions maintained for legacy purpose
  * @{
  *//** @defgroup HAL_UART_Aliased_Functions HAL UART Aliased Functions maintained for legacy purpose
  * @{
  *//* STM32H7 || STM32G0 || STM32F0 || STM32F1 || STM32F2 || STM32F3 || STM32F4 || STM32F7 || STM32L0 *//** @defgroup HAL_TIM_Aliased_Functions HAL TIM Aliased Functions maintained for legacy purpose
  * @{
  *//** @defgroup HAL_SPI_Aliased_Functions HAL SPI Aliased Functions maintained for legacy purpose
  * @{
  *//** @defgroup HAL_SMBUS_Aliased_Functions HAL SMBUS Aliased Functions maintained for legacy purpose
  * @{
  *//* STM32H5 || STM32WBA || STM32H7RS *//** @defgroup HAL_RTC_Aliased_Functions HAL RTC Aliased Functions maintained for legacy purpose
  * @{
  *//**
  * @}
 *//** @defgroup HAL_PWR_Aliased HAL PWR Aliased maintained for legacy purpose
  * @{
  *//* STM32H7 || STM32WB  || STM32G0 || STM32F4 || STM32F7 || STM32L0 || STM32L4 || STM32L5 || STM32G4 || STM32L1 *//* STM32H7 || STM32WB  || STM32G0 || STM32F0 || STM32F1 || STM32F2 || STM32F3 || STM32F4 || STM32F7 || STM32L0 ||
          STM32L4 || STM32L5 || STM32G4 || STM32L1 *//** @defgroup HAL_I2C_Aliased_Functions HAL I2C Aliased Functions maintained for legacy purpose
  * @{
  *//** @defgroup HAL_FLASH_Aliased_Functions HAL FLASH Aliased Functions maintained for legacy purpose
  * @{
  *//* STM32H7A3xx || STM32H7B3xx || STM32H7B0xx || STM32H7A3xxQ || STM32H7B3xxQ  || STM32H7B0xxQ *//** @defgroup HAL_Aliased_Functions HAL Generic Aliased Functions maintained for legacy purpose
  * @{
  *//* STM32L4 || STM32L5 || STM32F2 || STM32F4 || STM32F7 || STM32H7 *//*HASH Algorithm Selection*//** @defgroup HAL_HASH_Aliased_Functions HAL HASH Aliased Functions maintained for legacy purpose
  * @{
  *//* STM32F2 *//**
  *
  * @}
  *//*!< Redirection for compatibility with legacy code *//** @defgroup HASH_alias HASH API alias
  * @{
  *//** @defgroup HAL_DCACHE_Aliased_Functions HAL DCACHE Aliased Functions maintained for legacy purpose
  * @{
  *//** @defgroup HAL_CRYP_Aliased_Functions HAL CRYP Aliased Functions maintained for legacy purpose
  * @{
  *//** @defgroup HAL_PPP_Aliased_Defines HAL PPP Aliased Defines maintained for legacy purpose
  * @{
  *//* STM32L4 ||  STM32F7 ||  STM32F4 ||  STM32H7 || STM32U5 *//*!< Aliased to HAL_DMA2D_CLUTLoading_Abort
                                                                        for compatibility with legacy code *//** @defgroup DMA2D_Aliases DMA2D API Aliases
  * @{
  *//* STM32L4 ||  STM32F7 ||  STM32F4 ||  STM32H7 *//** @defgroup HAL_DMA2D_Aliased_Defines HAL DMA2D Aliased Defines maintained for legacy purpose
  * @{
  *//** @defgroup HAL_DCMI_Aliased_Defines HAL DCMI Aliased Defines maintained for legacy purpose
  * @{
  *//* Transmit Packet Configuration structure definition *//* MAC MII receive protocol engine active *//* MAC small FIFO read / write controllers active *//* MAC small FIFO write controller active *//* MAC small FIFO read controller active *//* MAC small FIFO read / write controllers not active *//* Rx FIFO write controller active *//* Rx FIFO read controller Flushing the frame data and 
                                                              status *//* Rx FIFO read controller Reading frame status 
                                                             (or time-stamp) *//* Rx FIFO read controller Reading frame data *//* Rx FIFO read controller IDLE state *//* Rx FIFO fill level: full *//* Rx FIFO fill level: fill-level above flow-control 
                                                              activate threshold *//* Rx FIFO fill level: fill-level below flow-control 
                                                              de-activate threshold *//* Rx FIFO fill level: empty *//* MAC MII transmit engine active *//* MAC transmit frame controller: Transferring input 
                                                                      frame for transmission *//* MAC transmit frame controller: Generating and 
                                                             transmitting a Pause control frame (in full duplex mode) *//* MAC transmit frame controller: Waiting for Status 
                                                                   of previous frame or IFG/backoff period to be over *//* MAC transmit frame controller: Idle *//* MAC transmitter in pause *//* Tx FIFO read status: Writing the received TxStatus
                                                                      or flushing the TxFIFO *//* Tx FIFO read status: Waiting for TxStatus from 
                                                                      MAC transmitter *//* Tx FIFO read status: Read (transferring data to 
                                                                      the MAC transmitter) *//* Tx FIFO read status: Idle *//* Tx FIFO write active *//* Tx FIFO not empty *//* Tx FIFO full *//** @defgroup HAL_ETH_Aliased_Defines HAL ETH Aliased Defines maintained for legacy purpose
  * @{
  *//** @defgroup HAL_CAN_Aliased_Defines HAL CAN Aliased Defines maintained for legacy purpose
  * @{
  *//** @defgroup HAL_WWDG_Aliased_Defines HAL WWDG Aliased Defines maintained for legacy purpose
  * @{
  *//** @defgroup HAL_USART_Aliased_Defines HAL USART Aliased Defines maintained for legacy purpose
  * @{
  *//** @defgroup HAL_UART_Aliased_Defines HAL UART Aliased Defines maintained for legacy purpose
  * @{
  *//** @defgroup HAL_TSC_Aliased_Defines HAL TSC Aliased Defines maintained for legacy purpose
  * @{
  *//** @defgroup HAL_TIM_Aliased_Defines HAL TIM Aliased Defines maintained for legacy purpose
  * @{
  *//** @defgroup HAL_SPI_Aliased_Defines HAL SPI Aliased Defines maintained for legacy purpose
  * @{
  *//** @defgroup HAL_SMBUS_Aliased_Defines HAL SMBUS Aliased Defines maintained for legacy purpose
  * @{
  *//** @defgroup HAL_SMARTCARD_Aliased_Defines HAL SMARTCARD Aliased Defines maintained for legacy purpose
  * @{
  *//* STM32F7 || STM32H7 || STM32L0 *//* STM32WBA *//* STM32H5 || STM32H7RS *//** @defgroup HAL_RTC_Aliased_Defines HAL RTC Aliased Defines maintained for legacy purpose
  * @{
  *//* Compact Flash-ATA commands *//* Compact Flash-ATA registers description *//** @defgroup HAL_PCCARD_Aliased_Defines HAL PCCARD Aliased Defines maintained for legacy purpose
  * @{
  *//** @defgroup HAL_I2S_Aliased_Defines HAL I2S Aliased Defines maintained for legacy purpose
  * @{
  *//** @defgroup HAL_OPAMP_Aliased_Defines HAL OPAMP Aliased Defines maintained for legacy purpose
  * @{
  *//** @defgroup HAL_NOR_Aliased_Defines HAL NOR Aliased Defines maintained for legacy purpose
  * @{
  *//** @defgroup HAL_NAND_Aliased_Defines HAL NAND Aliased Defines maintained for legacy purpose
  * @{
  *//** @defgroup HAL_LPTIM_Aliased_Defines HAL LPTIM Aliased Defines maintained for legacy purpose
  * @{
  *//* They need to be renamed also to the right name, just in case *//* The following 3 definition have also been present in a temporary version of lptim.h *//** @defgroup HAL_IWDG_Aliased_Defines HAL IWDG Aliased Defines maintained for legacy purpose
  * @{
  *//** @defgroup HAL_IRDA_Aliased_Defines HAL IRDA Aliased Defines maintained for legacy purpose
  * @{
  *//** @defgroup HAL_I2C_Aliased_Defines HAL I2C Aliased Defines maintained for legacy purpose
  * @{
  *//* STM32F3 *//** @brief Constants defining the DLL calibration periods (in micro seconds)
  *//** @brief Constants defining available sources associated to external events.
  *//* STM32G4 *//** @defgroup HAL_HRTIM_Aliased_Macros HAL HRTIM Aliased Macros maintained for legacy purpose
  * @{
  *//* STM32H5 || STM32U5 *//** @defgroup HAL_GTZC_Aliased_Defines HAL GTZC Aliased Defines maintained for legacy purpose
  * @{
  *//* STM32U5 || STM32H5 *//* STM32F0 || STM32F3 || STM32F1 *//* STM32L0 || STM32L4 || STM32F4 || STM32F2 || STM32F7 || STM32G4 || STM32H7 || STM32WB || STM32U5*//*STM32H743xx || STM32H753xx || STM32H750xx || STM32H742xx || STM32H745xx || STM32H755xx || STM32H747xx || \
         STM32H757xx *//** @defgroup HAL_GPIO_Aliased_Macros HAL GPIO Aliased Macros maintained for legacy purpose
  * @{
  *//** @defgroup LL_FSMC_Aliased_Defines LL FSMC Aliased Defines maintained for legacy purpose
  * @{
  *//** @defgroup LL_FMC_Aliased_Defines LL FMC Aliased Defines maintained for compatibility purpose
  * @{
  *//* __ARM_FEATURE_CMSE *//** @defgroup HAL_SYSCFG_Aliased_Defines HAL SYSCFG Aliased Defines maintained for legacy purpose
  * @{
  *//** @defgroup HAL_JPEG_Aliased_Macros HAL JPEG Aliased Macros maintained for legacy purpose
  * @{
  *//* STM32U0 *//** @defgroup HAL_FLASH_Aliased_Defines HAL FLASH Aliased Defines maintained for legacy purpose
  * @{
  *//* STM32L4 *//** @defgroup HAL_DMA_Aliased_Defines HAL DMA Aliased Defines maintained for legacy purpose
  * @{
  *//** @defgroup HAL_DAC_Aliased_Defines HAL DAC Aliased Defines maintained for legacy purpose
  * @{
  *//** @defgroup HAL_CRC_Aliased_Defines HAL CRC Aliased Defines maintained for legacy purpose
  * @{
  *//*!< Aliased to HAL_CRCEx_Output_Data_Reverse for 
                                                                          inter STM32 series compatibility *//*!< Aliased to HAL_CRCEx_Input_Data_Reverse for 
                                                                          inter STM32 series compatibility  *//** @defgroup CRC_Aliases CRC API aliases
  * @{
  *//** @defgroup HAL_CORTEX_Aliased_Defines HAL CORTEX Aliased Defines maintained for legacy purpose
  * @{
  *//*       To check COMP lock state, use macro "__HAL_COMP_IS_LOCKED()".        *//* Note: Literal "COMP_FLAG_LOCK" kept for legacy purpose.                    *//* to the second dedicated IO (only for COMP2).                               *//* IO2 was wrongly assigned to IO shared with DAC and IO3 was corresponding   *//* Issue fixed on STM32L0 COMP driver: only 2 dedicated IO (IO1 and IO2),     *//* STM32F373xC || STM32F378xx *//*!< COMPX output generic naming: connected to LPTIM 
                                                                       input 1 for COMP1, LPTIM input 2 for COMP2 *//** @defgroup HAL_COMP_Aliased_Defines HAL COMP Aliased Defines maintained for legacy purpose
  * @{
  *//** @defgroup HAL_CEC_Aliased_Defines HAL CEC Aliased Defines maintained for legacy purpose
  * @{
  *//** @defgroup HAL_ADC_Aliased_Defines HAL ADC Aliased Defines maintained for legacy purpose
  * @{
  *//* STM32H7 || STM32MP1 *//** @defgroup HAL_AES_Aliased_Defines HAL CRYP Aliased Defines maintained for legacy purpose
  * @{
  *//**
  ******************************************************************************
  * @file    stm32_hal_legacy.h
  * @author  MCD Application Team
  * @brief   This file contains aliases definition for the STM32Cube HAL constants
  *          macros and functions maintained for legacy purpose.
  ******************************************************************************
  * @attention
  *
  * Copyright (c) 2021 STMicroelectronics.
  * All rights reserved.
  *
  * This software is licensed under terms that can be found in the LICENSE file
  * in the root directory of this software component.
  * If no LICENSE file comes with this software, it is provided AS-IS.
  *
  ******************************************************************************
  *//Users/jie/Documents/posixGen_Demos-main/LwIP_StreamingServer/Drivers/STM32F7xx_HAL_Driver/Inc/Legacy"stm32f7xx_hal_def.h"HAL_RCCEx_DisablePLLSAIHAL_RCCEx_EnablePLLSAIRCC_PLLSAIInitTypeDef *HAL_RCCEx_DisablePLLI2SHAL_RCCEx_EnablePLLI2SRCC_PLLI2SInitTypeDef *HAL_RCCEx_GetPeriphCLKFreqHAL_RCCEx_GetPeriphCLKConfigHAL_RCCEx_PeriphCLKConfigRCC_PeriphCLKInitTypeDefRCC_PLLSAIInitTypeDefRCC_PLLI2SInitTypeDefRCC_PLLInitTypeDefDfsdm1AudioClockSelectionSdmmc2ClockSelectionClk48ClockSelectionCecClockSelectionLptim1ClockSelectionI2c4ClockSelectionI2c3ClockSelectionI2c2ClockSelectionI2c1ClockSelectionUart8ClockSelectionUart7ClockSelectionUsart6ClockSelectionUart5ClockSelectionUart4ClockSelectionUsart3ClockSelectionUsart2ClockSelectionUsart1ClockSelectionSai2ClockSelectionSai1ClockSelectionTIMPresSelectionI2sClockSelectionRTCClockSelectionPLLSAIDivRPLLSAIDivQPLLI2SDivQPLLSAIPLLI2SPeriphClockSelectionPLLSAIPPLLSAIRPLLSAIQPLLSAINPLLI2SPPLLI2SQPLLI2SRPLLI2SNPLLRPLLQPLLPPLLNPLLMPLLSourcePLLStateIS_RCC_DSIBYTELANECLKSOURCE(SOURCE)(((SOURCE) == RCC_DSICLKSOURCE_PLLR) || ((SOURCE) == RCC_DSICLKSOURCE_DSIPHY))IS_RCC_SDMMC2CLKSOURCE(SOURCE)(((SOURCE) == RCC_SDMMC2CLKSOURCE_SYSCLK) || ((SOURCE) == RCC_SDMMC2CLKSOURCE_CLK48))IS_RCC_DFSDM1AUDIOCLKSOURCE(SOURCE)(((SOURCE) == RCC_DFSDM1AUDIOCLKSOURCE_SAI1) || ((SOURCE) == RCC_DFSDM1AUDIOCLKSOURCE_SAI2))IS_RCC_DFSDM1CLKSOURCE(SOURCE)(((SOURCE) == RCC_DFSDM1CLKSOURCE_PCLK2) || ((SOURCE) == RCC_DFSDM1CLKSOURCE_SYSCLK))IS_RCC_SAI2CLKSOURCE(SOURCE)(((SOURCE) == RCC_SAI2CLKSOURCE_PLLSAI) || ((SOURCE) == RCC_SAI2CLKSOURCE_PLLI2S) || ((SOURCE) == RCC_SAI2CLKSOURCE_PIN) || ((SOURCE) == RCC_SAI2CLKSOURCE_PLLSRC))IS_RCC_SAI1CLKSOURCE(SOURCE)(((SOURCE) == RCC_SAI1CLKSOURCE_PLLSAI) || ((SOURCE) == RCC_SAI1CLKSOURCE_PLLI2S) || ((SOURCE) == RCC_SAI1CLKSOURCE_PIN) || ((SOURCE) == RCC_SAI1CLKSOURCE_PLLSRC))IS_RCC_PLLR_VALUE(VALUE)((2 <= (VALUE)) && ((VALUE) <= 7))IS_RCC_TIMPRES(VALUE)(((VALUE) == RCC_TIMPRES_DESACTIVATED) || ((VALUE) == RCC_TIMPRES_ACTIVATED))IS_RCC_CLK48SOURCE(SOURCE)(((SOURCE) == RCC_CLK48SOURCE_PLLSAIP) || ((SOURCE) == RCC_CLK48SOURCE_PLL))IS_RCC_LPTIM1CLK(SOURCE)(((SOURCE) == RCC_LPTIM1CLKSOURCE_PCLK1) || ((SOURCE) == RCC_LPTIM1CLKSOURCE_LSI) || ((SOURCE) == RCC_LPTIM1CLKSOURCE_HSI) || ((SOURCE) == RCC_LPTIM1CLKSOURCE_LSE))IS_RCC_I2C4CLKSOURCE(SOURCE)(((SOURCE) == RCC_I2C4CLKSOURCE_PCLK1) || ((SOURCE) == RCC_I2C4CLKSOURCE_SYSCLK)|| ((SOURCE) == RCC_I2C4CLKSOURCE_HSI))IS_RCC_I2C3CLKSOURCE(SOURCE)(((SOURCE) == RCC_I2C3CLKSOURCE_PCLK1) || ((SOURCE) == RCC_I2C3CLKSOURCE_SYSCLK)|| ((SOURCE) == RCC_I2C3CLKSOURCE_HSI))IS_RCC_I2C2CLKSOURCE(SOURCE)(((SOURCE) == RCC_I2C2CLKSOURCE_PCLK1) || ((SOURCE) == RCC_I2C2CLKSOURCE_SYSCLK)|| ((SOURCE) == RCC_I2C2CLKSOURCE_HSI))IS_RCC_I2C1CLKSOURCE(SOURCE)(((SOURCE) == RCC_I2C1CLKSOURCE_PCLK1) || ((SOURCE) == RCC_I2C1CLKSOURCE_SYSCLK)|| ((SOURCE) == RCC_I2C1CLKSOURCE_HSI))IS_RCC_UART8CLKSOURCE(SOURCE)(((SOURCE) == RCC_UART8CLKSOURCE_PCLK1) || ((SOURCE) == RCC_UART8CLKSOURCE_SYSCLK) || ((SOURCE) == RCC_UART8CLKSOURCE_LSE) || ((SOURCE) == RCC_UART8CLKSOURCE_HSI))IS_RCC_UART7CLKSOURCE(SOURCE)(((SOURCE) == RCC_UART7CLKSOURCE_PCLK1) || ((SOURCE) == RCC_UART7CLKSOURCE_SYSCLK) || ((SOURCE) == RCC_UART7CLKSOURCE_LSE) || ((SOURCE) == RCC_UART7CLKSOURCE_HSI))IS_RCC_USART6CLKSOURCE(SOURCE)(((SOURCE) == RCC_USART6CLKSOURCE_PCLK2) || ((SOURCE) == RCC_USART6CLKSOURCE_SYSCLK) || ((SOURCE) == RCC_USART6CLKSOURCE_LSE) || ((SOURCE) == RCC_USART6CLKSOURCE_HSI))IS_RCC_UART5CLKSOURCE(SOURCE)(((SOURCE) == RCC_UART5CLKSOURCE_PCLK1) || ((SOURCE) == RCC_UART5CLKSOURCE_SYSCLK) || ((SOURCE) == RCC_UART5CLKSOURCE_LSE) || ((SOURCE) == RCC_UART5CLKSOURCE_HSI))IS_RCC_UART4CLKSOURCE(SOURCE)(((SOURCE) == RCC_UART4CLKSOURCE_PCLK1) || ((SOURCE) == RCC_UART4CLKSOURCE_SYSCLK) || ((SOURCE) == RCC_UART4CLKSOURCE_LSE) || ((SOURCE) == RCC_UART4CLKSOURCE_HSI))IS_RCC_USART3CLKSOURCE(SOURCE)(((SOURCE) == RCC_USART3CLKSOURCE_PCLK1) || ((SOURCE) == RCC_USART3CLKSOURCE_SYSCLK) || ((SOURCE) == RCC_USART3CLKSOURCE_LSE) || ((SOURCE) == RCC_USART3CLKSOURCE_HSI))IS_RCC_USART2CLKSOURCE(SOURCE)(((SOURCE) == RCC_USART2CLKSOURCE_PCLK1) || ((SOURCE) == RCC_USART2CLKSOURCE_SYSCLK) || ((SOURCE) == RCC_USART2CLKSOURCE_LSE) || ((SOURCE) == RCC_USART2CLKSOURCE_HSI))IS_RCC_USART1CLKSOURCE(SOURCE)(((SOURCE) == RCC_USART1CLKSOURCE_PCLK2) || ((SOURCE) == RCC_USART1CLKSOURCE_SYSCLK) || ((SOURCE) == RCC_USART1CLKSOURCE_LSE) || ((SOURCE) == RCC_USART1CLKSOURCE_HSI))IS_RCC_CECCLKSOURCE(SOURCE)(((SOURCE) == RCC_CECCLKSOURCE_HSI) || ((SOURCE) == RCC_CECCLKSOURCE_LSE))IS_RCC_SDMMC1CLKSOURCE(SOURCE)(((SOURCE) == RCC_SDMMC1CLKSOURCE_SYSCLK) || ((SOURCE) == RCC_SDMMC1CLKSOURCE_CLK48))IS_RCC_I2SCLKSOURCE(SOURCE)(((SOURCE) == RCC_I2SCLKSOURCE_PLLI2S) || ((SOURCE) == RCC_I2SCLKSOURCE_EXT))IS_RCC_PLLSAI_DIVR_VALUE(VALUE)(((VALUE) == RCC_PLLSAIDIVR_2) || ((VALUE) == RCC_PLLSAIDIVR_4) || ((VALUE) == RCC_PLLSAIDIVR_8) || ((VALUE) == RCC_PLLSAIDIVR_16))IS_RCC_PLLI2S_DIVQ_VALUE(VALUE)((1 <= (VALUE)) && ((VALUE) <= 32))IS_RCC_PLLSAI_DIVQ_VALUE(VALUE)IS_RCC_PLLSAIR_VALUE(VALUE)IS_RCC_PLLSAIQ_VALUE(VALUE)((2 <= (VALUE)) && ((VALUE) <= 15))IS_RCC_PLLSAIP_VALUE(VALUE)(((VALUE) == RCC_PLLSAIP_DIV2) || ((VALUE) == RCC_PLLSAIP_DIV4) || ((VALUE) == RCC_PLLSAIP_DIV6) || ((VALUE) == RCC_PLLSAIP_DIV8))IS_RCC_PLLSAIN_VALUE(VALUE)((50 <= (VALUE)) && ((VALUE) <= 432))IS_RCC_PLLI2SR_VALUE(VALUE)IS_RCC_PLLI2SQ_VALUE(VALUE)IS_RCC_PLLI2SP_VALUE(VALUE)(((VALUE) == RCC_PLLI2SP_DIV2) || ((VALUE) == RCC_PLLI2SP_DIV4) || ((VALUE) == RCC_PLLI2SP_DIV6) || ((VALUE) == RCC_PLLI2SP_DIV8))IS_RCC_PLLI2SN_VALUE(VALUE)IS_RCC_PERIPHCLOCK(SELECTION)((((SELECTION) & RCC_PERIPHCLK_I2S) == RCC_PERIPHCLK_I2S) || (((SELECTION) & RCC_PERIPHCLK_LTDC) == RCC_PERIPHCLK_LTDC) || (((SELECTION) & RCC_PERIPHCLK_TIM) == RCC_PERIPHCLK_TIM) || (((SELECTION) & RCC_PERIPHCLK_USART1) == RCC_PERIPHCLK_USART1) || (((SELECTION) & RCC_PERIPHCLK_USART2) == RCC_PERIPHCLK_USART2) || (((SELECTION) & RCC_PERIPHCLK_USART3) == RCC_PERIPHCLK_USART3) || (((SELECTION) & RCC_PERIPHCLK_UART4) == RCC_PERIPHCLK_UART4) || (((SELECTION) & RCC_PERIPHCLK_UART5) == RCC_PERIPHCLK_UART5) || (((SELECTION) & RCC_PERIPHCLK_USART6) == RCC_PERIPHCLK_USART6) || (((SELECTION) & RCC_PERIPHCLK_UART7) == RCC_PERIPHCLK_UART7) || (((SELECTION) & RCC_PERIPHCLK_UART8) == RCC_PERIPHCLK_UART8) || (((SELECTION) & RCC_PERIPHCLK_I2C1) == RCC_PERIPHCLK_I2C1) || (((SELECTION) & RCC_PERIPHCLK_I2C2) == RCC_PERIPHCLK_I2C2) || (((SELECTION) & RCC_PERIPHCLK_I2C3) == RCC_PERIPHCLK_I2C3) || (((SELECTION) & RCC_PERIPHCLK_I2C4) == RCC_PERIPHCLK_I2C4) || (((SELECTION) & RCC_PERIPHCLK_LPTIM1) == RCC_PERIPHCLK_LPTIM1) || (((SELECTION) & RCC_PERIPHCLK_SAI1) == RCC_PERIPHCLK_SAI1) || (((SELECTION) & RCC_PERIPHCLK_SAI2) == RCC_PERIPHCLK_SAI2) || (((SELECTION) & RCC_PERIPHCLK_CLK48) == RCC_PERIPHCLK_CLK48) || (((SELECTION) & RCC_PERIPHCLK_CEC) == RCC_PERIPHCLK_CEC) || (((SELECTION) & RCC_PERIPHCLK_SDMMC1) == RCC_PERIPHCLK_SDMMC1) || (((SELECTION) & RCC_PERIPHCLK_SDMMC2) == RCC_PERIPHCLK_SDMMC2) || (((SELECTION) & RCC_PERIPHCLK_DFSDM1) == RCC_PERIPHCLK_DFSDM1) || (((SELECTION) & RCC_PERIPHCLK_DFSDM1_AUDIO) == RCC_PERIPHCLK_DFSDM1_AUDIO) || (((SELECTION) & RCC_PERIPHCLK_SPDIFRX) == RCC_PERIPHCLK_SPDIFRX) || (((SELECTION) & RCC_PERIPHCLK_RTC) == RCC_PERIPHCLK_RTC))__HAL_RCC_GET_DSI_SOURCE()(READ_BIT(RCC->DCKCFGR2, RCC_DCKCFGR2_DSISEL))__HAL_RCC_DSI_CONFIG(__DSI_CLKSOURCE__)(MODIFY_REG(RCC->DCKCFGR2, RCC_DCKCFGR2_DSISEL, (uint32_t)(__DSI_CLKSOURCE__)))__HAL_RCC_GET_DFSDM1AUDIO_SOURCE()((uint32_t)(READ_BIT(RCC->DCKCFGR1, RCC_DCKCFGR1_ADFSDM1SEL)))__HAL_RCC_DFSDM1AUDIO_CONFIG(__DFSDM1AUDIO_CLKSOURCE__)MODIFY_REG(RCC->DCKCFGR1, RCC_DCKCFGR1_ADFSDM1SEL, (uint32_t)(__DFSDM1AUDIO_CLKSOURCE__))__HAL_RCC_GET_DFSDM1_SOURCE()((uint32_t)(READ_BIT(RCC->DCKCFGR1, RCC_DCKCFGR1_DFSDM1SEL)))__HAL_RCC_DFSDM1_CONFIG(__DFSDM1_CLKSOURCE__)MODIFY_REG(RCC->DCKCFGR1, RCC_DCKCFGR1_DFSDM1SEL, (uint32_t)(__DFSDM1_CLKSOURCE__))__HAL_RCC_GET_SDMMC2_SOURCE()((uint32_t)(READ_BIT(RCC->DCKCFGR2, RCC_DCKCFGR2_SDMMC2SEL)))__HAL_RCC_SDMMC2_CONFIG(__SDMMC2_CLKSOURCE__)MODIFY_REG(RCC->DCKCFGR2, RCC_DCKCFGR2_SDMMC2SEL, (uint32_t)(__SDMMC2_CLKSOURCE__))__HAL_RCC_GET_SDMMC1_SOURCE()((uint32_t)(READ_BIT(RCC->DCKCFGR2, RCC_DCKCFGR2_SDMMC1SEL)))__HAL_RCC_SDMMC1_CONFIG(__SDMMC1_CLKSOURCE__)MODIFY_REG(RCC->DCKCFGR2, RCC_DCKCFGR2_SDMMC1SEL, (uint32_t)(__SDMMC1_CLKSOURCE__))__HAL_RCC_GET_CLK48_SOURCE()((uint32_t)(READ_BIT(RCC->DCKCFGR2, RCC_DCKCFGR2_CK48MSEL)))__HAL_RCC_CLK48_CONFIG(__CLK48_SOURCE__)MODIFY_REG(RCC->DCKCFGR2, RCC_DCKCFGR2_CK48MSEL, (uint32_t)(__CLK48_SOURCE__))__HAL_RCC_GET_CEC_SOURCE()((uint32_t)(READ_BIT(RCC->DCKCFGR2, RCC_DCKCFGR2_CECSEL)))__HAL_RCC_CEC_CONFIG(__CEC_CLKSOURCE__)MODIFY_REG(RCC->DCKCFGR2, RCC_DCKCFGR2_CECSEL, (uint32_t)(__CEC_CLKSOURCE__))__HAL_RCC_GET_LPTIM1_SOURCE()((uint32_t)(READ_BIT(RCC->DCKCFGR2, RCC_DCKCFGR2_LPTIM1SEL)))__HAL_RCC_LPTIM1_CONFIG(__LPTIM1_CLKSOURCE__)MODIFY_REG(RCC->DCKCFGR2, RCC_DCKCFGR2_LPTIM1SEL, (uint32_t)(__LPTIM1_CLKSOURCE__))__HAL_RCC_GET_UART8_SOURCE()((uint32_t)(READ_BIT(RCC->DCKCFGR2, RCC_DCKCFGR2_UART8SEL)))__HAL_RCC_UART8_CONFIG(__UART8_CLKSOURCE__)MODIFY_REG(RCC->DCKCFGR2, RCC_DCKCFGR2_UART8SEL, (uint32_t)(__UART8_CLKSOURCE__))__HAL_RCC_GET_UART7_SOURCE()((uint32_t)(READ_BIT(RCC->DCKCFGR2, RCC_DCKCFGR2_UART7SEL)))__HAL_RCC_UART7_CONFIG(__UART7_CLKSOURCE__)MODIFY_REG(RCC->DCKCFGR2, RCC_DCKCFGR2_UART7SEL, (uint32_t)(__UART7_CLKSOURCE__))__HAL_RCC_GET_USART6_SOURCE()((uint32_t)(READ_BIT(RCC->DCKCFGR2, RCC_DCKCFGR2_USART6SEL)))__HAL_RCC_USART6_CONFIG(__USART6_CLKSOURCE__)MODIFY_REG(RCC->DCKCFGR2, RCC_DCKCFGR2_USART6SEL, (uint32_t)(__USART6_CLKSOURCE__))__HAL_RCC_GET_UART5_SOURCE()((uint32_t)(READ_BIT(RCC->DCKCFGR2, RCC_DCKCFGR2_UART5SEL)))__HAL_RCC_UART5_CONFIG(__UART5_CLKSOURCE__)MODIFY_REG(RCC->DCKCFGR2, RCC_DCKCFGR2_UART5SEL, (uint32_t)(__UART5_CLKSOURCE__))__HAL_RCC_GET_UART4_SOURCE()((uint32_t)(READ_BIT(RCC->DCKCFGR2, RCC_DCKCFGR2_UART4SEL)))__HAL_RCC_UART4_CONFIG(__UART4_CLKSOURCE__)MODIFY_REG(RCC->DCKCFGR2, RCC_DCKCFGR2_UART4SEL, (uint32_t)(__UART4_CLKSOURCE__))__HAL_RCC_GET_USART3_SOURCE()((uint32_t)(READ_BIT(RCC->DCKCFGR2, RCC_DCKCFGR2_USART3SEL)))__HAL_RCC_USART3_CONFIG(__USART3_CLKSOURCE__)MODIFY_REG(RCC->DCKCFGR2, RCC_DCKCFGR2_USART3SEL, (uint32_t)(__USART3_CLKSOURCE__))__HAL_RCC_GET_USART2_SOURCE()((uint32_t)(READ_BIT(RCC->DCKCFGR2, RCC_DCKCFGR2_USART2SEL)))__HAL_RCC_USART2_CONFIG(__USART2_CLKSOURCE__)MODIFY_REG(RCC->DCKCFGR2, RCC_DCKCFGR2_USART2SEL, (uint32_t)(__USART2_CLKSOURCE__))__HAL_RCC_GET_USART1_SOURCE()((uint32_t)(READ_BIT(RCC->DCKCFGR2, RCC_DCKCFGR2_USART1SEL)))__HAL_RCC_USART1_CONFIG(__USART1_CLKSOURCE__)MODIFY_REG(RCC->DCKCFGR2, RCC_DCKCFGR2_USART1SEL, (uint32_t)(__USART1_CLKSOURCE__))__HAL_RCC_GET_I2C4_SOURCE()((uint32_t)(READ_BIT(RCC->DCKCFGR2, RCC_DCKCFGR2_I2C4SEL)))__HAL_RCC_I2C4_CONFIG(__I2C4_CLKSOURCE__)MODIFY_REG(RCC->DCKCFGR2, RCC_DCKCFGR2_I2C4SEL, (uint32_t)(__I2C4_CLKSOURCE__))__HAL_RCC_GET_I2C3_SOURCE()((uint32_t)(READ_BIT(RCC->DCKCFGR2, RCC_DCKCFGR2_I2C3SEL)))__HAL_RCC_I2C3_CONFIG(__I2C3_CLKSOURCE__)MODIFY_REG(RCC->DCKCFGR2, RCC_DCKCFGR2_I2C3SEL, (uint32_t)(__I2C3_CLKSOURCE__))__HAL_RCC_GET_I2C2_SOURCE()((uint32_t)(READ_BIT(RCC->DCKCFGR2, RCC_DCKCFGR2_I2C2SEL)))__HAL_RCC_I2C2_CONFIG(__I2C2_CLKSOURCE__)MODIFY_REG(RCC->DCKCFGR2, RCC_DCKCFGR2_I2C2SEL, (uint32_t)(__I2C2_CLKSOURCE__))__HAL_RCC_GET_I2C1_SOURCE()((uint32_t)(READ_BIT(RCC->DCKCFGR2, RCC_DCKCFGR2_I2C1SEL)))__HAL_RCC_I2C1_CONFIG(__I2C1_CLKSOURCE__)MODIFY_REG(RCC->DCKCFGR2, RCC_DCKCFGR2_I2C1SEL, (uint32_t)(__I2C1_CLKSOURCE__))__HAL_RCC_GET_I2SCLKSOURCE()(READ_BIT(RCC->CFGR, RCC_CFGR_I2SSRC))__HAL_RCC_PLLSAI_GET_FLAG()((RCC->CR & (RCC_CR_PLLSAIRDY)) == (RCC_CR_PLLSAIRDY))__HAL_RCC_PLLSAI_GET_IT()((RCC->CIR & (RCC_CIR_PLLSAIRDYIE)) == (RCC_CIR_PLLSAIRDYIE))__HAL_RCC_PLLSAI_CLEAR_IT()(RCC->CIR |= (RCC_CIR_PLLSAIRDYF))__HAL_RCC_PLLSAI_DISABLE_IT()(RCC->CIR &= ~(RCC_CIR_PLLSAIRDYIE))__HAL_RCC_PLLSAI_ENABLE_IT()(RCC->CIR |= (RCC_CIR_PLLSAIRDYIE))__HAL_RCC_GET_SAI2_SOURCE()((uint32_t)(READ_BIT(RCC->DCKCFGR1, RCC_DCKCFGR1_SAI2SEL)))__HAL_RCC_SAI2_CONFIG(__SOURCE__)MODIFY_REG(RCC->DCKCFGR1, RCC_DCKCFGR1_SAI2SEL, (uint32_t)(__SOURCE__))__HAL_RCC_GET_SAI1_SOURCE()((uint32_t)(READ_BIT(RCC->DCKCFGR1, RCC_DCKCFGR1_SAI1SEL)))__HAL_RCC_SAI1_CONFIG(__SOURCE__)MODIFY_REG(RCC->DCKCFGR1, RCC_DCKCFGR1_SAI1SEL, (uint32_t)(__SOURCE__))__HAL_RCC_PLLSAI_PLLSAICLKDIVR_CONFIG(__PLLSAIDivR__)MODIFY_REG(RCC->DCKCFGR1, RCC_DCKCFGR1_PLLSAIDIVR, (uint32_t)(__PLLSAIDivR__))__HAL_RCC_PLLSAI_PLLSAICLKDIVQ_CONFIG(__PLLSAIDivQ__)(MODIFY_REG(RCC->DCKCFGR1, RCC_DCKCFGR1_PLLSAIDIVQ, ((__PLLSAIDivQ__)-1)<<8))__HAL_RCC_PLLI2S_PLLSAICLKDIVQ_CONFIG(__PLLI2SDivQ__)(MODIFY_REG(RCC->DCKCFGR1, RCC_DCKCFGR1_PLLI2SDIVQ, (__PLLI2SDivQ__)-1))__HAL_RCC_PLLI2S_CONFIG(__PLLI2SN__,__PLLI2SP__,__PLLI2SQ__,__PLLI2SR__)(RCC->PLLI2SCFGR = ((__PLLI2SN__) << RCC_PLLI2SCFGR_PLLI2SN_Pos) | ((__PLLI2SP__) << RCC_PLLI2SCFGR_PLLI2SP_Pos) | ((__PLLI2SQ__) << RCC_PLLI2SCFGR_PLLI2SQ_Pos) | ((__PLLI2SR__) << RCC_PLLI2SCFGR_PLLI2SR_Pos))__HAL_RCC_PLLSAI_CONFIG(__PLLSAIN__,__PLLSAIP__,__PLLSAIQ__,__PLLSAIR__)(RCC->PLLSAICFGR = ((__PLLSAIN__) << RCC_PLLSAICFGR_PLLSAIN_Pos) | ((__PLLSAIP__) << RCC_PLLSAICFGR_PLLSAIP_Pos) | ((__PLLSAIQ__) << RCC_PLLSAICFGR_PLLSAIQ_Pos) | ((__PLLSAIR__) << RCC_PLLSAICFGR_PLLSAIR_Pos))__HAL_RCC_PLLSAI_DISABLE()(RCC->CR &= ~(RCC_CR_PLLSAION))__HAL_RCC_PLLSAI_ENABLE()(RCC->CR |= (RCC_CR_PLLSAION))__HAL_RCC_TIMCLKPRESCALER(__PRESC__)do {RCC->DCKCFGR1 &= ~(RCC_DCKCFGR1_TIMPRE); RCC->DCKCFGR1 |= (__PRESC__); }while(0)__HAL_RCC_PLL_CONFIG(__RCC_PLLSource__,__PLLM__,__PLLN__,__PLLP__,__PLLQ__,__PLLR__)(RCC->PLLCFGR = ((__RCC_PLLSource__) | (__PLLM__) | ((__PLLN__) << RCC_PLLCFGR_PLLN_Pos) | ((((__PLLP__) >> 1) -1) << RCC_PLLCFGR_PLLP_Pos) | ((__PLLQ__) << RCC_PLLCFGR_PLLQ_Pos) | ((__PLLR__) << RCC_PLLCFGR_PLLR_Pos)))__HAL_RCC_SPI6_IS_CLK_SLEEP_DISABLED()((RCC->APB2LPENR & (RCC_APB2LPENR_SPI6LPEN)) == RESET)__HAL_RCC_SPI6_IS_CLK_SLEEP_ENABLED()((RCC->APB2LPENR & (RCC_APB2LPENR_SPI6LPEN)) != RESET)__HAL_RCC_MDIO_IS_CLK_SLEEP_DISABLED()((RCC->APB2LPENR & (RCC_APB2LPENR_MDIOLPEN)) == RESET)__HAL_RCC_DFSDM1_IS_CLK_SLEEP_DISABLED()((RCC->APB2LPENR & (RCC_APB2LPENR_DFSDM1LPEN)) == RESET)__HAL_RCC_SDMMC2_IS_CLK_SLEEP_DISABLED()((RCC->APB2LPENR & (RCC_APB2LPENR_SDMMC2LPEN)) == RESET)__HAL_RCC_DSI_IS_CLK_SLEEP_DISABLED()((RCC->APB2LPENR & (RCC_APB2LPENR_DSILPEN)) == RESET)__HAL_RCC_LTDC_IS_CLK_SLEEP_DISABLED()((RCC->APB2LPENR & (RCC_APB2LPENR_LTDCLPEN)) == RESET)__HAL_RCC_SAI2_IS_CLK_SLEEP_DISABLED()((RCC->APB2LPENR & (RCC_APB2LPENR_SAI2LPEN)) == RESET)__HAL_RCC_SAI1_IS_CLK_SLEEP_DISABLED()((RCC->APB2LPENR & (RCC_APB2LPENR_SAI1LPEN)) == RESET)__HAL_RCC_SPI5_IS_CLK_SLEEP_DISABLED()((RCC->APB2LPENR & (RCC_APB2LPENR_SPI5LPEN)) == RESET)__HAL_RCC_TIM11_IS_CLK_SLEEP_DISABLED()((RCC->APB2LPENR & (RCC_APB2LPENR_TIM11LPEN)) == RESET)__HAL_RCC_TIM10_IS_CLK_SLEEP_DISABLED()((RCC->APB2LPENR & (RCC_APB2LPENR_TIM10LPEN)) == RESET)__HAL_RCC_TIM9_IS_CLK_SLEEP_DISABLED()((RCC->APB2LPENR & (RCC_APB2LPENR_TIM9LPEN)) == RESET)__HAL_RCC_SPI4_IS_CLK_SLEEP_DISABLED()((RCC->APB2LPENR & (RCC_APB2LPENR_SPI4LPEN)) == RESET)__HAL_RCC_SPI1_IS_CLK_SLEEP_DISABLED()((RCC->APB2LPENR & (RCC_APB2LPENR_SPI1LPEN)) == RESET)__HAL_RCC_SDMMC1_IS_CLK_SLEEP_DISABLED()((RCC->APB2LPENR & (RCC_APB2LPENR_SDMMC1LPEN)) == RESET)__HAL_RCC_ADC3_IS_CLK_SLEEP_DISABLED()((RCC->APB2LPENR & (RCC_APB2LPENR_ADC3LPEN)) == RESET)__HAL_RCC_ADC2_IS_CLK_SLEEP_DISABLED()((RCC->APB2LPENR & (RCC_APB2LPENR_ADC2LPEN)) == RESET)__HAL_RCC_ADC1_IS_CLK_SLEEP_DISABLED()((RCC->APB2LPENR & (RCC_APB2LPENR_ADC1LPEN)) == RESET)__HAL_RCC_USART6_IS_CLK_SLEEP_DISABLED()((RCC->APB2LPENR & (RCC_APB2LPENR_USART6LPEN)) == RESET)__HAL_RCC_USART1_IS_CLK_SLEEP_DISABLED()((RCC->APB2LPENR & (RCC_APB2LPENR_USART1LPEN)) == RESET)__HAL_RCC_TIM8_IS_CLK_SLEEP_DISABLED()((RCC->APB2LPENR & (RCC_APB2LPENR_TIM8LPEN)) == RESET)__HAL_RCC_TIM1_IS_CLK_SLEEP_DISABLED()((RCC->APB2LPENR & (RCC_APB2LPENR_TIM1LPEN)) == RESET)__HAL_RCC_MDIO_IS_CLK_SLEEP_ENABLED()((RCC->APB2LPENR & (RCC_APB2LPENR_MDIOLPEN)) != RESET)__HAL_RCC_DFSDM1_IS_CLK_SLEEP_ENABLED()((RCC->APB2LPENR & (RCC_APB2LPENR_DFSDM1LPEN)) != RESET)__HAL_RCC_SDMMC2_IS_CLK_SLEEP_ENABLED()((RCC->APB2LPENR & (RCC_APB2LPENR_SDMMC2LPEN)) != RESET)__HAL_RCC_DSI_IS_CLK_SLEEP_ENABLED()((RCC->APB2LPENR & (RCC_APB2LPENR_DSILPEN)) != RESET)__HAL_RCC_LTDC_IS_CLK_SLEEP_ENABLED()((RCC->APB2LPENR & (RCC_APB2LPENR_LTDCLPEN)) != RESET)__HAL_RCC_SAI2_IS_CLK_SLEEP_ENABLED()((RCC->APB2LPENR & (RCC_APB2LPENR_SAI2LPEN)) != RESET)__HAL_RCC_SAI1_IS_CLK_SLEEP_ENABLED()((RCC->APB2LPENR & (RCC_APB2LPENR_SAI1LPEN)) != RESET)__HAL_RCC_SPI5_IS_CLK_SLEEP_ENABLED()((RCC->APB2LPENR & (RCC_APB2LPENR_SPI5LPEN)) != RESET)__HAL_RCC_TIM11_IS_CLK_SLEEP_ENABLED()((RCC->APB2LPENR & (RCC_APB2LPENR_TIM11LPEN)) != RESET)__HAL_RCC_TIM10_IS_CLK_SLEEP_ENABLED()((RCC->APB2LPENR & (RCC_APB2LPENR_TIM10LPEN)) != RESET)__HAL_RCC_TIM9_IS_CLK_SLEEP_ENABLED()((RCC->APB2LPENR & (RCC_APB2LPENR_TIM9LPEN)) != RESET)__HAL_RCC_SPI4_IS_CLK_SLEEP_ENABLED()((RCC->APB2LPENR & (RCC_APB2LPENR_SPI4LPEN)) != RESET)__HAL_RCC_SPI1_IS_CLK_SLEEP_ENABLED()((RCC->APB2LPENR & (RCC_APB2LPENR_SPI1LPEN)) != RESET)__HAL_RCC_SDMMC1_IS_CLK_SLEEP_ENABLED()((RCC->APB2LPENR & (RCC_APB2LPENR_SDMMC1LPEN)) != RESET)__HAL_RCC_ADC3_IS_CLK_SLEEP_ENABLED()((RCC->APB2LPENR & (RCC_APB2LPENR_ADC3LPEN)) != RESET)__HAL_RCC_ADC2_IS_CLK_SLEEP_ENABLED()((RCC->APB2LPENR & (RCC_APB2LPENR_ADC2LPEN)) != RESET)__HAL_RCC_ADC1_IS_CLK_SLEEP_ENABLED()((RCC->APB2LPENR & (RCC_APB2LPENR_ADC1LPEN)) != RESET)__HAL_RCC_USART6_IS_CLK_SLEEP_ENABLED()((RCC->APB2LPENR & (RCC_APB2LPENR_USART6LPEN)) != RESET)__HAL_RCC_USART1_IS_CLK_SLEEP_ENABLED()((RCC->APB2LPENR & (RCC_APB2LPENR_USART1LPEN)) != RESET)__HAL_RCC_TIM8_IS_CLK_SLEEP_ENABLED()((RCC->APB2LPENR & (RCC_APB2LPENR_TIM8LPEN)) != RESET)__HAL_RCC_TIM1_IS_CLK_SLEEP_ENABLED()((RCC->APB2LPENR & (RCC_APB2LPENR_TIM1LPEN)) != RESET)__HAL_RCC_CEC_IS_CLK_SLEEP_DISABLED()((RCC->APB1LPENR & (RCC_APB1LPENR_CECLPEN)) == RESET)__HAL_RCC_CAN2_IS_CLK_SLEEP_DISABLED()((RCC->APB1LPENR & (RCC_APB1LPENR_CAN2LPEN)) == RESET)__HAL_RCC_I2C4_IS_CLK_SLEEP_DISABLED()((RCC->APB1LPENR & (RCC_APB1LPENR_I2C4LPEN)) == RESET)__HAL_RCC_SPDIFRX_IS_CLK_SLEEP_DISABLED()((RCC->APB1LPENR & (RCC_APB1LPENR_SPDIFRXLPEN)) == RESET)__HAL_RCC_CEC_IS_CLK_SLEEP_ENABLED()((RCC->APB1LPENR & (RCC_APB1LPENR_CECLPEN)) != RESET)__HAL_RCC_CAN2_IS_CLK_SLEEP_ENABLED()((RCC->APB1LPENR & (RCC_APB1LPENR_CAN2LPEN)) != RESET)__HAL_RCC_I2C4_IS_CLK_SLEEP_ENABLED()((RCC->APB1LPENR & (RCC_APB1LPENR_I2C4LPEN)) != RESET)__HAL_RCC_SPDIFRX_IS_CLK_SLEEP_ENABLED()((RCC->APB1LPENR & (RCC_APB1LPENR_SPDIFRXLPEN)) != RESET)__HAL_RCC_UART8_IS_CLK_SLEEP_DISABLED()((RCC->APB1LPENR & (RCC_APB1LPENR_UART8LPEN)) == RESET)__HAL_RCC_UART7_IS_CLK_SLEEP_DISABLED()((RCC->APB1LPENR & (RCC_APB1LPENR_UART7LPEN)) == RESET)__HAL_RCC_DAC_IS_CLK_SLEEP_DISABLED()((RCC->APB1LPENR & (RCC_APB1LPENR_DACLPEN)) == RESET)__HAL_RCC_CAN1_IS_CLK_SLEEP_DISABLED()((RCC->APB1LPENR & (RCC_APB1LPENR_CAN1LPEN)) == RESET)__HAL_RCC_I2C3_IS_CLK_SLEEP_DISABLED()((RCC->APB1LPENR & (RCC_APB1LPENR_I2C3LPEN)) == RESET)__HAL_RCC_I2C2_IS_CLK_SLEEP_DISABLED()((RCC->APB1LPENR & (RCC_APB1LPENR_I2C2LPEN)) == RESET)__HAL_RCC_I2C1_IS_CLK_SLEEP_DISABLED()((RCC->APB1LPENR & (RCC_APB1LPENR_I2C1LPEN)) == RESET)__HAL_RCC_UART5_IS_CLK_SLEEP_DISABLED()((RCC->APB1LPENR & (RCC_APB1LPENR_UART5LPEN)) == RESET)__HAL_RCC_UART4_IS_CLK_SLEEP_DISABLED()((RCC->APB1LPENR & (RCC_APB1LPENR_UART4LPEN)) == RESET)__HAL_RCC_USART3_IS_CLK_SLEEP_DISABLED()((RCC->APB1LPENR & (RCC_APB1LPENR_USART3LPEN)) == RESET)__HAL_RCC_USART2_IS_CLK_SLEEP_DISABLED()((RCC->APB1LPENR & (RCC_APB1LPENR_USART2LPEN)) == RESET)__HAL_RCC_SPI3_IS_CLK_SLEEP_DISABLED()((RCC->APB1LPENR & (RCC_APB1LPENR_SPI3LPEN)) == RESET)__HAL_RCC_SPI2_IS_CLK_SLEEP_DISABLED()((RCC->APB1LPENR & (RCC_APB1LPENR_SPI2LPEN)) == RESET)__HAL_RCC_CAN3_IS_CLK_SLEEP_DISABLED()((RCC->APB1LPENR & (RCC_APB1LPENR_CAN3LPEN)) == RESET)__HAL_RCC_RTC_IS_CLK_SLEEP_DISABLED()((RCC->APB1LPENR & (RCC_APB1LPENR_RTCLPEN)) == RESET)__HAL_RCC_LPTIM1_IS_CLK_SLEEP_DISABLED()((RCC->APB1LPENR & (RCC_APB1LPENR_LPTIM1LPEN)) == RESET)__HAL_RCC_TIM14_IS_CLK_SLEEP_DISABLED()((RCC->APB1LPENR & (RCC_APB1LPENR_TIM14LPEN)) == RESET)__HAL_RCC_TIM13_IS_CLK_SLEEP_DISABLED()((RCC->APB1LPENR & (RCC_APB1LPENR_TIM13LPEN)) == RESET)__HAL_RCC_TIM12_IS_CLK_SLEEP_DISABLED()((RCC->APB1LPENR & (RCC_APB1LPENR_TIM12LPEN)) == RESET)__HAL_RCC_TIM7_IS_CLK_SLEEP_DISABLED()((RCC->APB1LPENR & (RCC_APB1LPENR_TIM7LPEN)) == RESET)__HAL_RCC_TIM6_IS_CLK_SLEEP_DISABLED()((RCC->APB1LPENR & (RCC_APB1LPENR_TIM6LPEN)) == RESET)__HAL_RCC_TIM5_IS_CLK_SLEEP_DISABLED()((RCC->APB1LPENR & (RCC_APB1LPENR_TIM5LPEN)) == RESET)__HAL_RCC_TIM4_IS_CLK_SLEEP_DISABLED()((RCC->APB1LPENR & (RCC_APB1LPENR_TIM4LPEN)) == RESET)__HAL_RCC_TIM3_IS_CLK_SLEEP_DISABLED()((RCC->APB1LPENR & (RCC_APB1LPENR_TIM3LPEN)) == RESET)__HAL_RCC_TIM2_IS_CLK_SLEEP_DISABLED()((RCC->APB1LPENR & (RCC_APB1LPENR_TIM2LPEN)) == RESET)__HAL_RCC_UART8_IS_CLK_SLEEP_ENABLED()((RCC->APB1LPENR & (RCC_APB1LPENR_UART8LPEN)) != RESET)__HAL_RCC_UART7_IS_CLK_SLEEP_ENABLED()((RCC->APB1LPENR & (RCC_APB1LPENR_UART7LPEN)) != RESET)__HAL_RCC_DAC_IS_CLK_SLEEP_ENABLED()((RCC->APB1LPENR & (RCC_APB1LPENR_DACLPEN)) != RESET)__HAL_RCC_CAN1_IS_CLK_SLEEP_ENABLED()((RCC->APB1LPENR & (RCC_APB1LPENR_CAN1LPEN)) != RESET)__HAL_RCC_I2C3_IS_CLK_SLEEP_ENABLED()((RCC->APB1LPENR & (RCC_APB1LPENR_I2C3LPEN)) != RESET)__HAL_RCC_I2C2_IS_CLK_SLEEP_ENABLED()((RCC->APB1LPENR & (RCC_APB1LPENR_I2C2LPEN)) != RESET)__HAL_RCC_I2C1_IS_CLK_SLEEP_ENABLED()((RCC->APB1LPENR & (RCC_APB1LPENR_I2C1LPEN)) != RESET)__HAL_RCC_UART5_IS_CLK_SLEEP_ENABLED()((RCC->APB1LPENR & (RCC_APB1LPENR_UART5LPEN)) != RESET)__HAL_RCC_UART4_IS_CLK_SLEEP_ENABLED()((RCC->APB1LPENR & (RCC_APB1LPENR_UART4LPEN)) != RESET)__HAL_RCC_USART3_IS_CLK_SLEEP_ENABLED()((RCC->APB1LPENR & (RCC_APB1LPENR_USART3LPEN)) != RESET)__HAL_RCC_USART2_IS_CLK_SLEEP_ENABLED()((RCC->APB1LPENR & (RCC_APB1LPENR_USART2LPEN)) != RESET)__HAL_RCC_SPI3_IS_CLK_SLEEP_ENABLED()((RCC->APB1LPENR & (RCC_APB1LPENR_SPI3LPEN)) != RESET)__HAL_RCC_SPI2_IS_CLK_SLEEP_ENABLED()((RCC->APB1LPENR & (RCC_APB1LPENR_SPI2LPEN)) != RESET)__HAL_RCC_CAN3_IS_CLK_SLEEP_ENABLED()((RCC->APB1LPENR & (RCC_APB1LPENR_CAN3LPEN)) != RESET)__HAL_RCC_RTC_IS_CLK_SLEEP_ENABLED()((RCC->APB1LPENR & (RCC_APB1LPENR_RTCLPEN)) != RESET)__HAL_RCC_LPTIM1_IS_CLK_SLEEP_ENABLED()((RCC->APB1LPENR & (RCC_APB1LPENR_LPTIM1LPEN)) != RESET)__HAL_RCC_TIM14_IS_CLK_SLEEP_ENABLED()((RCC->APB1LPENR & (RCC_APB1LPENR_TIM14LPEN)) != RESET)__HAL_RCC_TIM13_IS_CLK_SLEEP_ENABLED()((RCC->APB1LPENR & (RCC_APB1LPENR_TIM13LPEN)) != RESET)__HAL_RCC_TIM12_IS_CLK_SLEEP_ENABLED()((RCC->APB1LPENR & (RCC_APB1LPENR_TIM12LPEN)) != RESET)__HAL_RCC_TIM7_IS_CLK_SLEEP_ENABLED()((RCC->APB1LPENR & (RCC_APB1LPENR_TIM7LPEN)) != RESET)__HAL_RCC_TIM6_IS_CLK_SLEEP_ENABLED()((RCC->APB1LPENR & (RCC_APB1LPENR_TIM6LPEN)) != RESET)__HAL_RCC_TIM5_IS_CLK_SLEEP_ENABLED()((RCC->APB1LPENR & (RCC_APB1LPENR_TIM5LPEN)) != RESET)__HAL_RCC_TIM4_IS_CLK_SLEEP_ENABLED()((RCC->APB1LPENR & (RCC_APB1LPENR_TIM4LPEN)) != RESET)__HAL_RCC_TIM3_IS_CLK_SLEEP_ENABLED()((RCC->APB1LPENR & (RCC_APB1LPENR_TIM3LPEN)) != RESET)__HAL_RCC_TIM2_IS_CLK_SLEEP_ENABLED()((RCC->APB1LPENR & (RCC_APB1LPENR_TIM2LPEN)) != RESET)__HAL_RCC_QSPI_IS_CLK_SLEEP_DISABLED()((RCC->AHB3LPENR & (RCC_AHB3LPENR_QSPILPEN)) == RESET)__HAL_RCC_QSPI_IS_CLK_SLEEP_ENABLED()((RCC->AHB3LPENR & (RCC_AHB3LPENR_QSPILPEN)) != RESET)__HAL_RCC_FMC_IS_CLK_SLEEP_DISABLED()((RCC->AHB3LPENR & (RCC_AHB3LPENR_FMCLPEN)) == RESET)__HAL_RCC_FMC_IS_CLK_SLEEP_ENABLED()((RCC->AHB3LPENR & (RCC_AHB3LPENR_FMCLPEN)) != RESET)__HAL_RCC_USB_OTG_FS_IS_CLK_SLEEP_DISABLED()((RCC->AHB2LPENR & (RCC_AHB2LPENR_OTGFSLPEN)) == RESET)__HAL_RCC_USB_OTG_FS_IS_CLK_SLEEP_ENABLED()((RCC->AHB2LPENR & (RCC_AHB2LPENR_OTGFSLPEN)) != RESET)__HAL_RCC_RNG_IS_CLK_SLEEP_DISABLED()((RCC->AHB2LPENR & (RCC_AHB2LPENR_RNGLPEN)) == RESET)__HAL_RCC_RNG_IS_CLK_SLEEP_ENABLED()((RCC->AHB2LPENR & (RCC_AHB2LPENR_RNGLPEN)) != RESET)__HAL_RCC_JPEG_IS_CLK_SLEEP_DISABLED()((RCC->AHB2LPENR & (RCC_AHB2LPENR_JPEGLPEN)) == RESET)__HAL_RCC_JPEG_IS_CLK_SLEEP_ENABLED()((RCC->AHB2LPENR & (RCC_AHB2LPENR_JPEGLPEN)) != RESET)__HAL_RCC_DCMI_IS_CLK_SLEEP_DISABLED()((RCC->AHB2LPENR & (RCC_AHB2LPENR_DCMILPEN)) == RESET)__HAL_RCC_DCMI_IS_CLK_SLEEP_ENABLED()((RCC->AHB2LPENR & (RCC_AHB2LPENR_DCMILPEN)) != RESET)__HAL_RCC_GPIOK_IS_CLK_SLEEP_DISABLED()((RCC->AHB1LPENR & (RCC_AHB1LPENR_GPIOKLPEN)) == RESET)__HAL_RCC_GPIOJ_IS_CLK_SLEEP_DISABLED()((RCC->AHB1LPENR & (RCC_AHB1LPENR_GPIOJLPEN)) == RESET)__HAL_RCC_ETHMACPTP_IS_CLK_SLEEP_DISABLED()((RCC->AHB1LPENR & (RCC_AHB1LPENR_ETHMACPTPLPEN)) == RESET)__HAL_RCC_ETHMACRX_IS_CLK_SLEEP_DISABLED()((RCC->AHB1LPENR & (RCC_AHB1LPENR_ETHMACRXLPEN)) == RESET)__HAL_RCC_ETHMACTX_IS_CLK_SLEEP_DISABLED()((RCC->AHB1LPENR & (RCC_AHB1LPENR_ETHMACTXLPEN)) == RESET)__HAL_RCC_ETHMAC_IS_CLK_SLEEP_DISABLED()((RCC->AHB1LPENR & (RCC_AHB1LPENR_ETHMACLPEN)) == RESET)__HAL_RCC_DMA2D_IS_CLK_SLEEP_DISABLED()((RCC->AHB1LPENR & (RCC_AHB1LPENR_DMA2DLPEN)) == RESET)__HAL_RCC_GPIOK_IS_CLK_SLEEP_ENABLED()((RCC->AHB1LPENR & (RCC_AHB1LPENR_GPIOKLPEN)) != RESET)__HAL_RCC_GPIOJ_IS_CLK_SLEEP_ENABLED()((RCC->AHB1LPENR & (RCC_AHB1LPENR_GPIOJLPEN)) != RESET)__HAL_RCC_ETHMACPTP_IS_CLK_SLEEP_ENABLED()((RCC->AHB1LPENR & (RCC_AHB1LPENR_ETHMACPTPLPEN)) != RESET)__HAL_RCC_ETHMACRX_IS_CLK_SLEEP_ENABLED()((RCC->AHB1LPENR & (RCC_AHB1LPENR_ETHMACRXLPEN)) != RESET)__HAL_RCC_ETHMACTX_IS_CLK_SLEEP_ENABLED()((RCC->AHB1LPENR & (RCC_AHB1LPENR_ETHMACTXLPEN)) != RESET)__HAL_RCC_ETHMAC_IS_CLK_SLEEP_ENABLED()((RCC->AHB1LPENR & (RCC_AHB1LPENR_ETHMACLPEN)) != RESET)__HAL_RCC_DMA2D_IS_CLK_SLEEP_ENABLED()((RCC->AHB1LPENR & (RCC_AHB1LPENR_DMA2DLPEN)) != RESET)__HAL_RCC_GPIOI_IS_CLK_SLEEP_DISABLED()((RCC->AHB1LPENR & (RCC_AHB1LPENR_GPIOILPEN)) == RESET)__HAL_RCC_GPIOH_IS_CLK_SLEEP_DISABLED()((RCC->AHB1LPENR & (RCC_AHB1LPENR_GPIOHLPEN)) == RESET)__HAL_RCC_GPIOG_IS_CLK_SLEEP_DISABLED()((RCC->AHB1LPENR & (RCC_AHB1LPENR_GPIOGLPEN)) == RESET)__HAL_RCC_GPIOF_IS_CLK_SLEEP_DISABLED()((RCC->AHB1LPENR & (RCC_AHB1LPENR_GPIOFLPEN)) == RESET)__HAL_RCC_GPIOE_IS_CLK_SLEEP_DISABLED()((RCC->AHB1LPENR & (RCC_AHB1LPENR_GPIOELPEN)) == RESET)__HAL_RCC_GPIOD_IS_CLK_SLEEP_DISABLED()((RCC->AHB1LPENR & (RCC_AHB1LPENR_GPIODLPEN)) == RESET)__HAL_RCC_GPIOC_IS_CLK_SLEEP_DISABLED()((RCC->AHB1LPENR & (RCC_AHB1LPENR_GPIOCLPEN)) == RESET)__HAL_RCC_GPIOB_IS_CLK_SLEEP_DISABLED()((RCC->AHB1LPENR & (RCC_AHB1LPENR_GPIOBLPEN)) == RESET)__HAL_RCC_GPIOA_IS_CLK_SLEEP_DISABLED()((RCC->AHB1LPENR & (RCC_AHB1LPENR_GPIOALPEN)) == RESET)__HAL_RCC_USB_OTG_HS_ULPI_IS_CLK_SLEEP_DISABLED()((RCC->AHB1LPENR & (RCC_AHB1LPENR_OTGHSULPILPEN)) == RESET)__HAL_RCC_USB_OTG_HS_IS_CLK_SLEEP_DISABLED()((RCC->AHB1LPENR & (RCC_AHB1LPENR_OTGHSLPEN)) == RESET)__HAL_RCC_DMA2_IS_CLK_SLEEP_DISABLED()((RCC->AHB1LPENR & (RCC_AHB1LPENR_DMA2LPEN)) == RESET)__HAL_RCC_DTCM_IS_CLK_SLEEP_DISABLED()((RCC->AHB1LPENR & (RCC_AHB1LPENR_DTCMLPEN)) == RESET)__HAL_RCC_BKPSRAM_IS_CLK_SLEEP_DISABLED()((RCC->AHB1LPENR & (RCC_AHB1LPENR_BKPSRAMLPEN)) == RESET)__HAL_RCC_SRAM2_IS_CLK_SLEEP_DISABLED()((RCC->AHB1LPENR & (RCC_AHB1LPENR_SRAM2LPEN)) == RESET)__HAL_RCC_SRAM1_IS_CLK_SLEEP_DISABLED()((RCC->AHB1LPENR & (RCC_AHB1LPENR_SRAM1LPEN)) == RESET)__HAL_RCC_AXI_IS_CLK_SLEEP_DISABLED()((RCC->AHB1LPENR & (RCC_AHB1LPENR_AXILPEN)) == RESET)__HAL_RCC_FLITF_IS_CLK_SLEEP_DISABLED()((RCC->AHB1LPENR & (RCC_AHB1LPENR_FLITFLPEN)) == RESET)__HAL_RCC_GPIOI_IS_CLK_SLEEP_ENABLED()((RCC->AHB1LPENR & (RCC_AHB1LPENR_GPIOILPEN)) != RESET)__HAL_RCC_GPIOH_IS_CLK_SLEEP_ENABLED()((RCC->AHB1LPENR & (RCC_AHB1LPENR_GPIOHLPEN)) != RESET)__HAL_RCC_GPIOG_IS_CLK_SLEEP_ENABLED()((RCC->AHB1LPENR & (RCC_AHB1LPENR_GPIOGLPEN)) != RESET)__HAL_RCC_GPIOF_IS_CLK_SLEEP_ENABLED()((RCC->AHB1LPENR & (RCC_AHB1LPENR_GPIOFLPEN)) != RESET)__HAL_RCC_GPIOE_IS_CLK_SLEEP_ENABLED()((RCC->AHB1LPENR & (RCC_AHB1LPENR_GPIOELPEN)) != RESET)__HAL_RCC_GPIOD_IS_CLK_SLEEP_ENABLED()((RCC->AHB1LPENR & (RCC_AHB1LPENR_GPIODLPEN)) != RESET)__HAL_RCC_GPIOC_IS_CLK_SLEEP_ENABLED()((RCC->AHB1LPENR & (RCC_AHB1LPENR_GPIOCLPEN)) != RESET)__HAL_RCC_GPIOB_IS_CLK_SLEEP_ENABLED()((RCC->AHB1LPENR & (RCC_AHB1LPENR_GPIOBLPEN)) != RESET)__HAL_RCC_GPIOA_IS_CLK_SLEEP_ENABLED()((RCC->AHB1LPENR & (RCC_AHB1LPENR_GPIOALPEN)) != RESET)__HAL_RCC_USB_OTG_HS_ULPI_IS_CLK_SLEEP_ENABLED()((RCC->AHB1LPENR & (RCC_AHB1LPENR_OTGHSULPILPEN)) != RESET)__HAL_RCC_USB_OTG_HS_IS_CLK_SLEEP_ENABLED()((RCC->AHB1LPENR & (RCC_AHB1LPENR_OTGHSLPEN)) != RESET)__HAL_RCC_DMA2_IS_CLK_SLEEP_ENABLED()((RCC->AHB1LPENR & (RCC_AHB1LPENR_DMA2LPEN)) != RESET)__HAL_RCC_DTCM_IS_CLK_SLEEP_ENABLED()((RCC->AHB1LPENR & (RCC_AHB1LPENR_DTCMLPEN)) != RESET)__HAL_RCC_BKPSRAM_IS_CLK_SLEEP_ENABLED()((RCC->AHB1LPENR & (RCC_AHB1LPENR_BKPSRAMLPEN)) != RESET)__HAL_RCC_SRAM2_IS_CLK_SLEEP_ENABLED()((RCC->AHB1LPENR & (RCC_AHB1LPENR_SRAM2LPEN)) != RESET)__HAL_RCC_SRAM1_IS_CLK_SLEEP_ENABLED()((RCC->AHB1LPENR & (RCC_AHB1LPENR_SRAM1LPEN)) != RESET)__HAL_RCC_AXI_IS_CLK_SLEEP_ENABLED()((RCC->AHB1LPENR & (RCC_AHB1LPENR_AXILPEN)) != RESET)__HAL_RCC_FLITF_IS_CLK_SLEEP_ENABLED()((RCC->AHB1LPENR & (RCC_AHB1LPENR_FLITFLPEN)) != RESET)__HAL_RCC_SPI6_CLK_SLEEP_DISABLE()(RCC->APB2LPENR &= ~(RCC_APB2LPENR_SPI6LPEN))__HAL_RCC_SPI6_CLK_SLEEP_ENABLE()(RCC->APB2LPENR |= (RCC_APB2LPENR_SPI6LPEN))__HAL_RCC_SDMMC2_CLK_SLEEP_DISABLE()(RCC->APB2LPENR &= ~(RCC_APB2LPENR_SDMMC2LPEN))__HAL_RCC_SDMMC2_CLK_SLEEP_ENABLE()(RCC->APB2LPENR |= (RCC_APB2LPENR_SDMMC2LPEN))__HAL_RCC_MDIO_CLK_SLEEP_DISABLE()(RCC->APB2LPENR &= ~(RCC_APB2LPENR_MDIOLPEN))__HAL_RCC_DFSDM1_CLK_SLEEP_DISABLE()(RCC->APB2LPENR &= ~(RCC_APB2LPENR_DFSDM1LPEN))__HAL_RCC_MDIO_CLK_SLEEP_ENABLE()(RCC->APB2LPENR |= (RCC_APB2LPENR_MDIOLPEN))__HAL_RCC_DFSDM1_CLK_SLEEP_ENABLE()(RCC->APB2LPENR |= (RCC_APB2LPENR_DFSDM1LPEN))__HAL_RCC_DSI_CLK_SLEEP_DISABLE()(RCC->APB2LPENR &= ~(RCC_APB2LPENR_DSILPEN))__HAL_RCC_DSI_CLK_SLEEP_ENABLE()(RCC->APB2LPENR |= (RCC_APB2LPENR_DSILPEN))__HAL_RCC_LTDC_CLK_SLEEP_DISABLE()(RCC->APB2LPENR &= ~(RCC_APB2LPENR_LTDCLPEN))__HAL_RCC_SAI2_CLK_SLEEP_DISABLE()(RCC->APB2LPENR &= ~(RCC_APB2LPENR_SAI2LPEN))__HAL_RCC_SAI1_CLK_SLEEP_DISABLE()(RCC->APB2LPENR &= ~(RCC_APB2LPENR_SAI1LPEN))__HAL_RCC_SPI5_CLK_SLEEP_DISABLE()(RCC->APB2LPENR &= ~(RCC_APB2LPENR_SPI5LPEN))__HAL_RCC_TIM11_CLK_SLEEP_DISABLE()(RCC->APB2LPENR &= ~(RCC_APB2LPENR_TIM11LPEN))__HAL_RCC_TIM10_CLK_SLEEP_DISABLE()(RCC->APB2LPENR &= ~(RCC_APB2LPENR_TIM10LPEN))__HAL_RCC_TIM9_CLK_SLEEP_DISABLE()(RCC->APB2LPENR &= ~(RCC_APB2LPENR_TIM9LPEN))__HAL_RCC_SPI4_CLK_SLEEP_DISABLE()(RCC->APB2LPENR &= ~(RCC_APB2LPENR_SPI4LPEN))__HAL_RCC_SPI1_CLK_SLEEP_DISABLE()(RCC->APB2LPENR &= ~(RCC_APB2LPENR_SPI1LPEN))__HAL_RCC_SDMMC1_CLK_SLEEP_DISABLE()(RCC->APB2LPENR &= ~(RCC_APB2LPENR_SDMMC1LPEN))__HAL_RCC_ADC3_CLK_SLEEP_DISABLE()(RCC->APB2LPENR &= ~(RCC_APB2LPENR_ADC3LPEN))__HAL_RCC_ADC2_CLK_SLEEP_DISABLE()(RCC->APB2LPENR &= ~(RCC_APB2LPENR_ADC2LPEN))__HAL_RCC_ADC1_CLK_SLEEP_DISABLE()(RCC->APB2LPENR &= ~(RCC_APB2LPENR_ADC1LPEN))__HAL_RCC_USART6_CLK_SLEEP_DISABLE()(RCC->APB2LPENR &= ~(RCC_APB2LPENR_USART6LPEN))__HAL_RCC_USART1_CLK_SLEEP_DISABLE()(RCC->APB2LPENR &= ~(RCC_APB2LPENR_USART1LPEN))__HAL_RCC_TIM8_CLK_SLEEP_DISABLE()(RCC->APB2LPENR &= ~(RCC_APB2LPENR_TIM8LPEN))__HAL_RCC_TIM1_CLK_SLEEP_DISABLE()(RCC->APB2LPENR &= ~(RCC_APB2LPENR_TIM1LPEN))__HAL_RCC_LTDC_CLK_SLEEP_ENABLE()(RCC->APB2LPENR |= (RCC_APB2LPENR_LTDCLPEN))__HAL_RCC_SAI2_CLK_SLEEP_ENABLE()(RCC->APB2LPENR |= (RCC_APB2LPENR_SAI2LPEN))__HAL_RCC_SAI1_CLK_SLEEP_ENABLE()(RCC->APB2LPENR |= (RCC_APB2LPENR_SAI1LPEN))__HAL_RCC_SPI5_CLK_SLEEP_ENABLE()(RCC->APB2LPENR |= (RCC_APB2LPENR_SPI5LPEN))__HAL_RCC_TIM11_CLK_SLEEP_ENABLE()(RCC->APB2LPENR |= (RCC_APB2LPENR_TIM11LPEN))__HAL_RCC_TIM10_CLK_SLEEP_ENABLE()(RCC->APB2LPENR |= (RCC_APB2LPENR_TIM10LPEN))__HAL_RCC_TIM9_CLK_SLEEP_ENABLE()(RCC->APB2LPENR |= (RCC_APB2LPENR_TIM9LPEN))__HAL_RCC_SPI4_CLK_SLEEP_ENABLE()(RCC->APB2LPENR |= (RCC_APB2LPENR_SPI4LPEN))__HAL_RCC_SPI1_CLK_SLEEP_ENABLE()(RCC->APB2LPENR |= (RCC_APB2LPENR_SPI1LPEN))__HAL_RCC_SDMMC1_CLK_SLEEP_ENABLE()(RCC->APB2LPENR |= (RCC_APB2LPENR_SDMMC1LPEN))__HAL_RCC_ADC3_CLK_SLEEP_ENABLE()(RCC->APB2LPENR |= (RCC_APB2LPENR_ADC3LPEN))__HAL_RCC_ADC2_CLK_SLEEP_ENABLE()(RCC->APB2LPENR |= (RCC_APB2LPENR_ADC2LPEN))__HAL_RCC_ADC1_CLK_SLEEP_ENABLE()(RCC->APB2LPENR |= (RCC_APB2LPENR_ADC1LPEN))__HAL_RCC_USART6_CLK_SLEEP_ENABLE()(RCC->APB2LPENR |= (RCC_APB2LPENR_USART6LPEN))__HAL_RCC_USART1_CLK_SLEEP_ENABLE()(RCC->APB2LPENR |= (RCC_APB2LPENR_USART1LPEN))__HAL_RCC_TIM8_CLK_SLEEP_ENABLE()(RCC->APB2LPENR |= (RCC_APB2LPENR_TIM8LPEN))__HAL_RCC_TIM1_CLK_SLEEP_ENABLE()(RCC->APB2LPENR |= (RCC_APB2LPENR_TIM1LPEN))__HAL_RCC_CEC_CLK_SLEEP_DISABLE()(RCC->APB1LPENR &= ~(RCC_APB1LPENR_CECLPEN))__HAL_RCC_CAN2_CLK_SLEEP_DISABLE()(RCC->APB1LPENR &= ~(RCC_APB1LPENR_CAN2LPEN))__HAL_RCC_I2C4_CLK_SLEEP_DISABLE()(RCC->APB1LPENR &= ~(RCC_APB1LPENR_I2C4LPEN))__HAL_RCC_SPDIFRX_CLK_SLEEP_DISABLE()(RCC->APB1LPENR &= ~(RCC_APB1LPENR_SPDIFRXLPEN))__HAL_RCC_CEC_CLK_SLEEP_ENABLE()(RCC->APB1LPENR |= (RCC_APB1LPENR_CECLPEN))__HAL_RCC_CAN2_CLK_SLEEP_ENABLE()(RCC->APB1LPENR |= (RCC_APB1LPENR_CAN2LPEN))__HAL_RCC_I2C4_CLK_SLEEP_ENABLE()(RCC->APB1LPENR |= (RCC_APB1LPENR_I2C4LPEN))__HAL_RCC_SPDIFRX_CLK_SLEEP_ENABLE()(RCC->APB1LPENR |= (RCC_APB1LPENR_SPDIFRXLPEN))__HAL_RCC_RTC_CLK_SLEEP_DISABLE()(RCC->APB1LPENR &= ~(RCC_APB1LPENR_RTCLPEN))__HAL_RCC_RTC_CLK_SLEEP_ENABLE()(RCC->APB1LPENR |= (RCC_APB1LPENR_RTCLPEN))__HAL_RCC_UART8_CLK_SLEEP_DISABLE()(RCC->APB1LPENR &= ~(RCC_APB1LPENR_UART8LPEN))__HAL_RCC_UART7_CLK_SLEEP_DISABLE()(RCC->APB1LPENR &= ~(RCC_APB1LPENR_UART7LPEN))__HAL_RCC_DAC_CLK_SLEEP_DISABLE()(RCC->APB1LPENR &= ~(RCC_APB1LPENR_DACLPEN))__HAL_RCC_CAN1_CLK_SLEEP_DISABLE()(RCC->APB1LPENR &= ~(RCC_APB1LPENR_CAN1LPEN))__HAL_RCC_I2C3_CLK_SLEEP_DISABLE()(RCC->APB1LPENR &= ~(RCC_APB1LPENR_I2C3LPEN))__HAL_RCC_I2C2_CLK_SLEEP_DISABLE()(RCC->APB1LPENR &= ~(RCC_APB1LPENR_I2C2LPEN))__HAL_RCC_I2C1_CLK_SLEEP_DISABLE()(RCC->APB1LPENR &= ~(RCC_APB1LPENR_I2C1LPEN))__HAL_RCC_UART5_CLK_SLEEP_DISABLE()(RCC->APB1LPENR &= ~(RCC_APB1LPENR_UART5LPEN))__HAL_RCC_UART4_CLK_SLEEP_DISABLE()(RCC->APB1LPENR &= ~(RCC_APB1LPENR_UART4LPEN))__HAL_RCC_USART3_CLK_SLEEP_DISABLE()(RCC->APB1LPENR &= ~(RCC_APB1LPENR_USART3LPEN))__HAL_RCC_USART2_CLK_SLEEP_DISABLE()(RCC->APB1LPENR &= ~(RCC_APB1LPENR_USART2LPEN))__HAL_RCC_SPI3_CLK_SLEEP_DISABLE()(RCC->APB1LPENR &= ~(RCC_APB1LPENR_SPI3LPEN))__HAL_RCC_SPI2_CLK_SLEEP_DISABLE()(RCC->APB1LPENR &= ~(RCC_APB1LPENR_SPI2LPEN))__HAL_RCC_CAN3_CLK_SLEEP_DISABLE()(RCC->APB1LPENR &= ~(RCC_APB1LPENR_CAN3LPEN))__HAL_RCC_LPTIM1_CLK_SLEEP_DISABLE()(RCC->APB1LPENR &= ~(RCC_APB1LPENR_LPTIM1LPEN))__HAL_RCC_TIM14_CLK_SLEEP_DISABLE()(RCC->APB1LPENR &= ~(RCC_APB1LPENR_TIM14LPEN))__HAL_RCC_TIM13_CLK_SLEEP_DISABLE()(RCC->APB1LPENR &= ~(RCC_APB1LPENR_TIM13LPEN))__HAL_RCC_TIM12_CLK_SLEEP_DISABLE()(RCC->APB1LPENR &= ~(RCC_APB1LPENR_TIM12LPEN))__HAL_RCC_TIM7_CLK_SLEEP_DISABLE()(RCC->APB1LPENR &= ~(RCC_APB1LPENR_TIM7LPEN))__HAL_RCC_TIM6_CLK_SLEEP_DISABLE()(RCC->APB1LPENR &= ~(RCC_APB1LPENR_TIM6LPEN))__HAL_RCC_TIM5_CLK_SLEEP_DISABLE()(RCC->APB1LPENR &= ~(RCC_APB1LPENR_TIM5LPEN))__HAL_RCC_TIM4_CLK_SLEEP_DISABLE()(RCC->APB1LPENR &= ~(RCC_APB1LPENR_TIM4LPEN))__HAL_RCC_TIM3_CLK_SLEEP_DISABLE()(RCC->APB1LPENR &= ~(RCC_APB1LPENR_TIM3LPEN))__HAL_RCC_TIM2_CLK_SLEEP_DISABLE()(RCC->APB1LPENR &= ~(RCC_APB1LPENR_TIM2LPEN))__HAL_RCC_UART8_CLK_SLEEP_ENABLE()(RCC->APB1LPENR |= (RCC_APB1LPENR_UART8LPEN))__HAL_RCC_UART7_CLK_SLEEP_ENABLE()(RCC->APB1LPENR |= (RCC_APB1LPENR_UART7LPEN))__HAL_RCC_DAC_CLK_SLEEP_ENABLE()(RCC->APB1LPENR |= (RCC_APB1LPENR_DACLPEN))__HAL_RCC_CAN1_CLK_SLEEP_ENABLE()(RCC->APB1LPENR |= (RCC_APB1LPENR_CAN1LPEN))__HAL_RCC_I2C3_CLK_SLEEP_ENABLE()(RCC->APB1LPENR |= (RCC_APB1LPENR_I2C3LPEN))__HAL_RCC_I2C2_CLK_SLEEP_ENABLE()(RCC->APB1LPENR |= (RCC_APB1LPENR_I2C2LPEN))__HAL_RCC_I2C1_CLK_SLEEP_ENABLE()(RCC->APB1LPENR |= (RCC_APB1LPENR_I2C1LPEN))__HAL_RCC_UART5_CLK_SLEEP_ENABLE()(RCC->APB1LPENR |= (RCC_APB1LPENR_UART5LPEN))__HAL_RCC_UART4_CLK_SLEEP_ENABLE()(RCC->APB1LPENR |= (RCC_APB1LPENR_UART4LPEN))__HAL_RCC_USART3_CLK_SLEEP_ENABLE()(RCC->APB1LPENR |= (RCC_APB1LPENR_USART3LPEN))__HAL_RCC_USART2_CLK_SLEEP_ENABLE()(RCC->APB1LPENR |= (RCC_APB1LPENR_USART2LPEN))__HAL_RCC_SPI3_CLK_SLEEP_ENABLE()(RCC->APB1LPENR |= (RCC_APB1LPENR_SPI3LPEN))__HAL_RCC_SPI2_CLK_SLEEP_ENABLE()(RCC->APB1LPENR |= (RCC_APB1LPENR_SPI2LPEN))__HAL_RCC_CAN3_CLK_SLEEP_ENABLE()(RCC->APB1LPENR |= (RCC_APB1LPENR_CAN3LPEN))__HAL_RCC_LPTIM1_CLK_SLEEP_ENABLE()(RCC->APB1LPENR |= (RCC_APB1LPENR_LPTIM1LPEN))__HAL_RCC_TIM14_CLK_SLEEP_ENABLE()(RCC->APB1LPENR |= (RCC_APB1LPENR_TIM14LPEN))__HAL_RCC_TIM13_CLK_SLEEP_ENABLE()(RCC->APB1LPENR |= (RCC_APB1LPENR_TIM13LPEN))__HAL_RCC_TIM12_CLK_SLEEP_ENABLE()(RCC->APB1LPENR |= (RCC_APB1LPENR_TIM12LPEN))__HAL_RCC_TIM7_CLK_SLEEP_ENABLE()(RCC->APB1LPENR |= (RCC_APB1LPENR_TIM7LPEN))__HAL_RCC_TIM6_CLK_SLEEP_ENABLE()(RCC->APB1LPENR |= (RCC_APB1LPENR_TIM6LPEN))__HAL_RCC_TIM5_CLK_SLEEP_ENABLE()(RCC->APB1LPENR |= (RCC_APB1LPENR_TIM5LPEN))__HAL_RCC_TIM4_CLK_SLEEP_ENABLE()(RCC->APB1LPENR |= (RCC_APB1LPENR_TIM4LPEN))__HAL_RCC_TIM3_CLK_SLEEP_ENABLE()(RCC->APB1LPENR |= (RCC_APB1LPENR_TIM3LPEN))__HAL_RCC_TIM2_CLK_SLEEP_ENABLE()(RCC->APB1LPENR |= (RCC_APB1LPENR_TIM2LPEN))__HAL_RCC_QSPI_CLK_SLEEP_DISABLE()(RCC->AHB3LPENR &= ~(RCC_AHB3LPENR_QSPILPEN))__HAL_RCC_QSPI_CLK_SLEEP_ENABLE()(RCC->AHB3LPENR |= (RCC_AHB3LPENR_QSPILPEN))__HAL_RCC_FMC_CLK_SLEEP_DISABLE()(RCC->AHB3LPENR &= ~(RCC_AHB3LPENR_FMCLPEN))__HAL_RCC_FMC_CLK_SLEEP_ENABLE()(RCC->AHB3LPENR |= (RCC_AHB3LPENR_FMCLPEN))__HAL_RCC_USB_OTG_FS_CLK_SLEEP_DISABLE()(RCC->AHB2LPENR &= ~(RCC_AHB2LPENR_OTGFSLPEN))__HAL_RCC_USB_OTG_FS_CLK_SLEEP_ENABLE()(RCC->AHB2LPENR |= (RCC_AHB2LPENR_OTGFSLPEN))__HAL_RCC_RNG_CLK_SLEEP_DISABLE()(RCC->AHB2LPENR &= ~(RCC_AHB2LPENR_RNGLPEN))__HAL_RCC_RNG_CLK_SLEEP_ENABLE()(RCC->AHB2LPENR |= (RCC_AHB2LPENR_RNGLPEN))__HAL_RCC_JPEG_CLK_SLEEP_DISABLE()(RCC->AHB2LPENR &= ~(RCC_AHB2LPENR_JPEGLPEN))__HAL_RCC_JPEG_CLK_SLEEP_ENABLE()(RCC->AHB2LPENR |= (RCC_AHB2LPENR_JPEGLPEN))__HAL_RCC_DCMI_CLK_SLEEP_DISABLE()(RCC->AHB2LPENR &= ~(RCC_AHB2LPENR_DCMILPEN))__HAL_RCC_DCMI_CLK_SLEEP_ENABLE()(RCC->AHB2LPENR |= (RCC_AHB2LPENR_DCMILPEN))__HAL_RCC_GPIOK_CLK_SLEEP_DISABLE()(RCC->AHB1LPENR &= ~(RCC_AHB1LPENR_GPIOKLPEN))__HAL_RCC_GPIOJ_CLK_SLEEP_DISABLE()(RCC->AHB1LPENR &= ~(RCC_AHB1LPENR_GPIOJLPEN))__HAL_RCC_ETHMACPTP_CLK_SLEEP_DISABLE()(RCC->AHB1LPENR &= ~(RCC_AHB1LPENR_ETHMACPTPLPEN))__HAL_RCC_ETHMACRX_CLK_SLEEP_DISABLE()(RCC->AHB1LPENR &= ~(RCC_AHB1LPENR_ETHMACRXLPEN))__HAL_RCC_ETHMACTX_CLK_SLEEP_DISABLE()(RCC->AHB1LPENR &= ~(RCC_AHB1LPENR_ETHMACTXLPEN))__HAL_RCC_ETHMAC_CLK_SLEEP_DISABLE()(RCC->AHB1LPENR &= ~(RCC_AHB1LPENR_ETHMACLPEN))__HAL_RCC_DMA2D_CLK_SLEEP_DISABLE()(RCC->AHB1LPENR &= ~(RCC_AHB1LPENR_DMA2DLPEN))__HAL_RCC_GPIOK_CLK_SLEEP_ENABLE()(RCC->AHB1LPENR |= (RCC_AHB1LPENR_GPIOKLPEN))__HAL_RCC_GPIOJ_CLK_SLEEP_ENABLE()(RCC->AHB1LPENR |= (RCC_AHB1LPENR_GPIOJLPEN))__HAL_RCC_ETHMACPTP_CLK_SLEEP_ENABLE()(RCC->AHB1LPENR |= (RCC_AHB1LPENR_ETHMACPTPLPEN))__HAL_RCC_ETHMACRX_CLK_SLEEP_ENABLE()(RCC->AHB1LPENR |= (RCC_AHB1LPENR_ETHMACRXLPEN))__HAL_RCC_ETHMACTX_CLK_SLEEP_ENABLE()(RCC->AHB1LPENR |= (RCC_AHB1LPENR_ETHMACTXLPEN))__HAL_RCC_ETHMAC_CLK_SLEEP_ENABLE()(RCC->AHB1LPENR |= (RCC_AHB1LPENR_ETHMACLPEN))__HAL_RCC_DMA2D_CLK_SLEEP_ENABLE()(RCC->AHB1LPENR |= (RCC_AHB1LPENR_DMA2DLPEN))__HAL_RCC_GPIOI_CLK_SLEEP_DISABLE()(RCC->AHB1LPENR &= ~(RCC_AHB1LPENR_GPIOILPEN))__HAL_RCC_GPIOH_CLK_SLEEP_DISABLE()(RCC->AHB1LPENR &= ~(RCC_AHB1LPENR_GPIOHLPEN))__HAL_RCC_GPIOG_CLK_SLEEP_DISABLE()(RCC->AHB1LPENR &= ~(RCC_AHB1LPENR_GPIOGLPEN))__HAL_RCC_GPIOF_CLK_SLEEP_DISABLE()(RCC->AHB1LPENR &= ~(RCC_AHB1LPENR_GPIOFLPEN))__HAL_RCC_GPIOE_CLK_SLEEP_DISABLE()(RCC->AHB1LPENR &= ~(RCC_AHB1LPENR_GPIOELPEN))__HAL_RCC_GPIOD_CLK_SLEEP_DISABLE()(RCC->AHB1LPENR &= ~(RCC_AHB1LPENR_GPIODLPEN))__HAL_RCC_GPIOC_CLK_SLEEP_DISABLE()(RCC->AHB1LPENR &= ~(RCC_AHB1LPENR_GPIOCLPEN))__HAL_RCC_GPIOB_CLK_SLEEP_DISABLE()(RCC->AHB1LPENR &= ~(RCC_AHB1LPENR_GPIOBLPEN))__HAL_RCC_GPIOA_CLK_SLEEP_DISABLE()(RCC->AHB1LPENR &= ~(RCC_AHB1LPENR_GPIOALPEN))__HAL_RCC_USB_OTG_HS_ULPI_CLK_SLEEP_DISABLE()(RCC->AHB1LPENR &= ~(RCC_AHB1LPENR_OTGHSULPILPEN))__HAL_RCC_USB_OTG_HS_CLK_SLEEP_DISABLE()(RCC->AHB1LPENR &= ~(RCC_AHB1LPENR_OTGHSLPEN))__HAL_RCC_DMA2_CLK_SLEEP_DISABLE()(RCC->AHB1LPENR &= ~(RCC_AHB1LPENR_DMA2LPEN))__HAL_RCC_DTCM_CLK_SLEEP_DISABLE()(RCC->AHB1LPENR &= ~(RCC_AHB1LPENR_DTCMLPEN))__HAL_RCC_BKPSRAM_CLK_SLEEP_DISABLE()(RCC->AHB1LPENR &= ~(RCC_AHB1LPENR_BKPSRAMLPEN))__HAL_RCC_SRAM2_CLK_SLEEP_DISABLE()(RCC->AHB1LPENR &= ~(RCC_AHB1LPENR_SRAM2LPEN))__HAL_RCC_SRAM1_CLK_SLEEP_DISABLE()(RCC->AHB1LPENR &= ~(RCC_AHB1LPENR_SRAM1LPEN))__HAL_RCC_AXI_CLK_SLEEP_DISABLE()(RCC->AHB1LPENR &= ~(RCC_AHB1LPENR_AXILPEN))__HAL_RCC_FLITF_CLK_SLEEP_DISABLE()(RCC->AHB1LPENR &= ~(RCC_AHB1LPENR_FLITFLPEN))__HAL_RCC_GPIOI_CLK_SLEEP_ENABLE()(RCC->AHB1LPENR |= (RCC_AHB1LPENR_GPIOILPEN))__HAL_RCC_GPIOH_CLK_SLEEP_ENABLE()(RCC->AHB1LPENR |= (RCC_AHB1LPENR_GPIOHLPEN))__HAL_RCC_GPIOG_CLK_SLEEP_ENABLE()(RCC->AHB1LPENR |= (RCC_AHB1LPENR_GPIOGLPEN))__HAL_RCC_GPIOF_CLK_SLEEP_ENABLE()(RCC->AHB1LPENR |= (RCC_AHB1LPENR_GPIOFLPEN))__HAL_RCC_GPIOE_CLK_SLEEP_ENABLE()(RCC->AHB1LPENR |= (RCC_AHB1LPENR_GPIOELPEN))__HAL_RCC_GPIOD_CLK_SLEEP_ENABLE()(RCC->AHB1LPENR |= (RCC_AHB1LPENR_GPIODLPEN))__HAL_RCC_GPIOC_CLK_SLEEP_ENABLE()(RCC->AHB1LPENR |= (RCC_AHB1LPENR_GPIOCLPEN))__HAL_RCC_GPIOB_CLK_SLEEP_ENABLE()(RCC->AHB1LPENR |= (RCC_AHB1LPENR_GPIOBLPEN))__HAL_RCC_GPIOA_CLK_SLEEP_ENABLE()(RCC->AHB1LPENR |= (RCC_AHB1LPENR_GPIOALPEN))__HAL_RCC_USB_OTG_HS_ULPI_CLK_SLEEP_ENABLE()(RCC->AHB1LPENR |= (RCC_AHB1LPENR_OTGHSULPILPEN))__HAL_RCC_USB_OTG_HS_CLK_SLEEP_ENABLE()(RCC->AHB1LPENR |= (RCC_AHB1LPENR_OTGHSLPEN))__HAL_RCC_DMA2_CLK_SLEEP_ENABLE()(RCC->AHB1LPENR |= (RCC_AHB1LPENR_DMA2LPEN))__HAL_RCC_DTCM_CLK_SLEEP_ENABLE()(RCC->AHB1LPENR |= (RCC_AHB1LPENR_DTCMLPEN))__HAL_RCC_BKPSRAM_CLK_SLEEP_ENABLE()(RCC->AHB1LPENR |= (RCC_AHB1LPENR_BKPSRAMLPEN))__HAL_RCC_SRAM2_CLK_SLEEP_ENABLE()(RCC->AHB1LPENR |= (RCC_AHB1LPENR_SRAM2LPEN))__HAL_RCC_SRAM1_CLK_SLEEP_ENABLE()(RCC->AHB1LPENR |= (RCC_AHB1LPENR_SRAM1LPEN))__HAL_RCC_AXI_CLK_SLEEP_ENABLE()(RCC->AHB1LPENR |= (RCC_AHB1LPENR_AXILPEN))__HAL_RCC_FLITF_CLK_SLEEP_ENABLE()(RCC->AHB1LPENR |= (RCC_AHB1LPENR_FLITFLPEN))__HAL_RCC_MDIO_RELEASE_RESET()(RCC->APB2RSTR &= ~(RCC_APB2RSTR_MDIORST))__HAL_RCC_DFSDM1_RELEASE_RESET()(RCC->APB2RSTR &= ~(RCC_APB2RSTR_DFSDM1RST))__HAL_RCC_MDIO_FORCE_RESET()(RCC->APB2RSTR |= (RCC_APB2RSTR_MDIORST))__HAL_RCC_DFSDM1_FORCE_RESET()(RCC->APB2RSTR |= (RCC_APB2RSTR_DFSDM1RST))__HAL_RCC_SDMMC2_RELEASE_RESET()(RCC->APB2RSTR &= ~(RCC_APB2RSTR_SDMMC2RST))__HAL_RCC_SDMMC2_FORCE_RESET()(RCC->APB2RSTR |= (RCC_APB2RSTR_SDMMC2RST))__HAL_RCC_DSI_RELEASE_RESET()(RCC->APB2RSTR &= ~(RCC_APB2RSTR_DSIRST))__HAL_RCC_DSI_FORCE_RESET()(RCC->APB2RSTR |= (RCC_APB2RSTR_DSIRST))__HAL_RCC_LTDC_RELEASE_RESET()(RCC->APB2RSTR &= ~(RCC_APB2RSTR_LTDCRST))__HAL_RCC_SAI2_RELEASE_RESET()(RCC->APB2RSTR &= ~(RCC_APB2RSTR_SAI2RST))__HAL_RCC_SAI1_RELEASE_RESET()(RCC->APB2RSTR &= ~(RCC_APB2RSTR_SAI1RST))__HAL_RCC_SPI6_RELEASE_RESET()(RCC->APB2RSTR &= ~(RCC_APB2RSTR_SPI6RST))__HAL_RCC_SPI5_RELEASE_RESET()(RCC->APB2RSTR &= ~(RCC_APB2RSTR_SPI5RST))__HAL_RCC_TIM11_RELEASE_RESET()(RCC->APB2RSTR &= ~(RCC_APB2RSTR_TIM11RST))__HAL_RCC_TIM10_RELEASE_RESET()(RCC->APB2RSTR &= ~(RCC_APB2RSTR_TIM10RST))__HAL_RCC_TIM9_RELEASE_RESET()(RCC->APB2RSTR &= ~(RCC_APB2RSTR_TIM9RST))__HAL_RCC_SPI4_RELEASE_RESET()(RCC->APB2RSTR &= ~(RCC_APB2RSTR_SPI4RST))__HAL_RCC_SPI1_RELEASE_RESET()(RCC->APB2RSTR &= ~(RCC_APB2RSTR_SPI1RST))__HAL_RCC_SDMMC1_RELEASE_RESET()(RCC->APB2RSTR &= ~(RCC_APB2RSTR_SDMMC1RST))(RCC->APB2RSTR &= ~(RCC_APB2RSTR_ADCRST))__HAL_RCC_USART6_RELEASE_RESET()(RCC->APB2RSTR &= ~(RCC_APB2RSTR_USART6RST))__HAL_RCC_USART1_RELEASE_RESET()(RCC->APB2RSTR &= ~(RCC_APB2RSTR_USART1RST))__HAL_RCC_TIM8_RELEASE_RESET()(RCC->APB2RSTR &= ~(RCC_APB2RSTR_TIM8RST))__HAL_RCC_TIM1_RELEASE_RESET()(RCC->APB2RSTR &= ~(RCC_APB2RSTR_TIM1RST))__HAL_RCC_LTDC_FORCE_RESET()(RCC->APB2RSTR |= (RCC_APB2RSTR_LTDCRST))__HAL_RCC_SAI2_FORCE_RESET()(RCC->APB2RSTR |= (RCC_APB2RSTR_SAI2RST))__HAL_RCC_SAI1_FORCE_RESET()(RCC->APB2RSTR |= (RCC_APB2RSTR_SAI1RST))__HAL_RCC_SPI6_FORCE_RESET()(RCC->APB2RSTR |= (RCC_APB2RSTR_SPI6RST))__HAL_RCC_SPI5_FORCE_RESET()(RCC->APB2RSTR |= (RCC_APB2RSTR_SPI5RST))__HAL_RCC_TIM11_FORCE_RESET()(RCC->APB2RSTR |= (RCC_APB2RSTR_TIM11RST))__HAL_RCC_TIM10_FORCE_RESET()(RCC->APB2RSTR |= (RCC_APB2RSTR_TIM10RST))__HAL_RCC_TIM9_FORCE_RESET()(RCC->APB2RSTR |= (RCC_APB2RSTR_TIM9RST))__HAL_RCC_SPI4_FORCE_RESET()(RCC->APB2RSTR |= (RCC_APB2RSTR_SPI4RST))__HAL_RCC_SPI1_FORCE_RESET()(RCC->APB2RSTR |= (RCC_APB2RSTR_SPI1RST))__HAL_RCC_SDMMC1_FORCE_RESET()(RCC->APB2RSTR |= (RCC_APB2RSTR_SDMMC1RST))(RCC->APB2RSTR |= (RCC_APB2RSTR_ADCRST))__HAL_RCC_USART6_FORCE_RESET()(RCC->APB2RSTR |= (RCC_APB2RSTR_USART6RST))__HAL_RCC_USART1_FORCE_RESET()(RCC->APB2RSTR |= (RCC_APB2RSTR_USART1RST))__HAL_RCC_TIM8_FORCE_RESET()(RCC->APB2RSTR |= (RCC_APB2RSTR_TIM8RST))__HAL_RCC_TIM1_FORCE_RESET()(RCC->APB2RSTR |= (RCC_APB2RSTR_TIM1RST))__HAL_RCC_CEC_RELEASE_RESET()(RCC->APB1RSTR &= ~(RCC_APB1RSTR_CECRST))__HAL_RCC_CAN2_RELEASE_RESET()(RCC->APB1RSTR &= ~(RCC_APB1RSTR_CAN2RST))__HAL_RCC_I2C4_RELEASE_RESET()(RCC->APB1RSTR &= ~(RCC_APB1RSTR_I2C4RST))__HAL_RCC_SPDIFRX_RELEASE_RESET()(RCC->APB1RSTR &= ~(RCC_APB1RSTR_SPDIFRXRST))__HAL_RCC_CEC_FORCE_RESET()(RCC->APB1RSTR |= (RCC_APB1RSTR_CECRST))__HAL_RCC_CAN2_FORCE_RESET()(RCC->APB1RSTR |= (RCC_APB1RSTR_CAN2RST))__HAL_RCC_I2C4_FORCE_RESET()(RCC->APB1RSTR |= (RCC_APB1RSTR_I2C4RST))__HAL_RCC_SPDIFRX_FORCE_RESET()(RCC->APB1RSTR |= (RCC_APB1RSTR_SPDIFRXRST))__HAL_RCC_UART8_RELEASE_RESET()(RCC->APB1RSTR &= ~(RCC_APB1RSTR_UART8RST))__HAL_RCC_UART7_RELEASE_RESET()(RCC->APB1RSTR &= ~(RCC_APB1RSTR_UART7RST))__HAL_RCC_DAC_RELEASE_RESET()(RCC->APB1RSTR &= ~(RCC_APB1RSTR_DACRST))__HAL_RCC_CAN1_RELEASE_RESET()(RCC->APB1RSTR &= ~(RCC_APB1RSTR_CAN1RST))__HAL_RCC_I2C3_RELEASE_RESET()(RCC->APB1RSTR &= ~(RCC_APB1RSTR_I2C3RST))__HAL_RCC_I2C2_RELEASE_RESET()(RCC->APB1RSTR &= ~(RCC_APB1RSTR_I2C2RST))(RCC->APB1RSTR &= ~(RCC_APB1RSTR_I2C1RST))__HAL_RCC_UART5_RELEASE_RESET()(RCC->APB1RSTR &= ~(RCC_APB1RSTR_UART5RST))__HAL_RCC_UART4_RELEASE_RESET()(RCC->APB1RSTR &= ~(RCC_APB1RSTR_UART4RST))__HAL_RCC_USART3_RELEASE_RESET()(RCC->APB1RSTR &= ~(RCC_APB1RSTR_USART3RST))__HAL_RCC_USART2_RELEASE_RESET()(RCC->APB1RSTR &= ~(RCC_APB1RSTR_USART2RST))__HAL_RCC_SPI3_RELEASE_RESET()(RCC->APB1RSTR &= ~(RCC_APB1RSTR_SPI3RST))__HAL_RCC_SPI2_RELEASE_RESET()(RCC->APB1RSTR &= ~(RCC_APB1RSTR_SPI2RST))__HAL_RCC_CAN3_RELEASE_RESET()(RCC->APB1RSTR &= ~(RCC_APB1RSTR_CAN3RST))__HAL_RCC_LPTIM1_RELEASE_RESET()(RCC->APB1RSTR &= ~(RCC_APB1RSTR_LPTIM1RST))__HAL_RCC_TIM14_RELEASE_RESET()(RCC->APB1RSTR &= ~(RCC_APB1RSTR_TIM14RST))__HAL_RCC_TIM13_RELEASE_RESET()(RCC->APB1RSTR &= ~(RCC_APB1RSTR_TIM13RST))__HAL_RCC_TIM12_RELEASE_RESET()(RCC->APB1RSTR &= ~(RCC_APB1RSTR_TIM12RST))__HAL_RCC_TIM7_RELEASE_RESET()(RCC->APB1RSTR &= ~(RCC_APB1RSTR_TIM7RST))__HAL_RCC_TIM6_RELEASE_RESET()(RCC->APB1RSTR &= ~(RCC_APB1RSTR_TIM6RST))__HAL_RCC_TIM5_RELEASE_RESET()(RCC->APB1RSTR &= ~(RCC_APB1RSTR_TIM5RST))__HAL_RCC_TIM4_RELEASE_RESET()(RCC->APB1RSTR &= ~(RCC_APB1RSTR_TIM4RST))__HAL_RCC_TIM3_RELEASE_RESET()(RCC->APB1RSTR &= ~(RCC_APB1RSTR_TIM3RST))__HAL_RCC_TIM2_RELEASE_RESET()(RCC->APB1RSTR &= ~(RCC_APB1RSTR_TIM2RST))__HAL_RCC_UART8_FORCE_RESET()(RCC->APB1RSTR |= (RCC_APB1RSTR_UART8RST))__HAL_RCC_UART7_FORCE_RESET()(RCC->APB1RSTR |= (RCC_APB1RSTR_UART7RST))__HAL_RCC_DAC_FORCE_RESET()(RCC->APB1RSTR |= (RCC_APB1RSTR_DACRST))__HAL_RCC_CAN1_FORCE_RESET()(RCC->APB1RSTR |= (RCC_APB1RSTR_CAN1RST))__HAL_RCC_I2C3_FORCE_RESET()(RCC->APB1RSTR |= (RCC_APB1RSTR_I2C3RST))__HAL_RCC_I2C2_FORCE_RESET()(RCC->APB1RSTR |= (RCC_APB1RSTR_I2C2RST))(RCC->APB1RSTR |= (RCC_APB1RSTR_I2C1RST))__HAL_RCC_UART5_FORCE_RESET()(RCC->APB1RSTR |= (RCC_APB1RSTR_UART5RST))__HAL_RCC_UART4_FORCE_RESET()(RCC->APB1RSTR |= (RCC_APB1RSTR_UART4RST))__HAL_RCC_USART3_FORCE_RESET()(RCC->APB1RSTR |= (RCC_APB1RSTR_USART3RST))__HAL_RCC_USART2_FORCE_RESET()(RCC->APB1RSTR |= (RCC_APB1RSTR_USART2RST))__HAL_RCC_SPI3_FORCE_RESET()(RCC->APB1RSTR |= (RCC_APB1RSTR_SPI3RST))__HAL_RCC_SPI2_FORCE_RESET()(RCC->APB1RSTR |= (RCC_APB1RSTR_SPI2RST))__HAL_RCC_CAN3_FORCE_RESET()(RCC->APB1RSTR |= (RCC_APB1RSTR_CAN3RST))__HAL_RCC_LPTIM1_FORCE_RESET()(RCC->APB1RSTR |= (RCC_APB1RSTR_LPTIM1RST))__HAL_RCC_TIM14_FORCE_RESET()(RCC->APB1RSTR |= (RCC_APB1RSTR_TIM14RST))__HAL_RCC_TIM13_FORCE_RESET()(RCC->APB1RSTR |= (RCC_APB1RSTR_TIM13RST))__HAL_RCC_TIM12_FORCE_RESET()(RCC->APB1RSTR |= (RCC_APB1RSTR_TIM12RST))__HAL_RCC_TIM7_FORCE_RESET()(RCC->APB1RSTR |= (RCC_APB1RSTR_TIM7RST))__HAL_RCC_TIM6_FORCE_RESET()(RCC->APB1RSTR |= (RCC_APB1RSTR_TIM6RST))__HAL_RCC_TIM5_FORCE_RESET()(RCC->APB1RSTR |= (RCC_APB1RSTR_TIM5RST))__HAL_RCC_TIM4_FORCE_RESET()(RCC->APB1RSTR |= (RCC_APB1RSTR_TIM4RST))__HAL_RCC_TIM3_FORCE_RESET()(RCC->APB1RSTR |= (RCC_APB1RSTR_TIM3RST))__HAL_RCC_TIM2_FORCE_RESET()(RCC->APB1RSTR |= (RCC_APB1RSTR_TIM2RST))__HAL_RCC_QSPI_RELEASE_RESET()(RCC->AHB3RSTR &= ~(RCC_AHB3RSTR_QSPIRST))__HAL_RCC_FMC_RELEASE_RESET()(RCC->AHB3RSTR &= ~(RCC_AHB3RSTR_FMCRST))__HAL_RCC_AHB3_RELEASE_RESET()(RCC->AHB3RSTR = 0x00U)__HAL_RCC_QSPI_FORCE_RESET()(RCC->AHB3RSTR |= (RCC_AHB3RSTR_QSPIRST))__HAL_RCC_FMC_FORCE_RESET()(RCC->AHB3RSTR |= (RCC_AHB3RSTR_FMCRST))__HAL_RCC_AHB3_FORCE_RESET()(RCC->AHB3RSTR = 0xFFFFFFFFU)__HAL_RCC_DCMI_RELEASE_RESET()(RCC->AHB2RSTR &= ~(RCC_AHB2RSTR_DCMIRST))__HAL_RCC_DCMI_FORCE_RESET()(RCC->AHB2RSTR |= (RCC_AHB2RSTR_DCMIRST))__HAL_RCC_JPEG_RELEASE_RESET()(RCC->AHB2RSTR &= ~(RCC_AHB2RSTR_JPEGRST))__HAL_RCC_JPEG_FORCE_RESET()(RCC->AHB2RSTR |= (RCC_AHB2RSTR_JPEGRST))__HAL_RCC_USB_OTG_FS_RELEASE_RESET()(RCC->AHB2RSTR &= ~(RCC_AHB2RSTR_OTGFSRST))__HAL_RCC_RNG_RELEASE_RESET()(RCC->AHB2RSTR &= ~(RCC_AHB2RSTR_RNGRST))__HAL_RCC_AHB2_RELEASE_RESET()(RCC->AHB2RSTR = 0x00U)__HAL_RCC_USB_OTG_FS_FORCE_RESET()(RCC->AHB2RSTR |= (RCC_AHB2RSTR_OTGFSRST))__HAL_RCC_RNG_FORCE_RESET()(RCC->AHB2RSTR |= (RCC_AHB2RSTR_RNGRST))__HAL_RCC_AHB2_FORCE_RESET()(RCC->AHB2RSTR = 0xFFFFFFFFU)__HAL_RCC_GPIOK_RELEASE_RESET()(RCC->AHB1RSTR &= ~(RCC_AHB1RSTR_GPIOKRST))__HAL_RCC_GPIOJ_RELEASE_RESET()(RCC->AHB1RSTR &= ~(RCC_AHB1RSTR_GPIOJRST))__HAL_RCC_ETHMAC_RELEASE_RESET()(RCC->AHB1RSTR &= ~(RCC_AHB1RSTR_ETHMACRST))__HAL_RCC_DMA2D_RELEASE_RESET()(RCC->AHB1RSTR &= ~(RCC_AHB1RSTR_DMA2DRST))__HAL_RCC_GPIOK_FORCE_RESET()(RCC->AHB1RSTR |= (RCC_AHB1RSTR_GPIOKRST))__HAL_RCC_GPIOJ_FORCE_RESET()(RCC->AHB1RSTR |= (RCC_AHB1RSTR_GPIOJRST))__HAL_RCC_ETHMAC_FORCE_RESET()(RCC->AHB1RSTR |= (RCC_AHB1RSTR_ETHMACRST))__HAL_RCC_DMA2D_FORCE_RESET()(RCC->AHB1RSTR |= (RCC_AHB1RSTR_DMA2DRST))__HAL_RCC_GPIOI_RELEASE_RESET()(RCC->AHB1RSTR &= ~(RCC_AHB1RSTR_GPIOIRST))__HAL_RCC_GPIOH_RELEASE_RESET()(RCC->AHB1RSTR &= ~(RCC_AHB1RSTR_GPIOHRST))__HAL_RCC_GPIOG_RELEASE_RESET()(RCC->AHB1RSTR &= ~(RCC_AHB1RSTR_GPIOGRST))__HAL_RCC_GPIOF_RELEASE_RESET()(RCC->AHB1RSTR &= ~(RCC_AHB1RSTR_GPIOFRST))__HAL_RCC_GPIOE_RELEASE_RESET()(RCC->AHB1RSTR &= ~(RCC_AHB1RSTR_GPIOERST))__HAL_RCC_GPIOD_RELEASE_RESET()(RCC->AHB1RSTR &= ~(RCC_AHB1RSTR_GPIODRST))__HAL_RCC_GPIOC_RELEASE_RESET()(RCC->AHB1RSTR &= ~(RCC_AHB1RSTR_GPIOCRST))__HAL_RCC_GPIOB_RELEASE_RESET()(RCC->AHB1RSTR &= ~(RCC_AHB1RSTR_GPIOBRST))__HAL_RCC_GPIOA_RELEASE_RESET()(RCC->AHB1RSTR &= ~(RCC_AHB1RSTR_GPIOARST))__HAL_RCC_USB_OTG_HS_RELEASE_RESET()(RCC->AHB1RSTR &= ~(RCC_AHB1RSTR_OTGHRST))__HAL_RCC_DMA2_RELEASE_RESET()(RCC->AHB1RSTR &= ~(RCC_AHB1RSTR_DMA2RST))__HAL_RCC_GPIOI_FORCE_RESET()(RCC->AHB1RSTR |= (RCC_AHB1RSTR_GPIOIRST))__HAL_RCC_GPIOH_FORCE_RESET()(RCC->AHB1RSTR |= (RCC_AHB1RSTR_GPIOHRST))__HAL_RCC_GPIOG_FORCE_RESET()(RCC->AHB1RSTR |= (RCC_AHB1RSTR_GPIOGRST))__HAL_RCC_GPIOF_FORCE_RESET()(RCC->AHB1RSTR |= (RCC_AHB1RSTR_GPIOFRST))__HAL_RCC_GPIOE_FORCE_RESET()(RCC->AHB1RSTR |= (RCC_AHB1RSTR_GPIOERST))__HAL_RCC_GPIOD_FORCE_RESET()(RCC->AHB1RSTR |= (RCC_AHB1RSTR_GPIODRST))__HAL_RCC_GPIOC_FORCE_RESET()(RCC->AHB1RSTR |= (RCC_AHB1RSTR_GPIOCRST))__HAL_RCC_GPIOB_FORCE_RESET()(RCC->AHB1RSTR |= (RCC_AHB1RSTR_GPIOBRST))__HAL_RCC_GPIOA_FORCE_RESET()(RCC->AHB1RSTR |= (RCC_AHB1RSTR_GPIOARST))__HAL_RCC_USB_OTG_HS_FORCE_RESET()(RCC->AHB1RSTR |= (RCC_AHB1RSTR_OTGHRST))__HAL_RCC_DMA2_FORCE_RESET()(RCC->AHB1RSTR |= (RCC_AHB1RSTR_DMA2RST))__HAL_RCC_MDIO_IS_CLK_DISABLED()((RCC->APB2ENR & (RCC_APB2ENR_MDIOEN)) == RESET)__HAL_RCC_DFSDM1_IS_CLK_DISABLED()((RCC->APB2ENR & (RCC_APB2ENR_DFSDM1EN)) == RESET)__HAL_RCC_SDMMC2_IS_CLK_DISABLED()((RCC->APB2ENR & (RCC_APB2ENR_SDMMC2EN)) == RESET)__HAL_RCC_DSI_IS_CLK_DISABLED()((RCC->APB2ENR & (RCC_APB2ENR_DSIEN)) == RESET)__HAL_RCC_LTDC_IS_CLK_DISABLED()((RCC->APB2ENR & (RCC_APB2ENR_LTDCEN)) == RESET)__HAL_RCC_SAI2_IS_CLK_DISABLED()((RCC->APB2ENR & (RCC_APB2ENR_SAI2EN)) == RESET)__HAL_RCC_SAI1_IS_CLK_DISABLED()((RCC->APB2ENR & (RCC_APB2ENR_SAI1EN)) == RESET)__HAL_RCC_SPI6_IS_CLK_DISABLED()((RCC->APB2ENR & (RCC_APB2ENR_SPI6EN)) == RESET)__HAL_RCC_SPI5_IS_CLK_DISABLED()((RCC->APB2ENR & (RCC_APB2ENR_SPI5EN)) == RESET)__HAL_RCC_TIM11_IS_CLK_DISABLED()((RCC->APB2ENR & (RCC_APB2ENR_TIM11EN)) == RESET)__HAL_RCC_TIM10_IS_CLK_DISABLED()((RCC->APB2ENR & (RCC_APB2ENR_TIM10EN)) == RESET)__HAL_RCC_TIM9_IS_CLK_DISABLED()((RCC->APB2ENR & (RCC_APB2ENR_TIM9EN)) == RESET)__HAL_RCC_SPI4_IS_CLK_DISABLED()((RCC->APB2ENR & (RCC_APB2ENR_SPI4EN)) == RESET)__HAL_RCC_SPI1_IS_CLK_DISABLED()((RCC->APB2ENR & (RCC_APB2ENR_SPI1EN)) == RESET)__HAL_RCC_SDMMC1_IS_CLK_DISABLED()((RCC->APB2ENR & (RCC_APB2ENR_SDMMC1EN)) == RESET)__HAL_RCC_ADC3_IS_CLK_DISABLED()((RCC->APB2ENR & (RCC_APB2ENR_ADC3EN)) == RESET)__HAL_RCC_ADC2_IS_CLK_DISABLED()((RCC->APB2ENR & (RCC_APB2ENR_ADC2EN)) == RESET)__HAL_RCC_ADC1_IS_CLK_DISABLED()((RCC->APB2ENR & (RCC_APB2ENR_ADC1EN)) == RESET)__HAL_RCC_USART6_IS_CLK_DISABLED()((RCC->APB2ENR & (RCC_APB2ENR_USART6EN)) == RESET)__HAL_RCC_USART1_IS_CLK_DISABLED()((RCC->APB2ENR & (RCC_APB2ENR_USART1EN)) == RESET)__HAL_RCC_TIM8_IS_CLK_DISABLED()((RCC->APB2ENR & (RCC_APB2ENR_TIM8EN)) == RESET)__HAL_RCC_TIM1_IS_CLK_DISABLED()((RCC->APB2ENR & (RCC_APB2ENR_TIM1EN)) == RESET)__HAL_RCC_MDIO_IS_CLK_ENABLED()((RCC->APB2ENR & (RCC_APB2ENR_MDIOEN)) != RESET)__HAL_RCC_DFSDM1_IS_CLK_ENABLED()((RCC->APB2ENR & (RCC_APB2ENR_DFSDM1EN)) != RESET)__HAL_RCC_SDMMC2_IS_CLK_ENABLED()((RCC->APB2ENR & (RCC_APB2ENR_SDMMC2EN)) != RESET)__HAL_RCC_DSI_IS_CLK_ENABLED()((RCC->APB2ENR & (RCC_APB2ENR_DSIEN)) != RESET)__HAL_RCC_LTDC_IS_CLK_ENABLED()((RCC->APB2ENR & (RCC_APB2ENR_LTDCEN)) != RESET)__HAL_RCC_SAI2_IS_CLK_ENABLED()((RCC->APB2ENR & (RCC_APB2ENR_SAI2EN)) != RESET)__HAL_RCC_SAI1_IS_CLK_ENABLED()((RCC->APB2ENR & (RCC_APB2ENR_SAI1EN)) != RESET)__HAL_RCC_SPI6_IS_CLK_ENABLED()((RCC->APB2ENR & (RCC_APB2ENR_SPI6EN)) != RESET)__HAL_RCC_SPI5_IS_CLK_ENABLED()((RCC->APB2ENR & (RCC_APB2ENR_SPI5EN)) != RESET)__HAL_RCC_TIM11_IS_CLK_ENABLED()((RCC->APB2ENR & (RCC_APB2ENR_TIM11EN)) != RESET)__HAL_RCC_TIM10_IS_CLK_ENABLED()((RCC->APB2ENR & (RCC_APB2ENR_TIM10EN)) != RESET)__HAL_RCC_TIM9_IS_CLK_ENABLED()((RCC->APB2ENR & (RCC_APB2ENR_TIM9EN)) != RESET)__HAL_RCC_SPI4_IS_CLK_ENABLED()((RCC->APB2ENR & (RCC_APB2ENR_SPI4EN)) != RESET)__HAL_RCC_SPI1_IS_CLK_ENABLED()((RCC->APB2ENR & (RCC_APB2ENR_SPI1EN)) != RESET)__HAL_RCC_SDMMC1_IS_CLK_ENABLED()((RCC->APB2ENR & (RCC_APB2ENR_SDMMC1EN)) != RESET)__HAL_RCC_ADC3_IS_CLK_ENABLED()((RCC->APB2ENR & (RCC_APB2ENR_ADC3EN)) != RESET)__HAL_RCC_ADC2_IS_CLK_ENABLED()((RCC->APB2ENR & (RCC_APB2ENR_ADC2EN)) != RESET)__HAL_RCC_ADC1_IS_CLK_ENABLED()((RCC->APB2ENR & (RCC_APB2ENR_ADC1EN)) != RESET)__HAL_RCC_USART6_IS_CLK_ENABLED()((RCC->APB2ENR & (RCC_APB2ENR_USART6EN)) != RESET)__HAL_RCC_USART1_IS_CLK_ENABLED()((RCC->APB2ENR & (RCC_APB2ENR_USART1EN)) != RESET)__HAL_RCC_TIM8_IS_CLK_ENABLED()((RCC->APB2ENR & (RCC_APB2ENR_TIM8EN)) != RESET)__HAL_RCC_TIM1_IS_CLK_ENABLED()((RCC->APB2ENR & (RCC_APB2ENR_TIM1EN)) != RESET)__HAL_RCC_RTC_IS_CLK_DISABLED()((RCC->APB1ENR & (RCC_APB1ENR_RTCEN)) == RESET)__HAL_RCC_RTC_IS_CLK_ENABLED()((RCC->APB1ENR & (RCC_APB1ENR_RTCEN)) != RESET)__HAL_RCC_I2C4_IS_CLK_DISABLED()((RCC->APB1ENR & (RCC_APB1ENR_I2C4EN)) == RESET)__HAL_RCC_CEC_IS_CLK_DISABLED()((RCC->APB1ENR & (RCC_APB1ENR_CECEN)) == RESET)__HAL_RCC_CAN2_IS_CLK_DISABLED()((RCC->APB1ENR & (RCC_APB1ENR_CAN2EN)) == RESET)__HAL_RCC_SPDIFRX_IS_CLK_DISABLED()((RCC->APB1ENR & (RCC_APB1ENR_SPDIFRXEN)) == RESET)__HAL_RCC_I2C4_IS_CLK_ENABLED()((RCC->APB1ENR & (RCC_APB1ENR_I2C4EN)) != RESET)__HAL_RCC_CEC_IS_CLK_ENABLED()((RCC->APB1ENR & (RCC_APB1ENR_CECEN)) != RESET)__HAL_RCC_CAN2_IS_CLK_ENABLED()((RCC->APB1ENR & (RCC_APB1ENR_CAN2EN)) != RESET)__HAL_RCC_SPDIFRX_IS_CLK_ENABLED()((RCC->APB1ENR & (RCC_APB1ENR_SPDIFRXEN)) != RESET)__HAL_RCC_UART8_IS_CLK_DISABLED()((RCC->APB1ENR & (RCC_APB1ENR_UART8EN)) == RESET)__HAL_RCC_UART7_IS_CLK_DISABLED()((RCC->APB1ENR & (RCC_APB1ENR_UART7EN)) == RESET)__HAL_RCC_DAC_IS_CLK_DISABLED()((RCC->APB1ENR & (RCC_APB1ENR_DACEN)) == RESET)__HAL_RCC_CAN1_IS_CLK_DISABLED()((RCC->APB1ENR & (RCC_APB1ENR_CAN1EN)) == RESET)__HAL_RCC_I2C3_IS_CLK_DISABLED()((RCC->APB1ENR & (RCC_APB1ENR_I2C3EN)) == RESET)__HAL_RCC_I2C2_IS_CLK_DISABLED()((RCC->APB1ENR & (RCC_APB1ENR_I2C2EN)) == RESET)__HAL_RCC_I2C1_IS_CLK_DISABLED()((RCC->APB1ENR & (RCC_APB1ENR_I2C1EN)) == RESET)__HAL_RCC_UART5_IS_CLK_DISABLED()((RCC->APB1ENR & (RCC_APB1ENR_UART5EN)) == RESET)__HAL_RCC_UART4_IS_CLK_DISABLED()((RCC->APB1ENR & (RCC_APB1ENR_UART4EN)) == RESET)__HAL_RCC_USART3_IS_CLK_DISABLED()((RCC->APB1ENR & (RCC_APB1ENR_USART3EN)) == RESET)__HAL_RCC_USART2_IS_CLK_DISABLED()((RCC->APB1ENR & (RCC_APB1ENR_USART2EN)) == RESET)__HAL_RCC_SPI3_IS_CLK_DISABLED()((RCC->APB1ENR & (RCC_APB1ENR_SPI3EN)) == RESET)__HAL_RCC_SPI2_IS_CLK_DISABLED()((RCC->APB1ENR & (RCC_APB1ENR_SPI2EN)) == RESET)__HAL_RCC_CAN3_IS_CLK_DISABLED()((RCC->APB1ENR & (RCC_APB1ENR_CAN3EN)) == RESET)__HAL_RCC_LPTIM1_IS_CLK_DISABLED()((RCC->APB1ENR & (RCC_APB1ENR_LPTIM1EN)) == RESET)__HAL_RCC_TIM14_IS_CLK_DISABLED()((RCC->APB1ENR & (RCC_APB1ENR_TIM14EN)) == RESET)__HAL_RCC_TIM13_IS_CLK_DISABLED()((RCC->APB1ENR & (RCC_APB1ENR_TIM13EN)) == RESET)__HAL_RCC_TIM12_IS_CLK_DISABLED()((RCC->APB1ENR & (RCC_APB1ENR_TIM12EN)) == RESET)__HAL_RCC_TIM7_IS_CLK_DISABLED()((RCC->APB1ENR & (RCC_APB1ENR_TIM7EN)) == RESET)__HAL_RCC_TIM6_IS_CLK_DISABLED()((RCC->APB1ENR & (RCC_APB1ENR_TIM6EN)) == RESET)__HAL_RCC_TIM5_IS_CLK_DISABLED()((RCC->APB1ENR & (RCC_APB1ENR_TIM5EN)) == RESET)__HAL_RCC_TIM4_IS_CLK_DISABLED()((RCC->APB1ENR & (RCC_APB1ENR_TIM4EN)) == RESET)__HAL_RCC_TIM3_IS_CLK_DISABLED()((RCC->APB1ENR & (RCC_APB1ENR_TIM3EN)) == RESET)__HAL_RCC_TIM2_IS_CLK_DISABLED()((RCC->APB1ENR & (RCC_APB1ENR_TIM2EN)) == RESET)__HAL_RCC_UART8_IS_CLK_ENABLED()((RCC->APB1ENR & (RCC_APB1ENR_UART8EN)) != RESET)__HAL_RCC_UART7_IS_CLK_ENABLED()((RCC->APB1ENR & (RCC_APB1ENR_UART7EN)) != RESET)__HAL_RCC_DAC_IS_CLK_ENABLED()((RCC->APB1ENR & (RCC_APB1ENR_DACEN)) != RESET)__HAL_RCC_CAN1_IS_CLK_ENABLED()((RCC->APB1ENR & (RCC_APB1ENR_CAN1EN)) != RESET)__HAL_RCC_I2C3_IS_CLK_ENABLED()((RCC->APB1ENR & (RCC_APB1ENR_I2C3EN)) != RESET)__HAL_RCC_I2C2_IS_CLK_ENABLED()((RCC->APB1ENR & (RCC_APB1ENR_I2C2EN)) != RESET)__HAL_RCC_I2C1_IS_CLK_ENABLED()((RCC->APB1ENR & (RCC_APB1ENR_I2C1EN)) != RESET)__HAL_RCC_UART5_IS_CLK_ENABLED()((RCC->APB1ENR & (RCC_APB1ENR_UART5EN)) != RESET)__HAL_RCC_UART4_IS_CLK_ENABLED()((RCC->APB1ENR & (RCC_APB1ENR_UART4EN)) != RESET)__HAL_RCC_USART3_IS_CLK_ENABLED()((RCC->APB1ENR & (RCC_APB1ENR_USART3EN)) != RESET)__HAL_RCC_USART2_IS_CLK_ENABLED()((RCC->APB1ENR & (RCC_APB1ENR_USART2EN)) != RESET)__HAL_RCC_SPI3_IS_CLK_ENABLED()((RCC->APB1ENR & (RCC_APB1ENR_SPI3EN)) != RESET)__HAL_RCC_SPI2_IS_CLK_ENABLED()((RCC->APB1ENR & (RCC_APB1ENR_SPI2EN)) != RESET)__HAL_RCC_CAN3_IS_CLK_ENABLED()((RCC->APB1ENR & (RCC_APB1ENR_CAN3EN)) != RESET)__HAL_RCC_LPTIM1_IS_CLK_ENABLED()((RCC->APB1ENR & (RCC_APB1ENR_LPTIM1EN)) != RESET)__HAL_RCC_TIM14_IS_CLK_ENABLED()((RCC->APB1ENR & (RCC_APB1ENR_TIM14EN)) != RESET)__HAL_RCC_TIM13_IS_CLK_ENABLED()((RCC->APB1ENR & (RCC_APB1ENR_TIM13EN)) != RESET)__HAL_RCC_TIM12_IS_CLK_ENABLED()((RCC->APB1ENR & (RCC_APB1ENR_TIM12EN)) != RESET)__HAL_RCC_TIM7_IS_CLK_ENABLED()((RCC->APB1ENR & (RCC_APB1ENR_TIM7EN)) != RESET)__HAL_RCC_TIM6_IS_CLK_ENABLED()((RCC->APB1ENR & (RCC_APB1ENR_TIM6EN)) != RESET)__HAL_RCC_TIM5_IS_CLK_ENABLED()((RCC->APB1ENR & (RCC_APB1ENR_TIM5EN)) != RESET)__HAL_RCC_TIM4_IS_CLK_ENABLED()((RCC->APB1ENR & (RCC_APB1ENR_TIM4EN)) != RESET)__HAL_RCC_TIM3_IS_CLK_ENABLED()((RCC->APB1ENR & (RCC_APB1ENR_TIM3EN)) != RESET)__HAL_RCC_TIM2_IS_CLK_ENABLED()((RCC->APB1ENR & (RCC_APB1ENR_TIM2EN)) != RESET)__HAL_RCC_QSPI_IS_CLK_DISABLED()((RCC->AHB3ENR & (RCC_AHB3ENR_QSPIEN)) == RESET)__HAL_RCC_FMC_IS_CLK_DISABLED()((RCC->AHB3ENR & (RCC_AHB3ENR_FMCEN)) == RESET)__HAL_RCC_QSPI_IS_CLK_ENABLED()((RCC->AHB3ENR & (RCC_AHB3ENR_QSPIEN)) != RESET)__HAL_RCC_FMC_IS_CLK_ENABLED()((RCC->AHB3ENR & (RCC_AHB3ENR_FMCEN)) != RESET)__HAL_RCC_JPEG_IS_CLK_DISABLED()((RCC->AHB2ENR & (RCC_AHB2ENR_JPEGEN)) == RESET)__HAL_RCC_JPEG_IS_CLK_ENABLED()((RCC->AHB2ENR & (RCC_AHB2ENR_JPEGEN)) != RESET)__HAL_RCC_DCMI_IS_CLK_DISABLED()((RCC->AHB2ENR & (RCC_AHB2ENR_DCMIEN)) == RESET)__HAL_RCC_DCMI_IS_CLK_ENABLED()((RCC->AHB2ENR & (RCC_AHB2ENR_DCMIEN)) != RESET)__HAL_RCC_USB_IS_OTG_FS_CLK_DISABLED()((RCC->AHB2ENR & (RCC_AHB2ENR_OTGFSEN)) == RESET)__HAL_RCC_RNG_IS_CLK_DISABLED()((RCC->AHB2ENR & (RCC_AHB2ENR_RNGEN)) == RESET)__HAL_RCC_USB_OTG_FS_IS_CLK_ENABLED()((RCC->AHB2ENR & (RCC_AHB2ENR_OTGFSEN)) != RESET)__HAL_RCC_RNG_IS_CLK_ENABLED()((RCC->AHB2ENR & (RCC_AHB2ENR_RNGEN)) != RESET)__HAL_RCC_ETH_IS_CLK_DISABLED()(__HAL_RCC_ETHMAC_IS_CLK_DISABLED() && __HAL_RCC_ETHMACTX_IS_CLK_DISABLED() && __HAL_RCC_ETHMACRX_IS_CLK_DISABLED())__HAL_RCC_ETHMACPTP_IS_CLK_DISABLED()((RCC->AHB1ENR & (RCC_AHB1ENR_ETHMACPTPEN)) == RESET)__HAL_RCC_ETHMACRX_IS_CLK_DISABLED()((RCC->AHB1ENR & (RCC_AHB1ENR_ETHMACRXEN)) == RESET)__HAL_RCC_ETHMACTX_IS_CLK_DISABLED()((RCC->AHB1ENR & (RCC_AHB1ENR_ETHMACTXEN)) == RESET)__HAL_RCC_ETHMAC_IS_CLK_DISABLED()((RCC->AHB1ENR & (RCC_AHB1ENR_ETHMACEN)) == RESET)__HAL_RCC_ETH_IS_CLK_ENABLED()(__HAL_RCC_ETHMAC_IS_CLK_ENABLED() && __HAL_RCC_ETHMACTX_IS_CLK_ENABLED() && __HAL_RCC_ETHMACRX_IS_CLK_ENABLED())__HAL_RCC_ETHMACPTP_IS_CLK_ENABLED()((RCC->AHB1ENR & (RCC_AHB1ENR_ETHMACPTPEN)) != RESET)__HAL_RCC_ETHMACRX_IS_CLK_ENABLED()((RCC->AHB1ENR & (RCC_AHB1ENR_ETHMACRXEN)) != RESET)__HAL_RCC_ETHMACTX_IS_CLK_ENABLED()((RCC->AHB1ENR & (RCC_AHB1ENR_ETHMACTXEN)) != RESET)__HAL_RCC_ETHMAC_IS_CLK_ENABLED()((RCC->AHB1ENR & (RCC_AHB1ENR_ETHMACEN)) != RESET)__HAL_RCC_DMA2D_IS_CLK_DISABLED()((RCC->AHB1ENR & (RCC_AHB1ENR_DMA2DEN)) == RESET)__HAL_RCC_GPIOK_IS_CLK_DISABLED()((RCC->AHB1ENR & (RCC_AHB1ENR_GPIOKEN)) == RESET)__HAL_RCC_GPIOJ_IS_CLK_DISABLED()((RCC->AHB1ENR & (RCC_AHB1ENR_GPIOJEN)) == RESET)__HAL_RCC_GPIOI_IS_CLK_DISABLED()((RCC->AHB1ENR & (RCC_AHB1ENR_GPIOIEN)) == RESET)__HAL_RCC_GPIOH_IS_CLK_DISABLED()((RCC->AHB1ENR & (RCC_AHB1ENR_GPIOHEN)) == RESET)__HAL_RCC_GPIOG_IS_CLK_DISABLED()((RCC->AHB1ENR & (RCC_AHB1ENR_GPIOGEN)) == RESET)__HAL_RCC_GPIOF_IS_CLK_DISABLED()((RCC->AHB1ENR & (RCC_AHB1ENR_GPIOFEN)) == RESET)__HAL_RCC_GPIOE_IS_CLK_DISABLED()((RCC->AHB1ENR & (RCC_AHB1ENR_GPIOEEN)) == RESET)__HAL_RCC_GPIOD_IS_CLK_DISABLED()((RCC->AHB1ENR & (RCC_AHB1ENR_GPIODEN)) == RESET)__HAL_RCC_GPIOC_IS_CLK_DISABLED()((RCC->AHB1ENR & (RCC_AHB1ENR_GPIOCEN)) == RESET)__HAL_RCC_GPIOB_IS_CLK_DISABLED()((RCC->AHB1ENR & (RCC_AHB1ENR_GPIOBEN)) == RESET)__HAL_RCC_GPIOA_IS_CLK_DISABLED()((RCC->AHB1ENR & (RCC_AHB1ENR_GPIOAEN)) == RESET)__HAL_RCC_USB_OTG_HS_ULPI_IS_CLK_DISABLED()((RCC->AHB1ENR & (RCC_AHB1ENR_OTGHSULPIEN)) == RESET)__HAL_RCC_USB_OTG_HS_IS_CLK_DISABLED()((RCC->AHB1ENR & (RCC_AHB1ENR_OTGHSEN)) == RESET)__HAL_RCC_DMA2_IS_CLK_DISABLED()((RCC->AHB1ENR & (RCC_AHB1ENR_DMA2EN)) == RESET)__HAL_RCC_DTCMRAMEN_IS_CLK_DISABLED()((RCC->AHB1ENR & (RCC_AHB1ENR_DTCMRAMEN)) == RESET)__HAL_RCC_BKPSRAM_IS_CLK_DISABLED()((RCC->AHB1ENR & (RCC_AHB1ENR_BKPSRAMEN)) == RESET)__HAL_RCC_DMA2D_IS_CLK_ENABLED()((RCC->AHB1ENR & (RCC_AHB1ENR_DMA2DEN)) != RESET)__HAL_RCC_GPIOK_IS_CLK_ENABLED()((RCC->AHB1ENR & (RCC_AHB1ENR_GPIOKEN)) != RESET)__HAL_RCC_GPIOJ_IS_CLK_ENABLED()((RCC->AHB1ENR & (RCC_AHB1ENR_GPIOJEN)) != RESET)__HAL_RCC_GPIOI_IS_CLK_ENABLED()((RCC->AHB1ENR & (RCC_AHB1ENR_GPIOIEN)) != RESET)__HAL_RCC_GPIOH_IS_CLK_ENABLED()((RCC->AHB1ENR & (RCC_AHB1ENR_GPIOHEN)) != RESET)__HAL_RCC_GPIOG_IS_CLK_ENABLED()((RCC->AHB1ENR & (RCC_AHB1ENR_GPIOGEN)) != RESET)__HAL_RCC_GPIOF_IS_CLK_ENABLED()((RCC->AHB1ENR & (RCC_AHB1ENR_GPIOFEN)) != RESET)__HAL_RCC_GPIOE_IS_CLK_ENABLED()((RCC->AHB1ENR & (RCC_AHB1ENR_GPIOEEN)) != RESET)__HAL_RCC_GPIOD_IS_CLK_ENABLED()((RCC->AHB1ENR & (RCC_AHB1ENR_GPIODEN)) != RESET)__HAL_RCC_GPIOC_IS_CLK_ENABLED()((RCC->AHB1ENR & (RCC_AHB1ENR_GPIOCEN)) != RESET)__HAL_RCC_GPIOB_IS_CLK_ENABLED()((RCC->AHB1ENR & (RCC_AHB1ENR_GPIOBEN)) != RESET)__HAL_RCC_GPIOA_IS_CLK_ENABLED()((RCC->AHB1ENR & (RCC_AHB1ENR_GPIOAEN)) != RESET)__HAL_RCC_USB_OTG_HS_ULPI_IS_CLK_ENABLED()((RCC->AHB1ENR & (RCC_AHB1ENR_OTGHSULPIEN)) != RESET)__HAL_RCC_USB_OTG_HS_IS_CLK_ENABLED()((RCC->AHB1ENR & (RCC_AHB1ENR_OTGHSEN)) != RESET)__HAL_RCC_DMA2_IS_CLK_ENABLED()((RCC->AHB1ENR & (RCC_AHB1ENR_DMA2EN)) != RESET)__HAL_RCC_DTCMRAMEN_IS_CLK_ENABLED()((RCC->AHB1ENR & (RCC_AHB1ENR_DTCMRAMEN)) != RESET)__HAL_RCC_BKPSRAM_IS_CLK_ENABLED()((RCC->AHB1ENR & (RCC_AHB1ENR_BKPSRAMEN)) != RESET)__HAL_RCC_MDIO_CLK_DISABLE()(RCC->APB2ENR &= ~(RCC_APB2ENR_MDIOEN))__HAL_RCC_DFSDM1_CLK_DISABLE()(RCC->APB2ENR &= ~(RCC_APB2ENR_DFSDM1EN))__HAL_RCC_DSI_CLK_DISABLE()(RCC->APB2ENR &= ~(RCC_APB2ENR_DSIEN))__HAL_RCC_LTDC_CLK_DISABLE()(RCC->APB2ENR &= ~(RCC_APB2ENR_LTDCEN))__HAL_RCC_SAI2_CLK_DISABLE()(RCC->APB2ENR &= ~(RCC_APB2ENR_SAI2EN))__HAL_RCC_SAI1_CLK_DISABLE()(RCC->APB2ENR &= ~(RCC_APB2ENR_SAI1EN))__HAL_RCC_SPI6_CLK_DISABLE()(RCC->APB2ENR &= ~(RCC_APB2ENR_SPI6EN))__HAL_RCC_SPI5_CLK_DISABLE()(RCC->APB2ENR &= ~(RCC_APB2ENR_SPI5EN))__HAL_RCC_TIM11_CLK_DISABLE()(RCC->APB2ENR &= ~(RCC_APB2ENR_TIM11EN))__HAL_RCC_TIM10_CLK_DISABLE()(RCC->APB2ENR &= ~(RCC_APB2ENR_TIM10EN))__HAL_RCC_TIM9_CLK_DISABLE()(RCC->APB2ENR &= ~(RCC_APB2ENR_TIM9EN))__HAL_RCC_SPI4_CLK_DISABLE()(RCC->APB2ENR &= ~(RCC_APB2ENR_SPI4EN))__HAL_RCC_SPI1_CLK_DISABLE()(RCC->APB2ENR &= ~(RCC_APB2ENR_SPI1EN))__HAL_RCC_SDMMC1_CLK_DISABLE()(RCC->APB2ENR &= ~(RCC_APB2ENR_SDMMC1EN))__HAL_RCC_ADC3_CLK_DISABLE()(RCC->APB2ENR &= ~(RCC_APB2ENR_ADC3EN))__HAL_RCC_ADC2_CLK_DISABLE()(RCC->APB2ENR &= ~(RCC_APB2ENR_ADC2EN))__HAL_RCC_ADC1_CLK_DISABLE()(RCC->APB2ENR &= ~(RCC_APB2ENR_ADC1EN))__HAL_RCC_SDMMC2_CLK_DISABLE()(RCC->APB2ENR &= ~(RCC_APB2ENR_SDMMC2EN))__HAL_RCC_USART6_CLK_DISABLE()(RCC->APB2ENR &= ~(RCC_APB2ENR_USART6EN))(RCC->APB2ENR &= ~(RCC_APB2ENR_USART1EN))__HAL_RCC_TIM8_CLK_DISABLE()(RCC->APB2ENR &= ~(RCC_APB2ENR_TIM8EN))__HAL_RCC_TIM1_CLK_DISABLE()(RCC->APB2ENR &= ~(RCC_APB2ENR_TIM1EN))__HAL_RCC_MDIO_CLK_ENABLE()do { __IO uint32_t tmpreg; SET_BIT(RCC->APB2ENR, RCC_APB2ENR_MDIOEN); tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_MDIOEN); UNUSED(tmpreg); } while(0)__HAL_RCC_DFSDM1_CLK_ENABLE()do { __IO uint32_t tmpreg; SET_BIT(RCC->APB2ENR, RCC_APB2ENR_DFSDM1EN); tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_DFSDM1EN); UNUSED(tmpreg); } while(0)__HAL_RCC_DSI_CLK_ENABLE()do { __IO uint32_t tmpreg; SET_BIT(RCC->APB2ENR, RCC_APB2ENR_DSIEN); tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_DSIEN); UNUSED(tmpreg); } while(0)__HAL_RCC_LTDC_CLK_ENABLE()do { __IO uint32_t tmpreg; SET_BIT(RCC->APB2ENR, RCC_APB2ENR_LTDCEN); tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_LTDCEN); UNUSED(tmpreg); } while(0)__HAL_RCC_SAI2_CLK_ENABLE()do { __IO uint32_t tmpreg; SET_BIT(RCC->APB2ENR, RCC_APB2ENR_SAI2EN); tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_SAI2EN); UNUSED(tmpreg); } while(0)__HAL_RCC_SAI1_CLK_ENABLE()do { __IO uint32_t tmpreg; SET_BIT(RCC->APB2ENR, RCC_APB2ENR_SAI1EN); tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_SAI1EN); UNUSED(tmpreg); } while(0)__HAL_RCC_SPI6_CLK_ENABLE()do { __IO uint32_t tmpreg; SET_BIT(RCC->APB2ENR, RCC_APB2ENR_SPI6EN); tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_SPI6EN); UNUSED(tmpreg); } while(0)__HAL_RCC_SPI5_CLK_ENABLE()do { __IO uint32_t tmpreg; SET_BIT(RCC->APB2ENR, RCC_APB2ENR_SPI5EN); tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_SPI5EN); UNUSED(tmpreg); } while(0)__HAL_RCC_TIM11_CLK_ENABLE()do { __IO uint32_t tmpreg; SET_BIT(RCC->APB2ENR, RCC_APB2ENR_TIM11EN); tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_TIM11EN); UNUSED(tmpreg); } while(0)__HAL_RCC_TIM10_CLK_ENABLE()do { __IO uint32_t tmpreg; SET_BIT(RCC->APB2ENR, RCC_APB2ENR_TIM10EN); tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_TIM10EN); UNUSED(tmpreg); } while(0)__HAL_RCC_TIM9_CLK_ENABLE()do { __IO uint32_t tmpreg; SET_BIT(RCC->APB2ENR, RCC_APB2ENR_TIM9EN); tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_TIM9EN); UNUSED(tmpreg); } while(0)__HAL_RCC_SPI4_CLK_ENABLE()do { __IO uint32_t tmpreg; SET_BIT(RCC->APB2ENR, RCC_APB2ENR_SPI4EN); tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_SPI4EN); UNUSED(tmpreg); } while(0)__HAL_RCC_SPI1_CLK_ENABLE()do { __IO uint32_t tmpreg; SET_BIT(RCC->APB2ENR, RCC_APB2ENR_SPI1EN); tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_SPI1EN); UNUSED(tmpreg); } while(0)__HAL_RCC_SDMMC1_CLK_ENABLE()do { __IO uint32_t tmpreg; SET_BIT(RCC->APB2ENR, RCC_APB2ENR_SDMMC1EN); tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_SDMMC1EN); UNUSED(tmpreg); } while(0)do { __IO uint32_t tmpreg; SET_BIT(RCC->APB2ENR, RCC_APB2ENR_ADC3EN); tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_ADC3EN); UNUSED(tmpreg); } while(0)__HAL_RCC_ADC2_CLK_ENABLE()do { __IO uint32_t tmpreg; SET_BIT(RCC->APB2ENR, RCC_APB2ENR_ADC2EN); tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_ADC2EN); UNUSED(tmpreg); } while(0)__HAL_RCC_ADC1_CLK_ENABLE()do { __IO uint32_t tmpreg; SET_BIT(RCC->APB2ENR, RCC_APB2ENR_ADC1EN); tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_ADC1EN); UNUSED(tmpreg); } while(0)__HAL_RCC_SDMMC2_CLK_ENABLE()do { __IO uint32_t tmpreg; SET_BIT(RCC->APB2ENR, RCC_APB2ENR_SDMMC2EN); tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_SDMMC2EN); UNUSED(tmpreg); } while(0)__HAL_RCC_USART6_CLK_ENABLE()do { __IO uint32_t tmpreg; SET_BIT(RCC->APB2ENR, RCC_APB2ENR_USART6EN); tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_USART6EN); UNUSED(tmpreg); } while(0)do { __IO uint32_t tmpreg; SET_BIT(RCC->APB2ENR, RCC_APB2ENR_USART1EN); tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_USART1EN); UNUSED(tmpreg); } while(0)__HAL_RCC_TIM8_CLK_ENABLE()do { __IO uint32_t tmpreg; SET_BIT(RCC->APB2ENR, RCC_APB2ENR_TIM8EN); tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_TIM8EN); UNUSED(tmpreg); } while(0)__HAL_RCC_TIM1_CLK_ENABLE()do { __IO uint32_t tmpreg; SET_BIT(RCC->APB2ENR, RCC_APB2ENR_TIM1EN); tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_TIM1EN); UNUSED(tmpreg); } while(0)__HAL_RCC_CEC_CLK_DISABLE()(RCC->APB1ENR &= ~(RCC_APB1ENR_CECEN))__HAL_RCC_CAN2_CLK_DISABLE()(RCC->APB1ENR &= ~(RCC_APB1ENR_CAN2EN))__HAL_RCC_I2C4_CLK_DISABLE()(RCC->APB1ENR &= ~(RCC_APB1ENR_I2C4EN))__HAL_RCC_SPDIFRX_CLK_DISABLE()(RCC->APB1ENR &= ~(RCC_APB1ENR_SPDIFRXEN))__HAL_RCC_UART8_CLK_DISABLE()(RCC->APB1ENR &= ~(RCC_APB1ENR_UART8EN))__HAL_RCC_UART7_CLK_DISABLE()(RCC->APB1ENR &= ~(RCC_APB1ENR_UART7EN))__HAL_RCC_DAC_CLK_DISABLE()(RCC->APB1ENR &= ~(RCC_APB1ENR_DACEN))__HAL_RCC_CAN1_CLK_DISABLE()(RCC->APB1ENR &= ~(RCC_APB1ENR_CAN1EN))__HAL_RCC_I2C3_CLK_DISABLE()(RCC->APB1ENR &= ~(RCC_APB1ENR_I2C3EN))__HAL_RCC_I2C2_CLK_DISABLE()(RCC->APB1ENR &= ~(RCC_APB1ENR_I2C2EN))__HAL_RCC_I2C1_CLK_DISABLE()(RCC->APB1ENR &= ~(RCC_APB1ENR_I2C1EN))__HAL_RCC_UART5_CLK_DISABLE()(RCC->APB1ENR &= ~(RCC_APB1ENR_UART5EN))__HAL_RCC_UART4_CLK_DISABLE()(RCC->APB1ENR &= ~(RCC_APB1ENR_UART4EN))__HAL_RCC_USART3_CLK_DISABLE()(RCC->APB1ENR &= ~(RCC_APB1ENR_USART3EN))__HAL_RCC_USART2_CLK_DISABLE()(RCC->APB1ENR &= ~(RCC_APB1ENR_USART2EN))__HAL_RCC_SPI3_CLK_DISABLE()(RCC->APB1ENR &= ~(RCC_APB1ENR_SPI3EN))__HAL_RCC_SPI2_CLK_DISABLE()(RCC->APB1ENR &= ~(RCC_APB1ENR_SPI2EN))__HAL_RCC_CAN3_CLK_DISABLE()(RCC->APB1ENR &= ~(RCC_APB1ENR_CAN3EN))__HAL_RCC_RTC_CLK_DISABLE()(RCC->APB1ENR &= ~(RCC_APB1ENR_RTCEN))__HAL_RCC_LPTIM1_CLK_DISABLE()(RCC->APB1ENR &= ~(RCC_APB1ENR_LPTIM1EN))__HAL_RCC_TIM14_CLK_DISABLE()(RCC->APB1ENR &= ~(RCC_APB1ENR_TIM14EN))__HAL_RCC_TIM13_CLK_DISABLE()(RCC->APB1ENR &= ~(RCC_APB1ENR_TIM13EN))__HAL_RCC_TIM12_CLK_DISABLE()(RCC->APB1ENR &= ~(RCC_APB1ENR_TIM12EN))__HAL_RCC_TIM7_CLK_DISABLE()(RCC->APB1ENR &= ~(RCC_APB1ENR_TIM7EN))__HAL_RCC_TIM6_CLK_DISABLE()(RCC->APB1ENR &= ~(RCC_APB1ENR_TIM6EN))__HAL_RCC_TIM5_CLK_DISABLE()(RCC->APB1ENR &= ~(RCC_APB1ENR_TIM5EN))__HAL_RCC_TIM4_CLK_DISABLE()(RCC->APB1ENR &= ~(RCC_APB1ENR_TIM4EN))__HAL_RCC_TIM3_CLK_DISABLE()(RCC->APB1ENR &= ~(RCC_APB1ENR_TIM3EN))__HAL_RCC_TIM2_CLK_DISABLE()(RCC->APB1ENR &= ~(RCC_APB1ENR_TIM2EN))__HAL_RCC_CEC_CLK_ENABLE()do { __IO uint32_t tmpreg; SET_BIT(RCC->APB1ENR, RCC_APB1ENR_CECEN); tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_CECEN); UNUSED(tmpreg); } while(0)__HAL_RCC_CAN2_CLK_ENABLE()do { __IO uint32_t tmpreg; SET_BIT(RCC->APB1ENR, RCC_APB1ENR_CAN2EN); tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_CAN2EN); UNUSED(tmpreg); } while(0)__HAL_RCC_I2C4_CLK_ENABLE()do { __IO uint32_t tmpreg; SET_BIT(RCC->APB1ENR, RCC_APB1ENR_I2C4EN); tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_I2C4EN); UNUSED(tmpreg); } while(0)__HAL_RCC_SPDIFRX_CLK_ENABLE()do { __IO uint32_t tmpreg; SET_BIT(RCC->APB1ENR, RCC_APB1ENR_SPDIFRXEN); tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_SPDIFRXEN); UNUSED(tmpreg); } while(0)__HAL_RCC_UART8_CLK_ENABLE()do { __IO uint32_t tmpreg; SET_BIT(RCC->APB1ENR, RCC_APB1ENR_UART8EN); tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_UART8EN); UNUSED(tmpreg); } while(0)__HAL_RCC_UART7_CLK_ENABLE()do { __IO uint32_t tmpreg; SET_BIT(RCC->APB1ENR, RCC_APB1ENR_UART7EN); tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_UART7EN); UNUSED(tmpreg); } while(0)__HAL_RCC_DAC_CLK_ENABLE()do { __IO uint32_t tmpreg; SET_BIT(RCC->APB1ENR, RCC_APB1ENR_DACEN); tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_DACEN); UNUSED(tmpreg); } while(0)__HAL_RCC_CAN1_CLK_ENABLE()do { __IO uint32_t tmpreg; SET_BIT(RCC->APB1ENR, RCC_APB1ENR_CAN1EN); tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_CAN1EN); UNUSED(tmpreg); } while(0)__HAL_RCC_I2C3_CLK_ENABLE()do { __IO uint32_t tmpreg; SET_BIT(RCC->APB1ENR, RCC_APB1ENR_I2C3EN); tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_I2C3EN); UNUSED(tmpreg); } while(0)__HAL_RCC_I2C2_CLK_ENABLE()do { __IO uint32_t tmpreg; SET_BIT(RCC->APB1ENR, RCC_APB1ENR_I2C2EN); tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_I2C2EN); UNUSED(tmpreg); } while(0)do { __IO uint32_t tmpreg; SET_BIT(RCC->APB1ENR, RCC_APB1ENR_I2C1EN); tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_I2C1EN); UNUSED(tmpreg); } while(0)__HAL_RCC_UART5_CLK_ENABLE()do { __IO uint32_t tmpreg; SET_BIT(RCC->APB1ENR, RCC_APB1ENR_UART5EN); tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_UART5EN); UNUSED(tmpreg); } while(0)__HAL_RCC_UART4_CLK_ENABLE()do { __IO uint32_t tmpreg; SET_BIT(RCC->APB1ENR, RCC_APB1ENR_UART4EN); tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_UART4EN); UNUSED(tmpreg); } while(0)__HAL_RCC_USART3_CLK_ENABLE()do { __IO uint32_t tmpreg; SET_BIT(RCC->APB1ENR, RCC_APB1ENR_USART3EN); tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_USART3EN); UNUSED(tmpreg); } while(0)__HAL_RCC_USART2_CLK_ENABLE()do { __IO uint32_t tmpreg; SET_BIT(RCC->APB1ENR, RCC_APB1ENR_USART2EN); tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_USART2EN); UNUSED(tmpreg); } while(0)__HAL_RCC_SPI3_CLK_ENABLE()do { __IO uint32_t tmpreg; SET_BIT(RCC->APB1ENR, RCC_APB1ENR_SPI3EN); tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_SPI3EN); UNUSED(tmpreg); } while(0)__HAL_RCC_SPI2_CLK_ENABLE()do { __IO uint32_t tmpreg; SET_BIT(RCC->APB1ENR, RCC_APB1ENR_SPI2EN); tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_SPI2EN); UNUSED(tmpreg); } while(0)__HAL_RCC_CAN3_CLK_ENABLE()do { __IO uint32_t tmpreg; SET_BIT(RCC->APB1ENR, RCC_APB1ENR_CAN3EN); tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_CAN3EN); UNUSED(tmpreg); } while(0)__HAL_RCC_RTC_CLK_ENABLE()do { __IO uint32_t tmpreg; SET_BIT(RCC->APB1ENR, RCC_APB1ENR_RTCEN); tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_RTCEN); UNUSED(tmpreg); } while(0)__HAL_RCC_LPTIM1_CLK_ENABLE()do { __IO uint32_t tmpreg; SET_BIT(RCC->APB1ENR, RCC_APB1ENR_LPTIM1EN); tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_LPTIM1EN); UNUSED(tmpreg); } while(0)__HAL_RCC_TIM14_CLK_ENABLE()do { __IO uint32_t tmpreg; SET_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM14EN); tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM14EN); UNUSED(tmpreg); } while(0)__HAL_RCC_TIM13_CLK_ENABLE()do { __IO uint32_t tmpreg; SET_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM13EN); tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM13EN); UNUSED(tmpreg); } while(0)__HAL_RCC_TIM12_CLK_ENABLE()do { __IO uint32_t tmpreg; SET_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM12EN); tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM12EN); UNUSED(tmpreg); } while(0)__HAL_RCC_TIM7_CLK_ENABLE()do { __IO uint32_t tmpreg; SET_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM7EN); tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM7EN); UNUSED(tmpreg); } while(0)__HAL_RCC_TIM6_CLK_ENABLE()do { __IO uint32_t tmpreg; SET_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM6EN); tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM6EN); UNUSED(tmpreg); } while(0)__HAL_RCC_TIM5_CLK_ENABLE()do { __IO uint32_t tmpreg; SET_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM5EN); tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM5EN); UNUSED(tmpreg); } while(0)__HAL_RCC_TIM4_CLK_ENABLE()do { __IO uint32_t tmpreg; SET_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM4EN); tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM4EN); UNUSED(tmpreg); } while(0)__HAL_RCC_TIM3_CLK_ENABLE()do { __IO uint32_t tmpreg; SET_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM3EN); tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM3EN); UNUSED(tmpreg); } while(0)__HAL_RCC_TIM2_CLK_ENABLE()do { __IO uint32_t tmpreg; SET_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM2EN); tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM2EN); UNUSED(tmpreg); } while(0)__HAL_RCC_QSPI_CLK_DISABLE()(RCC->AHB3ENR &= ~(RCC_AHB3ENR_QSPIEN))__HAL_RCC_FMC_CLK_DISABLE()(RCC->AHB3ENR &= ~(RCC_AHB3ENR_FMCEN))__HAL_RCC_QSPI_CLK_ENABLE()do { __IO uint32_t tmpreg; SET_BIT(RCC->AHB3ENR, RCC_AHB3ENR_QSPIEN); tmpreg = READ_BIT(RCC->AHB3ENR, RCC_AHB3ENR_QSPIEN); UNUSED(tmpreg); } while(0)__HAL_RCC_FMC_CLK_ENABLE()do { __IO uint32_t tmpreg; SET_BIT(RCC->AHB3ENR, RCC_AHB3ENR_FMCEN); tmpreg = READ_BIT(RCC->AHB3ENR, RCC_AHB3ENR_FMCEN); UNUSED(tmpreg); } while(0)__HAL_RCC_USB_OTG_FS_CLK_DISABLE()(RCC->AHB2ENR &= ~(RCC_AHB2ENR_OTGFSEN))__HAL_RCC_RNG_CLK_DISABLE()(RCC->AHB2ENR &= ~(RCC_AHB2ENR_RNGEN))__HAL_RCC_USB_OTG_FS_CLK_ENABLE()do { __IO uint32_t tmpreg; SET_BIT(RCC->AHB2ENR, RCC_AHB2ENR_OTGFSEN); tmpreg = READ_BIT(RCC->AHB2ENR, RCC_AHB2ENR_OTGFSEN); UNUSED(tmpreg); __HAL_RCC_SYSCFG_CLK_ENABLE(); } while(0)__HAL_RCC_RNG_CLK_ENABLE()do { __IO uint32_t tmpreg; SET_BIT(RCC->AHB2ENR, RCC_AHB2ENR_RNGEN); tmpreg = READ_BIT(RCC->AHB2ENR, RCC_AHB2ENR_RNGEN); UNUSED(tmpreg); } while(0)__HAL_RCC_JPEG_CLK_DISABLE()(RCC->AHB2ENR &= ~(RCC_AHB2ENR_JPEGEN))__HAL_RCC_JPEG_CLK_ENABLE()do { __IO uint32_t tmpreg; SET_BIT(RCC->AHB2ENR, RCC_AHB2ENR_JPEGEN); tmpreg = READ_BIT(RCC->AHB2ENR, RCC_AHB2ENR_JPEGEN); UNUSED(tmpreg); } while(0)__HAL_RCC_DCMI_CLK_DISABLE()(RCC->AHB2ENR &= ~(RCC_AHB2ENR_DCMIEN))__HAL_RCC_DCMI_CLK_ENABLE()do { __IO uint32_t tmpreg; SET_BIT(RCC->AHB2ENR, RCC_AHB2ENR_DCMIEN); tmpreg = READ_BIT(RCC->AHB2ENR, RCC_AHB2ENR_DCMIEN); UNUSED(tmpreg); } while(0)__HAL_RCC_ETH_CLK_DISABLE()do { __HAL_RCC_ETHMACTX_CLK_DISABLE(); __HAL_RCC_ETHMACRX_CLK_DISABLE(); __HAL_RCC_ETHMAC_CLK_DISABLE(); } while(0)__HAL_RCC_ETHMACPTP_CLK_DISABLE()(RCC->AHB1ENR &= ~(RCC_AHB1ENR_ETHMACPTPEN))__HAL_RCC_ETHMACRX_CLK_DISABLE()(RCC->AHB1ENR &= ~(RCC_AHB1ENR_ETHMACRXEN))__HAL_RCC_ETHMACTX_CLK_DISABLE()(RCC->AHB1ENR &= ~(RCC_AHB1ENR_ETHMACTXEN))__HAL_RCC_ETHMAC_CLK_DISABLE()(RCC->AHB1ENR &= ~(RCC_AHB1ENR_ETHMACEN))__HAL_RCC_ETH_CLK_ENABLE()do { __HAL_RCC_ETHMAC_CLK_ENABLE(); __HAL_RCC_ETHMACTX_CLK_ENABLE(); __HAL_RCC_ETHMACRX_CLK_ENABLE(); } while(0)__HAL_RCC_ETHMACPTP_CLK_ENABLE()do { __IO uint32_t tmpreg; SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_ETHMACPTPEN); tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_ETHMACPTPEN); UNUSED(tmpreg); } while(0)__HAL_RCC_ETHMACRX_CLK_ENABLE()do { __IO uint32_t tmpreg; SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_ETHMACRXEN); tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_ETHMACRXEN); UNUSED(tmpreg); } while(0)__HAL_RCC_ETHMACTX_CLK_ENABLE()do { __IO uint32_t tmpreg; SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_ETHMACTXEN); tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_ETHMACTXEN); UNUSED(tmpreg); } while(0)__HAL_RCC_ETHMAC_CLK_ENABLE()do { __IO uint32_t tmpreg; SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_ETHMACEN); tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_ETHMACEN); UNUSED(tmpreg); } while(0)__HAL_RCC_DMA2D_CLK_DISABLE()(RCC->AHB1ENR &= ~(RCC_AHB1ENR_DMA2DEN))__HAL_RCC_GPIOK_CLK_DISABLE()(RCC->AHB1ENR &= ~(RCC_AHB1ENR_GPIOKEN))(RCC->AHB1ENR &= ~(RCC_AHB1ENR_GPIOJEN))(RCC->AHB1ENR &= ~(RCC_AHB1ENR_GPIOIEN))__HAL_RCC_GPIOH_CLK_DISABLE()(RCC->AHB1ENR &= ~(RCC_AHB1ENR_GPIOHEN))__HAL_RCC_GPIOG_CLK_DISABLE()(RCC->AHB1ENR &= ~(RCC_AHB1ENR_GPIOGEN))__HAL_RCC_GPIOF_CLK_DISABLE()(RCC->AHB1ENR &= ~(RCC_AHB1ENR_GPIOFEN))__HAL_RCC_GPIOE_CLK_DISABLE()(RCC->AHB1ENR &= ~(RCC_AHB1ENR_GPIOEEN))__HAL_RCC_GPIOD_CLK_DISABLE()(RCC->AHB1ENR &= ~(RCC_AHB1ENR_GPIODEN))(RCC->AHB1ENR &= ~(RCC_AHB1ENR_GPIOCEN))__HAL_RCC_GPIOB_CLK_DISABLE()(RCC->AHB1ENR &= ~(RCC_AHB1ENR_GPIOBEN))(RCC->AHB1ENR &= ~(RCC_AHB1ENR_GPIOAEN))__HAL_RCC_USB_OTG_HS_ULPI_CLK_DISABLE()(RCC->AHB1ENR &= ~(RCC_AHB1ENR_OTGHSULPIEN))__HAL_RCC_USB_OTG_HS_CLK_DISABLE()(RCC->AHB1ENR &= ~(RCC_AHB1ENR_OTGHSEN))__HAL_RCC_DMA2_CLK_DISABLE()(RCC->AHB1ENR &= ~(RCC_AHB1ENR_DMA2EN))__HAL_RCC_DTCMRAMEN_CLK_DISABLE()(RCC->AHB1ENR &= ~(RCC_AHB1ENR_DTCMRAMEN))__HAL_RCC_BKPSRAM_CLK_DISABLE()(RCC->AHB1ENR &= ~(RCC_AHB1ENR_BKPSRAMEN))__HAL_RCC_DMA2D_CLK_ENABLE()do { __IO uint32_t tmpreg; SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_DMA2DEN); tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_DMA2DEN); UNUSED(tmpreg); } while(0)__HAL_RCC_GPIOK_CLK_ENABLE()do { __IO uint32_t tmpreg; SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIOKEN); tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIOKEN); UNUSED(tmpreg); } while(0)do { __IO uint32_t tmpreg; SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIOJEN); tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIOJEN); UNUSED(tmpreg); } while(0)do { __IO uint32_t tmpreg; SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIOIEN); tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIOIEN); UNUSED(tmpreg); } while(0)__HAL_RCC_GPIOH_CLK_ENABLE()do { __IO uint32_t tmpreg; SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIOHEN); tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIOHEN); UNUSED(tmpreg); } while(0)__HAL_RCC_GPIOG_CLK_ENABLE()do { __IO uint32_t tmpreg; SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIOGEN); tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIOGEN); UNUSED(tmpreg); } while(0)do { __IO uint32_t tmpreg; SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIOFEN); tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIOFEN); UNUSED(tmpreg); } while(0)__HAL_RCC_GPIOE_CLK_ENABLE()do { __IO uint32_t tmpreg; SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIOEEN); tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIOEEN); UNUSED(tmpreg); } while(0)__HAL_RCC_GPIOD_CLK_ENABLE()do { __IO uint32_t tmpreg; SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIODEN); tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIODEN); UNUSED(tmpreg); } while(0)do { __IO uint32_t tmpreg; SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIOCEN); tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIOCEN); UNUSED(tmpreg); } while(0)do { __IO uint32_t tmpreg; SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIOBEN); tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIOBEN); UNUSED(tmpreg); } while(0)do { __IO uint32_t tmpreg; SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIOAEN); tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIOAEN); UNUSED(tmpreg); } while(0)__HAL_RCC_USB_OTG_HS_ULPI_CLK_ENABLE()do { __IO uint32_t tmpreg; SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_OTGHSULPIEN); tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_OTGHSULPIEN); UNUSED(tmpreg); } while(0)__HAL_RCC_USB_OTG_HS_CLK_ENABLE()do { __IO uint32_t tmpreg; SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_OTGHSEN); tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_OTGHSEN); UNUSED(tmpreg); } while(0)__HAL_RCC_DMA2_CLK_ENABLE()do { __IO uint32_t tmpreg; SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_DMA2EN); tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_DMA2EN); UNUSED(tmpreg); } while(0)__HAL_RCC_DTCMRAMEN_CLK_ENABLE()do { __IO uint32_t tmpreg; SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_DTCMRAMEN); tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_DTCMRAMEN); UNUSED(tmpreg); } while(0)__HAL_RCC_BKPSRAM_CLK_ENABLE()do { __IO uint32_t tmpreg; SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_BKPSRAMEN); tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_BKPSRAMEN); UNUSED(tmpreg); } while(0)RCC_DSICLKSOURCE_PLLR((uint32_t)RCC_DCKCFGR2_DSISEL)RCC_DSICLKSOURCE_DSIPHY((uint32_t)0x00000000U)RCC_DFSDM1AUDIOCLKSOURCE_SAI2RCC_DFSDM1AUDIOCLKSOURCE_SAI1RCC_SDMMC2CLKSOURCE_SYSCLKRCC_SDMMC2CLKSOURCE_CLK48RCC_TIMPRES_ACTIVATEDRCC_TIMPRES_DESACTIVATEDRCC_CLK48SOURCE_PLLSAIPRCC_CLK48SOURCE_PLLRCC_LPTIM1CLKSOURCE_LSERCC_LPTIM1CLKSOURCE_HSIRCC_LPTIM1CLKSOURCE_LSIRCC_I2C4CLKSOURCE_HSIRCC_I2C4CLKSOURCE_SYSCLKRCC_I2C4CLKSOURCE_PCLK1RCC_I2C3CLKSOURCE_HSIRCC_I2C3CLKSOURCE_SYSCLKRCC_I2C3CLKSOURCE_PCLK1RCC_I2C2CLKSOURCE_HSIRCC_I2C2CLKSOURCE_SYSCLKRCC_I2C2CLKSOURCE_PCLK1RCC_I2C1CLKSOURCE_HSIRCC_I2C1CLKSOURCE_SYSCLKRCC_I2C1CLKSOURCE_PCLK1RCC_UART8CLKSOURCE_LSERCC_UART8CLKSOURCE_HSIRCC_UART8CLKSOURCE_SYSCLKRCC_UART8CLKSOURCE_PCLK1RCC_UART7CLKSOURCE_LSERCC_UART7CLKSOURCE_HSIRCC_UART7CLKSOURCE_SYSCLKRCC_UART7CLKSOURCE_PCLK1RCC_USART6CLKSOURCE_LSERCC_USART6CLKSOURCE_HSIRCC_USART6CLKSOURCE_SYSCLKRCC_USART6CLKSOURCE_PCLK2RCC_UART5CLKSOURCE_LSERCC_UART5CLKSOURCE_HSIRCC_UART5CLKSOURCE_SYSCLKRCC_UART5CLKSOURCE_PCLK1RCC_UART4CLKSOURCE_LSERCC_UART4CLKSOURCE_HSIRCC_UART4CLKSOURCE_SYSCLKRCC_UART4CLKSOURCE_PCLK1RCC_USART3CLKSOURCE_LSERCC_USART3CLKSOURCE_HSIRCC_USART3CLKSOURCE_SYSCLKRCC_USART3CLKSOURCE_PCLK1RCC_USART2CLKSOURCE_LSERCC_USART2CLKSOURCE_HSIRCC_USART2CLKSOURCE_SYSCLKRCC_USART2CLKSOURCE_PCLK1RCC_USART1CLKSOURCE_LSERCC_USART1CLKSOURCE_HSIRCC_USART1CLKSOURCE_SYSCLKRCC_USART1CLKSOURCE_PCLK2RCC_CECCLKSOURCE_HSIRCC_CECCLKSOURCE_LSERCC_SAI2CLKSOURCE_PLLSRCRCC_SAI2CLKSOURCE_PINRCC_SAI2CLKSOURCE_PLLI2SRCC_SAI2CLKSOURCE_PLLSAIRCC_SAI1CLKSOURCE_PLLSRCRCC_SAI1CLKSOURCE_PINRCC_SAI1CLKSOURCE_PLLI2SRCC_SAI1CLKSOURCE_PLLSAIRCC_I2SCLKSOURCE_EXTRCC_I2SCLKSOURCE_PLLI2SRCC_PLLSAIDIVR_16RCC_PLLSAIDIVR_8RCC_PLLSAIDIVR_4RCC_PLLSAIP_DIV8((uint32_t)0x00000003U)RCC_PLLSAIP_DIV6((uint32_t)0x00000002U)RCC_PLLSAIP_DIV4((uint32_t)0x00000001U)RCC_PLLSAIP_DIV2RCC_PLLI2SP_DIV8RCC_PLLI2SP_DIV6RCC_PLLI2SP_DIV4RCC_PLLI2SP_DIV2RCC_PERIPHCLK_DFSDM1_AUDIO((uint32_t)0x10000000U)((uint32_t)0x08000000U)RCC_PERIPHCLK_SDMMC2((uint32_t)0x04000000U)RCC_PERIPHCLK_PLLI2S((uint32_t)0x02000000U)RCC_PERIPHCLK_SPDIFRX((uint32_t)0x01000000U)((uint32_t)0x00800000U)RCC_PERIPHCLK_CEC((uint32_t)0x00400000U)((uint32_t)0x00200000U)RCC_PERIPHCLK_SAI2((uint32_t)0x00100000U)RCC_PERIPHCLK_SAI1((uint32_t)0x00080000U)RCC_PERIPHCLK_LPTIM1((uint32_t)0x00040000U)RCC_PERIPHCLK_I2C4((uint32_t)0x00020000U)RCC_PERIPHCLK_I2C3((uint32_t)0x00010000U)RCC_PERIPHCLK_I2C2((uint32_t)0x00008000U)RCC_PERIPHCLK_I2C1((uint32_t)0x00004000U)RCC_PERIPHCLK_UART8((uint32_t)0x00002000U)RCC_PERIPHCLK_UART7((uint32_t)0x00001000U)RCC_PERIPHCLK_USART6((uint32_t)0x00000800U)RCC_PERIPHCLK_UART5((uint32_t)0x00000400U)RCC_PERIPHCLK_UART4((uint32_t)0x00000200U)RCC_PERIPHCLK_USART3((uint32_t)0x00000100U)RCC_PERIPHCLK_USART2((uint32_t)0x00000080U)RCC_PERIPHCLK_USART1((uint32_t)0x00000040U)RCC_PERIPHCLK_RTC((uint32_t)0x00000020U)RCC_PERIPHCLK_TIM((uint32_t)0x00000010U)((uint32_t)0x00000008U)RCC_PERIPHCLK_I2S__STM32F7xx_HAL_RCC_EX_Hdefined (STM32F745xx) || defined (STM32F746xx) || defined (STM32F756xx) || defined (STM32F765xx) || defined (STM32F767xx) || defined (STM32F769xx) || defined (STM32F777xx) || defined (STM32F779xx) || defined (STM32F750xx)defined (STM32F722xx) || defined (STM32F723xx) || defined (STM32F732xx) || defined (STM32F733xx) || defined (STM32F765xx) || defined (STM32F767xx) || defined (STM32F769xx) || defined (STM32F777xx) || defined (STM32F779xx) || defined (STM32F730xx)defined(STM32F746xx) || defined(STM32F756xx) || defined (STM32F767xx) || defined (STM32F769xx) || defined (STM32F777xx) || defined (STM32F779xx) || defined (STM32F750xx)defined (STM32F769xx) || defined (STM32F779xx)defined (STM32F767xx) || defined (STM32F769xx) || defined (STM32F777xx) || defined (STM32F779xx)defined(STM32F756xx) || defined (STM32F777xx) || defined (STM32F779xx) || defined (STM32F750xx)defined(STM32F732xx) || defined (STM32F733xx) || defined (STM32F730xx)defined (STM32F746xx) || defined (STM32F756xx) || defined (STM32F767xx) || defined (STM32F769xx) || defined (STM32F777xx) || defined (STM32F779xx) || defined (STM32F750xx)defined (STM32F723xx) || defined (STM32F733xx) || defined (STM32F730xx)defined (STM32F746xx) || defined (STM32F756xx) || defined (STM32F767xx) || defined (STM32F769xx) || defined (STM32F777xx) || defined (STM32F779xx)|| defined (STM32F750xx)defined(STM32F767xx) || defined(STM32F769xx) || defined (STM32F777xx) || defined (STM32F779xx)defined (STM32F722xx) || defined (STM32F723xx) || defined (STM32F732xx) || defined (STM32F733xx) || defined (STM32F730xx)defined(STM32F756xx) || defined(STM32F746xx) || defined(STM32F750xx)defined (STM32F765xx)defined (STM32F722xx) || defined (STM32F723xx) || defined (STM32F732xx) || defined (STM32F733xx) || defined (STM32F745xx) || defined (STM32F746xx) || defined (STM32F756xx) || defined (STM32F730xx) || defined (STM32F750xx)/* __STM32F7xx_HAL_RCC_EX_H *//* STM32F767xx || STM32F769xx || STM32F777xx || STM32F779xx *//* STM32F722xx || STM32F723xx || STM32F732xx || STM32F733xx || STM32F767xx || STM32F769xx || STM32F777xx || STM32F779xx || STM32F730xx *//* STM32F722xx || STM32F723xx || STM32F732xx || STM32F733xx || STM32F745xx || STM32F746xx || STM32F756xx || STM32F750xx || STM32F730xx *//* STM32F745xx || STM32F746xx || STM32F756xx || STM32F765xx || STM32F767xx || STM32F769xx || STM32F777xx || STM32F779xx || STM32F750xx *//* STM32F746xx || STM32F756xx || STM32F750xx *//** @defgroup RCCEx_IS_RCC_Definitions RCC Private macros to check input parameters
  * @{
  *//** @addtogroup RCCEx_Private_Macros RCCEx Private Macros
  * @{
  *//** @addtogroup RCCEx_Exported_Functions_Group1
  * @{
  *//* STM32F769xx || STM32F779xx *//** @brief  Macro to Get the DSI clock.
  * @retval The clock source can be one of the following values:
  *            @arg RCC_DSICLKSOURCE_PLLR: PLLR output used as DSI clock.
  *            @arg RCC_DSICLKSOURCE_DSIPHY: DSI-PHY output used as DSI clock.
  *//** @brief  Macro to configure the DSI clock.
  * @param  __DSI_CLKSOURCE__ specifies the DSI clock source.
  *         This parameter can be one of the following values:
  *            @arg RCC_DSICLKSOURCE_PLLR: PLLR output used as DSI clock.
  *            @arg RCC_DSICLKSOURCE_DSIPHY: DSI-PHY output used as DSI clock.
  *//** @brief  Macro to get the DFSDM1 Audio clock source.
  * @retval The clock source can be one of the following values:
  *            @arg RCC_DFSDM1AUDIOCLKSOURCE_SAI1:  SAI1 Clock selected as DFSDM1 Audio clock
  *            @arg RCC_DFSDM1AUDIOCLKSOURCE_SAI2:  SAI2 Clock selected as DFSDM1 Audio clock
  *//** @brief  Macro to configure the DFSDM1 Audio clock
  * @param  __DFSDM1AUDIO_CLKSOURCE__ specifies the DFSDM1 Audio clock source.
  *         This parameter can be one of the following values:
  *            @arg RCC_DFSDM1AUDIOCLKSOURCE_SAI1:  SAI1 Clock selected as DFSDM1 Audio clock
  *            @arg RCC_DFSDM1AUDIOCLKSOURCE_SAI2:  SAI2 Clock selected as DFSDM1 Audio clock
  *//** @brief  Macro to get the DFSDM1 clock source.
  * @retval The clock source can be one of the following values:
  *            @arg RCC_DFSDM1CLKSOURCE_PCLK2:  PCLK2 Clock selected as DFSDM1 clock
  *            @arg RCC_DFSDM1CLKSOURCE_SYSCLK:   System Clock selected as DFSDM1 clock
  *//** @brief  Macro to configure the DFSDM1 clock
  * @param  __DFSDM1_CLKSOURCE__ specifies the DFSDM1  clock source.
  *         This parameter can be one of the following values:
  *            @arg RCC_DFSDM1CLKSOURCE_PCLK2: PCLK2 Clock selected as DFSDM clock
  *            @arg RCC_DFSDMCLKSOURCE_SYSCLK: System Clock selected as DFSDM clock
  *//* STM32F722xx || STM32F723xx || STM32F732xx || STM32F733xx || STM32F765xx || STM32F767xx || STM32F769xx || STM32F777xx || STM32F779xx  || STM32F730xx *//** @brief  macro to get the SDMMC2 clock source.
  * @retval The clock source can be one of the following values:
  *            @arg RCC_SDMMC2CLKSOURCE_CLK48: CLK48 selected as SDMMC2 clock
  *            @arg RCC_SDMMC2CLKSOURCE_SYSCLK: SYSCLK selected as SDMMC2 clock
  *//** @brief  Macro to configure the SDMMC2 clock (SDMMC2CLK).
  * @param  __SDMMC2_CLKSOURCE__ specifies the SDMMC2 clock source.
  *          This parameter can be one of the following values:
  *            @arg RCC_SDMMC2CLKSOURCE_CLK48: CLK48 selected as SDMMC2 clock
  *            @arg RCC_SDMMC2CLKSOURCE_SYSCLK: SYSCLK selected as SDMMC2 clock
  *//** @brief  macro to get the SDMMC1 clock source.
  * @retval The clock source can be one of the following values:
  *            @arg RCC_SDMMC1CLKSOURCE_CLK48: CLK48 selected as SDMMC1 clock
  *            @arg RCC_SDMMC1CLKSOURCE_SYSCLK: SYSCLK selected as SDMMC1 clock
  *//** @brief  Macro to configure the SDMMC1 clock (SDMMC1CLK).
  *
  * @param  __SDMMC1_CLKSOURCE__ specifies the SDMMC1 clock source.
  *          This parameter can be one of the following values:
  *            @arg RCC_SDMMC1CLKSOURCE_CLK48: CLK48 selected as SDMMC clock
  *            @arg RCC_SDMMC1CLKSOURCE_SYSCLK: SYSCLK selected as SDMMC clock
  *//** @brief  macro to get the CLK48 source.
  * @retval The clock source can be one of the following values:
  *            @arg RCC_CLK48SOURCE_PLL: PLL used as CLK48 source
  *            @arg RCC_CLK48SOURCE_PLLSAIP: PLLSAIP used as CLK48 source
  *//** @brief  Macro to configure the CLK48 source (CLK48CLK).
  *
  * @param  __CLK48_SOURCE__ specifies the CLK48 clock source.
  *          This parameter can be one of the following values:
  *            @arg RCC_CLK48SOURCE_PLL: PLL selected as CLK48 source
  *            @arg RCC_CLK48SOURCE_PLLSAIP: PLLSAIP selected as CLK48 source
  *//** @brief  macro to get the CEC clock source.
  * @retval The clock source can be one of the following values:
  *            @arg RCC_CECCLKSOURCE_LSE: LSE selected as CEC clock
  *            @arg RCC_CECCLKSOURCE_HSI: HSI selected as CEC clock
  *//** @brief  Macro to configure the CEC clock (CECCLK).
  *
  * @param  __CEC_CLKSOURCE__ specifies the CEC clock source.
  *          This parameter can be one of the following values:
  *            @arg RCC_CECCLKSOURCE_LSE: LSE selected as CEC clock
  *            @arg RCC_CECCLKSOURCE_HSI: HSI divided by 488 selected as CEC clock
  *//** @brief  macro to get the LPTIM1 clock source.
  * @retval The clock source can be one of the following values:
  *            @arg RCC_LPTIM1CLKSOURCE_PCLK1: PCLK selected as LPTIM1 clock
  *            @arg RCC_LPTIM1CLKSOURCE_HSI: HSI selected as LPTIM1 clock
  *            @arg RCC_LPTIM1CLKSOURCE_LSI: LSI selected as LPTIM1 clock
  *            @arg RCC_LPTIM1CLKSOURCE_LSE: LSE selected as LPTIM1 clock
  *//** @brief  Macro to configure the LPTIM1 clock (LPTIM1CLK).
  *
  * @param  __LPTIM1_CLKSOURCE__ specifies the LPTIM1 clock source.
  *          This parameter can be one of the following values:
  *            @arg RCC_LPTIM1CLKSOURCE_PCLK1: PCLK selected as LPTIM1 clock
  *            @arg RCC_LPTIM1CLKSOURCE_HSI: HSI selected as LPTIM1 clock
  *            @arg RCC_LPTIM1CLKSOURCE_LSI: LSI selected as LPTIM1 clock
  *            @arg RCC_LPTIM1CLKSOURCE_LSE: LSE selected as LPTIM1 clock
  *//** @brief  macro to get the UART8 clock source.
  * @retval The clock source can be one of the following values:
  *            @arg RCC_UART8CLKSOURCE_PCLK1: PCLK1 selected as UART8 clock
  *            @arg RCC_UART8CLKSOURCE_HSI: HSI selected as UART8 clock
  *            @arg RCC_UART8CLKSOURCE_SYSCLK: System Clock selected as UART8 clock
  *            @arg RCC_UART8CLKSOURCE_LSE: LSE selected as UART8 clock
  *//** @brief  Macro to configure the UART8 clock (UART8CLK).
  *
  * @param  __UART8_CLKSOURCE__ specifies the UART8 clock source.
  *          This parameter can be one of the following values:
  *            @arg RCC_UART8CLKSOURCE_PCLK1: PCLK1 selected as UART8 clock
  *            @arg RCC_UART8CLKSOURCE_HSI: HSI selected as UART8 clock
  *            @arg RCC_UART8CLKSOURCE_SYSCLK: System Clock selected as UART8 clock
  *            @arg RCC_UART8CLKSOURCE_LSE: LSE selected as UART8 clock
  *//** @brief  macro to get the UART7 clock source.
  * @retval The clock source can be one of the following values:
  *            @arg RCC_UART7CLKSOURCE_PCLK1: PCLK1 selected as UART7 clock
  *            @arg RCC_UART7CLKSOURCE_HSI: HSI selected as UART7 clock
  *            @arg RCC_UART7CLKSOURCE_SYSCLK: System Clock selected as UART7 clock
  *            @arg RCC_UART7CLKSOURCE_LSE: LSE selected as UART7 clock
  *//** @brief  Macro to configure the UART7 clock (UART7CLK).
  *
  * @param  __UART7_CLKSOURCE__ specifies the UART7 clock source.
  *          This parameter can be one of the following values:
  *            @arg RCC_UART7CLKSOURCE_PCLK1: PCLK1 selected as UART7 clock
  *            @arg RCC_UART7CLKSOURCE_HSI: HSI selected as UART7 clock
  *            @arg RCC_UART7CLKSOURCE_SYSCLK: System Clock selected as UART7 clock
  *            @arg RCC_UART7CLKSOURCE_LSE: LSE selected as UART7 clock
  *//** @brief  macro to get the USART6 clock source.
  * @retval The clock source can be one of the following values:
  *            @arg RCC_USART6CLKSOURCE_PCLK1: PCLK1 selected as USART6 clock
  *            @arg RCC_USART6CLKSOURCE_HSI: HSI selected as USART6 clock
  *            @arg RCC_USART6CLKSOURCE_SYSCLK: System Clock selected as USART6 clock
  *            @arg RCC_USART6CLKSOURCE_LSE: LSE selected as USART6 clock
  *//** @brief  Macro to configure the USART6 clock (USART6CLK).
  *
  * @param  __USART6_CLKSOURCE__ specifies the USART6 clock source.
  *          This parameter can be one of the following values:
  *            @arg RCC_USART6CLKSOURCE_PCLK1: PCLK1 selected as USART6 clock
  *            @arg RCC_USART6CLKSOURCE_HSI: HSI selected as USART6 clock
  *            @arg RCC_USART6CLKSOURCE_SYSCLK: System Clock selected as USART6 clock
  *            @arg RCC_USART6CLKSOURCE_LSE: LSE selected as USART6 clock
  *//** @brief  macro to get the UART5 clock source.
  * @retval The clock source can be one of the following values:
  *            @arg RCC_UART5CLKSOURCE_PCLK1: PCLK1 selected as UART5 clock
  *            @arg RCC_UART5CLKSOURCE_HSI: HSI selected as UART5 clock
  *            @arg RCC_UART5CLKSOURCE_SYSCLK: System Clock selected as UART5 clock
  *            @arg RCC_UART5CLKSOURCE_LSE: LSE selected as UART5 clock
  *//** @brief  Macro to configure the UART5 clock (UART5CLK).
  *
  * @param  __UART5_CLKSOURCE__ specifies the UART5 clock source.
  *          This parameter can be one of the following values:
  *            @arg RCC_UART5CLKSOURCE_PCLK1: PCLK1 selected as UART5 clock
  *            @arg RCC_UART5CLKSOURCE_HSI: HSI selected as UART5 clock
  *            @arg RCC_UART5CLKSOURCE_SYSCLK: System Clock selected as UART5 clock
  *            @arg RCC_UART5CLKSOURCE_LSE: LSE selected as UART5 clock
  *//** @brief  macro to get the UART4 clock source.
  * @retval The clock source can be one of the following values:
  *            @arg RCC_UART4CLKSOURCE_PCLK1: PCLK1 selected as UART4 clock
  *            @arg RCC_UART4CLKSOURCE_HSI: HSI selected as UART4 clock
  *            @arg RCC_UART4CLKSOURCE_SYSCLK: System Clock selected as UART4 clock
  *            @arg RCC_UART4CLKSOURCE_LSE: LSE selected as UART4 clock
  *//** @brief  Macro to configure the UART4 clock (UART4CLK).
  *
  * @param  __UART4_CLKSOURCE__ specifies the UART4 clock source.
  *          This parameter can be one of the following values:
  *            @arg RCC_UART4CLKSOURCE_PCLK1: PCLK1 selected as UART4 clock
  *            @arg RCC_UART4CLKSOURCE_HSI: HSI selected as UART4 clock
  *            @arg RCC_UART4CLKSOURCE_SYSCLK: System Clock selected as UART4 clock
  *            @arg RCC_UART4CLKSOURCE_LSE: LSE selected as UART4 clock
  *//** @brief  macro to get the USART3 clock source.
  * @retval The clock source can be one of the following values:
  *            @arg RCC_USART3CLKSOURCE_PCLK1: PCLK1 selected as USART3 clock
  *            @arg RCC_USART3CLKSOURCE_HSI: HSI selected as USART3 clock
  *            @arg RCC_USART3CLKSOURCE_SYSCLK: System Clock selected as USART3 clock
  *            @arg RCC_USART3CLKSOURCE_LSE: LSE selected as USART3 clock
  *//** @brief  Macro to configure the USART3 clock (USART3CLK).
  *
  * @param  __USART3_CLKSOURCE__ specifies the USART3 clock source.
  *          This parameter can be one of the following values:
  *            @arg RCC_USART3CLKSOURCE_PCLK1: PCLK1 selected as USART3 clock
  *            @arg RCC_USART3CLKSOURCE_HSI: HSI selected as USART3 clock
  *            @arg RCC_USART3CLKSOURCE_SYSCLK: System Clock selected as USART3 clock
  *            @arg RCC_USART3CLKSOURCE_LSE: LSE selected as USART3 clock
  *//** @brief  macro to get the USART2 clock source.
  * @retval The clock source can be one of the following values:
  *            @arg RCC_USART2CLKSOURCE_PCLK1: PCLK1 selected as USART2 clock
  *            @arg RCC_USART2CLKSOURCE_HSI: HSI selected as USART2 clock
  *            @arg RCC_USART2CLKSOURCE_SYSCLK: System Clock selected as USART2 clock
  *            @arg RCC_USART2CLKSOURCE_LSE: LSE selected as USART2 clock
  *//** @brief  Macro to configure the USART2 clock (USART2CLK).
  *
  * @param  __USART2_CLKSOURCE__ specifies the USART2 clock source.
  *          This parameter can be one of the following values:
  *            @arg RCC_USART2CLKSOURCE_PCLK1: PCLK1 selected as USART2 clock
  *            @arg RCC_USART2CLKSOURCE_HSI: HSI selected as USART2 clock
  *            @arg RCC_USART2CLKSOURCE_SYSCLK: System Clock selected as USART2 clock
  *            @arg RCC_USART2CLKSOURCE_LSE: LSE selected as USART2 clock
  *//** @brief  macro to get the USART1 clock source.
  * @retval The clock source can be one of the following values:
  *            @arg RCC_USART1CLKSOURCE_PCLK2: PCLK2 selected as USART1 clock
  *            @arg RCC_USART1CLKSOURCE_HSI: HSI selected as USART1 clock
  *            @arg RCC_USART1CLKSOURCE_SYSCLK: System Clock selected as USART1 clock
  *            @arg RCC_USART1CLKSOURCE_LSE: LSE selected as USART1 clock
  *//** @brief  Macro to configure the USART1 clock (USART1CLK).
  *
  * @param  __USART1_CLKSOURCE__ specifies the USART1 clock source.
  *          This parameter can be one of the following values:
  *            @arg RCC_USART1CLKSOURCE_PCLK2: PCLK2 selected as USART1 clock
  *            @arg RCC_USART1CLKSOURCE_HSI: HSI selected as USART1 clock
  *            @arg RCC_USART1CLKSOURCE_SYSCLK: System Clock selected as USART1 clock
  *            @arg RCC_USART1CLKSOURCE_LSE: LSE selected as USART1 clock
  *//** @brief  macro to get the I2C4 clock source.
  * @retval The clock source can be one of the following values:
  *            @arg RCC_I2C4CLKSOURCE_PCLK1: PCLK1 selected as I2C4 clock
  *            @arg RCC_I2C4CLKSOURCE_HSI: HSI selected as I2C4 clock
  *            @arg RCC_I2C4CLKSOURCE_SYSCLK: System Clock selected as I2C4 clock
  *//** @brief  Macro to configure the I2C4 clock (I2C4CLK).
  *
  * @param  __I2C4_CLKSOURCE__ specifies the I2C4 clock source.
  *          This parameter can be one of the following values:
  *            @arg RCC_I2C4CLKSOURCE_PCLK1: PCLK1 selected as I2C4 clock
  *            @arg RCC_I2C4CLKSOURCE_HSI: HSI selected as I2C4 clock
  *            @arg RCC_I2C4CLKSOURCE_SYSCLK: System Clock selected as I2C4 clock
  *//** @brief  macro to get the I2C3 clock source.
  * @retval The clock source can be one of the following values:
  *            @arg RCC_I2C3CLKSOURCE_PCLK1: PCLK1 selected as I2C3 clock
  *            @arg RCC_I2C3CLKSOURCE_HSI: HSI selected as I2C3 clock
  *            @arg RCC_I2C3CLKSOURCE_SYSCLK: System Clock selected as I2C3 clock
  *//** @brief  Macro to configure the I2C3 clock (I2C3CLK).
  *
  * @param  __I2C3_CLKSOURCE__ specifies the I2C3 clock source.
  *          This parameter can be one of the following values:
  *            @arg RCC_I2C3CLKSOURCE_PCLK1: PCLK1 selected as I2C3 clock
  *            @arg RCC_I2C3CLKSOURCE_HSI: HSI selected as I2C3 clock
  *            @arg RCC_I2C3CLKSOURCE_SYSCLK: System Clock selected as I2C3 clock
  *//** @brief  Macro to get the I2C2 clock source.
  * @retval The clock source can be one of the following values:
  *            @arg RCC_I2C2CLKSOURCE_PCLK1: PCLK1 selected as I2C2 clock
  *            @arg RCC_I2C2CLKSOURCE_HSI: HSI selected as I2C2 clock
  *            @arg RCC_I2C2CLKSOURCE_SYSCLK: System Clock selected as I2C2 clock
  *//** @brief  Macro to configure the I2C2 clock (I2C2CLK).
  *
  * @param  __I2C2_CLKSOURCE__ specifies the I2C2 clock source.
  *          This parameter can be one of the following values:
  *            @arg RCC_I2C2CLKSOURCE_PCLK1: PCLK1 selected as I2C2 clock
  *            @arg RCC_I2C2CLKSOURCE_HSI: HSI selected as I2C2 clock
  *            @arg RCC_I2C2CLKSOURCE_SYSCLK: System Clock selected as I2C2 clock
  *//** @brief  Macro to get the I2C1 clock source.
  * @retval The clock source can be one of the following values:
  *            @arg RCC_I2C1CLKSOURCE_PCLK1: PCLK1 selected as I2C1 clock
  *            @arg RCC_I2C1CLKSOURCE_HSI: HSI selected as I2C1 clock
  *            @arg RCC_I2C1CLKSOURCE_SYSCLK: System Clock selected as I2C1 clock
  *//** @brief  Macro to configure the I2C1 clock (I2C1CLK).
  *
  * @param  __I2C1_CLKSOURCE__ specifies the I2C1 clock source.
  *          This parameter can be one of the following values:
  *            @arg RCC_I2C1CLKSOURCE_PCLK1: PCLK1 selected as I2C1 clock
  *            @arg RCC_I2C1CLKSOURCE_HSI: HSI selected as I2C1 clock
  *            @arg RCC_I2C1CLKSOURCE_SYSCLK: System Clock selected as I2C1 clock
  *//** @brief  Macro to Get I2S clock source selection.
  * @retval The clock source can be one of the following values:
  *            @arg RCC_I2SCLKSOURCE_PLLI2S: PLLI2S VCO output clock divided by PLLI2SR used as I2S clock.
  *            @arg RCC_I2SCLKSOURCE_EXT: External clock mapped on the I2S_CKIN pin used as I2S clock source
  *//** @brief  Check PLLSAI RDY flag is set or not.
  * @retval The new state (TRUE or FALSE).
  *//** @brief Check the PLLSAI RDY interrupt has occurred or not.
  * @retval The new state (TRUE or FALSE).
  *//** @brief Clear the PLLSAI RDY interrupt pending bits.
  *//** @brief Disable PLLSAI_RDY interrupt.
  *//** @brief Enable PLLSAI_RDY interrupt.
  *//** @brief  Macro to get the SAI2 clock source.
  * @retval The clock source can be one of the following values:
  *            @arg RCC_SAI2CLKSOURCE_PLLI2S: PLLI2S_Q clock divided by PLLI2SDIVQ used
  *                                           as SAI2 clock.
  *            @arg RCC_SAI2CLKSOURCE_PLLSAI: PLLISAI_Q clock divided by PLLSAIDIVQ used
  *                                           as SAI2 clock.
  *            @arg RCC_SAI2CLKSOURCE_PIN: External clock mapped on the I2S_CKIN pin
  *                                        used as SAI2 clock.
  *            @arg RCC_SAI2CLKSOURCE_PLLSRC: HSI or HSE depending from PLL Source clock
  *                                           used as SAI2 clock.
  * @note      The RCC_SAI2CLKSOURCE_PLLSRC value is only available with STM32F767/769/777/779xx Devices
  *//** @brief  Macro to configure SAI2 clock source selection.
  * @note   This function must be called before enabling PLLSAI, PLLI2S and
  *         the SAI clock.
  * @param  __SOURCE__ specifies the SAI2 clock source.
  *         This parameter can be one of the following values:
  *            @arg RCC_SAI2CLKSOURCE_PLLI2S: PLLI2S_Q clock divided by PLLI2SDIVQ used
  *                                           as SAI2 clock.
  *            @arg RCC_SAI2CLKSOURCE_PLLSAI: PLLISAI_Q clock divided by PLLSAIDIVQ used
  *                                           as SAI2 clock.
  *            @arg RCC_SAI2CLKSOURCE_PIN: External clock mapped on the I2S_CKIN pin
  *                                        used as SAI2 clock.
  *            @arg RCC_SAI2CLKSOURCE_PLLSRC: HSI or HSE depending from PLL Source clock
  *                                           used as SAI2 clock.
  * @note      The RCC_SAI2CLKSOURCE_PLLSRC value is only available with STM32F767/769/777/779xx Devices
  *//** @brief  Macro to get the SAI1 clock source.
  * @retval The clock source can be one of the following values:
  *            @arg RCC_SAI1CLKSOURCE_PLLI2S: PLLI2S_Q clock divided by PLLI2SDIVQ used
  *                                           as SAI1 clock.
  *            @arg RCC_SAI1CLKSOURCE_PLLSAI: PLLISAI_Q clock divided by PLLSAIDIVQ used
  *                                           as SAI1 clock.
  *            @arg RCC_SAI1CLKSOURCE_PIN: External clock mapped on the I2S_CKIN pin
  *                                        used as SAI1 clock.
  *            @arg RCC_SAI1CLKSOURCE_PLLSRC: HSI or HSE depending from PLL Source clock
  *                                           used as SAI1 clock.
  * @note      The RCC_SAI1CLKSOURCE_PLLSRC value is only available with STM32F767/769/777/779xx Devices
  *//** @brief  Macro to configure SAI1 clock source selection.
  * @note   This function must be called before enabling PLLSAI, PLLI2S and
  *         the SAI clock.
  * @param  __SOURCE__ specifies the SAI1 clock source.
  *         This parameter can be one of the following values:
  *            @arg RCC_SAI1CLKSOURCE_PLLI2S: PLLI2S_Q clock divided by PLLI2SDIVQ used
  *                                           as SAI1 clock.
  *            @arg RCC_SAI1CLKSOURCE_PLLSAI: PLLISAI_Q clock divided by PLLSAIDIVQ used
  *                                           as SAI1 clock.
  *            @arg RCC_SAI1CLKSOURCE_PIN: External clock mapped on the I2S_CKIN pin
  *                                        used as SAI1 clock.
  *            @arg RCC_SAI1CLKSOURCE_PLLSRC: HSI or HSE depending from PLL Source clock
  *                                           used as SAI1 clock.
  * @note      The RCC_SAI1CLKSOURCE_PLLSRC value is only available with STM32F767/769/777/779xx Devices
  *//** @brief  Macro to configure the LTDC clock Divider coming from PLLSAI.
  * @note   This function must be called before enabling the PLLSAI.
  * @param  __PLLSAIDivR__ specifies the PLLSAI division factor for LTDC clock .
  *          This parameter can be a value of @ref RCCEx_PLLSAI_DIVR.
  *          LTDC clock frequency = f(PLLSAIR) / __PLLSAIDivR__
  *//** @brief  Macro to configure the SAI clock Divider coming from PLLSAI.
  * @note   This function must be called before enabling the PLLSAI.
  * @param  __PLLSAIDivQ__ specifies the PLLSAI division factor for SAI1 clock .
  *         This parameter must be a number between Min_Data = 1 and Max_Data = 32.
  *         SAI1 clock frequency = f(PLLSAIQ) / __PLLSAIDivQ__
  *//** @brief  Macro to configure the SAI clock Divider coming from PLLI2S.
  * @note   This function must be called before enabling the PLLI2S.
  * @param  __PLLI2SDivQ__ specifies the PLLI2S division factor for SAI1 clock .
  *          This parameter must be a number between 1 and 32.
  *          SAI1 clock frequency = f(PLLI2SQ) / __PLLI2SDivQ__
  *//* STM32F722xx || STM32F723xx || STM32F732xx || STM32F733xx || STM32F730xx *//** @brief  Macro to configure the PLLI2S clock multiplication and division factors.
  * @note   This macro must be used only when the PLLI2S is disabled.
  * @note   PLLI2S clock source is common with the main PLL (configured in
  *         HAL_RCC_ClockConfig() API)
  * @param  __PLLI2SN__ specifies the multiplication factor for PLLI2S VCO output clock.
  *         This parameter must be a number between Min_Data = 50 and Max_Data = 432.
  * @note   You have to set the PLLI2SN parameter correctly to ensure that the VCO
  *         output frequency is between Min_Data = 100 and Max_Data = 432 MHz.
  * @param  __PLLI2SP__ specifies the division factor for SPDDIF-RX clock.
  *         This parameter can be a value of @ref RCCEx_PLLI2SP_Clock_Divider.
  * @param  __PLLI2SQ__ specifies the division factor for SAI clock.
  *         This parameter must be a number between Min_Data = 2 and Max_Data = 15.
  * @param  __PLLI2SR__ specifies the division factor for I2S clock
  *         This parameter must be a number between Min_Data = 2 and Max_Data = 7.
  * @note   You have to set the PLLI2SR parameter correctly to not exceed 192 MHz
  *         on the I2S clock frequency.
  *//** @brief  Macro to configure the PLLSAI clock multiplication and division factors.
  * @note   This function must be used only when the PLLSAI is disabled.
  * @note   PLLSAI clock source is common with the main PLL (configured in
  *         RCC_PLLConfig function )
  * @param  __PLLSAIN__ specifies the multiplication factor for PLLSAI VCO output clock.
  *         This parameter must be a number between Min_Data = 50 and Max_Data = 432.
  * @note   You have to set the PLLSAIN parameter correctly to ensure that the VCO
  *         output frequency is between Min_Data = 100 and Max_Data = 432 MHz.
  * @param  __PLLSAIP__ specifies the division factor for USB, RNG, SDMMC clocks
  *         This parameter can be a value of @ref RCCEx_PLLSAIP_Clock_Divider.
  * @param  __PLLSAIQ__ specifies the division factor for SAI clock
  *         This parameter must be a number between Min_Data = 2 and Max_Data = 15.
  * @param  __PLLSAIR__ specifies the division factor for LTDC clock
  *         This parameter must be a number between Min_Data = 2 and Max_Data = 7.
  *//** @brief  Macro to configure the PLLI2S clock multiplication and division factors.
  * @note   This macro must be used only when the PLLI2S is disabled.
  * @note   PLLI2S clock source is common with the main PLL (configured in
  *         HAL_RCC_ClockConfig() API)
  * @param  __PLLI2SN__ specifies the multiplication factor for PLLI2S VCO output clock.
  *         This parameter must be a number between Min_Data = 50 and Max_Data = 432.
  * @note   You have to set the PLLI2SN parameter correctly to ensure that the VCO
  *         output frequency is between Min_Data = 100 and Max_Data = 432 MHz.
  * @param  __PLLI2SQ__ specifies the division factor for SAI clock.
  *         This parameter must be a number between Min_Data = 2 and Max_Data = 15.
  * @param  __PLLI2SR__ specifies the division factor for I2S clock
  *         This parameter must be a number between Min_Data = 2 and Max_Data = 7.
  * @note   You have to set the PLLI2SR parameter correctly to not exceed 192 MHz
  *         on the I2S clock frequency.
  *//** @brief  Macro to configure the PLLSAI clock multiplication and division factors.
  * @note   This function must be used only when the PLLSAI is disabled.
  * @note   PLLSAI clock source is common with the main PLL (configured in
  *         RCC_PLLConfig function )
  * @param  __PLLSAIN__ specifies the multiplication factor for PLLSAI VCO output clock.
  *         This parameter must be a number between Min_Data = 50 and Max_Data = 432.
  * @note   You have to set the PLLSAIN parameter correctly to ensure that the VCO
  *         output frequency is between Min_Data = 100 and Max_Data = 432 MHz.
  * @param  __PLLSAIP__ specifies the division factor for USB, RNG, SDMMC clocks
  *         This parameter can be a value of @ref RCCEx_PLLSAIP_Clock_Divider.
  * @param  __PLLSAIQ__ specifies the division factor for SAI clock
  *         This parameter must be a number between Min_Data = 2 and Max_Data = 15.
  *//** @brief Macros to Enable or Disable the PLLISAI.
  * @note  The PLLSAI is disabled by hardware when entering STOP and STANDBY modes.
  *//** @brief  Macro to configure the Timers clocks prescalers
  * @param  __PRESC__  specifies the Timers clocks prescalers selection
  *         This parameter can be one of the following values:
  *            @arg RCC_TIMPRES_DESACTIVATED: The Timers kernels clocks prescaler is
  *                 equal to HPRE if PPREx is corresponding to division by 1 or 2,
  *                 else it is equal to [(HPRE * PPREx) / 2] if PPREx is corresponding to
  *                 division by 4 or more.
  *            @arg RCC_TIMPRES_ACTIVATED: The Timers kernels clocks prescaler is
  *                 equal to HPRE if PPREx is corresponding to division by 1, 2 or 4,
  *                 else it is equal to [(HPRE * PPREx) / 4] if PPREx is corresponding
  *                 to division by 8 or more.
  *//*---------------------------------------------------------------------------------------------*//** @brief  Macro to configure the main PLL clock source, multiplication and division factors.
  * @note   This function must be used only when the main PLL is disabled.
  * @param  __RCC_PLLSource__ specifies the PLL entry clock source.
  *         This parameter can be one of the following values:
  *            @arg RCC_PLLSOURCE_HSI: HSI oscillator clock selected as PLL clock entry
  *            @arg RCC_PLLSOURCE_HSE: HSE oscillator clock selected as PLL clock entry
  * @note   This clock source (RCC_PLLSource) is common for the main PLL and PLLI2S.
  * @param  __PLLM__ specifies the division factor for PLL VCO input clock
  *         This parameter must be a number between Min_Data = 2 and Max_Data = 63.
  * @note   You have to set the PLLM parameter correctly to ensure that the VCO input
  *         frequency ranges from 1 to 2 MHz. It is recommended to select a frequency
  *         of 2 MHz to limit PLL jitter.
  * @param  __PLLN__ specifies the multiplication factor for PLL VCO output clock
  *         This parameter must be a number between Min_Data = 50 and Max_Data = 432.
  * @note   You have to set the PLLN parameter correctly to ensure that the VCO
  *         output frequency is between 100 and 432 MHz.
  * @param  __PLLP__ specifies the division factor for main system clock (SYSCLK)
  *         This parameter must be a number in the range {2, 4, 6, or 8}.
  * @note   You have to set the PLLP parameter correctly to not exceed 216 MHz on
  *         the System clock frequency.
  * @param  __PLLQ__ specifies the division factor for OTG FS, SDMMC and RNG clocks
  *         This parameter must be a number between Min_Data = 2 and Max_Data = 15.
  * @note   If the USB OTG FS is used in your application, you have to set the
  *         PLLQ parameter correctly to have 48 MHz clock for the USB. However,
  *         the SDMMC and RNG need a frequency lower than or equal to 48 MHz to work
  *         correctly.
  *//** @brief  Macro to configure the main PLL clock source, multiplication and division factors.
  * @note   This function must be used only when the main PLL is disabled.
  * @param  __RCC_PLLSource__ specifies the PLL entry clock source.
  *         This parameter can be one of the following values:
  *            @arg RCC_PLLSOURCE_HSI: HSI oscillator clock selected as PLL clock entry
  *            @arg RCC_PLLSOURCE_HSE: HSE oscillator clock selected as PLL clock entry
  * @note   This clock source (RCC_PLLSource) is common for the main PLL and PLLI2S.
  * @param  __PLLM__ specifies the division factor for PLL VCO input clock
  *         This parameter must be a number between Min_Data = 2 and Max_Data = 63.
  * @note   You have to set the PLLM parameter correctly to ensure that the VCO input
  *         frequency ranges from 1 to 2 MHz. It is recommended to select a frequency
  *         of 2 MHz to limit PLL jitter.
  * @param  __PLLN__ specifies the multiplication factor for PLL VCO output clock
  *         This parameter must be a number between Min_Data = 50 and Max_Data = 432.
  * @note   You have to set the PLLN parameter correctly to ensure that the VCO
  *         output frequency is between 100 and 432 MHz.
  * @param  __PLLP__ specifies the division factor for main system clock (SYSCLK)
  *         This parameter must be a number in the range {2, 4, 6, or 8}.
  * @note   You have to set the PLLP parameter correctly to not exceed 216 MHz on
  *         the System clock frequency.
  * @param  __PLLQ__ specifies the division factor for OTG FS, SDMMC and RNG clocks
  *         This parameter must be a number between Min_Data = 2 and Max_Data = 15.
  * @note   If the USB OTG FS is used in your application, you have to set the
  *         PLLQ parameter correctly to have 48 MHz clock for the USB. However,
  *         the SDMMC and RNG need a frequency lower than or equal to 48 MHz to work
  *         correctly.
  * @param  __PLLR__ specifies the division factor for DSI clock
  *         This parameter must be a number between Min_Data = 2 and Max_Data = 7.
  *//*------------------------------- PLL Configuration --------------------------*//* STM32F722xx || STM32F723xx || STM32F732xx || STM32F733xx || STM32F765xx || STM32F767xx || STM32F769xx || STM32F777xx || STM32F779xx || STM32F730xx *//* STM32F746xx || STM32F756xx || STM32F767xx || STM32F769xx || STM32F777xx || STM32F779xx || STM32F750xx *//** @brief  Get the enable or disable status of the APB2 peripheral clock during Low Power (Sleep) mode.
  * @note   Peripheral clock gating in SLEEP mode can be used to further reduce
  *         power consumption.
  * @note   After wakeup from SLEEP mode, the peripheral clock is enabled again.
  * @note   By default, all peripheral clocks are enabled during SLEEP mode.
  *//* STM32F722xx || STM32F723xx || STM32F732xx || STM32F733xx || STM32F765xx || STM32F767xx ||
          STM32F769xx || STM32F777xx || STM32F779xx || STM32F730xx *//** @brief  Get the enable or disable status of the APB1 peripheral clock during Low Power (Sleep) mode.
  * @note   Peripheral clock gating in SLEEP mode can be used to further reduce
  *         power consumption.
  * @note   After wakeup from SLEEP mode, the peripheral clock is enabled again.
  * @note   By default, all peripheral clocks are enabled during SLEEP mode.
  *//** @brief  Get the enable or disable status of the AHB3 peripheral clock during Low Power (Sleep) mode.
  * @note   Peripheral clock gating in SLEEP mode can be used to further reduce
  *         power consumption.
  * @note   After wakeup from SLEEP mode, the peripheral clock is enabled again.
  * @note   By default, all peripheral clocks are enabled during SLEEP mode.
  *//* STM32F732xx || STM32F733xx || STM32F730xx *//* STM32F756xx || STM32F777xx || STM32F779xx || STM32F750xx *//** @brief  Get the enable or disable status of the AHB2 peripheral clock during Low Power (Sleep) mode.
  * @note   Peripheral clock gating in SLEEP mode can be used to further reduce
  *         power consumption.
  * @note   After wakeup from SLEEP mode, the peripheral clock is enabled again.
  * @note   By default, all peripheral clocks are enabled during SLEEP mode.
  *//** @brief  Get the enable or disable status of the AHB1 peripheral clock during Low Power (Sleep) mode.
  * @note   Peripheral clock gating in SLEEP mode can be used to further reduce
  *         power consumption.
  * @note   After wakeup from SLEEP mode, the peripheral clock is enabled again.
  * @note   By default, all peripheral clocks are enabled during SLEEP mode.
  *//** @defgroup RCC_Clock_Sleep_Enable_Disable_Status AHB/APB Peripheral Clock Sleep Enable Disable Status
  * @brief  Get the enable or disable status of the AHB/APB peripheral clock during Low Power (Sleep) mode.
  * @note   Peripheral clock gating in SLEEP mode can be used to further reduce
  *         power consumption.
  * @note   After wakeup from SLEEP mode, the peripheral clock is enabled again.
  * @note   By default, all peripheral clocks are enabled during SLEEP mode.
  * @{
  *//* STM32F746xx || STM32F756xx || STM32F767xx || STM32F769xx || STM32F777xx || STM32F779xx || STM32F750xx  *//** @brief  Enable or disable the APB2 peripheral clock during Low Power (Sleep) mode.
  * @note   Peripheral clock gating in SLEEP mode can be used to further reduce
  *         power consumption.
  * @note   After wakeup from SLEEP mode, the peripheral clock is enabled again.
  * @note   By default, all peripheral clocks are enabled during SLEEP mode.
  *//** @brief  Enable or disable the APB1 peripheral clock during Low Power (Sleep) mode.
  * @note   Peripheral clock gating in SLEEP mode can be used to further reduce
  *         power consumption.
  * @note   After wakeup from SLEEP mode, the peripheral clock is enabled again.
  * @note   By default, all peripheral clocks are enabled during SLEEP mode.
  *//** @brief  Enable or disable the AHB3 peripheral clock during Low Power (Sleep) mode.
  * @note   Peripheral clock gating in SLEEP mode can be used to further reduce
  *         power consumption.
  * @note   After wakeup from SLEEP mode, the peripheral clock is enabled again.
  * @note   By default, all peripheral clocks are enabled during SLEEP mode.
  *//** @brief  Enable or disable the AHB2 peripheral clock during Low Power (Sleep) mode.
  * @note   Peripheral clock gating in SLEEP mode can be used to further reduce
  *         power consumption.
  * @note   After wakeup from SLEEP mode, the peripheral clock is enabled again.
  * @note   By default, all peripheral clocks are enabled during SLEEP mode.
  *//** @brief  Enable or disable the AHB1 peripheral clock during Low Power (Sleep) mode.
  *//** @defgroup RCCEx_Peripheral_Clock_Sleep_Enable_Disable RCCEx Peripheral Clock Sleep Enable Disable
  * @brief  Enables or disables the AHB/APB peripheral clock during Low Power (Sleep) mode.
  * @note   Peripheral clock gating in SLEEP mode can be used to further reduce
  *         power consumption.
  * @note   After wakeup from SLEEP mode, the peripheral clock is enabled again.
  * @note   By default, all peripheral clocks are enabled during SLEEP mode.
  * @{
  *//* STM32F723xx || STM32F733xx || STM32F730xx *//** @brief  Force or release APB2 peripheral reset.
  *//** @brief  Force or release APB1 peripheral reset.
  *//** @brief  Force or release AHB3 peripheral reset
  *//** @brief  Force or release AHB2 peripheral reset.
  *//** @brief  Force or release AHB1 peripheral reset.
  *//** @defgroup RCCEx_Force_Release_Peripheral_Reset RCCEx Force Release Peripheral Reset
  * @brief  Forces or releases AHB/APB peripheral reset.
  * @{
  *//** @brief  Get the enable or disable status of the APB2 peripheral clock.
  * @note   After reset, the peripheral clock (used for registers read/write access)
  *         is disabled and the application software has to enable this clock before
  *         using it.
  *//** @brief  Get the enable or disable status of the APB1 peripheral clock.
  * @note   After reset, the peripheral clock (used for registers read/write access)
  *         is disabled and the application software has to enable this clock before
  *         using it.
  *//** @brief  Get the enable or disable status of the AHB3 peripheral clock.
  * @note   After reset, the peripheral clock (used for registers read/write access)
  *         is disabled and the application software has to enable this clock before
  *         using it.
  *//** @brief  Get the enable or disable status of the AHB2 peripheral clock.
  * @note   After reset, the peripheral clock (used for registers read/write access)
  *         is disabled and the application software has to enable this clock before
  *         using it.
  *//**
  * @brief  Disable ETHERNET clock.
  *//**
  * @brief  Enable ETHERNET clock.
  *//** @brief  Get the enable or disable status of the AHB1 peripheral clock.
  * @note   After reset, the peripheral clock (used for registers read/write access)
  *         is disabled and the application software has to enable this clock before
  *         using it.
  *//** @defgroup RCCEx_Peripheral_Clock_Enable_Disable_Status Peripheral Clock Enable Disable Status
  * @brief  Get the enable or disable status of the AHB/APB peripheral clock.
  * @note   After reset, the peripheral clock (used for registers read/write access)
  *         is disabled and the application software has to enable this clock before
  *         using it.
  * @{
  *//* Delay after an RCC peripheral clock enabling *//* STM32F722xx || STM32F723xx || STM32F732xx || STM32F733xx || STM32F767xx || STM32F769xx || STM32F777xx || STM32F779xx || || STM32F730xx *//** @brief  Enable or disable the High Speed APB (APB2) peripheral clock.
  * @note   After reset, the peripheral clock (used for registers read/write access)
  *         is disabled and the application software has to enable this clock before
  *         using it.
  *//* STM32F745xx || STM32F746xx || STM32F756xx || STM32F765xx || STM32F767xx || STM32F769xx || STM32F777xx || STM32F779xx || || STM32F750xx *//** @brief  Enable or disable the Low Speed APB (APB1) peripheral clock.
  * @note   After reset, the peripheral clock (used for registers read/write access)
  *         is disabled and the application software has to enable this clock before
  *         using it.
  *//** @brief  Enables or disables the AHB3 peripheral clock.
  * @note   After reset, the peripheral clock (used for registers read/write access)
  *         is disabled and the application software has to enable this clock before
  *         using it.
  *//* STM32F756x || STM32F777xx || STM32F779xx || STM32F750xx *//** @brief  Enable or disable the AHB2 peripheral clock.
  * @note   After reset, the peripheral clock (used for registers read/write access)
  *         is disabled and the application software has to enable this clock before
  *         using it.
  *//** @brief  Enables or disables the AHB1 peripheral clock.
  * @note   After reset, the peripheral clock (used for registers read/write access)
  *         is disabled and the application software has to enable this clock before
  *         using it.
  *//** @defgroup RCCEx_Peripheral_Clock_Enable_Disable RCCEx_Peripheral_Clock_Enable_Disable
  * @brief  Enables or disables the AHB/APB peripheral clock.
  * @note   After reset, the peripheral clock (used for registers read/write access)
  *         is disabled and the application software has to enable this clock before
  *         using it.
  * @{
  *//** @defgroup RCCEx_Exported_Macros RCCEx Exported Macros
  * @{
  *//** @defgroup RCCEx_DSI_Clock_Source  RCC DSI Clock Source
  * @{
  *//** @defgroup RCCEx_DFSDM1_AUDIO_Clock_Source RCCEx DFSDM1 AUDIO Clock Source
  * @{
  *//** @defgroup RCCEx_DFSDM1_Kernel_Clock_Source  RCCEx DFSDM1 Kernel Clock Source
  * @{
  *//** @defgroup RCCEx_SDMMC2_Clock_Source RCCEx SDMMC2 Clock Source
  * @{
  *//** @defgroup RCCEx_SDMMC1_Clock_Source RCCEx SDMMC1 Clock Source
  * @{
  *//** @defgroup RCCEx_TIM_Prescaler_Selection RCCEx TIM Prescaler Selection
  * @{
  *//** @defgroup RCCEx_CLK48_Clock_Source RCCEx CLK48 Clock Source
  * @{
  *//** @defgroup RCCEx_LPTIM1_Clock_Source RCCEx LPTIM1 Clock Source
  * @{
  *//** @defgroup RCCEx_I2C4_Clock_Source RCCEx I2C4 Clock Source
  * @{
  *//** @defgroup RCCEx_I2C3_Clock_Source RCCEx I2C3 Clock Source
  * @{
  *//** @defgroup RCCEx_I2C2_Clock_Source RCCEx I2C2 Clock Source
  * @{
  *//** @defgroup RCCEx_I2C1_Clock_Source RCCEx I2C1 Clock Source
  * @{
  *//** @defgroup RCCEx_UART8_Clock_Source RCCEx UART8 Clock Source
  * @{
  *//** @defgroup RCCEx_UART7_Clock_Source RCCEx UART7 Clock Source
  * @{
  *//** @defgroup RCCEx_USART6_Clock_Source RCCEx USART6 Clock Source
  * @{
  *//** @defgroup RCCEx_UART5_Clock_Source RCCEx UART5 Clock Source
  * @{
  *//** @defgroup RCCEx_UART4_Clock_Source RCCEx UART4 Clock Source
  * @{
  *//** @defgroup RCCEx_USART3_Clock_Source RCCEx USART3 Clock Source
  * @{
  *//** @defgroup RCCEx_USART2_Clock_Source RCCEx USART2 Clock Source
  * @{
  *//** @defgroup RCCEx_USART1_Clock_Source RCCEx USART1 Clock Source
  * @{
  *//* CEC clock is HSI/488*//** @defgroup RCCEx_CEC_Clock_Source RCCEx CEC Clock Source
  * @{
  *//** @defgroup RCCEx_SAI2_Clock_Source RCCEx SAI2 Clock Source
  * @{
  *//** @defgroup RCCEx_SAI1_Clock_Source RCCEx SAI1 Clock Source
  * @{
  *//** @defgroup RCCEx_I2S_Clock_Source RCCEx I2S Clock Source
  * @{
  *//** @defgroup RCCEx_PLLSAI_DIVR RCCEx PLLSAI DIVR
  * @{
  *//** @defgroup RCCEx_PLLSAIP_Clock_Divider RCCEx PLLSAIP Clock Divider
  * @{
  *//** @defgroup RCCEx_PLLI2SP_Clock_Divider RCCEx PLLI2SP Clock Divider
  * @{
  *//** @defgroup RCCEx_Periph_Clock_Selection RCC Periph Clock Selection
  * @{
  *//** @defgroup RCCEx_Exported_Constants RCCEx Exported Constants
  * @{
  *//*!< DFSDM1 clock source
                                        This parameter can be a value of @ref RCCEx_DFSDM1_AUDIO_Clock_Source *//*!< DFSDM1 clock source
                                        This parameter can be a value of @ref RCCEx_DFSDM1_Kernel_Clock_Source *//*!< SDMMC2 clock source
                                        This parameter can be a value of @ref RCCEx_SDMMC2_Clock_Source *//*!< SDMMC1 clock source
                                        This parameter can be a value of @ref RCCEx_SDMMC1_Clock_Source *//*!< Specifies 48Mhz clock source used by USB OTG FS, RNG and SDMMC
                                        This parameter can be a value of @ref RCCEx_CLK48_Clock_Source *//*!< CEC clock source
                                        This parameter can be a value of @ref RCCEx_CEC_Clock_Source *//*!< Specifies LPTIM1 clock source
                                        This parameter can be a value of @ref RCCEx_LPTIM1_Clock_Source *//*!< I2C4 clock source
                                      This parameter can be a value of @ref RCCEx_I2C4_Clock_Source *//*!< I2C3 clock source
                                      This parameter can be a value of @ref RCCEx_I2C3_Clock_Source *//*!< I2C2 clock source
                                      This parameter can be a value of @ref RCCEx_I2C2_Clock_Source *//*!< I2C1 clock source
                                      This parameter can be a value of @ref RCCEx_I2C1_Clock_Source *//*!< UART8 clock source
                                      This parameter can be a value of @ref RCCEx_UART8_Clock_Source *//*!< UART7 clock source
                                      This parameter can be a value of @ref RCCEx_UART7_Clock_Source *//*!< USART6 clock source
                                      This parameter can be a value of @ref RCCEx_USART6_Clock_Source *//*!< UART5 clock source
                                      This parameter can be a value of @ref RCCEx_UART5_Clock_Source *//*!< UART4 clock source
                                      This parameter can be a value of @ref RCCEx_UART4_Clock_Source *//*!< USART3 clock source
                                      This parameter can be a value of @ref RCCEx_USART3_Clock_Source *//*!< USART2 clock source
                                      This parameter can be a value of @ref RCCEx_USART2_Clock_Source *//*!< USART1 clock source
                                      This parameter can be a value of @ref RCCEx_USART1_Clock_Source *//*!< Specifies SAI2 Clock Prescalers Selection
                                        This parameter can be a value of @ref RCCEx_SAI2_Clock_Source *//*!< Specifies SAI1 Clock Prescalers Selection
                                        This parameter can be a value of @ref RCCEx_SAI1_Clock_Source *//*!< Specifies TIM Clock Prescalers Selection.
                                       This parameter can be a value of @ref RCCEx_TIM_Prescaler_Selection *//*!< Specifies I2S Clock source Selection.
                                        This parameter can be a value of @ref RCCEx_I2S_Clock_Source *//*!< Specifies RTC Clock source Selection.
                                        This parameter can be a value of @ref RCC_RTC_Clock_Source *//*!< Specifies the PLLSAI division factor for LTDC clock.
                                      This parameter must be one value of @ref RCCEx_PLLSAI_DIVR *//*!< Specifies the PLLI2S division factor for SAI1 clock.
                                      This parameter must be a number between Min_Data = 1 and Max_Data = 32
                                      This parameter will be used only when PLLSAI is selected as Clock Source SAI *//*!< Specifies the PLLI2S division factor for SAI1 clock.
                                      This parameter must be a number between Min_Data = 1 and Max_Data = 32
                                      This parameter will be used only when PLLI2S is selected as Clock Source SAI *//*!< PLL SAI structure parameters.
                                      This parameter will be used only when PLLI2S is selected as Clock Source SAI or LTDC *//*!< PLL I2S structure parameters.
                                      This parameter will be used only when PLLI2S is selected as Clock Source I2S or SAI *//*!< The Extended Clock to be configured.
                                      This parameter can be a value of @ref RCCEx_Periph_Clock_Selection *//**
  * @brief  RCC extended clocks structure definition
  *//*!< Specifies the division factor for 48MHz clock.
                            This parameter must be a value of @ref RCCEx_PLLSAIP_Clock_Divider
                            This parameter will be used only when PLLSAI is disabled *//*!< specifies the division factor for LTDC clock
                            This parameter must be a number between Min_Data = 2 and Max_Data = 7.
                            This parameter will be used only when PLLSAI is selected as Clock Source LTDC *//*!< Specifies the division factor for SAI1 clock.
                            This parameter must be a number between Min_Data = 2 and Max_Data = 15.
                            This parameter will be used only when PLLSAI is selected as Clock Source SAI or LTDC *//*!< Specifies the multiplication factor for PLLI2S VCO output clock.
                            This parameter must be a number between Min_Data = 50 and Max_Data = 432.
                            This parameter will be used only when PLLSAI is selected as Clock Source SAI or LTDC *//**
  * @brief  PLLSAI Clock structure definition
  *//*!< Specifies the division factor for SPDIF-RX clock.
                            This parameter must be a value of @ref RCCEx_PLLI2SP_Clock_Divider.
                            This parameter will be used only when PLLI2S is selected as Clock Source SPDIF-RX *//*!< Specifies the division factor for SAI1 clock.
                            This parameter must be a number between Min_Data = 2 and Max_Data = 15.
                            This parameter will be used only when PLLI2S is selected as Clock Source SAI *//*!< Specifies the division factor for I2S clock.
                            This parameter must be a number between Min_Data = 2 and Max_Data = 7.
                            This parameter will be used only when PLLI2S is selected as Clock Source I2S or SAI *//*!< Specifies the multiplication factor for PLLI2S VCO output clock.
                            This parameter must be a number between Min_Data = 50 and Max_Data = 432.
                            This parameter will be used only when PLLI2S is selected as Clock Source I2S or SAI *//**
  * @brief  PLLI2S Clock structure definition
  *//*!< PLLR: Division factor for DSI clock.
                            This parameter must be a number between Min_Data = 2 and Max_Data = 7    *//*!< PLLQ: Division factor for OTG FS, SDMMC and RNG clocks.
                            This parameter must be a number between Min_Data = 2 and Max_Data = 15    *//*!< PLLP: Division factor for main system clock (SYSCLK).
                            This parameter must be a value of @ref RCC_PLLP_Clock_Divider             *//*!< PLLN: Multiplication factor for PLL VCO output clock.
                            This parameter must be a number between Min_Data = 50 and Max_Data = 432  *//*!< PLLM: Division factor for PLL VCO input clock.
                            This parameter must be a number between Min_Data = 2 and Max_Data = 63    *//*!< RCC_PLLSource: PLL entry clock source.
                            This parameter must be a value of @ref RCC_PLL_Clock_Source               *//*!< The new state of the PLL.
                            This parameter can be a value of @ref RCC_PLL_Config                      *//**
  * @brief  RCC PLL configuration structure definition
  *//** @defgroup RCCEx_Exported_Types RCCEx Exported Types
  * @{
  *//** @addtogroup RCCEx
  * @{
  *//**
  ******************************************************************************
  * @file    stm32f7xx_hal_rcc_ex.h
  * @author  MCD Application Team
  * @brief   Header file of RCC HAL Extension module.
  ******************************************************************************
  * @attention
  *
  * Copyright (c) 2017 STMicroelectronics.
  * All rights reserved.
  *
  * This software is licensed under terms that can be found in the LICENSE file in
  * the root directory of this software component.
  * If no LICENSE file comes with this software, it is provided AS-IS.
  ******************************************************************************
  */PLLSAIInitPLLI2SInitPeriphClkPeriphClkInit"stm32f7xx_hal_rcc_ex.h"HAL_RCC_NMI_IRQHandlerHAL_RCC_GetClockConfigRCC_ClkInitTypeDef *HAL_RCC_GetOscConfigRCC_OscInitTypeDef *HAL_RCC_GetPCLK2FreqHAL_RCC_GetPCLK1FreqHAL_RCC_GetHCLKFreqHAL_RCC_GetSysClockFreqHAL_RCC_DisableCSSHAL_RCC_EnableCSSHAL_RCC_MCOConfigHAL_RCC_ClockConfigHAL_RCC_OscConfigHAL_RCC_DeInitRCC_ClkInitTypeDefRCC_OscInitTypeDefAPB2CLKDividerAPB1CLKDividerAHBCLKDividerSYSCLKSourceClockTypePLLLSIStateHSICalibrationValueHSIStateLSEStateHSEStateOscillatorTypeIS_RCC_LSE_DRIVE(DRIVE)(((DRIVE) == RCC_LSEDRIVE_LOW) || ((DRIVE) == RCC_LSEDRIVE_MEDIUMLOW) || ((DRIVE) == RCC_LSEDRIVE_MEDIUMHIGH) || ((DRIVE) == RCC_LSEDRIVE_HIGH))IS_RCC_RTCCLKSOURCE(SOURCE)(((SOURCE) == RCC_RTCCLKSOURCE_LSE) || ((SOURCE) == RCC_RTCCLKSOURCE_LSI) || ((SOURCE) == RCC_RTCCLKSOURCE_HSE_DIV2) || ((SOURCE) == RCC_RTCCLKSOURCE_HSE_DIV3) || ((SOURCE) == RCC_RTCCLKSOURCE_HSE_DIV4) || ((SOURCE) == RCC_RTCCLKSOURCE_HSE_DIV5) || ((SOURCE) == RCC_RTCCLKSOURCE_HSE_DIV6) || ((SOURCE) == RCC_RTCCLKSOURCE_HSE_DIV7) || ((SOURCE) == RCC_RTCCLKSOURCE_HSE_DIV8) || ((SOURCE) == RCC_RTCCLKSOURCE_HSE_DIV9) || ((SOURCE) == RCC_RTCCLKSOURCE_HSE_DIV10) || ((SOURCE) == RCC_RTCCLKSOURCE_HSE_DIV11) || ((SOURCE) == RCC_RTCCLKSOURCE_HSE_DIV12) || ((SOURCE) == RCC_RTCCLKSOURCE_HSE_DIV13) || ((SOURCE) == RCC_RTCCLKSOURCE_HSE_DIV14) || ((SOURCE) == RCC_RTCCLKSOURCE_HSE_DIV15) || ((SOURCE) == RCC_RTCCLKSOURCE_HSE_DIV16) || ((SOURCE) == RCC_RTCCLKSOURCE_HSE_DIV17) || ((SOURCE) == RCC_RTCCLKSOURCE_HSE_DIV18) || ((SOURCE) == RCC_RTCCLKSOURCE_HSE_DIV19) || ((SOURCE) == RCC_RTCCLKSOURCE_HSE_DIV20) || ((SOURCE) == RCC_RTCCLKSOURCE_HSE_DIV21) || ((SOURCE) == RCC_RTCCLKSOURCE_HSE_DIV22) || ((SOURCE) == RCC_RTCCLKSOURCE_HSE_DIV23) || ((SOURCE) == RCC_RTCCLKSOURCE_HSE_DIV24) || ((SOURCE) == RCC_RTCCLKSOURCE_HSE_DIV25) || ((SOURCE) == RCC_RTCCLKSOURCE_HSE_DIV26) || ((SOURCE) == RCC_RTCCLKSOURCE_HSE_DIV27) || ((SOURCE) == RCC_RTCCLKSOURCE_HSE_DIV28) || ((SOURCE) == RCC_RTCCLKSOURCE_HSE_DIV29) || ((SOURCE) == RCC_RTCCLKSOURCE_HSE_DIV30) || ((SOURCE) == RCC_RTCCLKSOURCE_HSE_DIV31))IS_RCC_CALIBRATION_VALUE(VALUE)((VALUE) <= 0x1F)IS_RCC_MCODIV(DIV)(((DIV) == RCC_MCODIV_1) || ((DIV) == RCC_MCODIV_2) || ((DIV) == RCC_MCODIV_3) || ((DIV) == RCC_MCODIV_4) || ((DIV) == RCC_MCODIV_5))IS_RCC_MCO2SOURCE(SOURCE)(((SOURCE) == RCC_MCO2SOURCE_SYSCLK) || ((SOURCE) == RCC_MCO2SOURCE_PLLI2SCLK)|| ((SOURCE) == RCC_MCO2SOURCE_HSE) || ((SOURCE) == RCC_MCO2SOURCE_PLLCLK))IS_RCC_MCO1SOURCE(SOURCE)(((SOURCE) == RCC_MCO1SOURCE_HSI) || ((SOURCE) == RCC_MCO1SOURCE_LSE) || ((SOURCE) == RCC_MCO1SOURCE_HSE) || ((SOURCE) == RCC_MCO1SOURCE_PLLCLK))IS_RCC_MCO(MCOX)(((MCOX) == RCC_MCO1) || ((MCOX) == RCC_MCO2))IS_RCC_PCLK(PCLK)(((PCLK) == RCC_HCLK_DIV1) || ((PCLK) == RCC_HCLK_DIV2) || ((PCLK) == RCC_HCLK_DIV4) || ((PCLK) == RCC_HCLK_DIV8) || ((PCLK) == RCC_HCLK_DIV16))IS_RCC_CLOCKTYPE(CLK)((1 <= (CLK)) && ((CLK) <= 15))IS_RCC_HCLK(HCLK)(((HCLK) == RCC_SYSCLK_DIV1) || ((HCLK) == RCC_SYSCLK_DIV2) || ((HCLK) == RCC_SYSCLK_DIV4) || ((HCLK) == RCC_SYSCLK_DIV8) || ((HCLK) == RCC_SYSCLK_DIV16) || ((HCLK) == RCC_SYSCLK_DIV64) || ((HCLK) == RCC_SYSCLK_DIV128) || ((HCLK) == RCC_SYSCLK_DIV256) || ((HCLK) == RCC_SYSCLK_DIV512))IS_RCC_PLLQ_VALUE(VALUE)IS_RCC_PLLP_VALUE(VALUE)(((VALUE) == RCC_PLLP_DIV2) || ((VALUE) == RCC_PLLP_DIV4) || ((VALUE) == RCC_PLLP_DIV6) || ((VALUE) == RCC_PLLP_DIV8))IS_RCC_PLLN_VALUE(VALUE)IS_RCC_PLLM_VALUE(VALUE)((2 <= (VALUE)) && ((VALUE) <= 63))IS_RCC_SYSCLKSOURCE(SOURCE)(((SOURCE) == RCC_SYSCLKSOURCE_HSI) || ((SOURCE) == RCC_SYSCLKSOURCE_HSE) || ((SOURCE) == RCC_SYSCLKSOURCE_PLLCLK))IS_RCC_PLLSOURCE(SOURCE)(((SOURCE) == RCC_PLLSOURCE_HSI) || ((SOURCE) == RCC_PLLSOURCE_HSE))IS_RCC_PLL(PLL)(((PLL) == RCC_PLL_NONE) ||((PLL) == RCC_PLL_OFF) || ((PLL) == RCC_PLL_ON))IS_RCC_LSI(LSI)(((LSI) == RCC_LSI_OFF) || ((LSI) == RCC_LSI_ON))IS_RCC_HSI(HSI)(((HSI) == RCC_HSI_OFF) || ((HSI) == RCC_HSI_ON))IS_RCC_LSE(LSE)(((LSE) == RCC_LSE_OFF) || ((LSE) == RCC_LSE_ON) || ((LSE) == RCC_LSE_BYPASS))IS_RCC_HSE(HSE)(((HSE) == RCC_HSE_OFF) || ((HSE) == RCC_HSE_ON) || ((HSE) == RCC_HSE_BYPASS))IS_RCC_OSCILLATORTYPE(OSCILLATOR)((OSCILLATOR) <= 15)LSE_STARTUP_TIMEOUT((uint32_t)100)((uint32_t)(RCC_BASE + 0x0C + 0x02))((uint32_t)(RCC_BASE + 0x0C + 0x01))PLLSAI_TIMEOUT_VALUE100UPLLI2S_TIMEOUT_VALUECLOCKSWITCH_TIMEOUT_VALUE((uint32_t)5000)PLL_TIMEOUT_VALUE((uint32_t)2)LSI_TIMEOUT_VALUEHSI_TIMEOUT_VALUEHSE_TIMEOUT_VALUEHSE_STARTUP_TIMEOUT__HAL_RCC_GET_FLAG(__FLAG__)(((((((__FLAG__) >> 5) == 1)? RCC->CR :((((__FLAG__) >> 5) == 2) ? RCC->BDCR :((((__FLAG__) >> 5) == 3)? RCC->CSR :RCC->CIR))) & ((uint32_t)1 << ((__FLAG__) & RCC_FLAG_MASK)))!= 0)? 1 : 0)RCC_FLAG_MASK((uint8_t)0x1F)__HAL_RCC_CLEAR_RESET_FLAGS()(RCC->CSR |= RCC_CSR_RMVF)__HAL_RCC_GET_IT(__INTERRUPT__)((RCC->CIR & (__INTERRUPT__)) == (__INTERRUPT__))__HAL_RCC_CLEAR_IT(__INTERRUPT__)(*(__IO uint8_t *) RCC_CIR_BYTE2_ADDRESS = (__INTERRUPT__))__HAL_RCC_DISABLE_IT(__INTERRUPT__)(*(__IO uint8_t *) RCC_CIR_BYTE1_ADDRESS &= (uint8_t)(~(__INTERRUPT__)))__HAL_RCC_ENABLE_IT(__INTERRUPT__)(*(__IO uint8_t *) RCC_CIR_BYTE1_ADDRESS |= (__INTERRUPT__))__HAL_RCC_MCO2_CONFIG(__MCOCLKSOURCE__,__MCODIV__)MODIFY_REG(RCC->CFGR, (RCC_CFGR_MCO2 | RCC_CFGR_MCO2PRE), ((__MCOCLKSOURCE__) | ((__MCODIV__) << 3)));__HAL_RCC_MCO1_CONFIG(__MCOCLKSOURCE__,__MCODIV__)MODIFY_REG(RCC->CFGR, (RCC_CFGR_MCO1 | RCC_CFGR_MCO1PRE), ((__MCOCLKSOURCE__) | (__MCODIV__)))__HAL_RCC_GET_PLL_OSCSOURCE()((uint32_t)(RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC))__HAL_RCC_LSEDRIVE_CONFIG(__RCC_LSEDRIVE__)(MODIFY_REG(RCC->BDCR, RCC_BDCR_LSEDRV, (uint32_t)(__RCC_LSEDRIVE__) ))__HAL_RCC_GET_SYSCLK_SOURCE()(RCC->CFGR & RCC_CFGR_SWS)__HAL_RCC_SYSCLK_CONFIG(__RCC_SYSCLKSOURCE__)MODIFY_REG(RCC->CFGR, RCC_CFGR_SW, (__RCC_SYSCLKSOURCE__))__HAL_RCC_PLLI2S_DISABLE()(RCC->CR &= ~(RCC_CR_PLLI2SON))__HAL_RCC_PLLI2S_ENABLE()(RCC->CR |= (RCC_CR_PLLI2SON))__HAL_RCC_I2S_CONFIG(__SOURCE__)do {RCC->CFGR &= ~(RCC_CFGR_I2SSRC); RCC->CFGR |= (__SOURCE__); }while(0)__HAL_RCC_PLL_PLLM_CONFIG(__PLLM__)MODIFY_REG(RCC->PLLCFGR, RCC_PLLCFGR_PLLM, (__PLLM__))__HAL_RCC_PLL_PLLSOURCE_CONFIG(__PLLSOURCE__)MODIFY_REG(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC, (__PLLSOURCE__))__HAL_RCC_PLL_DISABLE()CLEAR_BIT(RCC->CR, RCC_CR_PLLON)__HAL_RCC_PLL_ENABLE()SET_BIT(RCC->CR, RCC_CR_PLLON)__HAL_RCC_BACKUPRESET_RELEASE()(RCC->BDCR &= ~(RCC_BDCR_BDRST))__HAL_RCC_BACKUPRESET_FORCE()(RCC->BDCR |= (RCC_BDCR_BDRST))__HAL_RCC_GET_RTC_HSE_PRESCALER()(READ_BIT(RCC->CFGR, RCC_CFGR_RTCPRE) | RCC_BDCR_RTCSEL)__HAL_RCC_GET_RTC_SOURCE()(READ_BIT(RCC->BDCR, RCC_BDCR_RTCSEL))__HAL_RCC_RTC_CONFIG(__RTCCLKSource__)do { __HAL_RCC_RTC_CLKPRESCALER(__RTCCLKSource__); RCC->BDCR |= ((__RTCCLKSource__) & 0x00000FFF); } while (0)__HAL_RCC_RTC_CLKPRESCALER(__RTCCLKSource__)(((__RTCCLKSource__) & RCC_BDCR_RTCSEL) == RCC_BDCR_RTCSEL) ? MODIFY_REG(RCC->CFGR, RCC_CFGR_RTCPRE, ((__RTCCLKSource__) & 0xFFFFCFF)) : CLEAR_BIT(RCC->CFGR, RCC_CFGR_RTCPRE)__HAL_RCC_RTC_DISABLE()(RCC->BDCR &= ~(RCC_BDCR_RTCEN))__HAL_RCC_RTC_ENABLE()(RCC->BDCR |= (RCC_BDCR_RTCEN))__HAL_RCC_LSE_CONFIG(__STATE__)do { if((__STATE__) == RCC_LSE_ON) { SET_BIT(RCC->BDCR, RCC_BDCR_LSEON); } else if((__STATE__) == RCC_LSE_OFF) { CLEAR_BIT(RCC->BDCR, RCC_BDCR_LSEON); CLEAR_BIT(RCC->BDCR, RCC_BDCR_LSEBYP); } else if((__STATE__) == RCC_LSE_BYPASS) { SET_BIT(RCC->BDCR, RCC_BDCR_LSEBYP); SET_BIT(RCC->BDCR, RCC_BDCR_LSEON); } else { CLEAR_BIT(RCC->BDCR, RCC_BDCR_LSEON); CLEAR_BIT(RCC->BDCR, RCC_BDCR_LSEBYP); } } while(0)__HAL_RCC_HSE_CONFIG(__STATE__)do { if ((__STATE__) == RCC_HSE_ON) { SET_BIT(RCC->CR, RCC_CR_HSEON); } else if ((__STATE__) == RCC_HSE_OFF) { CLEAR_BIT(RCC->CR, RCC_CR_HSEON); CLEAR_BIT(RCC->CR, RCC_CR_HSEBYP); } else if ((__STATE__) == RCC_HSE_BYPASS) { SET_BIT(RCC->CR, RCC_CR_HSEBYP); SET_BIT(RCC->CR, RCC_CR_HSEON); } else { CLEAR_BIT(RCC->CR, RCC_CR_HSEON); CLEAR_BIT(RCC->CR, RCC_CR_HSEBYP); } } while(0)__HAL_RCC_LSI_DISABLE()(RCC->CSR &= ~(RCC_CSR_LSION))__HAL_RCC_LSI_ENABLE()(RCC->CSR |= (RCC_CSR_LSION))__HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(__HSICALIBRATIONVALUE__)(MODIFY_REG(RCC->CR, RCC_CR_HSITRIM, (uint32_t)(__HSICALIBRATIONVALUE__) << RCC_CR_HSITRIM_Pos))__HAL_RCC_HSI_DISABLE()(RCC->CR &= ~(RCC_CR_HSION))__HAL_RCC_HSI_ENABLE()(RCC->CR |= (RCC_CR_HSION))__HAL_RCC_SYSCFG_IS_CLK_SLEEP_DISABLED()((RCC->APB2LPENR & (RCC_APB2LPENR_SYSCFGLPEN)) == RESET)__HAL_RCC_SYSCFG_IS_CLK_SLEEP_ENABLED()((RCC->APB2LPENR & (RCC_APB2LPENR_SYSCFGLPEN)) != RESET)__HAL_RCC_PWR_IS_CLK_SLEEP_DISABLED()((RCC->APB1LPENR & (RCC_APB1LPENR_PWRLPEN)) == RESET)__HAL_RCC_WWDG_IS_CLK_SLEEP_DISABLED()((RCC->APB1LPENR & (RCC_APB1LPENR_WWDGLPEN)) == RESET)__HAL_RCC_PWR_IS_CLK_SLEEP_ENABLED()((RCC->APB1LPENR & (RCC_APB1LPENR_PWRLPEN)) != RESET)__HAL_RCC_WWDG_IS_CLK_SLEEP_ENABLED()((RCC->APB1LPENR & (RCC_APB1LPENR_WWDGLPEN)) != RESET)__HAL_RCC_DMA1_IS_CLK_SLEEP_DISABLED()((RCC->AHB1LPENR & (RCC_AHB1LPENR_DMA1LPEN)) == RESET)__HAL_RCC_CRC_IS_CLK_SLEEP_DISABLED()((RCC->AHB1LPENR & (RCC_AHB1LPENR_CRCLPEN)) == RESET)__HAL_RCC_DMA1_IS_CLK_SLEEP_ENABLED()((RCC->AHB1LPENR & (RCC_AHB1LPENR_DMA1LPEN)) != RESET)__HAL_RCC_CRC_IS_CLK_SLEEP_ENABLED()((RCC->AHB1LPENR & (RCC_AHB1LPENR_CRCLPEN)) != RESET)__HAL_RCC_SYSCFG_CLK_SLEEP_DISABLE()(RCC->APB2LPENR &= ~(RCC_APB2LPENR_SYSCFGLPEN))__HAL_RCC_SYSCFG_CLK_SLEEP_ENABLE()(RCC->APB2LPENR |= (RCC_APB2LPENR_SYSCFGLPEN))__HAL_RCC_PWR_CLK_SLEEP_DISABLE()(RCC->APB1LPENR &= ~(RCC_APB1LPENR_PWRLPEN))__HAL_RCC_WWDG_CLK_SLEEP_DISABLE()(RCC->APB1LPENR &= ~(RCC_APB1LPENR_WWDGLPEN))__HAL_RCC_PWR_CLK_SLEEP_ENABLE()(RCC->APB1LPENR |= (RCC_APB1LPENR_PWRLPEN))__HAL_RCC_WWDG_CLK_SLEEP_ENABLE()(RCC->APB1LPENR |= (RCC_APB1LPENR_WWDGLPEN))__HAL_RCC_DMA1_CLK_SLEEP_DISABLE()(RCC->AHB1LPENR &= ~(RCC_AHB1LPENR_DMA1LPEN))__HAL_RCC_CRC_CLK_SLEEP_DISABLE()(RCC->AHB1LPENR &= ~(RCC_AHB1LPENR_CRCLPEN))__HAL_RCC_DMA1_CLK_SLEEP_ENABLE()(RCC->AHB1LPENR |= (RCC_AHB1LPENR_DMA1LPEN))__HAL_RCC_CRC_CLK_SLEEP_ENABLE()(RCC->AHB1LPENR |= (RCC_AHB1LPENR_CRCLPEN))__HAL_RCC_SYSCFG_RELEASE_RESET()(RCC->APB2RSTR &= ~(RCC_APB2RSTR_SYSCFGRST))__HAL_RCC_APB2_RELEASE_RESET()(RCC->APB2RSTR = 0x00U)__HAL_RCC_SYSCFG_FORCE_RESET()(RCC->APB2RSTR |= (RCC_APB2RSTR_SYSCFGRST))__HAL_RCC_APB2_FORCE_RESET()(RCC->APB2RSTR = 0xFFFFFFFFU)__HAL_RCC_PWR_RELEASE_RESET()(RCC->APB1RSTR &= ~(RCC_APB1RSTR_PWRRST))__HAL_RCC_WWDG_RELEASE_RESET()(RCC->APB1RSTR &= ~(RCC_APB1RSTR_WWDGRST))__HAL_RCC_APB1_RELEASE_RESET()(RCC->APB1RSTR = 0x00U)__HAL_RCC_PWR_FORCE_RESET()(RCC->APB1RSTR |= (RCC_APB1RSTR_PWRRST))__HAL_RCC_WWDG_FORCE_RESET()(RCC->APB1RSTR |= (RCC_APB1RSTR_WWDGRST))__HAL_RCC_APB1_FORCE_RESET()(RCC->APB1RSTR = 0xFFFFFFFFU)__HAL_RCC_DMA1_RELEASE_RESET()(RCC->AHB1RSTR &= ~(RCC_AHB1RSTR_DMA1RST))__HAL_RCC_CRC_RELEASE_RESET()(RCC->AHB1RSTR &= ~(RCC_AHB1RSTR_CRCRST))__HAL_RCC_AHB1_RELEASE_RESET()(RCC->AHB1RSTR = 0x00U)__HAL_RCC_DMA1_FORCE_RESET()(RCC->AHB1RSTR |= (RCC_AHB1RSTR_DMA1RST))__HAL_RCC_CRC_FORCE_RESET()(RCC->AHB1RSTR |= (RCC_AHB1RSTR_CRCRST))__HAL_RCC_AHB1_FORCE_RESET()(RCC->AHB1RSTR = 0xFFFFFFFFU)__HAL_RCC_SYSCFG_IS_CLK_DISABLED()((RCC->APB2ENR & (RCC_APB2ENR_SYSCFGEN)) == RESET)__HAL_RCC_SYSCFG_IS_CLK_ENABLED()((RCC->APB2ENR & (RCC_APB2ENR_SYSCFGEN)) != RESET)__HAL_RCC_PWR_IS_CLK_DISABLED()((RCC->APB1ENR & (RCC_APB1ENR_PWREN)) == RESET)__HAL_RCC_WWDG_IS_CLK_DISABLED()((RCC->APB1ENR & (RCC_APB1ENR_WWDGEN)) == RESET)__HAL_RCC_PWR_IS_CLK_ENABLED()((RCC->APB1ENR & (RCC_APB1ENR_PWREN)) != RESET)__HAL_RCC_WWDG_IS_CLK_ENABLED()((RCC->APB1ENR & (RCC_APB1ENR_WWDGEN)) != RESET)__HAL_RCC_DMA1_IS_CLK_DISABLED()((RCC->AHB1ENR & (RCC_AHB1ENR_DMA1EN)) == RESET)__HAL_RCC_CRC_IS_CLK_DISABLED()((RCC->AHB1ENR & (RCC_AHB1ENR_CRCEN)) == RESET)__HAL_RCC_DMA1_IS_CLK_ENABLED()((RCC->AHB1ENR & (RCC_AHB1ENR_DMA1EN)) != RESET)__HAL_RCC_CRC_IS_CLK_ENABLED()((RCC->AHB1ENR & (RCC_AHB1ENR_CRCEN)) != RESET)__HAL_RCC_SYSCFG_CLK_DISABLE()(RCC->APB2ENR &= ~(RCC_APB2ENR_SYSCFGEN))__HAL_RCC_SYSCFG_CLK_ENABLE()do { __IO uint32_t tmpreg; SET_BIT(RCC->APB2ENR, RCC_APB2ENR_SYSCFGEN); tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_SYSCFGEN); UNUSED(tmpreg); } while(0)__HAL_RCC_PWR_CLK_DISABLE()(RCC->APB1ENR &= ~(RCC_APB1ENR_PWREN))__HAL_RCC_WWDG_CLK_DISABLE()(RCC->APB1ENR &= ~(RCC_APB1ENR_WWDGEN))__HAL_RCC_PWR_CLK_ENABLE()do { __IO uint32_t tmpreg; SET_BIT(RCC->APB1ENR, RCC_APB1ENR_PWREN); tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_PWREN); UNUSED(tmpreg); } while(0)__HAL_RCC_WWDG_CLK_ENABLE()do { __IO uint32_t tmpreg; SET_BIT(RCC->APB1ENR, RCC_APB1ENR_WWDGEN); tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_WWDGEN); UNUSED(tmpreg); } while(0)__HAL_RCC_DMA1_CLK_DISABLE()(RCC->AHB1ENR &= ~(RCC_AHB1ENR_DMA1EN))__HAL_RCC_CRC_CLK_DISABLE()(RCC->AHB1ENR &= ~(RCC_AHB1ENR_CRCEN))do { __IO uint32_t tmpreg; SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_DMA1EN); tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_DMA1EN); UNUSED(tmpreg); } while(0)__HAL_RCC_CRC_CLK_ENABLE()do { __IO uint32_t tmpreg; SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_CRCEN); tmpreg = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_CRCEN); UNUSED(tmpreg); } while(0)RCC_LSEDRIVE_HIGHRCC_LSEDRIVE_MEDIUMHIGHRCC_LSEDRIVE_MEDIUMLOWRCC_LSEDRIVE_LOWRCC_FLAG_LPWRRST((uint8_t)0x7FU)RCC_FLAG_WWDGRST((uint8_t)0x7EU)RCC_FLAG_IWDGRST((uint8_t)0x7DU)RCC_FLAG_SFTRST((uint8_t)0x7CU)RCC_FLAG_PORRST((uint8_t)0x7BU)RCC_FLAG_PINRST((uint8_t)0x7AU)RCC_FLAG_BORRST((uint8_t)0x79U)RCC_FLAG_LSIRDY((uint8_t)0x61U)RCC_FLAG_LSERDY((uint8_t)0x41U)RCC_FLAG_PLLSAIRDY((uint8_t)0x3CU)RCC_FLAG_PLLI2SRDY((uint8_t)0x3BU)RCC_FLAG_PLLRDY((uint8_t)0x39U)RCC_FLAG_HSERDY((uint8_t)0x31U)RCC_FLAG_HSIRDY((uint8_t)0x21U)((uint8_t)0x80U)RCC_IT_PLLSAIRDY((uint8_t)0x40U)RCC_IT_PLLI2SRDY((uint8_t)0x20U)RCC_IT_PLLRDYRCC_IT_HSERDYRCC_IT_HSIRDYRCC_IT_LSERDYRCC_IT_LSIRDYRCC_MCODIV_5((uint32_t)RCC_CFGR_MCO1PRE_1 | RCC_CFGR_MCO1PRE_2)RCC_MCODIV_3((uint32_t)RCC_CFGR_MCO1PRE_0 | RCC_CFGR_MCO1PRE_2)RCC_MCO2SOURCE_PLLCLKRCC_MCO2SOURCE_HSERCC_MCO2SOURCE_PLLI2SCLKRCC_MCO2SOURCE_SYSCLKRCC_MCO2RCC_MCO1RCC_RTCCLKSOURCE_HSE_DIV31((uint32_t)0x001F0300U)RCC_RTCCLKSOURCE_HSE_DIV30((uint32_t)0x001E0300U)RCC_RTCCLKSOURCE_HSE_DIV29((uint32_t)0x001D0300U)RCC_RTCCLKSOURCE_HSE_DIV28((uint32_t)0x001C0300U)RCC_RTCCLKSOURCE_HSE_DIV27((uint32_t)0x001B0300U)RCC_RTCCLKSOURCE_HSE_DIV26((uint32_t)0x001A0300U)RCC_RTCCLKSOURCE_HSE_DIV25((uint32_t)0x00190300U)RCC_RTCCLKSOURCE_HSE_DIV24((uint32_t)0x00180300U)RCC_RTCCLKSOURCE_HSE_DIV23((uint32_t)0x00170300U)RCC_RTCCLKSOURCE_HSE_DIV22((uint32_t)0x00160300U)RCC_RTCCLKSOURCE_HSE_DIV21((uint32_t)0x00150300U)RCC_RTCCLKSOURCE_HSE_DIV20((uint32_t)0x00140300U)RCC_RTCCLKSOURCE_HSE_DIV19((uint32_t)0x00130300U)RCC_RTCCLKSOURCE_HSE_DIV18((uint32_t)0x00120300U)RCC_RTCCLKSOURCE_HSE_DIV17((uint32_t)0x00110300U)RCC_RTCCLKSOURCE_HSE_DIV16((uint32_t)0x00100300U)RCC_RTCCLKSOURCE_HSE_DIV15((uint32_t)0x000F0300U)RCC_RTCCLKSOURCE_HSE_DIV14((uint32_t)0x000E0300U)RCC_RTCCLKSOURCE_HSE_DIV13((uint32_t)0x000D0300U)RCC_RTCCLKSOURCE_HSE_DIV12((uint32_t)0x000C0300U)RCC_RTCCLKSOURCE_HSE_DIV11((uint32_t)0x000B0300U)RCC_RTCCLKSOURCE_HSE_DIV10((uint32_t)0x000A0300U)RCC_RTCCLKSOURCE_HSE_DIV9((uint32_t)0x00090300U)RCC_RTCCLKSOURCE_HSE_DIV8((uint32_t)0x00080300U)RCC_RTCCLKSOURCE_HSE_DIV7((uint32_t)0x00070300U)RCC_RTCCLKSOURCE_HSE_DIV6((uint32_t)0x00060300U)RCC_RTCCLKSOURCE_HSE_DIV5((uint32_t)0x00050300U)RCC_RTCCLKSOURCE_HSE_DIV4((uint32_t)0x00040300U)RCC_RTCCLKSOURCE_HSE_DIV3((uint32_t)0x00030300U)RCC_RTCCLKSOURCE_HSE_DIV2((uint32_t)0x00020300U)RCC_RTCCLKSOURCE_HSE_DIVX((uint32_t)0x00000300U)RCC_RTCCLKSOURCE_LSIRCC_RTCCLKSOURCE_LSERCC_HCLK_DIV16RCC_HCLK_DIV8RCC_HCLK_DIV4RCC_HCLK_DIV2RCC_HCLK_DIV1RCC_SYSCLK_DIV512RCC_SYSCLK_DIV256RCC_SYSCLK_DIV128RCC_SYSCLK_DIV64RCC_SYSCLK_DIV16RCC_SYSCLK_DIV8RCC_SYSCLK_DIV4RCC_SYSCLK_DIV2RCC_SYSCLK_DIV1RCC_SYSCLKSOURCE_STATUS_PLLCLKRCC_SYSCLKSOURCE_STATUS_HSERCC_SYSCLKSOURCE_STATUS_HSIRCC_SYSCLKSOURCE_PLLCLKRCC_SYSCLKSOURCE_HSERCC_SYSCLKSOURCE_HSIRCC_CLOCKTYPE_PCLK2RCC_CLOCKTYPE_PCLK1((uint32_t)0x00000004U)RCC_CLOCKTYPE_HCLKRCC_CLOCKTYPE_SYSCLKRCC_PLLSOURCE_HSERCC_PLLSOURCE_HSIRCC_PLLP_DIV8RCC_PLLP_DIV6((uint32_t)0x00000006U)RCC_PLLP_DIV4RCC_PLLP_DIV2RCC_PLL_ONRCC_PLL_OFFRCC_PLL_NONERCC_LSI_ONRCC_LSI_OFFRCC_HSICALIBRATION_DEFAULT((uint32_t)0x10U)RCC_HSI_ONRCC_HSI_OFFRCC_LSE_BYPASS((uint32_t)(RCC_BDCR_LSEBYP | RCC_BDCR_LSEON))RCC_LSE_ONRCC_LSE_OFFRCC_HSE_BYPASS((uint32_t)(RCC_CR_HSEBYP | RCC_CR_HSEON))RCC_HSE_ONRCC_HSE_OFFRCC_OSCILLATORTYPE_LSIRCC_OSCILLATORTYPE_LSERCC_OSCILLATORTYPE_HSIRCC_OSCILLATORTYPE_HSERCC_OSCILLATORTYPE_NONE__STM32F7xx_HAL_RCC_H/* __STM32F7xx_HAL_RCC_H *//** @defgroup RCC_IS_RCC_Definitions RCC Private macros to check input parameters
  * @{
  *//** @addtogroup RCC_Private_Macros RCC Private Macros
  * @{
  *//* CIR register byte 3 (Bits[23:16]) base address *//* CIR register byte 2 (Bits[15:8]) base address *//** @defgroup RCC_BitAddress_Alias RCC BitAddress Alias
  * @brief RCC registers bit address alias
  * @{
  *//* Timeout value fixed to 100 ms *//* 5 s *//* 2 ms *//** @defgroup RCC_Private_Constants RCC Private Constants
  * @{
  *//* User Callbacks in non blocking mode (IT mode) *//* CSS NMI IRQ handler *//** @addtogroup RCC_Exported_Functions_Group2
  * @{
  *//* Initialization and de-initialization functions  ******************************//** @addtogroup RCC_Exported_Functions_Group1
  * @{
  *//** @addtogroup RCC_Exported_Functions
  * @{
  *//* Include RCC HAL Extension module *//** @brief  Check RCC flag is set or not.
  * @param  __FLAG__ specifies the flag to check.
  *         This parameter can be one of the following values:
  *            @arg RCC_FLAG_HSIRDY: HSI oscillator clock ready.
  *            @arg RCC_FLAG_HSERDY: HSE oscillator clock ready.
  *            @arg RCC_FLAG_PLLRDY: Main PLL clock ready.
  *            @arg RCC_FLAG_PLLI2SRDY: PLLI2S clock ready.
  *            @arg RCC_FLAG_LSERDY: LSE oscillator clock ready.
  *            @arg RCC_FLAG_LSIRDY: LSI oscillator clock ready.
  *            @arg RCC_FLAG_BORRST: POR/PDR or BOR reset.
  *            @arg RCC_FLAG_PINRST: Pin reset.
  *            @arg RCC_FLAG_PORRST: POR/PDR reset.
  *            @arg RCC_FLAG_SFTRST: Software reset.
  *            @arg RCC_FLAG_IWDGRST: Independent Watchdog reset.
  *            @arg RCC_FLAG_WWDGRST: Window Watchdog reset.
  *            @arg RCC_FLAG_LPWRRST: Low Power reset.
  * @retval The new state of __FLAG__ (TRUE or FALSE).
  *//** @brief Set RMVF bit to clear the reset flags: RCC_FLAG_PINRST, RCC_FLAG_PORRST, 
  *        RCC_FLAG_SFTRST, RCC_FLAG_IWDGRST, RCC_FLAG_WWDGRST and RCC_FLAG_LPWRRST.
  *//** @brief  Check the RCC's interrupt has occurred or not.
  * @param  __INTERRUPT__ specifies the RCC interrupt source to check.
  *         This parameter can be one of the following values:
  *            @arg RCC_IT_LSIRDY: LSI ready interrupt.
  *            @arg RCC_IT_LSERDY: LSE ready interrupt.
  *            @arg RCC_IT_HSIRDY: HSI ready interrupt.
  *            @arg RCC_IT_HSERDY: HSE ready interrupt.
  *            @arg RCC_IT_PLLRDY: Main PLL ready interrupt.
  *            @arg RCC_IT_PLLI2SRDY: PLLI2S ready interrupt.
  *            @arg RCC_IT_CSS: Clock Security System interrupt
  * @retval The new state of __INTERRUPT__ (TRUE or FALSE).
  *//** @brief  Clear the RCC's interrupt pending bits (Perform Byte access to RCC_CIR[23:16]
  *         bits to clear the selected interrupt pending bits.
  * @param  __INTERRUPT__ specifies the interrupt pending bit to clear.
  *         This parameter can be any combination of the following values:
  *            @arg RCC_IT_LSIRDY: LSI ready interrupt.
  *            @arg RCC_IT_LSERDY: LSE ready interrupt.
  *            @arg RCC_IT_HSIRDY: HSI ready interrupt.
  *            @arg RCC_IT_HSERDY: HSE ready interrupt.
  *            @arg RCC_IT_PLLRDY: Main PLL ready interrupt.
  *            @arg RCC_IT_PLLI2SRDY: PLLI2S ready interrupt.  
  *            @arg RCC_IT_CSS: Clock Security System interrupt
  *//** @brief Disable RCC interrupt (Perform Byte access to RCC_CIR[14:8] bits to disable 
  *        the selected interrupts).
  * @param  __INTERRUPT__ specifies the RCC interrupt sources to be disabled.
  *         This parameter can be any combination of the following values:
  *            @arg RCC_IT_LSIRDY: LSI ready interrupt.
  *            @arg RCC_IT_LSERDY: LSE ready interrupt.
  *            @arg RCC_IT_HSIRDY: HSI ready interrupt.
  *            @arg RCC_IT_HSERDY: HSE ready interrupt.
  *            @arg RCC_IT_PLLRDY: Main PLL ready interrupt.
  *            @arg RCC_IT_PLLI2SRDY: PLLI2S ready interrupt.
  *//** @brief  Enable RCC interrupt (Perform Byte access to RCC_CIR[14:8] bits to enable
  *         the selected interrupts).
  * @param  __INTERRUPT__ specifies the RCC interrupt sources to be enabled.
  *         This parameter can be any combination of the following values:
  *            @arg RCC_IT_LSIRDY: LSI ready interrupt.
  *            @arg RCC_IT_LSERDY: LSE ready interrupt.
  *            @arg RCC_IT_HSIRDY: HSI ready interrupt.
  *            @arg RCC_IT_HSERDY: HSE ready interrupt.
  *            @arg RCC_IT_PLLRDY: Main PLL ready interrupt.
  *            @arg RCC_IT_PLLI2SRDY: PLLI2S ready interrupt.
  *//** @defgroup RCC_Flags_Interrupts_Management Flags Interrupts Management
  * @brief macros to manage the specified RCC Flags and interrupts.
  * @{
  *//** @brief  Macro to configure the MCO2 clock.
  * @param  __MCOCLKSOURCE__ specifies the MCO clock source.
  *          This parameter can be one of the following values:
  *            @arg RCC_MCO2SOURCE_SYSCLK: System clock (SYSCLK) selected as MCO2 source
  *            @arg RCC_MCO2SOURCE_PLLI2SCLK: PLLI2S clock selected as MCO2 source 
  *            @arg RCC_MCO2SOURCE_HSE: HSE clock selected as MCO2 source
  *            @arg RCC_MCO2SOURCE_PLLCLK: main PLL clock selected as MCO2 source
  * @param  __MCODIV__ specifies the MCO clock prescaler.
  *          This parameter can be one of the following values:
  *            @arg RCC_MCODIV_1: no division applied to MCOx clock
  *            @arg RCC_MCODIV_2: division by 2 applied to MCOx clock
  *            @arg RCC_MCODIV_3: division by 3 applied to MCOx clock
  *            @arg RCC_MCODIV_4: division by 4 applied to MCOx clock
  *            @arg RCC_MCODIV_5: division by 5 applied to MCOx clock
  *//** @brief  Macro to configure the MCO1 clock.
  * @param  __MCOCLKSOURCE__ specifies the MCO clock source.
  *          This parameter can be one of the following values:
  *            @arg RCC_MCO1SOURCE_HSI: HSI clock selected as MCO1 source
  *            @arg RCC_MCO1SOURCE_LSE: LSE clock selected as MCO1 source
  *            @arg RCC_MCO1SOURCE_HSE: HSE clock selected as MCO1 source
  *            @arg RCC_MCO1SOURCE_PLLCLK: main PLL clock selected as MCO1 source
  * @param  __MCODIV__ specifies the MCO clock prescaler.
  *          This parameter can be one of the following values:
  *            @arg RCC_MCODIV_1: no division applied to MCOx clock
  *            @arg RCC_MCODIV_2: division by 2 applied to MCOx clock
  *            @arg RCC_MCODIV_3: division by 3 applied to MCOx clock
  *            @arg RCC_MCODIV_4: division by 4 applied to MCOx clock
  *            @arg RCC_MCODIV_5: division by 5 applied to MCOx clock
  *//** @defgroup RCCEx_MCOx_Clock_Config RCC Extended MCOx Clock Config
  * @{   
  *//** @brief  Macro to get the oscillator used as PLL clock source.
  * @retval The oscillator used as PLL clock source. The returned value can be one
  *         of the following:
  *              - RCC_PLLSOURCE_HSI: HSI oscillator is used as PLL clock source.
  *              - RCC_PLLSOURCE_HSE: HSE oscillator is used as PLL clock source.
  *//**
  * @brief  Macro to configures the External Low Speed oscillator (LSE) drive capability.
  * @note   As the LSE is in the Backup domain and write access is denied to
  *         this domain after reset, you have to enable write access using
  *         HAL_PWR_EnableBkUpAccess() function before to configure the LSE
  *         (to be done once after reset).
  * @param  __RCC_LSEDRIVE__ specifies the new state of the LSE drive capability.
  *          This parameter can be one of the following values:
  *            @arg RCC_LSEDRIVE_LOW: LSE oscillator low drive capability.
  *            @arg RCC_LSEDRIVE_MEDIUMLOW: LSE oscillator medium low drive capability.
  *            @arg RCC_LSEDRIVE_MEDIUMHIGH: LSE oscillator medium high drive capability.
  *            @arg RCC_LSEDRIVE_HIGH: LSE oscillator high drive capability.
  * @retval None
  *//** @brief  Macro to get the clock source used as system clock.
  * @retval The clock source used as system clock. The returned value can be one
  *         of the following:
  *              - RCC_SYSCLKSOURCE_STATUS_HSI: HSI used as system clock.
  *              - RCC_SYSCLKSOURCE_STATUS_HSE: HSE used as system clock.
  *              - RCC_SYSCLKSOURCE_STATUS_PLLCLK: PLL used as system clock.
  *//**
  * @brief Macro to configure the system clock source.
  * @param __RCC_SYSCLKSOURCE__ specifies the system clock source.
  * This parameter can be one of the following values:
  *              - RCC_SYSCLKSOURCE_HSI: HSI oscillator is used as system clock source.
  *              - RCC_SYSCLKSOURCE_HSE: HSE oscillator is used as system clock source.
  *              - RCC_SYSCLKSOURCE_PLLCLK: PLL output is used as system clock source.
  *//** @defgroup RCC_Get_Clock_source Get Clock source
  * @{   
  *//** @brief Macros to enable or disable the PLLI2S. 
  * @note  The PLLI2S is disabled by hardware when entering STOP and STANDBY modes.
  *//** @brief  Macro to configure the I2S clock source (I2SCLK).
  * @note   This function must be called before enabling the I2S APB clock.
  * @param  __SOURCE__ specifies the I2S clock source.
  *         This parameter can be one of the following values:
  *            @arg RCC_I2SCLKSOURCE_PLLI2S: PLLI2S clock used as I2S clock source.
  *            @arg RCC_I2SCLKSOURCE_EXT: External clock mapped on the I2S_CKIN pin
  *                                       used as I2S clock source.
  *//** @defgroup RCC_PLL_I2S_Configuration PLL I2S Configuration
  * @{   
  *//** @brief  Macro to configure the PLL multiplication factor.
  * @note   This function must be used only when the main PLL is disabled.
  * @param  __PLLM__ specifies the division factor for PLL VCO input clock
  *         This parameter must be a number between Min_Data = 2 and Max_Data = 63.
  * @note   You have to set the PLLM parameter correctly to ensure that the VCO input
  *         frequency ranges from 1 to 2 MHz. It is recommended to select a frequency
  *         of 2 MHz to limit PLL jitter.
  *      
  *//** @brief  Macro to configure the PLL clock source.
  * @note   This function must be used only when the main PLL is disabled.
  * @param  __PLLSOURCE__ specifies the PLL entry clock source.
  *         This parameter can be one of the following values:
  *            @arg RCC_PLLSOURCE_HSI: HSI oscillator clock selected as PLL clock entry
  *            @arg RCC_PLLSOURCE_HSE: HSE oscillator clock selected as PLL clock entry
  *      
  *//** @brief  Macros to enable or disable the main PLL.
  * @note   After enabling the main PLL, the application software should wait on 
  *         PLLRDY flag to be set indicating that PLL clock is stable and can
  *         be used as system clock source.
  * @note   The main PLL can not be disabled if it is used as system clock source
  * @note   The main PLL is disabled by hardware when entering STOP and STANDBY modes.
  *//** @defgroup RCC_PLL_Configuration PLL Configuration
  * @{   
  *//** @brief  Macros to force or release the Backup domain reset.
  * @note   This function resets the RTC peripheral (including the backup registers)
  *         and the RTC clock source selection in RCC_CSR register.
  * @note   The BKPSRAM is not affected by this reset.   
  *//**
  * @brief   Get the RTC and HSE clock divider (RTCPRE).
  * @retval Returned value can be one of the following values:
  *            @arg @ref RCC_RTCCLKSOURCE_HSE_DIVX: HSE clock divided by x selected
  *                                                 as RTC clock, where x:[2,31]
  *//** @brief Macro to get the RTC clock source.
  * @retval The clock source can be one of the following values:
  *            @arg @ref RCC_RTCCLKSOURCE_NO_CLK No clock selected as RTC clock
  *            @arg @ref RCC_RTCCLKSOURCE_LSE LSE selected as RTC clock
  *            @arg @ref RCC_RTCCLKSOURCE_LSI LSI selected as RTC clock
  *            @arg @ref RCC_RTCCLKSOURCE_HSE_DIVX HSE divided by X selected as RTC clock (X can be retrieved thanks to @ref __HAL_RCC_GET_RTC_HSE_PRESCALER()
  *//** @brief  Macros to configure the RTC clock (RTCCLK).
  * @note   As the RTC clock configuration bits are in the Backup domain and write
  *         access is denied to this domain after reset, you have to enable write
  *         access using the Power Backup Access macro before to configure
  *         the RTC clock source (to be done once after reset).    
  * @note   Once the RTC clock is configured it can't be changed unless the  
  *         Backup domain is reset using __HAL_RCC_BackupReset_RELEASE() macro, or by
  *         a Power On Reset (POR).
  * @param  __RTCCLKSource__ specifies the RTC clock source.
  *         This parameter can be one of the following values:
               @arg @ref RCC_RTCCLKSOURCE_NO_CLK:  No clock selected as RTC clock.
  *            @arg @ref RCC_RTCCLKSOURCE_LSE: LSE selected as RTC clock.
  *            @arg @ref RCC_RTCCLKSOURCE_LSI: LSI selected as RTC clock.
  *            @arg @ref RCC_RTCCLKSOURCE_HSE_DIVX: HSE clock divided by x selected
  *                                                 as RTC clock, where x:[2,31]
  * @note   If the LSE or LSI is used as RTC clock source, the RTC continues to
  *         work in STOP and STANDBY modes, and can be used as wakeup source.
  *         However, when the HSE clock is used as RTC clock source, the RTC
  *         cannot be used in STOP and STANDBY modes.    
  * @note   The maximum input clock frequency for RTC is 1MHz (when using HSE as
  *         RTC clock source).
  *//** @brief  Macros to enable or disable the RTC clock.
  * @note   These macros must be used only after the RTC clock source was selected.
  *//** @defgroup RCC_Internal_RTC_Clock_Configuration RTC Clock Configuration
  * @{   
  *//**
  * @brief  Macro to configure the External Low Speed oscillator (LSE).
  * @note   Transitions LSE Bypass to LSE On and LSE On to LSE Bypass are not supported by this macro. 
  *         User should request a transition to LSE Off first and then LSE On or LSE Bypass.  
  * @note   As the LSE is in the Backup domain and write access is denied to
  *         this domain after reset, you have to enable write access using 
  *         HAL_PWR_EnableBkUpAccess() function before to configure the LSE
  *         (to be done once after reset).  
  * @note   After enabling the LSE (RCC_LSE_ON or RCC_LSE_BYPASS), the application
  *         software should wait on LSERDY flag to be set indicating that LSE clock
  *         is stable and can be used to clock the RTC.
  * @param  __STATE__ specifies the new state of the LSE.
  *         This parameter can be one of the following values:
  *            @arg RCC_LSE_OFF: turn OFF the LSE oscillator, LSERDY flag goes low after
  *                              6 LSE oscillator clock cycles.
  *            @arg RCC_LSE_ON: turn ON the LSE oscillator.
  *            @arg RCC_LSE_BYPASS: LSE oscillator bypassed with external clock.
  *//** @defgroup RCC_LSE_Configuration LSE Configuration
  * @{   
  *//**
  * @brief  Macro to configure the External High Speed oscillator (HSE).
  * @note   Transitions HSE Bypass to HSE On and HSE On to HSE Bypass are not
  *         supported by this macro. User should request a transition to HSE Off
  *         first and then HSE On or HSE Bypass.
  * @note   After enabling the HSE (RCC_HSE_ON or RCC_HSE_Bypass), the application
  *         software should wait on HSERDY flag to be set indicating that HSE clock
  *         is stable and can be used to clock the PLL and/or system clock.
  * @note   HSE state can not be changed if it is used directly or through the
  *         PLL as system clock. In this case, you have to select another source
  *         of the system clock then change the HSE state (ex. disable it).
  * @note   The HSE is stopped by hardware when entering STOP and STANDBY modes.
  * @note   This function reset the CSSON bit, so if the clock security system(CSS)
  *         was previously enabled you have to enable it again after calling this
  *         function.
  * @param  __STATE__ specifies the new state of the HSE.
  *         This parameter can be one of the following values:
  *            @arg RCC_HSE_OFF: turn OFF the HSE oscillator, HSERDY flag goes low after
  *                              6 HSE oscillator clock cycles.
  *            @arg RCC_HSE_ON: turn ON the HSE oscillator.
  *            @arg RCC_HSE_BYPASS: HSE oscillator bypassed with external clock.
  *//** @defgroup RCC_HSE_Configuration HSE Configuration
  * @{   
  *//** @brief  Macros to enable or disable the Internal Low Speed oscillator (LSI).
  * @note   After enabling the LSI, the application software should wait on 
  *         LSIRDY flag to be set indicating that LSI clock is stable and can
  *         be used to clock the IWDG and/or the RTC.
  * @note   LSI can not be disabled if the IWDG is running.
  * @note   When the LSI is stopped, LSIRDY flag goes low after 6 LSI oscillator
  *         clock cycles. 
  *//** @defgroup RCC_LSI_Configuration LSI Configuration
  * @{   
  *//** @brief  Macro to adjust the Internal High Speed oscillator (HSI) calibration value.
  * @note   The calibration is used to compensate for the variations in voltage
  *         and temperature that influence the frequency of the internal HSI RC.
  * @param  __HSICALIBRATIONVALUE__ specifies the calibration trimming value.
  *         (default is RCC_HSICALIBRATION_DEFAULT).
  *//** @brief  Macros to enable or disable the Internal High Speed oscillator (HSI).
  * @note   The HSI is stopped by hardware when entering STOP and STANDBY modes.
  *         It is used (enabled by hardware) as system clock source after startup
  *         from Reset, wakeup from STOP and STANDBY mode, or in case of failure
  *         of the HSE used directly or indirectly as system clock (if the Clock
  *         Security System CSS is enabled).             
  * @note   HSI can not be stopped if it is used as system clock source. In this case,
  *         you have to select another source of the system clock then stop the HSI.  
  * @note   After enabling the HSI, the application software should wait on HSIRDY
  *         flag to be set indicating that HSI clock is stable and can be used as
  *         system clock source.  
  * @note   When the HSI is stopped, HSIRDY flag goes low after 6 HSI oscillator
  *         clock cycles.  
  *//** @defgroup RCC_HSI_Configuration HSI Configuration
  * @{   
  *//** @defgroup RCC_APB2_Clock_Sleep_Enable_Disable_Status APB2 Peripheral Clock Sleep Enable Disable Status
  * @brief  Get the enable or disable status of the APB2 peripheral clock during Low Power (Sleep) mode.
  * @note   Peripheral clock gating in SLEEP mode can be used to further reduce
  *         power consumption.
  * @note   After wakeup from SLEEP mode, the peripheral clock is enabled again.
  * @note   By default, all peripheral clocks are enabled during SLEEP mode.
  * @{
  *//** @defgroup RCC_APB1_Clock_Sleep_Enable_Disable_Status APB1 Peripheral Clock Sleep Enable Disable Status
  * @brief  Get the enable or disable status of the APB1 peripheral clock during Low Power (Sleep) mode.
  * @note   Peripheral clock gating in SLEEP mode can be used to further reduce
  *         power consumption.
  * @note   After wakeup from SLEEP mode, the peripheral clock is enabled again.
  * @note   By default, all peripheral clocks are enabled during SLEEP mode.
  * @{
  *//** @defgroup RCC_AHB1_Clock_Sleep_Enable_Disable_Status AHB1 Peripheral Clock Sleep Enable Disable Status
  * @brief  Get the enable or disable status of the AHB1 peripheral clock during Low Power (Sleep) mode.
  * @note   Peripheral clock gating in SLEEP mode can be used to further reduce
  *         power consumption.
  * @note   After wakeup from SLEEP mode, the peripheral clock is enabled again.
  * @note   By default, all peripheral clocks are enabled during SLEEP mode.
  * @{
  *//** @defgroup RCC_Peripheral_Clock_Sleep_Enable_Disable RCC Peripheral Clock Sleep Enable Disable
  * @note   Peripheral clock gating in SLEEP mode can be used to further reduce
  *         power consumption.
  * @note   After wakeup from SLEEP mode, the peripheral clock is enabled again.
  * @note   By default, all peripheral clocks are enabled during SLEEP mode.
  * @{
  *//** @defgroup RCC_APB2_Force_Release_Reset APB2 Force Release Reset 
  * @brief  Force or release APB2 peripheral reset.
  * @{
  *//** @defgroup RCC_APB1_Force_Release_Reset APB1 Force Release Reset 
  * @brief  Force or release APB1 peripheral reset.
  * @{
  *//** @defgroup RCC_Peripheral_Clock_Force_Release RCC Peripheral Clock Force Release
  * @brief  Force or release AHB peripheral reset.
  * @{
  *//** @defgroup RCC_APB2_Clock_Enable_Disable_Status APB2 Peripheral Clock Enable Disable Status
  * @brief  EGet the enable or disable status of the APB2 peripheral clock.
  * @note   After reset, the peripheral clock (used for registers read/write access)
  *         is disabled and the application software has to enable this clock before
  *         using it.
  * @{
  *//** @defgroup RCC_APB1_Clock_Enable_Disable_Status APB1 Peripheral Clock Enable Disable  Status
  * @brief  Get the enable or disable status of the APB1 peripheral clock.
  * @note   After reset, the peripheral clock (used for registers read/write access)
  *         is disabled and the application software has to enable this clock before
  *         using it.
  * @{
  *//** @defgroup RCC_AHB1_Peripheral_Clock_Enable_Disable_Status AHB1 Peripheral Clock Enable Disable Status
  * @brief  Get the enable or disable status of the AHB1 peripheral clock.
  * @note   After reset, the peripheral clock (used for registers read/write access)
  *         is disabled and the application software has to enable this clock before
  *         using it.
  * @{
  *//** @defgroup RCC_APB2_Clock_Enable_Disable APB2 Peripheral Clock Enable Disable                                      
  * @brief  Enable or disable the High Speed APB (APB2) peripheral clock.
  * @note   After reset, the peripheral clock (used for registers read/write access)
  *         is disabled and the application software has to enable this clock before 
  *         using it.
  * @{
  *//** @defgroup RCC_APB1_Clock_Enable_Disable APB1 Peripheral Clock Enable Disable
  * @brief  Enable or disable the Low Speed APB (APB1) peripheral clock.
  * @note   After reset, the peripheral clock (used for registers read/write access)
  *         is disabled and the application software has to enable this clock before
  *         using it.
  * @{
  *//** @defgroup RCC_AHB1_Clock_Enable_Disable AHB1 Peripheral Clock Enable Disable
  * @brief  Enable or disable the AHB1 peripheral clock.
  * @note   After reset, the peripheral clock (used for registers read/write access)
  *         is disabled and the application software has to enable this clock before 
  *         using it.   
  * @{
  *//** @defgroup RCC_Exported_Macros RCC Exported Macros
  * @{
  *//** @defgroup RCC_LSEDrive_Configuration RCC LSE Drive configurations
  * @{
  *//* Flags in the CSR register *//* Flags in the BDCR register *//* Flags in the CR register *//** @defgroup RCC_Flag RCC Flags
  *        Elements values convention: 0XXYYYYYb
  *           - YYYYY  : Flag position in the register
  *           - 0XX  : Register index
  *                 - 01: CR register
  *                 - 10: BDCR register
  *                 - 11: CSR register
  * @{
  *//** @defgroup RCC_Interrupt RCC Interrupt 
  * @{
  *//** @defgroup RCC_MCOx_Clock_Prescaler RCC MCO1 Clock Prescaler
  * @{
  *//** @defgroup RCC_MCO2_Clock_Source RCC MCO2 Clock Source
  * @{
  *//** @defgroup RCC_MCO1_Clock_Source RCC MCO1 Clock Source
  * @{
  *//** @defgroup RCC_MCO_Index RCC MCO Index
  * @{
  *//** @defgroup RCC_RTC_Clock_Source RCC RTC Clock Source
  * @{
  *//** @defgroup RCC_APB1_APB2_Clock_Source RCC APB1/APB2 Clock Source
  * @{
  *//** @defgroup RCC_AHB_Clock_Source RCC AHB Clock Source
  * @{
  *//*!< HSE used as system clock *//*!< HSI used as system clock *//** @defgroup RCC_System_Clock_Source_Status System Clock Source Status
  * @{
  *//** @defgroup RCC_System_Clock_Source RCC System Clock Source
  * @{
  *//** @defgroup RCC_System_Clock_Type RCC System Clock Type
  * @{
  *//** @defgroup RCC_PLL_Clock_Source PLL Clock Source
  * @{
  *//** @defgroup RCC_PLLP_Clock_Divider PLLP Clock Divider
  * @{
  *//** @defgroup RCC_PLL_Config RCC PLL Config
  * @{
  *//** @defgroup RCC_LSI_Config RCC LSI Config
  * @{
  *//* Default HSI calibration trimming value *//** @defgroup RCC_HSI_Config RCC HSI Config
  * @{
  *//** @defgroup RCC_LSE_Config RCC LSE Config
  * @{
  *//** @defgroup RCC_HSE_Config RCC HSE Config
  * @{
  *//** @defgroup RCC_Oscillator_Type Oscillator Type
  * @{
  *//** @defgroup RCC_Exported_Constants RCC Exported Constants
  * @{
  *//*!< The APB2 clock (PCLK2) divider. This clock is derived from the AHB clock (HCLK).
                                       This parameter can be a value of @ref RCC_APB1_APB2_Clock_Source *//*!< The APB1 clock (PCLK1) divider. This clock is derived from the AHB clock (HCLK).
                                       This parameter can be a value of @ref RCC_APB1_APB2_Clock_Source *//*!< The AHB clock (HCLK) divider. This clock is derived from the system clock (SYSCLK).
                                       This parameter can be a value of @ref RCC_AHB_Clock_Source       *//*!< The clock source (SYSCLKS) used as system clock.
                                       This parameter can be a value of @ref RCC_System_Clock_Source    *//*!< The clock to be configured.
                                       This parameter can be a value of @ref RCC_System_Clock_Type *//**
  * @brief  RCC System, AHB and APB buses clock configuration structure definition  
  *//*!< PLL structure parameters                                                    *//*!< The new state of the LSI.
                                      This parameter can be a value of @ref RCC_LSI_Config                        *//*!< The HSI calibration trimming value (default is RCC_HSICALIBRATION_DEFAULT).
                                       This parameter must be a number between Min_Data = 0x00 and Max_Data = 0x1F *//*!< The new state of the HSI.
                                      This parameter can be a value of @ref RCC_HSI_Config                        *//*!< The new state of the LSE.
                                      This parameter can be a value of @ref RCC_LSE_Config                        *//*!< The new state of the HSE.
                                      This parameter can be a value of @ref RCC_HSE_Config                        *//*!< The oscillators to be configured.
                                      This parameter can be a value of @ref RCC_Oscillator_Type                   *//**
  * @brief  RCC Internal/External Oscillator (HSE, HSI, LSE and LSI) configuration structure definition  
  *//** @defgroup RCC_Exported_Types RCC Exported Types
  * @{
  *//** @addtogroup RCC
  * @{
  *//* (include on top of file since RCC structures are defined in extended file) *//* Include RCC HAL Extended module *//**
  ******************************************************************************
  * @file    stm32f7xx_hal_rcc.h
  * @author  MCD Application Team
  * @brief   Header file of RCC HAL module.
  ******************************************************************************
  * @attention
  *
  * Copyright (c) 2017 STMicroelectronics.
  * All rights reserved.
  *
  * This software is licensed under terms that can be found in the LICENSE file in
  * the root directory of this software component.
  * If no LICENSE file comes with this software, it is provided AS-IS.
  ******************************************************************************
  */RCC_ClkInitStructpFLatencyRCC_OscInitStructRCC_MCOxRCC_MCOSourceRCC_MCODivFLatencyIS_GPIO_AF(AF)(((AF) == GPIO_AF0_RTC_50Hz) || ((AF) == GPIO_AF1_TIM1) || ((AF) == GPIO_AF0_SWJ) || ((AF) == GPIO_AF0_TRACE) || ((AF) == GPIO_AF0_MCO) || ((AF) == GPIO_AF1_TIM2) || ((AF) == GPIO_AF2_TIM3) || ((AF) == GPIO_AF2_TIM4) || ((AF) == GPIO_AF2_TIM5) || ((AF) == GPIO_AF3_TIM8) || ((AF) == GPIO_AF3_TIM9) || ((AF) == GPIO_AF3_TIM10) || ((AF) == GPIO_AF3_TIM11) || ((AF) == GPIO_AF3_LPTIM1) || ((AF) == GPIO_AF3_CEC) || ((AF) == GPIO_AF4_CEC) || ((AF) == GPIO_AF4_I2C1) || ((AF) == GPIO_AF4_I2C2) || ((AF) == GPIO_AF4_I2C3) || ((AF) == GPIO_AF4_I2C4) || ((AF) == GPIO_AF5_SPI1) || ((AF) == GPIO_AF5_SPI2) || ((AF) == GPIO_AF5_SPI3) || ((AF) == GPIO_AF5_SPI4) || ((AF) == GPIO_AF5_SPI5) || ((AF) == GPIO_AF5_SPI6) || ((AF) == GPIO_AF6_SPI3) || ((AF) == GPIO_AF6_SAI1) || ((AF) == GPIO_AF7_SPI3) || ((AF) == GPIO_AF7_SPI2) || ((AF) == GPIO_AF7_USART1) || ((AF) == GPIO_AF7_USART2) || ((AF) == GPIO_AF7_USART3) || ((AF) == GPIO_AF7_UART5) || ((AF) == GPIO_AF7_SPDIFRX) || ((AF) == GPIO_AF8_SPDIFRX) || ((AF) == GPIO_AF8_SAI2) || ((AF) == GPIO_AF8_USART6) || ((AF) == GPIO_AF8_UART4) || ((AF) == GPIO_AF8_UART5) || ((AF) == GPIO_AF8_UART7) || ((AF) == GPIO_AF8_UART8) || ((AF) == GPIO_AF9_CAN1) || ((AF) == GPIO_AF9_CAN2) || ((AF) == GPIO_AF9_TIM12) || ((AF) == GPIO_AF9_TIM13) || ((AF) == GPIO_AF9_TIM14) || ((AF) == GPIO_AF9_QUADSPI) || ((AF) == GPIO_AF9_LTDC) || ((AF) == GPIO_AF10_OTG_FS) || ((AF) == GPIO_AF10_OTG_HS) || ((AF) == GPIO_AF10_SAI2) || ((AF) == GPIO_AF10_QUADSPI) || ((AF) == GPIO_AF11_ETH) || ((AF) == GPIO_AF10_SDMMC2) || ((AF) == GPIO_AF11_SDMMC2) || ((AF) == GPIO_AF11_CAN3) || ((AF) == GPIO_AF12_OTG_HS_FS) || ((AF) == GPIO_AF12_SDMMC1) || ((AF) == GPIO_AF12_FMC) || ((AF) == GPIO_AF15_EVENTOUT) || ((AF) == GPIO_AF13_DCMI) || ((AF) == GPIO_AF14_LTDC) || ((AF) == GPIO_AF13_DSI))IS_GPIO_PIN_AVAILABLE(__INSTANCE__,__PIN__)((((__INSTANCE__) == GPIOA) && (((__PIN__) & (GPIOA_PIN_AVAILABLE)) != 0) && (((__PIN__) | (GPIOA_PIN_AVAILABLE)) == (GPIOA_PIN_AVAILABLE))) || (((__INSTANCE__) == GPIOB) && (((__PIN__) & (GPIOB_PIN_AVAILABLE)) != 0) && (((__PIN__) | (GPIOB_PIN_AVAILABLE)) == (GPIOB_PIN_AVAILABLE))) || (((__INSTANCE__) == GPIOC) && (((__PIN__) & (GPIOC_PIN_AVAILABLE)) != 0) && (((__PIN__) | (GPIOC_PIN_AVAILABLE)) == (GPIOC_PIN_AVAILABLE))) || (((__INSTANCE__) == GPIOD) && (((__PIN__) & (GPIOD_PIN_AVAILABLE)) != 0) && (((__PIN__) | (GPIOD_PIN_AVAILABLE)) == (GPIOD_PIN_AVAILABLE))) || (((__INSTANCE__) == GPIOE) && (((__PIN__) & (GPIOE_PIN_AVAILABLE)) != 0) && (((__PIN__) | (GPIOE_PIN_AVAILABLE)) == (GPIOE_PIN_AVAILABLE))) || (((__INSTANCE__) == GPIOF) && (((__PIN__) & (GPIOF_PIN_AVAILABLE)) != 0) && (((__PIN__) | (GPIOF_PIN_AVAILABLE)) == (GPIOF_PIN_AVAILABLE))) || (((__INSTANCE__) == GPIOG) && (((__PIN__) & (GPIOG_PIN_AVAILABLE)) != 0) && (((__PIN__) | (GPIOG_PIN_AVAILABLE)) == (GPIOG_PIN_AVAILABLE))) || (((__INSTANCE__) == GPIOI) && (((__PIN__) & (GPIOI_PIN_AVAILABLE)) != 0) && (((__PIN__) | (GPIOI_PIN_AVAILABLE)) == (GPIOI_PIN_AVAILABLE))) || (((__INSTANCE__) == GPIOJ) && (((__PIN__) & (GPIOJ_PIN_AVAILABLE)) != 0) && (((__PIN__) | (GPIOJ_PIN_AVAILABLE)) == (GPIOJ_PIN_AVAILABLE))) || (((__INSTANCE__) == GPIOK) && (((__PIN__) & (GPIOK_PIN_AVAILABLE)) != 0) && (((__PIN__) | (GPIOK_PIN_AVAILABLE)) == (GPIOK_PIN_AVAILABLE))) || (((__INSTANCE__) == GPIOH) && (((__PIN__) & (GPIOH_PIN_AVAILABLE)) != 0) && (((__PIN__) | (GPIOH_PIN_AVAILABLE)) == (GPIOH_PIN_AVAILABLE))))GPIO_GET_INDEX(__GPIOx__)(uint8_t)(((__GPIOx__) == (GPIOA))? 0U : ((__GPIOx__) == (GPIOB))? 1U : ((__GPIOx__) == (GPIOC))? 2U : ((__GPIOx__) == (GPIOD))? 3U : ((__GPIOx__) == (GPIOE))? 4U : ((__GPIOx__) == (GPIOF))? 5U : ((__GPIOx__) == (GPIOG))? 6U : ((__GPIOx__) == (GPIOH))? 7U : ((__GPIOx__) == (GPIOI))? 8U : ((__GPIOx__) == (GPIOJ))? 9U : 10U)GPIOK_PIN_AVAILABLE(GPIO_PIN_0 | GPIO_PIN_1 | GPIO_PIN_2 | GPIO_PIN_3 | GPIO_PIN_4 | GPIO_PIN_5 | GPIO_PIN_6 | GPIO_PIN_7)GPIOH_PIN_AVAILABLEGPIO_PIN_AllGPIOJ_PIN_AVAILABLEGPIOI_PIN_AVAILABLEGPIOG_PIN_AVAILABLEGPIOF_PIN_AVAILABLEGPIOE_PIN_AVAILABLEGPIOD_PIN_AVAILABLEGPIOC_PIN_AVAILABLEGPIOB_PIN_AVAILABLEGPIOA_PIN_AVAILABLEGPIO_AF15_EVENTOUTGPIO_AF14_LTDCGPIO_AF13_LTDCGPIO_AF13_DSIGPIO_AF13_DCMIGPIO_AF12_UART7((uint8_t)0xCU)GPIO_AF12_MDIOSGPIO_AF12_OTG_HS_FSGPIO_AF11_I2C4GPIO_AF11_CAN3GPIO_AF11_ETHGPIO_AF10_LTDCGPIO_AF10_DFSDM1GPIO_AF10_SAI2((uint8_t)0xAU)GPIO_AF10_QUADSPIGPIO_AF10_OTG_HSGPIO_AF10_OTG_FSGPIO_AF9_FMCGPIO_AF9_LTDCGPIO_AF9_QUADSPIGPIO_AF9_TIM14GPIO_AF9_TIM13GPIO_AF9_TIM12GPIO_AF9_CAN2GPIO_AF9_CAN1GPIO_AF8_SPI6GPIO_AF8_SAI2GPIO_AF8_SPDIFRXGPIO_AF8_UART8GPIO_AF8_UART7GPIO_AF8_USART6GPIO_AF8_UART5GPIO_AF8_UART4GPIO_AF7_DFSDM1GPIO_AF7_SPI6GPIO_AF7_SPI3GPIO_AF7_SPI2GPIO_AF7_SPDIFRXGPIO_AF7_UART5GPIO_AF7_USART3GPIO_AF7_USART2GPIO_AF6_UART4GPIO_AF6_SAI1GPIO_AF6_SPI3GPIO_AF5_SPI6GPIO_AF5_SPI5GPIO_AF5_SPI4GPIO_AF5_SPI3GPIO_AF5_SPI2GPIO_AF5_SPI1GPIO_AF4_USART1GPIO_AF4_CECGPIO_AF4_I2C4GPIO_AF4_I2C3GPIO_AF4_I2C2GPIO_AF3_DFSDM1((uint8_t)0x03U)GPIO_AF3_CECGPIO_AF3_LPTIM1GPIO_AF3_TIM11GPIO_AF3_TIM10GPIO_AF3_TIM9GPIO_AF3_TIM8GPIO_AF2_TIM5GPIO_AF2_TIM4GPIO_AF2_TIM3GPIO_AF1_I2C4GPIO_AF1_UART5GPIO_AF1_TIM2GPIO_AF1_TIM1GPIO_AF0_TRACEGPIO_AF0_SWJGPIO_AF0_MCOGPIO_AF0_RTC_50Hz__STM32F7xx_HAL_GPIO_EX_Hdefined (STM32F765xx) || defined(STM32F767xx) || defined(STM32F769xx) || defined(STM32F777xx) || defined(STM32F779xx)defined(STM32F746xx) || defined(STM32F756xx) || defined(STM32F767xx) || defined(STM32F769xx) || defined(STM32F777xx) || defined(STM32F779xx) || defined(STM32F750xx)defined(STM32F746xx) || defined(STM32F756xx) || defined(STM32F765xx) || defined(STM32F765xx) || defined(STM32F767xx) || defined(STM32F769xx) || defined(STM32F777xx) || defined(STM32F779xx) || defined(STM32F750xx)defined(STM32F765xx) || defined (STM32F767xx) || defined (STM32F769xx) || defined (STM32F777xx) || defined (STM32F779xx)defined(STM32F722xx) || defined(STM32F723xx) || defined(STM32F732xx) || defined(STM32F733xx) || defined(STM32F730xx)defined(STM32F767xx) || defined(STM32F777xx)defined(STM32F769xx) || defined(STM32F779xx)/* __STM32F7xx_HAL_GPIO_EX_H *//** @defgroup GPIOEx_Private_Functions GPIO Private Functions
  * @{
  *//* STM32F756xx || STM32F746xx || STM32F750xx *//** @defgroup GPIOEx_IS_Alternat_function_selection GPIO Check Alternate Function
  * @{
  *//** @defgroup GPIOEx_Get_Port_Index GPIO Get Port Index
  * @{
  *//** @defgroup GPIOEx_Private_Macros GPIO Private Macros
  * @{
  *//* Defines the available pins per GPIOs *//**
  * @brief   GPIO pin available on the platform
  *//** @defgroup GPIOEx_Private_Constants GPIO Private Constants
  * @{
  *//** @defgroup GPIOEx_Exported_Functions GPIO Exported Functions
  * @{
  *//** @defgroup GPIOEx_Exported_Macros GPIO Exported Macros
  * @{
  *//* EVENTOUT Alternate Function mapping *//**
  * @brief   AF 15 selection
  *//* RNG Alternate Function mapping *//**
  * @brief   AF 13 selection
  *//* SDMMC1 Alternate Function mapping                   *//* OTG HS configured in FS, Alternate Function mapping *//* FMC Alternate Function mapping                      *//**
  * @brief   AF 12 selection
  *//* SDMMC2 Alternate Function mapping   *//**
  * @brief   AF 11 selection
  *//* SDMMC2 Alternate Function mapping *//* SAI2 Alternate Function mapping *//* QUADSPI Alternate Function mapping *//* OTG_HS Alternate Function mapping *//* OTG_FS Alternate Function mapping *//**
  * @brief   AF 10 selection
  *//* TIM14 Alternate Function mapping   *//* TIM13 Alternate Function mapping   *//* TIM12 Alternate Function mapping   *//* CAN1 Alternate Function mapping    *//**
  * @brief   AF 9 selection
  *//* SAI2 Alternate Function mapping   *//* UART8 Alternate Function mapping  *//* UART7 Alternate Function mapping  *//* USART6 Alternate Function mapping *//* UART5 Alternate Function mapping  *//* UART4 Alternate Function mapping  *//**
  * @brief   AF 8 selection
  *//* SPI3 Alternate Function mapping       *//* SPI2 Alternate Function mapping       *//* UART5 Alternate Function mapping      *//* USART3 Alternate Function mapping     *//* USART2 Alternate Function mapping     *//* USART1 Alternate Function mapping     *//**
  * @brief   AF 7 selection
  *//* SAI1 Alternate Function mapping       *//* SPI3/I2S3 Alternate Function mapping  *//**
  * @brief   AF 6 selection
  *//* SPI5 Alternate Function mapping        *//* SPI4 Alternate Function mapping        *//* SPI3/I2S3 Alternate Function mapping   *//* SPI2/I2S2 Alternate Function mapping   *//* SPI1 Alternate Function mapping        *//**
  * @brief   AF 5 selection
  *//* I2C3 Alternate Function mapping *//* I2C2 Alternate Function mapping *//* I2C1 Alternate Function mapping *//**
  * @brief   AF 4 selection
  *//* LPTIM1 Alternate Function mapping *//* TIM11 Alternate Function mapping *//* TIM10 Alternate Function mapping *//* TIM9 Alternate Function mapping  *//* TIM8 Alternate Function mapping  *//**
  * @brief   AF 3 selection
  *//* TIM5 Alternate Function mapping *//* TIM4 Alternate Function mapping *//* TIM3 Alternate Function mapping *//**
  * @brief   AF 2 selection
  *//* TIM2 Alternate Function mapping *//* TIM1 Alternate Function mapping *//**
  * @brief   AF 1 selection
  *//* TRACE Alternate Function mapping                          *//* SWJ (SWD and JTAG) Alternate Function mapping             *//* MCO (MCO1 and MCO2) Alternate Function mapping            *//* RTC_50Hz Alternate Function mapping                       *//**
 * @brief   AF 0 selection
 *//*---------------------------- STM32F72xxx/STM32F73xxx -----------------------*//* STM32F745xx || STM32F746xx || STM32F756xx || STM32F765xx || STM32F767xx || STM32F769xx || STM32F777xx || STM32F779xx *//* LCD-TFT Alternate Function mapping *//**
  * @brief   AF 14 selection
  *//* LTDC Alternate Function mapping *//* DSI Alternate Function mapping  *//* DCMI Alternate Function mapping *//* UART7 Alternate Function mapping                     *//* SDMMC1 Alternate Function mapping                    *//* I2C4 Alternate Function mapping     *//* CAN3 Alternate Function mapping     *//* ETHERNET Alternate Function mapping *//* DFSDM1 Alternate Function mapping  *//* FMC Alternate Function mapping     *//* CAN2 Alternate Function mapping    *//* SPI6 Alternate Function mapping   *//* SPIDIF-RX Alternate Function mapping *//* DFSDM1 Alternate Function mapping      *//* SPI6 Alternate Function mapping       *//* SPDIF-RX Alternate Function mapping   *//* DFSDM1 Alternate Function mapping     *//* UART4 Alternate Function mapping     *//* SPI6 Alternate Function mapping        *//* USART1 Alternate Function mapping *//* CEC Alternate Function mapping *//* I2C4 Alternate Function mapping *//* DFSDM1 Alternate Function mapping *//* I2C4 Alternate Function mapping  *//* UART5 Alternate Function mapping *//**
  * @brief   AF 0 selection
  *//*--------------- STM32F74xxx/STM32F75xxx/STM32F76xxx/STM32F77xxx -------------*//** @defgroup GPIO_Alternate_function_selection GPIO Alternate Function Selection
  * @{
  *//** @defgroup GPIOEx_Exported_Constants GPIO Exported Constants
  * @{
  *//** @defgroup GPIOEx GPIOEx
  * @{
  *//**
  ******************************************************************************
  * @file    stm32f7xx_hal_gpio_ex.h
  * @author  MCD Application Team
  * @brief   Header file of GPIO HAL Extension module.
  ******************************************************************************
  * @attention
  *
  * Copyright (c) 2017 STMicroelectronics.
  * All rights reserved.
  *
  * This software is licensed under terms that can be found in the LICENSE file
  * in the root directory of this software component.
  * If no LICENSE file comes with this software, it is provided AS-IS.
  *
  ******************************************************************************
  */"stm32f7xx_hal_gpio_ex.h"HAL_GPIO_EXTI_CallbackHAL_GPIO_EXTI_IRQHandlerHAL_GPIO_LockPinHAL_GPIO_TogglePinHAL_GPIO_WritePinHAL_GPIO_ReadPinHAL_GPIO_DeInitHAL_GPIO_InitGPIO_PinStateGPIO_InitTypeDefAlternateSpeedPullPinIS_GPIO_PULL(PULL)(((PULL) == GPIO_NOPULL) || ((PULL) == GPIO_PULLUP) || ((PULL) == GPIO_PULLDOWN))IS_GPIO_SPEED(SPEED)(((SPEED) == GPIO_SPEED_LOW) || ((SPEED) == GPIO_SPEED_MEDIUM) || ((SPEED) == GPIO_SPEED_FAST) || ((SPEED) == GPIO_SPEED_HIGH))IS_GPIO_MODE(MODE)(((MODE) == GPIO_MODE_INPUT) || ((MODE) == GPIO_MODE_OUTPUT_PP) || ((MODE) == GPIO_MODE_OUTPUT_OD) || ((MODE) == GPIO_MODE_AF_PP) || ((MODE) == GPIO_MODE_AF_OD) || ((MODE) == GPIO_MODE_IT_RISING) || ((MODE) == GPIO_MODE_IT_FALLING) || ((MODE) == GPIO_MODE_IT_RISING_FALLING) || ((MODE) == GPIO_MODE_EVT_RISING) || ((MODE) == GPIO_MODE_EVT_FALLING) || ((MODE) == GPIO_MODE_EVT_RISING_FALLING) || ((MODE) == GPIO_MODE_ANALOG))IS_GPIO_PIN(__PIN__)((((uint32_t)(__PIN__) & GPIO_PIN_MASK) != 0x00U))IS_GPIO_PIN_ACTION(ACTION)(((ACTION) == GPIO_PIN_RESET) || ((ACTION) == GPIO_PIN_SET))TRIGGER_FALLING(0x2UL << TRIGGER_MODE_Pos)TRIGGER_RISING(0x1UL << TRIGGER_MODE_Pos)TRIGGER_MODE(0x7UL << TRIGGER_MODE_Pos)TRIGGER_MODE_PosEXTI_EVT(0x2UL << EXTI_MODE_Pos)EXTI_IT(0x1UL << EXTI_MODE_Pos)EXTI_MODE(0x3UL << EXTI_MODE_Pos)EXTI_MODE_PosOUTPUT_OD(0x1UL << OUTPUT_TYPE_Pos)OUTPUT_PP(0x0UL << OUTPUT_TYPE_Pos)OUTPUT_TYPEOUTPUT_TYPE_PosMODE_ANALOG(0x3UL << GPIO_MODE_Pos)MODE_AF(0x2UL << GPIO_MODE_Pos)MODE_OUTPUT(0x1UL << GPIO_MODE_Pos)MODE_INPUT(0x0UL << GPIO_MODE_Pos)GPIO_MODEGPIO_MODE_Pos__HAL_GPIO_EXTI_GENERATE_SWIT(__EXTI_LINE__)(EXTI->SWIER |= (__EXTI_LINE__))__HAL_GPIO_EXTI_CLEAR_IT(__EXTI_LINE__)(EXTI->PR = (__EXTI_LINE__))__HAL_GPIO_EXTI_GET_IT(__EXTI_LINE__)(EXTI->PR & (__EXTI_LINE__))__HAL_GPIO_EXTI_CLEAR_FLAG(__EXTI_LINE__)__HAL_GPIO_EXTI_GET_FLAG(__EXTI_LINE__)GPIO_PULLDOWNGPIO_MODE_EVT_RISING_FALLING(MODE_INPUT | EXTI_EVT | TRIGGER_RISING | TRIGGER_FALLING)GPIO_MODE_EVT_FALLING(MODE_INPUT | EXTI_EVT | TRIGGER_FALLING)GPIO_MODE_EVT_RISING(MODE_INPUT | EXTI_EVT | TRIGGER_RISING)GPIO_MODE_IT_RISING_FALLING(MODE_INPUT | EXTI_IT | TRIGGER_RISING | TRIGGER_FALLING)(MODE_INPUT | EXTI_IT | TRIGGER_FALLING)(MODE_INPUT | EXTI_IT | TRIGGER_RISING)GPIO_MODE_ANALOG(MODE_AF | OUTPUT_OD)(MODE_AF | OUTPUT_PP)GPIO_MODE_OUTPUT_OD(MODE_OUTPUT | OUTPUT_OD)(MODE_OUTPUT | OUTPUT_PP)GPIO_MODE_INPUTGPIO_PIN_MASK((uint32_t)0x0000FFFFU)__STM32F7xx_HAL_GPIO_H/* __STM32F7xx_HAL_GPIO_H *//** @defgroup GPIO_Private_Functions GPIO Private Functions
  * @{
  *//** @defgroup GPIO_Private_Macros GPIO Private Macros
  * @{
  *//** @defgroup GPIO_Private_Constants GPIO Private Constants
  * @{
  *//* IO operation functions *****************************************************//** @addtogroup GPIO_Exported_Functions_Group2
  * @{
  *//* Initialization and de-initialization functions *****************************//** @addtogroup GPIO_Exported_Functions_Group1
  * @{
  *//** @addtogroup GPIO_Exported_Functions
  * @{
  *//* Include GPIO HAL Extension module *//**
  * @brief  Generates a Software interrupt on selected EXTI line.
  * @param  __EXTI_LINE__ specifies the EXTI line to check.
  *          This parameter can be GPIO_PIN_x where x can be(0..15)
  * @retval None
  *//**
  * @brief  Clears the EXTI's line pending bits.
  * @param  __EXTI_LINE__ specifies the EXTI lines to clear.
  *          This parameter can be any combination of GPIO_PIN_x where x can be (0..15)
  * @retval None
  *//**
  * @brief  Checks whether the specified EXTI line is asserted or not.
  * @param  __EXTI_LINE__ specifies the EXTI line to check.
  *          This parameter can be GPIO_PIN_x where x can be(0..15)
  * @retval The new state of __EXTI_LINE__ (SET or RESET).
  *//**
  * @brief  Clears the EXTI's line pending flags.
  * @param  __EXTI_LINE__ specifies the EXTI lines flags to clear.
  *         This parameter can be any combination of GPIO_PIN_x where x can be (0..15)
  * @retval None
  *//**
  * @brief  Checks whether the specified EXTI line flag is set or not.
  * @param  __EXTI_LINE__ specifies the EXTI line flag to check.
  *         This parameter can be GPIO_PIN_x where x can be(0..15)
  * @retval The new state of __EXTI_LINE__ (SET or RESET).
  *//** @defgroup GPIO_Exported_Macros GPIO Exported Macros
  * @{
  *//*!< Pull-down activation                *//*!< Pull-up activation                  *//*!< No Pull-up or Pull-down activation  *//** @defgroup GPIO_pull_define GPIO pull define
  * @brief GPIO Pull-Up or Pull-Down Activation
  * @{
  *//*!< High speed    *//*!< Fast speed    *//*!< Medium speed  *//*!< Low speed     *//** @defgroup GPIO_speed_define  GPIO speed define
  * @brief GPIO Output Maximum frequency
  * @{
  *//*!< External Event Mode with Rising/Falling edge trigger detection     *//*!< External Event Mode with Falling edge trigger detection            *//*!< External Event Mode with Rising edge trigger detection             *//*!< External Interrupt Mode with Rising/Falling edge trigger detection  *//*!< External Interrupt Mode with Falling edge trigger detection         *//*!< External Interrupt Mode with Rising edge trigger detection          *//*!< Analog Mode  *//*!< Alternate Function Open Drain Mode    *//*!< Alternate Function Push Pull Mode     *//*!< Output Open Drain Mode                *//*!< Output Push Pull Mode                 *//*!< Input Floating Mode                   *//** @defgroup GPIO_mode_define GPIO mode define
  * @brief GPIO Configuration Mode
  *        Elements values convention: 0x00WX00YZ
  *           - W  : EXTI trigger detection on 3 bits
  *           - X  : EXTI mode (IT or Event) on 2 bits
  *           - Y  : Output type (Push Pull or Open Drain) on 1 bit
  *           - Z  : GPIO mode (Input, Output, Alternate or Analog) on 2 bits
  * @{
  *//* PIN mask for assert test *//* All pins selected *//* Pin 15 selected   *//* Pin 14 selected   *//* Pin 13 selected   *//* Pin 12 selected   *//* Pin 11 selected   *//* Pin 10 selected   *//* Pin 9 selected    *//* Pin 8 selected    *//* Pin 7 selected    *//* Pin 6 selected    *//* Pin 5 selected    *//* Pin 4 selected    *//* Pin 3 selected    *//* Pin 2 selected    *//* Pin 1 selected    *//* Pin 0 selected    *//** @defgroup GPIO_pins_define GPIO pins define
  * @{
  *//** @defgroup GPIO_Exported_Constants GPIO Exported Constants
  * @{
  *//**
  * @brief  GPIO Bit SET and Bit RESET enumeration
  *//*!< Peripheral to be connected to the selected pins.
                            This parameter can be a value of @ref GPIO_Alternate_function_selection *//*!< Specifies the speed for the selected pins.
                           This parameter can be a value of @ref GPIO_speed_define *//*!< Specifies the Pull-up or Pull-Down activation for the selected pins.
                           This parameter can be a value of @ref GPIO_pull_define *//*!< Specifies the operating mode for the selected pins.
                           This parameter can be a value of @ref GPIO_mode_define *//*!< Specifies the GPIO pins to be configured.
                           This parameter can be any value of @ref GPIO_pins_define *//**
  * @brief GPIO Init structure definition
  *//** @defgroup GPIO_Exported_Types GPIO Exported Types
  * @{
  *//** @addtogroup GPIO
  * @{
  *//**
  ******************************************************************************
  * @file    stm32f7xx_hal_gpio.h
  * @author  MCD Application Team
  * @brief   Header file of GPIO HAL module.
  ******************************************************************************
  * @attention
  *
  * Copyright (c) 2017 STMicroelectronics.
  * All rights reserved.
  *
  * This software is licensed under terms that can be found in the LICENSE file
  * in the root directory of this software component.
  * If no LICENSE file comes with this software, it is provided AS-IS.
  *
  ******************************************************************************
  */GPIO_PinGPIOxGPIO_InitHAL_DMAEx_ChangeMemoryHAL_DMAEx_MultiBufferStart_ITHAL_DMAEx_MultiBufferStartHAL_DMA_MemoryTypeDefMEMORY0MEMORY1IS_DMA_CHANNEL(CHANNEL)(((CHANNEL) == DMA_CHANNEL_0) || ((CHANNEL) == DMA_CHANNEL_1) || ((CHANNEL) == DMA_CHANNEL_2) || ((CHANNEL) == DMA_CHANNEL_3) || ((CHANNEL) == DMA_CHANNEL_4) || ((CHANNEL) == DMA_CHANNEL_5) || ((CHANNEL) == DMA_CHANNEL_6) || ((CHANNEL) == DMA_CHANNEL_7) || ((CHANNEL) == DMA_CHANNEL_8) || ((CHANNEL) == DMA_CHANNEL_9) || ((CHANNEL) == DMA_CHANNEL_10) || ((CHANNEL) == DMA_CHANNEL_11) || ((CHANNEL) == DMA_CHANNEL_12) || ((CHANNEL) == DMA_CHANNEL_13) || ((CHANNEL) == DMA_CHANNEL_14) || ((CHANNEL) == DMA_CHANNEL_15))DMA_CHANNEL_150x1E000000UDMA_CHANNEL_140x1C000000UDMA_CHANNEL_130x1A000000UDMA_CHANNEL_120x18000000U0x16000000UDMA_CHANNEL_100x14000000UDMA_CHANNEL_90x12000000UDMA_CHANNEL_8DMA_CHANNEL_70x0E000000UDMA_CHANNEL_60x0C000000UDMA_CHANNEL_50x0A000000UDMA_CHANNEL_30x06000000UDMA_CHANNEL_2DMA_CHANNEL_1__STM32F7xx_HAL_DMA_EX_H/* __STM32F7xx_HAL_DMA_H *//** @defgroup DMAEx_Private_Functions DMAEx Private Functions
  * @brief DMAEx Private functions
  * @{
  *//* STM32F722xx || STM32F723xx || STM32F732xx || STM32F733xx || STM32F765xx || STM32F767xx ||
          STM32F769xx || STM32F777xx || STM32F779xx || STM32F730xx*//** @defgroup DMAEx_Private_Macros DMA Private Macros
  * @brief    DMAEx private macros 
  * @{
  *//* IO operation functions *******************************************************//** @defgroup DMAEx_Exported_Functions_Group1 Extended features functions
  * @brief   Extended features functions
  * @{
  *//** @defgroup DMAEx_Exported_Functions DMAEx Exported Functions
  * @brief   DMAEx Exported functions
  * @{
  *//*!< DMA Channel 15*//*!< DMA Channel 14*//*!< DMA Channel 13*//*!< DMA Channel 12*//*!< DMA Channel 11*//*!< DMA Channel 10*//*!< DMA Channel 9 *//*!< DMA Channel 8 *//*!< DMA Channel 7 *//*!< DMA Channel 6 *//*!< DMA Channel 5 *//*!< DMA Channel 4 *//*!< DMA Channel 3 *//*!< DMA Channel 2 *//*!< DMA Channel 1 *//*!< DMA Channel 0 *//** @defgroup DMAEx_Channel_selection DMA Channel selection
  * @brief    DMAEx channel selection 
  * @{
  *//** @defgroup DMA_Exported_Constants DMA Exported Constants
  * @brief    DMA Exported constants 
  * @{
  *//*!< Memory 1     *//*!< Memory 0     *//** 
  * @brief  HAL DMA Memory definition  
  *//** @defgroup DMAEx_Exported_Types DMAEx Exported Types
  * @brief DMAEx Exported types
  * @{
  *//** @addtogroup DMAEx
  * @{
  *//**
  ******************************************************************************
  * @file    stm32f7xx_hal_dma_ex.h
  * @author  MCD Application Team
  * @brief   Header file of DMA HAL extension module.
  ******************************************************************************
  * @attention
  *
  * Copyright (c) 2017 STMicroelectronics.
  * All rights reserved.
  *
  * This software is licensed under terms that can be found in the LICENSE file in
  * the root directory of this software component.
  * If no LICENSE file comes with this software, it is provided AS-IS.
  *
  ******************************************************************************
  */memorySrcAddressDstAddressSecondMemAddressDataLength"stm32f7xx_hal_dma_ex.h"HAL_DMA_GetErrorHAL_DMA_GetStateHAL_DMA_UnRegisterCallbackHAL_DMA_RegisterCallbackHAL_DMA_IRQHandlerHAL_DMA_PollForTransferHAL_DMA_Abort_ITHAL_DMA_AbortHAL_DMA_Start_ITHAL_DMA_StartHAL_DMA_DeInitHAL_DMA_InitDMA_HandleTypeDef__DMA_HandleTypeDefHAL_DMA_CallbackIDTypeDefHAL_DMA_XFER_CPLT_CB_IDHAL_DMA_XFER_HALFCPLT_CB_IDHAL_DMA_XFER_M1CPLT_CB_IDHAL_DMA_XFER_M1HALFCPLT_CB_IDHAL_DMA_XFER_ERROR_CB_ID0x04UHAL_DMA_XFER_ABORT_CB_ID0x05UHAL_DMA_XFER_ALL_CB_ID0x06UHAL_DMA_LevelCompleteTypeDefHAL_DMA_FULL_TRANSFERHAL_DMA_HALF_TRANSFERHAL_DMA_StateTypeDefHAL_DMA_STATE_RESETHAL_DMA_STATE_READYHAL_DMA_STATE_BUSYHAL_DMA_STATE_TIMEOUTHAL_DMA_STATE_ERRORHAL_DMA_STATE_ABORTDMA_InitTypeDefStreamIndexStreamBaseAddressErrorCodeXferAbortCallbackXferErrorCallbackXferM1HalfCpltCallbackXferM1CpltCallbackXferHalfCpltCallbackXferCpltCallbackParentvolatile HAL_DMA_StateTypeDefLockInstancePeriphBurstMemBurstFIFOThresholdFIFOModeMemDataAlignmentPeriphDataAlignmentMemIncPeriphIncChannelIS_DMA_PERIPHERAL_BURST(BURST)(((BURST) == DMA_PBURST_SINGLE) || ((BURST) == DMA_PBURST_INC4) || ((BURST) == DMA_PBURST_INC8) || ((BURST) == DMA_PBURST_INC16))IS_DMA_MEMORY_BURST(BURST)(((BURST) == DMA_MBURST_SINGLE) || ((BURST) == DMA_MBURST_INC4) || ((BURST) == DMA_MBURST_INC8) || ((BURST) == DMA_MBURST_INC16))IS_DMA_FIFO_THRESHOLD(THRESHOLD)(((THRESHOLD) == DMA_FIFO_THRESHOLD_1QUARTERFULL ) || ((THRESHOLD) == DMA_FIFO_THRESHOLD_HALFFULL) || ((THRESHOLD) == DMA_FIFO_THRESHOLD_3QUARTERSFULL) || ((THRESHOLD) == DMA_FIFO_THRESHOLD_FULL))IS_DMA_FIFO_MODE_STATE(STATE)(((STATE) == DMA_FIFOMODE_DISABLE ) || ((STATE) == DMA_FIFOMODE_ENABLE))IS_DMA_PRIORITY(PRIORITY)(((PRIORITY) == DMA_PRIORITY_LOW ) || ((PRIORITY) == DMA_PRIORITY_MEDIUM) || ((PRIORITY) == DMA_PRIORITY_HIGH) || ((PRIORITY) == DMA_PRIORITY_VERY_HIGH))IS_DMA_MODE(MODE)(((MODE) == DMA_NORMAL ) || ((MODE) == DMA_CIRCULAR) || ((MODE) == DMA_PFCTRL))IS_DMA_MEMORY_DATA_SIZE(SIZE)(((SIZE) == DMA_MDATAALIGN_BYTE) || ((SIZE) == DMA_MDATAALIGN_HALFWORD) || ((SIZE) == DMA_MDATAALIGN_WORD ))IS_DMA_PERIPHERAL_DATA_SIZE(SIZE)(((SIZE) == DMA_PDATAALIGN_BYTE) || ((SIZE) == DMA_PDATAALIGN_HALFWORD) || ((SIZE) == DMA_PDATAALIGN_WORD))IS_DMA_MEMORY_INC_STATE(STATE)(((STATE) == DMA_MINC_ENABLE) || ((STATE) == DMA_MINC_DISABLE))IS_DMA_PERIPHERAL_INC_STATE(STATE)(((STATE) == DMA_PINC_ENABLE) || ((STATE) == DMA_PINC_DISABLE))IS_DMA_BUFFER_SIZE(SIZE)(((SIZE) >= 0x01U) && ((SIZE) < 0x10000U))IS_DMA_DIRECTION(DIRECTION)(((DIRECTION) == DMA_PERIPH_TO_MEMORY ) || ((DIRECTION) == DMA_MEMORY_TO_PERIPH) || ((DIRECTION) == DMA_MEMORY_TO_MEMORY))__HAL_DMA_GET_COUNTER(__HANDLE__)((__HANDLE__)->Instance->NDTR)__HAL_DMA_SET_COUNTER(__HANDLE__,__COUNTER__)((__HANDLE__)->Instance->NDTR = (uint16_t)(__COUNTER__))__HAL_DMA_GET_IT_SOURCE(__HANDLE__,__INTERRUPT__)(((__INTERRUPT__) != DMA_IT_FE)? ((__HANDLE__)->Instance->CR & (__INTERRUPT__)) : ((__HANDLE__)->Instance->FCR & (__INTERRUPT__)))__HAL_DMA_DISABLE_IT(__HANDLE__,__INTERRUPT__)(((__INTERRUPT__) != DMA_IT_FE)? ((__HANDLE__)->Instance->CR &= ~(__INTERRUPT__)) : ((__HANDLE__)->Instance->FCR &= ~(__INTERRUPT__)))__HAL_DMA_ENABLE_IT(__HANDLE__,__INTERRUPT__)(((__INTERRUPT__) != DMA_IT_FE)? ((__HANDLE__)->Instance->CR |= (__INTERRUPT__)) : ((__HANDLE__)->Instance->FCR |= (__INTERRUPT__)))__HAL_DMA_CLEAR_FLAG(__HANDLE__,__FLAG__)(((uint32_t)((__HANDLE__)->Instance) > (uint32_t)DMA2_Stream3)? (DMA2->HIFCR = (__FLAG__)) : ((uint32_t)((__HANDLE__)->Instance) > (uint32_t)DMA1_Stream7)? (DMA2->LIFCR = (__FLAG__)) : ((uint32_t)((__HANDLE__)->Instance) > (uint32_t)DMA1_Stream3)? (DMA1->HIFCR = (__FLAG__)) : (DMA1->LIFCR = (__FLAG__)))__HAL_DMA_GET_FLAG(__HANDLE__,__FLAG__)(((uint32_t)((__HANDLE__)->Instance) > (uint32_t)DMA2_Stream3)? (DMA2->HISR & (__FLAG__)) : ((uint32_t)((__HANDLE__)->Instance) > (uint32_t)DMA1_Stream7)? (DMA2->LISR & (__FLAG__)) : ((uint32_t)((__HANDLE__)->Instance) > (uint32_t)DMA1_Stream3)? (DMA1->HISR & (__FLAG__)) : (DMA1->LISR & (__FLAG__)))__HAL_DMA_GET_DME_FLAG_INDEX(__HANDLE__)(((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Stream0))? DMA_FLAG_DMEIF0_4 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA2_Stream0))? DMA_FLAG_DMEIF0_4 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Stream4))? DMA_FLAG_DMEIF0_4 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA2_Stream4))? DMA_FLAG_DMEIF0_4 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Stream1))? DMA_FLAG_DMEIF1_5 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA2_Stream1))? DMA_FLAG_DMEIF1_5 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Stream5))? DMA_FLAG_DMEIF1_5 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA2_Stream5))? DMA_FLAG_DMEIF1_5 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Stream2))? DMA_FLAG_DMEIF2_6 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA2_Stream2))? DMA_FLAG_DMEIF2_6 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Stream6))? DMA_FLAG_DMEIF2_6 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA2_Stream6))? DMA_FLAG_DMEIF2_6 : DMA_FLAG_DMEIF3_7)__HAL_DMA_GET_FE_FLAG_INDEX(__HANDLE__)(((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Stream0))? DMA_FLAG_FEIF0_4 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA2_Stream0))? DMA_FLAG_FEIF0_4 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Stream4))? DMA_FLAG_FEIF0_4 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA2_Stream4))? DMA_FLAG_FEIF0_4 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Stream1))? DMA_FLAG_FEIF1_5 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA2_Stream1))? DMA_FLAG_FEIF1_5 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Stream5))? DMA_FLAG_FEIF1_5 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA2_Stream5))? DMA_FLAG_FEIF1_5 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Stream2))? DMA_FLAG_FEIF2_6 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA2_Stream2))? DMA_FLAG_FEIF2_6 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Stream6))? DMA_FLAG_FEIF2_6 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA2_Stream6))? DMA_FLAG_FEIF2_6 : DMA_FLAG_FEIF3_7)__HAL_DMA_GET_TE_FLAG_INDEX(__HANDLE__)(((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Stream0))? DMA_FLAG_TEIF0_4 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA2_Stream0))? DMA_FLAG_TEIF0_4 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Stream4))? DMA_FLAG_TEIF0_4 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA2_Stream4))? DMA_FLAG_TEIF0_4 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Stream1))? DMA_FLAG_TEIF1_5 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA2_Stream1))? DMA_FLAG_TEIF1_5 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Stream5))? DMA_FLAG_TEIF1_5 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA2_Stream5))? DMA_FLAG_TEIF1_5 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Stream2))? DMA_FLAG_TEIF2_6 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA2_Stream2))? DMA_FLAG_TEIF2_6 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Stream6))? DMA_FLAG_TEIF2_6 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA2_Stream6))? DMA_FLAG_TEIF2_6 : DMA_FLAG_TEIF3_7)__HAL_DMA_GET_HT_FLAG_INDEX(__HANDLE__)(((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Stream0))? DMA_FLAG_HTIF0_4 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA2_Stream0))? DMA_FLAG_HTIF0_4 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Stream4))? DMA_FLAG_HTIF0_4 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA2_Stream4))? DMA_FLAG_HTIF0_4 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Stream1))? DMA_FLAG_HTIF1_5 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA2_Stream1))? DMA_FLAG_HTIF1_5 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Stream5))? DMA_FLAG_HTIF1_5 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA2_Stream5))? DMA_FLAG_HTIF1_5 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Stream2))? DMA_FLAG_HTIF2_6 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA2_Stream2))? DMA_FLAG_HTIF2_6 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Stream6))? DMA_FLAG_HTIF2_6 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA2_Stream6))? DMA_FLAG_HTIF2_6 : DMA_FLAG_HTIF3_7)__HAL_DMA_GET_TC_FLAG_INDEX(__HANDLE__)(((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Stream0))? DMA_FLAG_TCIF0_4 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA2_Stream0))? DMA_FLAG_TCIF0_4 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Stream4))? DMA_FLAG_TCIF0_4 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA2_Stream4))? DMA_FLAG_TCIF0_4 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Stream1))? DMA_FLAG_TCIF1_5 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA2_Stream1))? DMA_FLAG_TCIF1_5 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Stream5))? DMA_FLAG_TCIF1_5 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA2_Stream5))? DMA_FLAG_TCIF1_5 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Stream2))? DMA_FLAG_TCIF2_6 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA2_Stream2))? DMA_FLAG_TCIF2_6 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA1_Stream6))? DMA_FLAG_TCIF2_6 : ((uint32_t)((__HANDLE__)->Instance) == ((uint32_t)DMA2_Stream6))? DMA_FLAG_TCIF2_6 : DMA_FLAG_TCIF3_7)__HAL_DMA_DISABLE(__HANDLE__)((__HANDLE__)->Instance->CR &= ~DMA_SxCR_EN)__HAL_DMA_ENABLE(__HANDLE__)((__HANDLE__)->Instance->CR |= DMA_SxCR_EN)__HAL_DMA_GET_FS(__HANDLE__)(((__HANDLE__)->Instance->FCR & (DMA_SxFCR_FS)))__HAL_DMA_RESET_HANDLE_STATE(__HANDLE__)((__HANDLE__)->State = HAL_DMA_STATE_RESET)DMA_FLAG_TCIF3_7DMA_FLAG_HTIF3_7DMA_FLAG_TEIF3_7DMA_FLAG_DMEIF3_7DMA_FLAG_FEIF3_7DMA_FLAG_TCIF2_6DMA_FLAG_HTIF2_6DMA_FLAG_TEIF2_6DMA_FLAG_DMEIF2_6DMA_FLAG_FEIF2_6DMA_FLAG_TCIF1_5DMA_FLAG_HTIF1_5DMA_FLAG_TEIF1_5DMA_FLAG_DMEIF1_5DMA_FLAG_FEIF1_5DMA_FLAG_TCIF0_4DMA_FLAG_HTIF0_4DMA_FLAG_TEIF0_4DMA_FLAG_DMEIF0_4DMA_FLAG_FEIF0_4DMA_IT_FEDMA_IT_DMEDMA_IT_TEDMA_IT_HTDMA_IT_TCDMA_PBURST_INC16DMA_PBURST_INC8DMA_PBURST_INC4DMA_MBURST_INC16DMA_MBURST_INC8DMA_MBURST_INC4DMA_FIFO_THRESHOLD_FULLDMA_FIFO_THRESHOLD_3QUARTERSFULLDMA_FIFO_THRESHOLD_HALFFULLDMA_FIFO_THRESHOLD_1QUARTERFULLDMA_FIFOMODE_ENABLEDMA_PRIORITY_VERY_HIGHDMA_PRIORITY_HIGHDMA_PRIORITY_MEDIUMDMA_PRIORITY_LOWDMA_PFCTRLDMA_CIRCULARDMA_MDATAALIGN_WORDDMA_MDATAALIGN_HALFWORDDMA_PDATAALIGN_WORDDMA_PDATAALIGN_HALFWORDDMA_PDATAALIGN_BYTEDMA_MINC_DISABLEDMA_MINC_ENABLEDMA_PINC_ENABLEDMA_MEMORY_TO_MEMORYDMA_MEMORY_TO_PERIPHHAL_DMA_ERROR_NOT_SUPPORTEDHAL_DMA_ERROR_NO_XFERHAL_DMA_ERROR_PARAMHAL_DMA_ERROR_TIMEOUTHAL_DMA_ERROR_DMEHAL_DMA_ERROR_FEHAL_DMA_ERROR_TEHAL_DMA_ERROR_NONE__STM32F7xx_HAL_DMA_H/** @defgroup DMA_Private_Functions DMA Private Functions
  * @brief    DMA private  functions 
  * @{
  *//** @defgroup DMA_Private_Macros DMA Private Macros
  * @brief    DMA private macros 
  * @{
  *//** @defgroup DMA_Private_Constants DMA Private Constants
  * @brief    DMA private defines and constants 
  * @{
  *//* Private Constants -------------------------------------------------------------*//** @defgroup DMA_Exported_Functions_Group3 Peripheral State functions
  * @brief    Peripheral State functions 
  * @{
  *//** @defgroup DMA_Exported_Functions_Group2 I/O operation functions
  * @brief   I/O operation functions  
  * @{
  *//** @defgroup DMA_Exported_Functions_Group1 Initialization and de-initialization functions
  * @brief   Initialization and de-initialization functions 
  * @{
  *//** @defgroup DMA_Exported_Functions DMA Exported Functions
  * @brief    DMA Exported functions 
  * @{
  *//* Include DMA HAL Extension module *//**
  * @brief  Returns the number of remaining data units in the current DMAy Streamx transfer.
  * @param  __HANDLE__ DMA handle
  *   
  * @retval The number of remaining data units in the current DMA Stream transfer.
  *//**
  * @brief  Writes the number of data units to be transferred on the DMA Stream.
  * @param  __HANDLE__ DMA handle
  * @param  __COUNTER__ Number of data units to be transferred (from 0 to 65535) 
  *          Number of data items depends only on the Peripheral data format.
  *            
  * @note   If Peripheral data format is Bytes: number of data units is equal 
  *         to total number of bytes to be transferred.
  *           
  * @note   If Peripheral data format is Half-Word: number of data units is  
  *         equal to total number of bytes to be transferred / 2.
  *           
  * @note   If Peripheral data format is Word: number of data units is equal 
  *         to total  number of bytes to be transferred / 4.
  *      
  * @retval The number of remaining data units in the current DMAy Streamx transfer.
  *//**
  * @brief  Check whether the specified DMA Stream interrupt is enabled or not.
  * @param  __HANDLE__ DMA handle
  * @param  __INTERRUPT__ specifies the DMA interrupt source to check.
  *         This parameter can be one of the following values:
  *            @arg DMA_IT_TC: Transfer complete interrupt mask.
  *            @arg DMA_IT_HT: Half transfer complete interrupt mask.
  *            @arg DMA_IT_TE: Transfer error interrupt mask.
  *            @arg DMA_IT_FE: FIFO error interrupt mask.
  *            @arg DMA_IT_DME: Direct mode error interrupt.
  * @retval The state of DMA_IT.
  *//**
  * @brief  Disable the specified DMA Stream interrupts.
  * @param  __HANDLE__ DMA handle
  * @param  __INTERRUPT__ specifies the DMA interrupt sources to be enabled or disabled. 
  *         This parameter can be one of the following values:
  *            @arg DMA_IT_TC: Transfer complete interrupt mask.
  *            @arg DMA_IT_HT: Half transfer complete interrupt mask.
  *            @arg DMA_IT_TE: Transfer error interrupt mask.
  *            @arg DMA_IT_FE: FIFO error interrupt mask.
  *            @arg DMA_IT_DME: Direct mode error interrupt.
  * @retval None
  *//**
  * @brief  Enable the specified DMA Stream interrupts.
  * @param  __HANDLE__ DMA handle
  * @param  __INTERRUPT__ specifies the DMA interrupt sources to be enabled or disabled. 
  *        This parameter can be one of the following values:
  *           @arg DMA_IT_TC: Transfer complete interrupt mask.
  *           @arg DMA_IT_HT: Half transfer complete interrupt mask.
  *           @arg DMA_IT_TE: Transfer error interrupt mask.
  *           @arg DMA_IT_FE: FIFO error interrupt mask.
  *           @arg DMA_IT_DME: Direct mode error interrupt.
  * @retval None
  *//**
  * @brief  Clear the DMA Stream pending flags.
  * @param  __HANDLE__ DMA handle
  * @param  __FLAG__ specifies the flag to clear.
  *          This parameter can be any combination of the following values:
  *            @arg DMA_FLAG_TCIFx: Transfer complete flag.
  *            @arg DMA_FLAG_HTIFx: Half transfer complete flag.
  *            @arg DMA_FLAG_TEIFx: Transfer error flag.
  *            @arg DMA_FLAG_DMEIFx: Direct mode error flag.
  *            @arg DMA_FLAG_FEIFx: FIFO error flag.
  *         Where x can be 0_4, 1_5, 2_6 or 3_7 to select the DMA Stream flag.   
  * @retval None
  *//**
  * @brief  Get the DMA Stream pending flags.
  * @param  __HANDLE__ DMA handle
  * @param  __FLAG__ Get the specified flag.
  *          This parameter can be any combination of the following values:
  *            @arg DMA_FLAG_TCIFx: Transfer complete flag.
  *            @arg DMA_FLAG_HTIFx: Half transfer complete flag.
  *            @arg DMA_FLAG_TEIFx: Transfer error flag.
  *            @arg DMA_FLAG_DMEIFx: Direct mode error flag.
  *            @arg DMA_FLAG_FEIFx: FIFO error flag.
  *         Where x can be 0_4, 1_5, 2_6 or 3_7 to select the DMA Stream flag.   
  * @retval The state of FLAG (SET or RESET).
  *//**
  * @brief  Return the current DMA Stream direct mode error flag.
  * @param  __HANDLE__ DMA handle
  * @retval The specified direct mode error flag index.
  *//**
  * @brief  Return the current DMA Stream FIFO error flag.
  * @param  __HANDLE__ DMA handle
  * @retval The specified FIFO error flag index.
  *//**
  * @brief  Return the current DMA Stream transfer error flag.
  * @param  __HANDLE__ DMA handle
  * @retval The specified transfer error flag index.
  *//**
  * @brief  Return the current DMA Stream half transfer complete flag.
  * @param  __HANDLE__ DMA handle
  * @retval The specified half transfer complete flag index.
  *//**
  * @brief  Return the current DMA Stream transfer complete flag.
  * @param  __HANDLE__ DMA handle
  * @retval The specified transfer complete flag index.
  *//* Interrupt & Flag management *//**
  * @brief  Disable the specified DMA Stream.
  * @param  __HANDLE__ DMA handle
  * @retval None
  *//**
  * @brief  Enable the specified DMA Stream.
  * @param  __HANDLE__ DMA handle
  * @retval None
  *//**
  * @brief  Return the current DMA Stream FIFO filled level.
  * @param  __HANDLE__ DMA handle
  * @retval The FIFO filling state.
  *           - DMA_FIFOStatus_Less1QuarterFull: when FIFO is less than 1 quarter-full 
  *                                              and not empty.
  *           - DMA_FIFOStatus_1QuarterFull: if more than 1 quarter-full.
  *           - DMA_FIFOStatus_HalfFull: if more than 1 half-full.
  *           - DMA_FIFOStatus_3QuartersFull: if more than 3 quarters-full.
  *           - DMA_FIFOStatus_Empty: when FIFO is empty
  *           - DMA_FIFOStatus_Full: when FIFO is full
  *//** @brief Reset DMA handle state
  * @param  __HANDLE__ specifies the DMA handle.
  * @retval None
  *//** @defgroup DMA_flag_definitions DMA flag definitions
  * @brief    DMA flag definitions 
  * @{
  *//** @defgroup DMA_interrupt_enable_definitions DMA interrupt enable definitions
  * @brief    DMA interrupts definition 
  * @{
  *//** @defgroup DMA_Peripheral_burst DMA Peripheral burst
  * @brief    DMA peripheral burst 
  * @{
  *//** @defgroup DMA_Memory_burst DMA Memory burst
  * @brief    DMA memory burst 
  * @{
  *//*!< FIFO threshold full configuration          *//*!< FIFO threshold 3 quarts full configuration *//*!< FIFO threshold half full configuration     *//*!< FIFO threshold 1 quart full configuration  *//** @defgroup DMA_FIFO_threshold_level DMA FIFO threshold level
  * @brief    DMA FIFO level 
  * @{
  *//*!< FIFO mode enable  *//*!< FIFO mode disable *//** @defgroup DMA_FIFO_direct_mode DMA FIFO direct mode
  * @brief    DMA FIFO direct mode
  * @{
  *//*!< Priority level: Very High *//*!< Priority level: High      *//*!< Priority level: Medium    *//*!< Priority level: Low       *//** @defgroup DMA_Priority_level DMA Priority level
  * @brief    DMA priority levels 
  * @{
  *//*!< Peripheral flow control mode *//*!< Circular mode                *//*!< Normal mode                  *//** @defgroup DMA_mode DMA mode
  * @brief    DMA mode 
  * @{
  *//*!< Memory data alignment: Word     *//*!< Memory data alignment: HalfWord *//*!< Memory data alignment: Byte     *//** @defgroup DMA_Memory_data_size DMA Memory data size
  * @brief    DMA memory data size 
  * @{ 
  *//*!< Peripheral data alignment: Word     *//*!< Peripheral data alignment: HalfWord *//*!< Peripheral data alignment: Byte     *//** @defgroup DMA_Peripheral_data_size DMA Peripheral data size
  * @brief    DMA peripheral data size 
  * @{
  *//*!< Memory increment mode disable *//*!< Memory increment mode enable  *//** @defgroup DMA_Memory_incremented_mode DMA Memory incremented mode
  * @brief    DMA memory incremented mode 
  * @{
  *//*!< Peripheral increment mode disable *//*!< Peripheral increment mode enable  *//** @defgroup DMA_Peripheral_incremented_mode DMA Peripheral incremented mode
  * @brief    DMA peripheral incremented mode 
  * @{
  *//*!< Memory to memory direction     *//*!< Memory to peripheral direction *//*!< Peripheral to memory direction *//** @defgroup DMA_Data_transfer_direction DMA Data transfer direction
  * @brief    DMA data transfer direction 
  * @{
  *//*!< Not supported mode                     *//*!< Abort requested with no Xfer ongoing   *//*!< Parameter error                        *//*!< Timeout error                          *//*!< Direct Mode error                      *//*!< FIFO error                             *//*!< Transfer error                         *//*!< No error                               *//** @defgroup DMA_Error_Code DMA Error Code
  * @brief    DMA Error Code 
  * @{
  *//*!< DMA Stream Index                       *//*!< DMA Stream Base Address                *//*!< DMA Error code                          *//*!< DMA transfer Abort callback            *//*!< DMA transfer error callback            *//*!< DMA transfer Half complete Memory1 callback *//*!< DMA transfer complete Memory1 callback *//*!< DMA Half transfer complete callback    *//*!< DMA transfer complete callback         *//*!< Parent object state                    *//*!< DMA transfer state                     *//*!< DMA locking object                     *//*!< DMA communication parameters           *//*!< Register base address                  *//** 
  * @brief  DMA handle Structure definition
  *//*!< All               *//*!< Abort             *//*!< Error             *//*!< M1 Half Transfer  *//*!< M1 Full Transfer  *//*!< Half Transfer     *//*!< Full transfer     *//** 
  * @brief  HAL DMA Error Code structure definition
  *//*!< DMA Abort state                     *//*!< DMA error state                     *//*!< DMA timeout state                   *//*!< DMA process is ongoing              *//*!< DMA initialized and ready for use   *//*!< DMA not yet initialized or disabled *//** 
  * @brief  HAL DMA State structures definition
  *//*!< Specifies the Burst transfer configuration for the peripheral transfers. 
                                      It specifies the amount of data to be transferred in a single non interruptible 
                                      transaction. 
                                      This parameter can be a value of @ref DMA_Peripheral_burst
                                      @note The burst mode is possible only if the address Increment mode is enabled. *//*!< Specifies the Burst transfer configuration for the memory transfers. 
                                      It specifies the amount of data to be transferred in a single non interruptible 
                                      transaction.
                                      This parameter can be a value of @ref DMA_Memory_burst 
                                      @note The burst mode is possible only if the address Increment mode is enabled. *//*!< Specifies the FIFO threshold level.
                                      This parameter can be a value of @ref DMA_FIFO_threshold_level                  *//*!< Specifies if the FIFO mode or Direct mode will be used for the specified stream.
                                      This parameter can be a value of @ref DMA_FIFO_direct_mode
                                      @note The Direct mode (FIFO mode disabled) cannot be used if the 
                                            memory-to-memory data transfer is configured on the selected stream       *//*!< Specifies the software priority for the DMAy Streamx.
                                      This parameter can be a value of @ref DMA_Priority_level                       *//*!< Specifies the operation mode of the DMAy Streamx.
                                      This parameter can be a value of @ref DMA_mode
                                      @note The circular buffer mode cannot be used if the memory-to-memory
                                            data transfer is configured on the selected Stream                        *//*!< Specifies the Memory data width.
                                      This parameter can be a value of @ref DMA_Memory_data_size                     *//*!< Specifies the Peripheral data width.
                                      This parameter can be a value of @ref DMA_Peripheral_data_size                 *//*!< Specifies whether the memory address register should be incremented or not.
                                      This parameter can be a value of @ref DMA_Memory_incremented_mode              *//*!< Specifies whether the Peripheral address register should be incremented or not.
                                      This parameter can be a value of @ref DMA_Peripheral_incremented_mode          *//*!< Specifies if the data will be transferred from memory to peripheral, 
                                      from memory to memory or from peripheral to memory.
                                      This parameter can be a value of @ref DMA_Data_transfer_direction              *//*!< Specifies the channel used for the specified stream. 
                                      This parameter can be a value of @ref DMAEx_Channel_selection                  *//** 
  * @brief  DMA Configuration Structure definition
  *//** @defgroup DMA_Exported_Types DMA Exported Types
  * @brief    DMA Exported Types 
  * @{
  *//** @addtogroup DMA
  * @{
  *//**
  ******************************************************************************
  * @file    stm32f7xx_hal_dma.h
  * @author  MCD Application Team
  * @brief   Header file of DMA HAL module.
  ******************************************************************************
  * @attention
  *
  * Copyright (c) 2017 STMicroelectronics.
  * All rights reserved.
  *
  * This software is licensed under terms that can be found in the LICENSE file in
  * the root directory of this software component.
  * If no LICENSE file comes with this software, it is provided AS-IS.
  *
  ******************************************************************************
  */CallbackIDpCallbackCompleteLevelHAL_SYSTICK_CallbackHAL_SYSTICK_IRQHandlerHAL_NVIC_GetActiveHAL_NVIC_ClearPendingIRQHAL_NVIC_SetPendingIRQHAL_NVIC_GetPendingIRQHAL_NVIC_GetPriorityHAL_NVIC_GetPriorityGroupingHAL_MPU_ConfigRegionMPU_Region_InitTypeDef *HAL_MPU_DisableRegionHAL_MPU_EnableRegionHAL_MPU_DisableHAL_MPU_EnableHAL_SYSTICK_ConfigHAL_NVIC_SystemResetHAL_NVIC_DisableIRQHAL_NVIC_EnableIRQHAL_NVIC_SetPriorityHAL_NVIC_SetPriorityGroupingMPU_Region_InitTypeDefIsBufferableIsCacheableIsShareableDisableExecAccessPermissionTypeExtFieldSubRegionDisableBaseAddressNumberEnableIS_MPU_SUB_REGION_DISABLE(SUBREGION)((SUBREGION) < (uint16_t)0x00FFU)IS_MPU_REGION_SIZE(SIZE)(((SIZE) == MPU_REGION_SIZE_32B) || ((SIZE) == MPU_REGION_SIZE_64B) || ((SIZE) == MPU_REGION_SIZE_128B) || ((SIZE) == MPU_REGION_SIZE_256B) || ((SIZE) == MPU_REGION_SIZE_512B) || ((SIZE) == MPU_REGION_SIZE_1KB) || ((SIZE) == MPU_REGION_SIZE_2KB) || ((SIZE) == MPU_REGION_SIZE_4KB) || ((SIZE) == MPU_REGION_SIZE_8KB) || ((SIZE) == MPU_REGION_SIZE_16KB) || ((SIZE) == MPU_REGION_SIZE_32KB) || ((SIZE) == MPU_REGION_SIZE_64KB) || ((SIZE) == MPU_REGION_SIZE_128KB) || ((SIZE) == MPU_REGION_SIZE_256KB) || ((SIZE) == MPU_REGION_SIZE_512KB) || ((SIZE) == MPU_REGION_SIZE_1MB) || ((SIZE) == MPU_REGION_SIZE_2MB) || ((SIZE) == MPU_REGION_SIZE_4MB) || ((SIZE) == MPU_REGION_SIZE_8MB) || ((SIZE) == MPU_REGION_SIZE_16MB) || ((SIZE) == MPU_REGION_SIZE_32MB) || ((SIZE) == MPU_REGION_SIZE_64MB) || ((SIZE) == MPU_REGION_SIZE_128MB) || ((SIZE) == MPU_REGION_SIZE_256MB) || ((SIZE) == MPU_REGION_SIZE_512MB) || ((SIZE) == MPU_REGION_SIZE_1GB) || ((SIZE) == MPU_REGION_SIZE_2GB) || ((SIZE) == MPU_REGION_SIZE_4GB))IS_MPU_REGION_NUMBER(NUMBER)(((NUMBER) == MPU_REGION_NUMBER0) || ((NUMBER) == MPU_REGION_NUMBER1) || ((NUMBER) == MPU_REGION_NUMBER2) || ((NUMBER) == MPU_REGION_NUMBER3) || ((NUMBER) == MPU_REGION_NUMBER4) || ((NUMBER) == MPU_REGION_NUMBER5) || ((NUMBER) == MPU_REGION_NUMBER6) || ((NUMBER) == MPU_REGION_NUMBER7))IS_MPU_REGION_PERMISSION_ATTRIBUTE(TYPE)(((TYPE) == MPU_REGION_NO_ACCESS) || ((TYPE) == MPU_REGION_PRIV_RW) || ((TYPE) == MPU_REGION_PRIV_RW_URO) || ((TYPE) == MPU_REGION_FULL_ACCESS) || ((TYPE) == MPU_REGION_PRIV_RO) || ((TYPE) == MPU_REGION_PRIV_RO_URO))IS_MPU_TEX_LEVEL(TYPE)(((TYPE) == MPU_TEX_LEVEL0) || ((TYPE) == MPU_TEX_LEVEL1) || ((TYPE) == MPU_TEX_LEVEL2))IS_MPU_ACCESS_BUFFERABLE(STATE)(((STATE) == MPU_ACCESS_BUFFERABLE) || ((STATE) == MPU_ACCESS_NOT_BUFFERABLE))IS_MPU_ACCESS_CACHEABLE(STATE)(((STATE) == MPU_ACCESS_CACHEABLE) || ((STATE) == MPU_ACCESS_NOT_CACHEABLE))IS_MPU_ACCESS_SHAREABLE(STATE)(((STATE) == MPU_ACCESS_SHAREABLE) || ((STATE) == MPU_ACCESS_NOT_SHAREABLE))IS_MPU_INSTRUCTION_ACCESS(STATE)(((STATE) == MPU_INSTRUCTION_ACCESS_ENABLE) || ((STATE) == MPU_INSTRUCTION_ACCESS_DISABLE))IS_MPU_REGION_ENABLE(STATE)(((STATE) == MPU_REGION_ENABLE) || ((STATE) == MPU_REGION_DISABLE))IS_SYSTICK_CLK_SOURCE(SOURCE)(((SOURCE) == SYSTICK_CLKSOURCE_HCLK) || ((SOURCE) == SYSTICK_CLKSOURCE_HCLK_DIV8))IS_NVIC_DEVICE_IRQ(IRQ)((IRQ) >= 0x00)IS_NVIC_SUB_PRIORITY(PRIORITY)((PRIORITY) < 0x10U)IS_NVIC_PREEMPTION_PRIORITY(PRIORITY)IS_NVIC_PRIORITY_GROUP(GROUP)(((GROUP) == NVIC_PRIORITYGROUP_0) || ((GROUP) == NVIC_PRIORITYGROUP_1) || ((GROUP) == NVIC_PRIORITYGROUP_2) || ((GROUP) == NVIC_PRIORITYGROUP_3) || ((GROUP) == NVIC_PRIORITYGROUP_4))MPU_REGION_NUMBER7MPU_REGION_NUMBER6MPU_REGION_NUMBER5MPU_REGION_NUMBER4MPU_REGION_NUMBER3MPU_REGION_NUMBER2MPU_REGION_NUMBER1MPU_REGION_NUMBER0MPU_REGION_PRIV_RO_UROMPU_REGION_PRIV_ROMPU_REGION_FULL_ACCESSMPU_REGION_PRIV_RW_UROMPU_REGION_PRIV_RWMPU_REGION_NO_ACCESSMPU_REGION_SIZE_4GBMPU_REGION_SIZE_2GBMPU_REGION_SIZE_1GBMPU_REGION_SIZE_512MBMPU_REGION_SIZE_256MBMPU_REGION_SIZE_128MBMPU_REGION_SIZE_64MBMPU_REGION_SIZE_32MBMPU_REGION_SIZE_16MBMPU_REGION_SIZE_8MBMPU_REGION_SIZE_4MBMPU_REGION_SIZE_2MBMPU_REGION_SIZE_1MBMPU_REGION_SIZE_512KBMPU_REGION_SIZE_256KBMPU_REGION_SIZE_128KBMPU_REGION_SIZE_64KBMPU_REGION_SIZE_32KBMPU_REGION_SIZE_16KBMPU_REGION_SIZE_8KBMPU_REGION_SIZE_4KBMPU_REGION_SIZE_2KBMPU_REGION_SIZE_1KBMPU_REGION_SIZE_512BMPU_REGION_SIZE_256BMPU_REGION_SIZE_128BMPU_REGION_SIZE_64BMPU_REGION_SIZE_32BMPU_TEX_LEVEL2MPU_TEX_LEVEL1MPU_TEX_LEVEL0MPU_ACCESS_NOT_BUFFERABLEMPU_ACCESS_BUFFERABLEMPU_ACCESS_NOT_CACHEABLEMPU_ACCESS_CACHEABLEMPU_ACCESS_NOT_SHAREABLEMPU_ACCESS_SHAREABLEMPU_INSTRUCTION_ACCESS_DISABLEMPU_INSTRUCTION_ACCESS_ENABLEMPU_REGION_DISABLEMPU_REGION_ENABLEMPU_HFNMI_PRIVDEFMPU_PRIVILEGED_DEFAULTMPU_HARDFAULT_NMIMPU_HFNMI_PRIVDEF_NONESYSTICK_CLKSOURCE_HCLKSYSTICK_CLKSOURCE_HCLK_DIV8NVIC_PRIORITYGROUP_4NVIC_PRIORITYGROUP_3NVIC_PRIORITYGROUP_2((uint32_t)0x00000005U)NVIC_PRIORITYGROUP_1NVIC_PRIORITYGROUP_0((uint32_t)0x00000007U)__STM32F7xx_HAL_CORTEX_H(__MPU_PRESENT == 1)/* __STM32F7xx_HAL_CORTEX_H *//**                                                                          
  * @}
  *//* __MPU_PRESENT *//** @defgroup CORTEX_Private_Macros CORTEX Private Macros
  * @{
  *//* Peripheral Control functions ***********************************************//** @addtogroup CORTEX_Exported_Functions_Group2
 * @{
 *//** @addtogroup CORTEX_Exported_Functions_Group1
 * @{
 *//** @addtogroup CORTEX_Exported_Functions
  * @{
  *//* Exported Macros -----------------------------------------------------------*//** @defgroup CORTEX_MPU_Region_Number CORTEX MPU Region Number
  * @{
  *//** @defgroup CORTEX_MPU_Region_Permission_Attributes CORTEX MPU Region Permission Attributes 
  * @{
  *//**                                
  * @}
  *//** @defgroup CORTEX_MPU_Region_Size CORTEX MPU Region Size
  * @{
  *//** @defgroup CORTEX_MPU_TEX_Levels MPU TEX Levels
  * @{
  *//** @defgroup CORTEX_MPU_Access_Bufferable CORTEX MPU Instruction Access Bufferable
  * @{
  *//** @defgroup CORTEX_MPU_Access_Cacheable CORTEX MPU Instruction Access Cacheable
  * @{
  *//** @defgroup CORTEX_MPU_Access_Shareable CORTEX MPU Instruction Access Shareable
  * @{
  *//** @defgroup CORTEX_MPU_Instruction_Access CORTEX MPU Instruction Access
  * @{
  *//** @defgroup CORTEX_MPU_Region_Enable CORTEX MPU Region Enable
  * @{
  *//** @defgroup CORTEX_MPU_HFNMI_PRIVDEF_Control MPU HFNMI and PRIVILEGED Access control
  * @{
  *//** @defgroup CORTEX_SysTick_clock_source CORTEX _SysTick clock source 
  * @{
  *//*!< 4 bits for pre-emption priority
                                                                 0 bits for subpriority *//*!< 3 bits for pre-emption priority
                                                                 1 bits for subpriority *//*!< 2 bits for pre-emption priority
                                                                 2 bits for subpriority *//*!< 1 bits for pre-emption priority
                                                                 3 bits for subpriority *//*!< 0 bits for pre-emption priority
                                                                 4 bits for subpriority *//** @defgroup CORTEX_Preemption_Priority_Group CORTEX Preemption Priority Group
  * @{
  *//** @defgroup CORTEX_Exported_Constants CORTEX Exported Constants
  * @{
  *//*!< Specifies the bufferable status of the protected region. 
                                                     This parameter can be a value of @ref CORTEX_MPU_Access_Bufferable             *//*!< Specifies the cacheable status of the region protected. 
                                                     This parameter can be a value of @ref CORTEX_MPU_Access_Cacheable              *//*!< Specifies the shareability status of the protected region. 
                                                     This parameter can be a value of @ref CORTEX_MPU_Access_Shareable              *//*!< Specifies the instruction access status. 
                                                     This parameter can be a value of @ref CORTEX_MPU_Instruction_Access            *//*!< Specifies the region access permission type. 
                                                     This parameter can be a value of @ref CORTEX_MPU_Region_Permission_Attributes  *//*!< Specifies the TEX field level.
                                                     This parameter can be a value of @ref CORTEX_MPU_TEX_Levels                    *//*!< Specifies the number of the subregion protection to disable. 
                                                     This parameter must be a number between Min_Data = 0x00 and Max_Data = 0xFF    *//*!< Specifies the size of the region to protect. 
                                                     This parameter can be a value of @ref CORTEX_MPU_Region_Size                   *//*!< Specifies the base address of the region to protect.                           *//*!< Specifies the number of the region to protect. 
                                                     This parameter can be a value of @ref CORTEX_MPU_Region_Number                 *//*!< Specifies the status of the region. 
                                                     This parameter can be a value of @ref CORTEX_MPU_Region_Enable                 *//** @defgroup CORTEX_MPU_Region_Initialization_Structure_definition MPU Region Initialization Structure Definition
  * @brief  MPU Region initialization structure 
  * @{
  *//** @defgroup CORTEX_Exported_Types Cortex Exported Types
  * @{
  *//** @addtogroup CORTEX
  * @{
  *//**
  ******************************************************************************
  * @file    stm32f7xx_hal_cortex.h
  * @author  MCD Application Team
  * @brief   Header file of CORTEX HAL module.
  ******************************************************************************
  * @attention
  *
  * Copyright (c) 2017 STMicroelectronics.
  * All rights reserved.
  *
  * This software is licensed under terms that can be found in the LICENSE file in
  * the root directory of this software component.
  * If no LICENSE file comes with this software, it is provided AS-IS.
  *
  ******************************************************************************
  */CLKSourceMPU_InitRegionNumberTicksNumbHAL_ADCEx_MultiModeConfigChannelADC_MultiModeTypeDef *HAL_ADCEx_InjectedConfigChannelADC_InjectionConfTypeDef *HAL_ADCEx_InjectedConvCpltCallbackHAL_ADCEx_MultiModeGetValueHAL_ADCEx_MultiModeStop_DMAHAL_ADCEx_MultiModeStart_DMAHAL_ADCEx_InjectedGetValueHAL_ADCEx_InjectedStop_ITHAL_ADCEx_InjectedStart_ITHAL_ADCEx_InjectedPollForConversionHAL_ADCEx_InjectedStopHAL_ADCEx_InjectedStartADC_MultiModeTypeDefADC_InjectionConfTypeDefTwoSamplingDelayDMAAccessModeExternalTrigInjecConvEdgeExternalTrigInjecConvAutoInjectedConvInjectedDiscontinuousConvModeInjectedNbrOfConversionInjectedOffsetInjectedSamplingTimeInjectedRankInjectedChannelADC_JSQR(_CHANNELNB_,_RANKNB_,_JSQR_JL_)(((uint32_t)((uint16_t)(_CHANNELNB_))) << (5 * (uint8_t)(((_RANKNB_) + 3) - (_JSQR_JL_))))IS_ADC_INJECTED_LENGTH(__LENGTH__)(((__LENGTH__) >= ((uint32_t)1)) && ((__LENGTH__) <= ((uint32_t)4)))IS_ADC_INJECTED_RANK(__RANK__)(((__RANK__) == ADC_INJECTED_RANK_1) || ((__RANK__) == ADC_INJECTED_RANK_2) || ((__RANK__) == ADC_INJECTED_RANK_3) || ((__RANK__) == ADC_INJECTED_RANK_4))IS_ADC_EXT_INJEC_TRIG(__INJTRIG__)(((__INJTRIG__) == ADC_EXTERNALTRIGINJECCONV_T1_TRGO) || ((__INJTRIG__) == ADC_EXTERNALTRIGINJECCONV_T1_CC4) || ((__INJTRIG__) == ADC_EXTERNALTRIGINJECCONV_T2_TRGO) || ((__INJTRIG__) == ADC_EXTERNALTRIGINJECCONV_T2_CC1) || ((__INJTRIG__) == ADC_EXTERNALTRIGINJECCONV_T3_CC4) || ((__INJTRIG__) == ADC_EXTERNALTRIGINJECCONV_T4_TRGO) || ((__INJTRIG__) == ADC_EXTERNALTRIGINJECCONV_T8_CC4) || ((__INJTRIG__) == ADC_EXTERNALTRIGINJECCONV_T1_TRGO2) || ((__INJTRIG__) == ADC_EXTERNALTRIGINJECCONV_T8_TRGO) || ((__INJTRIG__) == ADC_EXTERNALTRIGINJECCONV_T8_TRGO2) || ((__INJTRIG__) == ADC_EXTERNALTRIGINJECCONV_T3_CC3) || ((__INJTRIG__) == ADC_EXTERNALTRIGINJECCONV_T5_TRGO) || ((__INJTRIG__) == ADC_EXTERNALTRIGINJECCONV_T3_CC1) || ((__INJTRIG__) == ADC_EXTERNALTRIGINJECCONV_T6_TRGO) || ((__INJTRIG__) == ADC_INJECTED_SOFTWARE_START))IS_ADC_EXT_INJEC_TRIG_EDGE(__EDGE__)(((__EDGE__) == ADC_EXTERNALTRIGINJECCONVEDGE_NONE) || ((__EDGE__) == ADC_EXTERNALTRIGINJECCONVEDGE_RISING) || ((__EDGE__) == ADC_EXTERNALTRIGINJECCONVEDGE_FALLING) || ((__EDGE__) == ADC_EXTERNALTRIGINJECCONVEDGE_RISINGFALLING))IS_ADC_DMA_ACCESS_MODE(__MODE__)(((__MODE__) == ADC_DMAACCESSMODE_DISABLED) || ((__MODE__) == ADC_DMAACCESSMODE_1) || ((__MODE__) == ADC_DMAACCESSMODE_2) || ((__MODE__) == ADC_DMAACCESSMODE_3))IS_ADC_MODE(__MODE__)(((__MODE__) == ADC_MODE_INDEPENDENT) || ((__MODE__) == ADC_DUALMODE_REGSIMULT_INJECSIMULT) || ((__MODE__) == ADC_DUALMODE_REGSIMULT_ALTERTRIG) || ((__MODE__) == ADC_DUALMODE_INJECSIMULT) || ((__MODE__) == ADC_DUALMODE_REGSIMULT) || ((__MODE__) == ADC_DUALMODE_INTERL) || ((__MODE__) == ADC_DUALMODE_ALTERTRIG) || ((__MODE__) == ADC_TRIPLEMODE_REGSIMULT_INJECSIMULT) || ((__MODE__) == ADC_TRIPLEMODE_REGSIMULT_AlterTrig) || ((__MODE__) == ADC_TRIPLEMODE_INJECSIMULT) || ((__MODE__) == ADC_TRIPLEMODE_REGSIMULT) || ((__MODE__) == ADC_TRIPLEMODE_INTERL) || ((__MODE__) == ADC_TRIPLEMODE_ALTERTRIG))ADC_INJECTED_RANK_4ADC_INJECTED_RANK_3ADC_INJECTED_RANK_2ADC_INJECTED_RANK_1ADC_INJECTED_SOFTWARE_START((uint32_t)ADC_CR2_JEXTSEL + 1)ADC_EXTERNALTRIGINJECCONV_T6_TRGO((uint32_t)(ADC_CR2_JEXTSEL_3 | ADC_CR2_JEXTSEL_2 | ADC_CR2_JEXTSEL_1))ADC_EXTERNALTRIGINJECCONV_T3_CC1((uint32_t)(ADC_CR2_JEXTSEL_3 | ADC_CR2_JEXTSEL_2 | ADC_CR2_JEXTSEL_0))ADC_EXTERNALTRIGINJECCONV_T5_TRGO((uint32_t)(ADC_CR2_JEXTSEL_3 | ADC_CR2_JEXTSEL_2))ADC_EXTERNALTRIGINJECCONV_T3_CC3((uint32_t)(ADC_CR2_JEXTSEL_3 | ADC_CR2_JEXTSEL_1 | ADC_CR2_JEXTSEL_0))ADC_EXTERNALTRIGINJECCONV_T8_TRGO2((uint32_t)(ADC_CR2_JEXTSEL_3 | ADC_CR2_JEXTSEL_1))ADC_EXTERNALTRIGINJECCONV_T8_TRGO((uint32_t)(ADC_CR2_JEXTSEL_3 | ADC_CR2_JEXTSEL_0))ADC_EXTERNALTRIGINJECCONV_T1_TRGO2((uint32_t)ADC_CR2_JEXTSEL_3)ADC_EXTERNALTRIGINJECCONV_T8_CC4((uint32_t)(ADC_CR2_JEXTSEL_2 | ADC_CR2_JEXTSEL_1 | ADC_CR2_JEXTSEL_0))ADC_EXTERNALTRIGINJECCONV_T4_TRGO((uint32_t)(ADC_CR2_JEXTSEL_2 | ADC_CR2_JEXTSEL_0))ADC_EXTERNALTRIGINJECCONV_T3_CC4((uint32_t)ADC_CR2_JEXTSEL_2)ADC_EXTERNALTRIGINJECCONV_T2_CC1((uint32_t)(ADC_CR2_JEXTSEL_1 | ADC_CR2_JEXTSEL_0))ADC_EXTERNALTRIGINJECCONV_T2_TRGO((uint32_t)ADC_CR2_JEXTSEL_1)ADC_EXTERNALTRIGINJECCONV_T1_CC4((uint32_t)ADC_CR2_JEXTSEL_0)ADC_EXTERNALTRIGINJECCONV_T1_TRGOADC_EXTERNALTRIGINJECCONVEDGE_RISINGFALLING((uint32_t)ADC_CR2_JEXTEN)ADC_EXTERNALTRIGINJECCONVEDGE_FALLING((uint32_t)ADC_CR2_JEXTEN_1)ADC_EXTERNALTRIGINJECCONVEDGE_RISING((uint32_t)ADC_CR2_JEXTEN_0)ADC_EXTERNALTRIGINJECCONVEDGE_NONEADC_DMAACCESSMODE_3((uint32_t)ADC_CCR_DMA)ADC_DMAACCESSMODE_2((uint32_t)ADC_CCR_DMA_1)ADC_DMAACCESSMODE_1((uint32_t)ADC_CCR_DMA_0)ADC_DMAACCESSMODE_DISABLEDADC_TRIPLEMODE_ALTERTRIG((uint32_t)(ADC_CCR_MULTI_4 | ADC_CCR_MULTI_3 | ADC_CCR_MULTI_0))ADC_TRIPLEMODE_INTERL((uint32_t)(ADC_CCR_MULTI_4 | ADC_CCR_MULTI_2 | ADC_CCR_MULTI_1 | ADC_CCR_MULTI_0))ADC_TRIPLEMODE_REGSIMULT((uint32_t)(ADC_CCR_MULTI_4 | ADC_CCR_MULTI_2 | ADC_CCR_MULTI_1))ADC_TRIPLEMODE_INJECSIMULT((uint32_t)(ADC_CCR_MULTI_4 | ADC_CCR_MULTI_2 | ADC_CCR_MULTI_0))ADC_TRIPLEMODE_REGSIMULT_AlterTrig((uint32_t)(ADC_CCR_MULTI_4 | ADC_CCR_MULTI_1))ADC_TRIPLEMODE_REGSIMULT_INJECSIMULT((uint32_t)(ADC_CCR_MULTI_4 | ADC_CCR_MULTI_0))ADC_DUALMODE_ALTERTRIG((uint32_t)(ADC_CCR_MULTI_3 | ADC_CCR_MULTI_0))ADC_DUALMODE_INTERL((uint32_t)(ADC_CCR_MULTI_2 | ADC_CCR_MULTI_1 | ADC_CCR_MULTI_0))ADC_DUALMODE_REGSIMULT((uint32_t)(ADC_CCR_MULTI_2 | ADC_CCR_MULTI_1))ADC_DUALMODE_INJECSIMULT((uint32_t)(ADC_CCR_MULTI_2 | ADC_CCR_MULTI_0))ADC_DUALMODE_REGSIMULT_ALTERTRIG((uint32_t)ADC_CCR_MULTI_1)ADC_DUALMODE_REGSIMULT_INJECSIMULT((uint32_t)ADC_CCR_MULTI_0)ADC_MODE_INDEPENDENTSTM32F7xx_ADC_EX_H/* STM32F7xx_ADC_EX_H *//** @defgroup ADCEx_Private_Functions ADC Private Functions
  * @{
  *//**
  * @brief  Set the selected injected Channel rank.
  * @param  _CHANNELNB_ Channel number.
  * @param  _RANKNB_ Rank number. 
  * @param  _JSQR_JL_ Sequence length.     
  * @retval None
  *//** @defgroup ADCEx_Private_Macros ADC Private Macros
  * @{
  *//** @defgroup ADCEx_Private_Constants ADC Private Constants
  * @{
  *//* Peripheral Control functions *************************************************//* I/O operation functions ******************************************************//** @addtogroup ADCEx_Exported_Functions_Group1
  * @{
  *//** @addtogroup ADCEx_Exported_Functions
  * @{
  *//** @defgroup ADC_Exported_Macros ADC Exported Macros
  * @{
  *//** @defgroup ADCEx_channels  ADC Specific Channels
  * @{
  *//** @defgroup ADCEx_injected_rank ADC Injected Channel Rank
  * @{
  *//** @defgroup ADCEx_External_trigger_Source_Injected ADC External Trigger Source Injected
  * @{
  *//** @defgroup ADCEx_External_trigger_edge_Injected ADC External Trigger Edge Injected
  * @{
  *//*!< DMA mode 3 enabled (2 / 3 bytes by pairs - 2&1 then 1&3 then 3&2) *//*!< DMA mode 2 enabled (2 / 3 half-words by pairs - 2&1 then 1&3 then 3&2)*//*!< DMA mode 1 enabled (2 / 3 half-words one by one - 1 then 2 then 3)*//*!< DMA mode disabled *//** @defgroup ADCEx_Direct_memory_access_mode_for_multi_mode ADC Direct Memory Access Mode For Multi Mode
  * @{
  *//** @defgroup ADCEx_Common_mode ADC Common Mode
  * @{
  *//** @defgroup ADCEx_Exported_Constants ADC Exported Constants
  * @{
  *//*!< Configures the Delay between 2 sampling phases.
                                   This parameter can be a value of @ref ADC_delay_between_2_sampling_phases *//*!< Configures the Direct memory access mode for multi ADC mode.
                                   This parameter can be a value of @ref ADCEx_Direct_memory_access_mode_for_multi_mode *//*!< Configures the ADC to operate in independent or multi mode. 
                                   This parameter can be a value of @ref ADCEx_Common_mode *//** 
  * @brief ADC Configuration multi-mode structure definition  
  *//*!< Selects the external trigger edge of injected group.
                                                      This parameter can be a value of @ref ADCEx_External_trigger_edge_Injected.
                                                      If trigger is set to ADC_INJECTED_SOFTWARE_START, this parameter is discarded.
                                                      Caution: this setting impacts the entire injected group. Therefore, call of HAL_ADCEx_InjectedConfigChannel() to 
                                                               configure a channel on injected group can impact the configuration of other channels previously set. *//*!< Selects the external event used to trigger the conversion start of injected group.
                                                      If set to ADC_INJECTED_SOFTWARE_START, external triggers are disabled.
                                                      If set to external trigger source, triggering is on event rising edge.
                                                      This parameter can be a value of @ref ADCEx_External_trigger_Source_Injected
                                                      Note: This parameter must be modified when ADC is disabled (before ADC start conversion or after ADC stop conversion).
                                                            If ADC is enabled, this parameter setting is bypassed without error reporting (as it can be the expected behaviour in case of another parameter update on the fly)
                                                      Caution: this setting impacts the entire injected group. Therefore, call of HAL_ADCEx_InjectedConfigChannel() to
                                                               configure a channel on injected group can impact the configuration of other channels previously set. *//*!< Enables or disables the selected ADC automatic injected group conversion after regular one
                                                      This parameter can be set to ENABLE or DISABLE.      
                                                      Note: To use Automatic injected conversion, discontinuous mode must be disabled ('DiscontinuousConvMode' and 'InjectedDiscontinuousConvMode' set to DISABLE)
                                                      Note: To use Automatic injected conversion, injected group external triggers must be disabled ('ExternalTrigInjecConv' set to ADC_SOFTWARE_START)
                                                      Note: In case of DMA used with regular group: if DMA configured in normal mode (single shot) JAUTO will be stopped upon DMA transfer complete.
                                                            To maintain JAUTO always enabled, DMA must be configured in circular mode.
                                                      Caution: this setting impacts the entire injected group. Therefore, call of HAL_ADCEx_InjectedConfigChannel() to
                                                               configure a channel on injected group can impact the configuration of other channels previously set. *//*!< Specifies whether the conversions sequence of injected group is performed in Complete-sequence/Discontinuous-sequence (main sequence subdivided in successive parts).
                                                      Discontinuous mode is used only if sequencer is enabled (parameter 'ScanConvMode'). If sequencer is disabled, this parameter is discarded.
                                                      Discontinuous mode can be enabled only if continuous mode is disabled. If continuous mode is enabled, this parameter setting is discarded.
                                                      This parameter can be set to ENABLE or DISABLE.
                                                      Note: For injected group, number of discontinuous ranks increment is fixed to one-by-one.
                                                      Caution: this setting impacts the entire injected group. Therefore, call of HAL_ADCEx_InjectedConfigChannel() to 
                                                               configure a channel on injected group can impact the configuration of other channels previously set. *//*!< Specifies the number of ranks that will be converted within the injected group sequencer.
                                                      To use the injected group sequencer and convert several ranks, parameter 'ScanConvMode' must be enabled.
                                                      This parameter must be a number between Min_Data = 1 and Max_Data = 4.
                                                      Caution: this setting impacts the entire injected group. Therefore, call of HAL_ADCEx_InjectedConfigChannel() to 
                                                               configure a channel on injected group can impact the configuration of other channels previously set. *//*!< Defines the offset to be subtracted from the raw converted data (for channels set on injected group only).
                                                      Offset value must be a positive number.
                                                      Depending of ADC resolution selected (12, 10, 8 or 6 bits),
                                                      this parameter must be a number between Min_Data = 0x000 and Max_Data = 0xFFF, 0x3FF, 0xFF or 0x3F respectively. *//*!< Sampling time value to be set for the selected channel.
                                                      Unit: ADC clock cycles
                                                      Conversion time is the addition of sampling time and processing time (12 ADC clock cycles at ADC resolution 12 bits, 11 cycles at 10 bits, 9 cycles at 8 bits, 7 cycles at 6 bits).
                                                      This parameter can be a value of @ref ADC_sampling_times
                                                      Caution: This parameter updates the parameter property of the channel, that can be used into regular and/or injected groups.
                                                               If this same channel has been previously configured in the other group (regular/injected), it will be updated to last setting.
                                                      Note: In case of usage of internal measurement channels (VrefInt/Vbat/TempSensor),
                                                            sampling time constraints must be respected (sampling time can be adjusted in function of ADC clock frequency and sampling time setting)
                                                            Refer to device datasheet for timings values, parameters TS_vrefint, TS_temp (values rough order: 4us min). *//*!< Rank in the injected group sequencer
                                                      This parameter must be a value of @ref ADCEx_injected_rank
                                                      Note: In case of need to disable a channel or change order of conversion sequencer, rank containing a previous channel setting can be overwritten by the new channel setting (or parameter number of conversions can be adjusted) *//*!< Selection of ADC channel to configure
                                                      This parameter can be a value of @ref ADC_channels
                                                      Note: Depending on devices, some channels may not be available on package pins. Refer to device datasheet for channels availability. *//** 
  * @brief  ADC Configuration injected Channel structure definition
  * @note   Parameters of this structure are shared within 2 scopes:
  *          - Scope channel: InjectedChannel, InjectedRank, InjectedSamplingTime, InjectedOffset
  *          - Scope injected group (affects all channels of injected group): InjectedNbrOfConversion, InjectedDiscontinuousConvMode,
  *            AutoInjectedConv, ExternalTrigInjecConvEdge, ExternalTrigInjecConv.
  * @note   The setting of these parameters with function HAL_ADCEx_InjectedConfigChannel() is conditioned to ADC state.
  *         ADC state can be either:
  *          - For all parameters: ADC disabled
  *          - For all except parameters 'InjectedDiscontinuousConvMode' and 'AutoInjectedConv': ADC enabled without conversion on going on injected group.
  *          - For parameters 'ExternalTrigInjecConv' and 'ExternalTrigInjecConvEdge': ADC enabled, even with conversion on going on injected group.
  *//** @defgroup ADCEx_Exported_Types ADC Exported Types
  * @{
  *//** @addtogroup ADCEx
  * @{
  *//**
  ******************************************************************************
  * @file    stm32f7xx_hal_adc.h
  * @author  MCD Application Team
  * @brief   Header file of ADC HAL module.
  ******************************************************************************
  * @attention
  *
  * Copyright (c) 2017 STMicroelectronics.
  * All rights reserved.
  *
  * This software is licensed under terms that can be found in the LICENSE file
  * in the root directory of this software component.
  * If no LICENSE file comes with this software, it is provided AS-IS.
  *
  ******************************************************************************
  */hadcmultimodesConfigInjected"stm32f7xx_hal_adc_ex.h"HAL_ADC_GetErrorHAL_ADC_GetStateHAL_ADC_AnalogWDGConfigADC_AnalogWDGConfTypeDef *HAL_ADC_ConfigChannelHAL_ADC_ErrorCallbackHAL_ADC_LevelOutOfWindowCallbackHAL_ADC_ConvHalfCpltCallbackHAL_ADC_ConvCpltCallbackHAL_ADC_GetValueHAL_ADC_Stop_DMAHAL_ADC_Start_DMAHAL_ADC_IRQHandlerHAL_ADC_Stop_ITHAL_ADC_Start_ITHAL_ADC_PollForEventHAL_ADC_PollForConversionHAL_ADC_StopHAL_ADC_StartHAL_ADC_MspDeInitHAL_ADC_MspInitHAL_ADC_DeInitHAL_ADC_InitADC_HandleTypeDefADC_AnalogWDGConfTypeDefADC_ChannelConfTypeDefADC_InitTypeDefDMA_HandleNbrOfCurrentConversionRankWatchdogNumberITModeLowThresholdHighThresholdWatchdogModeOffsetSamplingTimeRankDMAContinuousRequestsExternalTrigConvEdgeExternalTrigConvNbrOfDiscConversionDiscontinuousConvModeNbrOfConversionContinuousConvModeEOCSelectionScanConvModeDataAlignResolutionClockPrescalerADC_GET_RESOLUTION(__HANDLE__)(((__HANDLE__)->Instance->CR1) & ADC_CR1_RES)ADC_CR2_DMAContReq(_DMAContReq_MODE_)((_DMAContReq_MODE_) << 9)ADC_CR2_EOCSelection(_EOCSelection_MODE_)((_EOCSelection_MODE_) << 10)ADC_CR1_SCANCONV(_SCANCONV_MODE_)((_SCANCONV_MODE_) << 8)ADC_CR1_DISCONTINUOUS(_NBR_DISCONTINUOUSCONV_)(((_NBR_DISCONTINUOUSCONV_) - 1) << ADC_CR1_DISCNUM_Pos)ADC_CR2_CONTINUOUS(_CONTINUOUS_MODE_)((_CONTINUOUS_MODE_) << 1)ADC_SQR1_RK(_CHANNELNB_,_RANKNB_)(((uint32_t)((uint16_t)(_CHANNELNB_))) << (5 * ((_RANKNB_) - 13)))ADC_SQR2_RK(_CHANNELNB_,_RANKNB_)(((uint32_t)((uint16_t)(_CHANNELNB_))) << (5 * ((_RANKNB_) - 7)))ADC_SQR3_RK(_CHANNELNB_,_RANKNB_)(((uint32_t)((uint16_t)(_CHANNELNB_))) << (5 * ((_RANKNB_) - 1)))ADC_SMPR2(_SAMPLETIME_,_CHANNELNB_)((_SAMPLETIME_) << (3 * ((uint32_t)((uint16_t)(_CHANNELNB_)))))ADC_SMPR1(_SAMPLETIME_,_CHANNELNB_)((_SAMPLETIME_) << (3 * (((uint32_t)((uint16_t)(_CHANNELNB_))) - 10)))ADC_SQR1(_NbrOfConversion_)(((_NbrOfConversion_) - (uint8_t)1) << 20)IS_ADC_RANGE(__RESOLUTION__,__ADC_VALUE__)((((__RESOLUTION__) == ADC_RESOLUTION_12B) && ((__ADC_VALUE__) <= ((uint32_t)0x0FFF))) || (((__RESOLUTION__) == ADC_RESOLUTION_10B) && ((__ADC_VALUE__) <= ((uint32_t)0x03FF))) || (((__RESOLUTION__) == ADC_RESOLUTION_8B) && ((__ADC_VALUE__) <= ((uint32_t)0x00FF))) || (((__RESOLUTION__) == ADC_RESOLUTION_6B) && ((__ADC_VALUE__) <= ((uint32_t)0x003F))))IS_ADC_REGULAR_DISC_NUMBER(__NUMBER__)(((__NUMBER__) >= ((uint32_t)1)) && ((__NUMBER__) <= ((uint32_t)8)))IS_ADC_REGULAR_LENGTH(__LENGTH__)(((__LENGTH__) >= ((uint32_t)1)) && ((__LENGTH__) <= ((uint32_t)16)))IS_ADC_THRESHOLD(__THRESHOLD__)((__THRESHOLD__) <= ((uint32_t)0xFFF))IS_ADC_SCAN_MODE(__SCAN_MODE__)(((__SCAN_MODE__) == ADC_SCAN_DISABLE) || ((__SCAN_MODE__) == ADC_SCAN_ENABLE))IS_ADC_REGULAR_RANK(__RANK__)(((__RANK__) == ADC_REGULAR_RANK_1 ) || ((__RANK__) == ADC_REGULAR_RANK_2 ) || ((__RANK__) == ADC_REGULAR_RANK_3 ) || ((__RANK__) == ADC_REGULAR_RANK_4 ) || ((__RANK__) == ADC_REGULAR_RANK_5 ) || ((__RANK__) == ADC_REGULAR_RANK_6 ) || ((__RANK__) == ADC_REGULAR_RANK_7 ) || ((__RANK__) == ADC_REGULAR_RANK_8 ) || ((__RANK__) == ADC_REGULAR_RANK_9 ) || ((__RANK__) == ADC_REGULAR_RANK_10) || ((__RANK__) == ADC_REGULAR_RANK_11) || ((__RANK__) == ADC_REGULAR_RANK_12) || ((__RANK__) == ADC_REGULAR_RANK_13) || ((__RANK__) == ADC_REGULAR_RANK_14) || ((__RANK__) == ADC_REGULAR_RANK_15) || ((__RANK__) == ADC_REGULAR_RANK_16))IS_ADC_CHANNELS_TYPE(CHANNEL_TYPE)(((CHANNEL_TYPE) == ADC_ALL_CHANNELS) || ((CHANNEL_TYPE) == ADC_REGULAR_CHANNELS) || ((CHANNEL_TYPE) == ADC_INJECTED_CHANNELS))IS_ADC_ANALOG_WATCHDOG(__WATCHDOG__)(((__WATCHDOG__) == ADC_ANALOGWATCHDOG_SINGLE_REG) || ((__WATCHDOG__) == ADC_ANALOGWATCHDOG_SINGLE_INJEC) || ((__WATCHDOG__) == ADC_ANALOGWATCHDOG_SINGLE_REGINJEC) || ((__WATCHDOG__) == ADC_ANALOGWATCHDOG_ALL_REG) || ((__WATCHDOG__) == ADC_ANALOGWATCHDOG_ALL_INJEC) || ((__WATCHDOG__) == ADC_ANALOGWATCHDOG_ALL_REGINJEC) || ((__WATCHDOG__) == ADC_ANALOGWATCHDOG_NONE))IS_ADC_EVENT_TYPE(__EVENT__)(((__EVENT__) == ADC_AWD_EVENT) || ((__EVENT__) == ADC_OVR_EVENT))IS_ADC_EOCSelection(__EOCSelection__)(((__EOCSelection__) == ADC_EOC_SINGLE_CONV) || ((__EOCSelection__) == ADC_EOC_SEQ_CONV) || ((__EOCSelection__) == ADC_EOC_SINGLE_SEQ_CONV))IS_ADC_SAMPLE_TIME(__TIME__)(((__TIME__) == ADC_SAMPLETIME_3CYCLES) || ((__TIME__) == ADC_SAMPLETIME_15CYCLES) || ((__TIME__) == ADC_SAMPLETIME_28CYCLES) || ((__TIME__) == ADC_SAMPLETIME_56CYCLES) || ((__TIME__) == ADC_SAMPLETIME_84CYCLES) || ((__TIME__) == ADC_SAMPLETIME_112CYCLES) || ((__TIME__) == ADC_SAMPLETIME_144CYCLES) || ((__TIME__) == ADC_SAMPLETIME_480CYCLES))IS_ADC_DATA_ALIGN(__ALIGN__)(((__ALIGN__) == ADC_DATAALIGN_RIGHT) || ((__ALIGN__) == ADC_DATAALIGN_LEFT))IS_ADC_EXT_TRIG(__REGTRIG__)(((__REGTRIG__) == ADC_EXTERNALTRIGCONV_T1_CC1) || ((__REGTRIG__) == ADC_EXTERNALTRIGCONV_T1_CC2) || ((__REGTRIG__) == ADC_EXTERNALTRIGCONV_T1_CC3) || ((__REGTRIG__) == ADC_EXTERNALTRIGCONV_T2_CC2) || ((__REGTRIG__) == ADC_EXTERNALTRIGCONV_T5_TRGO) || ((__REGTRIG__) == ADC_EXTERNALTRIGCONV_T4_CC4) || ((__REGTRIG__) == ADC_EXTERNALTRIGCONV_T3_CC4) || ((__REGTRIG__) == ADC_EXTERNALTRIGCONV_T8_TRGO) || ((__REGTRIG__) == ADC_EXTERNALTRIGCONV_T8_TRGO2) || ((__REGTRIG__) == ADC_EXTERNALTRIGCONV_T1_TRGO) || ((__REGTRIG__) == ADC_EXTERNALTRIGCONV_T1_TRGO2) || ((__REGTRIG__) == ADC_EXTERNALTRIGCONV_T2_TRGO) || ((__REGTRIG__) == ADC_EXTERNALTRIGCONV_T4_TRGO) || ((__REGTRIG__) == ADC_EXTERNALTRIGCONV_T6_TRGO) || ((__REGTRIG__) == ADC_EXTERNALTRIGCONV_EXT_IT11) || ((__REGTRIG__) == ADC_SOFTWARE_START))IS_ADC_EXT_TRIG_EDGE(__EDGE__)(((__EDGE__) == ADC_EXTERNALTRIGCONVEDGE_NONE) || ((__EDGE__) == ADC_EXTERNALTRIGCONVEDGE_RISING) || ((__EDGE__) == ADC_EXTERNALTRIGCONVEDGE_FALLING) || ((__EDGE__) == ADC_EXTERNALTRIGCONVEDGE_RISINGFALLING))IS_ADC_RESOLUTION(__RESOLUTION__)(((__RESOLUTION__) == ADC_RESOLUTION_12B) || ((__RESOLUTION__) == ADC_RESOLUTION_10B) || ((__RESOLUTION__) == ADC_RESOLUTION_8B) || ((__RESOLUTION__) == ADC_RESOLUTION_6B))IS_ADC_SAMPLING_DELAY(__DELAY__)(((__DELAY__) == ADC_TWOSAMPLINGDELAY_5CYCLES) || ((__DELAY__) == ADC_TWOSAMPLINGDELAY_6CYCLES) || ((__DELAY__) == ADC_TWOSAMPLINGDELAY_7CYCLES) || ((__DELAY__) == ADC_TWOSAMPLINGDELAY_8CYCLES) || ((__DELAY__) == ADC_TWOSAMPLINGDELAY_9CYCLES) || ((__DELAY__) == ADC_TWOSAMPLINGDELAY_10CYCLES) || ((__DELAY__) == ADC_TWOSAMPLINGDELAY_11CYCLES) || ((__DELAY__) == ADC_TWOSAMPLINGDELAY_12CYCLES) || ((__DELAY__) == ADC_TWOSAMPLINGDELAY_13CYCLES) || ((__DELAY__) == ADC_TWOSAMPLINGDELAY_14CYCLES) || ((__DELAY__) == ADC_TWOSAMPLINGDELAY_15CYCLES) || ((__DELAY__) == ADC_TWOSAMPLINGDELAY_16CYCLES) || ((__DELAY__) == ADC_TWOSAMPLINGDELAY_17CYCLES) || ((__DELAY__) == ADC_TWOSAMPLINGDELAY_18CYCLES) || ((__DELAY__) == ADC_TWOSAMPLINGDELAY_19CYCLES) || ((__DELAY__) == ADC_TWOSAMPLINGDELAY_20CYCLES))IS_ADC_CLOCKPRESCALER(__ADC_CLOCK__)(((__ADC_CLOCK__) == ADC_CLOCK_SYNC_PCLK_DIV2) || ((__ADC_CLOCK__) == ADC_CLOCK_SYNC_PCLK_DIV4) || ((__ADC_CLOCK__) == ADC_CLOCK_SYNC_PCLK_DIV6) || ((__ADC_CLOCK__) == ADC_CLOCK_SYNC_PCLK_DIV8))IS_ADC_CHANNEL(CHANNEL)(((CHANNEL) <= ADC_CHANNEL_18) || ((CHANNEL) == ADC_CHANNEL_TEMPSENSOR) || ((CHANNEL) == ADC_INTERNAL_NONE))ADC_CLEAR_ERRORCODE(__HANDLE__)((__HANDLE__)->ErrorCode = HAL_ADC_ERROR_NONE)ADC_STATE_CLR_SETMODIFY_REGADC_IS_SOFTWARE_START_INJECTED(__HANDLE__)(((__HANDLE__)->Instance->CR2 & ADC_CR2_JEXTEN) == RESET)ADC_IS_SOFTWARE_START_REGULAR(__HANDLE__)(((__HANDLE__)->Instance->CR2 & ADC_CR2_EXTEN) == RESET)ADC_IS_ENABLE(__HANDLE__)((( ((__HANDLE__)->Instance->SR & ADC_SR_ADONS) == ADC_SR_ADONS ) ) ? SET : RESET)ADC_TEMPSENSOR_DELAY_US((uint32_t) 10U)ADC_STAB_DELAY_US((uint32_t) 3U)__HAL_ADC_GET_FLAG(__HANDLE__,__FLAG__)((((__HANDLE__)->Instance->SR) & (__FLAG__)) == (__FLAG__))__HAL_ADC_CLEAR_FLAG(__HANDLE__,__FLAG__)(((__HANDLE__)->Instance->SR) = ~(__FLAG__))__HAL_ADC_GET_IT_SOURCE(__HANDLE__,__INTERRUPT__)(((__HANDLE__)->Instance->CR1 & (__INTERRUPT__)) == (__INTERRUPT__))__HAL_ADC_DISABLE_IT(__HANDLE__,__INTERRUPT__)(((__HANDLE__)->Instance->CR1) &= ~(__INTERRUPT__))__HAL_ADC_ENABLE_IT(__HANDLE__,__INTERRUPT__)(((__HANDLE__)->Instance->CR1) |= (__INTERRUPT__))__HAL_ADC_DISABLE(__HANDLE__)((__HANDLE__)->Instance->CR2 &= ~ADC_CR2_ADON)__HAL_ADC_ENABLE(__HANDLE__)((__HANDLE__)->Instance->CR2 |= ADC_CR2_ADON)__HAL_ADC_RESET_HANDLE_STATE(__HANDLE__)((__HANDLE__)->State = HAL_ADC_STATE_RESET)ADC_FLAG_OVR((uint32_t)ADC_SR_OVR)ADC_FLAG_STRT((uint32_t)ADC_SR_STRT)ADC_FLAG_JSTRT((uint32_t)ADC_SR_JSTRT)ADC_FLAG_JEOC((uint32_t)ADC_SR_JEOC)ADC_FLAG_EOC((uint32_t)ADC_SR_EOC)ADC_FLAG_AWD((uint32_t)ADC_SR_AWD)ADC_IT_OVR((uint32_t)ADC_CR1_OVRIE)ADC_IT_JEOC((uint32_t)ADC_CR1_JEOCIE)ADC_IT_AWD((uint32_t)ADC_CR1_AWDIE)ADC_IT_EOC((uint32_t)ADC_CR1_EOCIE)ADC_ANALOGWATCHDOG_NONEADC_ANALOGWATCHDOG_ALL_REGINJEC((uint32_t)(ADC_CR1_AWDEN | ADC_CR1_JAWDEN))ADC_ANALOGWATCHDOG_ALL_INJEC((uint32_t)ADC_CR1_JAWDEN)ADC_ANALOGWATCHDOG_ALL_REG((uint32_t)ADC_CR1_AWDEN)ADC_ANALOGWATCHDOG_SINGLE_REGINJEC((uint32_t)(ADC_CR1_AWDSGL | ADC_CR1_AWDEN | ADC_CR1_JAWDEN))ADC_ANALOGWATCHDOG_SINGLE_INJEC((uint32_t)(ADC_CR1_AWDSGL | ADC_CR1_JAWDEN))ADC_ANALOGWATCHDOG_SINGLE_REG((uint32_t)(ADC_CR1_AWDSGL | ADC_CR1_AWDEN))((uint32_t)ADC_FLAG_OVR)((uint32_t)ADC_FLAG_AWD)ADC_SAMPLETIME_480CYCLES((uint32_t)ADC_SMPR1_SMP10)ADC_SAMPLETIME_144CYCLES((uint32_t)(ADC_SMPR1_SMP10_2 | ADC_SMPR1_SMP10_1))ADC_SAMPLETIME_112CYCLES((uint32_t)(ADC_SMPR1_SMP10_2 | ADC_SMPR1_SMP10_0))ADC_SAMPLETIME_84CYCLES((uint32_t)ADC_SMPR1_SMP10_2)ADC_SAMPLETIME_56CYCLES((uint32_t)(ADC_SMPR1_SMP10_1 | ADC_SMPR1_SMP10_0))ADC_SAMPLETIME_28CYCLES((uint32_t)ADC_SMPR1_SMP10_1)ADC_SAMPLETIME_15CYCLES((uint32_t)ADC_SMPR1_SMP10_0)ADC_CHANNEL_TEMPSENSOR((uint32_t)(ADC_CHANNEL_18 | 0x10000000U))ADC_CHANNEL_VBAT((uint32_t)ADC_CHANNEL_18)ADC_CHANNEL_VREFINT((uint32_t)ADC_CHANNEL_17)ADC_INTERNAL_NONE0x80000000UADC_CHANNEL_18((uint32_t)(ADC_CR1_AWDCH_4 | ADC_CR1_AWDCH_1))ADC_CHANNEL_17((uint32_t)(ADC_CR1_AWDCH_4 | ADC_CR1_AWDCH_0))ADC_CHANNEL_16((uint32_t)ADC_CR1_AWDCH_4)ADC_CHANNEL_15((uint32_t)(ADC_CR1_AWDCH_3 | ADC_CR1_AWDCH_2 | ADC_CR1_AWDCH_1 | ADC_CR1_AWDCH_0))ADC_CHANNEL_14((uint32_t)(ADC_CR1_AWDCH_3 | ADC_CR1_AWDCH_2 | ADC_CR1_AWDCH_1))ADC_CHANNEL_13((uint32_t)(ADC_CR1_AWDCH_3 | ADC_CR1_AWDCH_2 | ADC_CR1_AWDCH_0))ADC_CHANNEL_12((uint32_t)(ADC_CR1_AWDCH_3 | ADC_CR1_AWDCH_2))ADC_CHANNEL_11((uint32_t)(ADC_CR1_AWDCH_3 | ADC_CR1_AWDCH_1 | ADC_CR1_AWDCH_0))ADC_CHANNEL_10((uint32_t)(ADC_CR1_AWDCH_3 | ADC_CR1_AWDCH_1))ADC_CHANNEL_9((uint32_t)(ADC_CR1_AWDCH_3 | ADC_CR1_AWDCH_0))((uint32_t)ADC_CR1_AWDCH_3)ADC_CHANNEL_7((uint32_t)(ADC_CR1_AWDCH_2 | ADC_CR1_AWDCH_1 | ADC_CR1_AWDCH_0))ADC_CHANNEL_6((uint32_t)(ADC_CR1_AWDCH_2 | ADC_CR1_AWDCH_1))ADC_CHANNEL_5((uint32_t)(ADC_CR1_AWDCH_2 | ADC_CR1_AWDCH_0))ADC_CHANNEL_4((uint32_t)ADC_CR1_AWDCH_2)ADC_CHANNEL_3((uint32_t)(ADC_CR1_AWDCH_1 | ADC_CR1_AWDCH_0))ADC_CHANNEL_2((uint32_t)ADC_CR1_AWDCH_1)ADC_CHANNEL_1((uint32_t)ADC_CR1_AWDCH_0)ADC_CHANNEL_0ADC_REGULAR_RANK_16((uint32_t)0x00000010)ADC_REGULAR_RANK_15((uint32_t)0x0000000F)ADC_REGULAR_RANK_14((uint32_t)0x0000000E)ADC_REGULAR_RANK_13((uint32_t)0x0000000D)ADC_REGULAR_RANK_12((uint32_t)0x0000000C)ADC_REGULAR_RANK_11((uint32_t)0x0000000B)ADC_REGULAR_RANK_10((uint32_t)0x0000000A)ADC_REGULAR_RANK_9((uint32_t)0x00000009)ADC_REGULAR_RANK_8((uint32_t)0x00000008)ADC_REGULAR_RANK_7((uint32_t)0x00000007)ADC_REGULAR_RANK_6((uint32_t)0x00000006)ADC_REGULAR_RANK_5((uint32_t)0x00000005)ADC_REGULAR_RANK_4((uint32_t)0x00000004)ADC_REGULAR_RANK_3((uint32_t)0x00000003)ADC_REGULAR_RANK_2((uint32_t)0x00000002)ADC_REGULAR_RANK_1((uint32_t)0x00000001)ADC_SCAN_ENABLEADC_SCAN_DISABLE((uint32_t)0x00000000)ADC_DATAALIGN_LEFT((uint32_t)ADC_CR2_ALIGN)ADC_SOFTWARE_START((uint32_t)ADC_CR2_EXTSEL + 1)((uint32_t)ADC_CR2_EXTSEL)((uint32_t)(ADC_CR2_EXTSEL_3 | ADC_CR2_EXTSEL_2 | ADC_CR2_EXTSEL_0))ADC_EXTERNALTRIGCONV_T4_TRGO((uint32_t)(ADC_CR2_EXTSEL_3 | ADC_CR2_EXTSEL_2))((uint32_t)(ADC_CR2_EXTSEL_3 | ADC_CR2_EXTSEL_1 | ADC_CR2_EXTSEL_0))ADC_EXTERNALTRIGCONV_T1_TRGO2((uint32_t)(ADC_CR2_EXTSEL_3 | ADC_CR2_EXTSEL_1))ADC_EXTERNALTRIGCONV_T1_TRGO((uint32_t)(ADC_CR2_EXTSEL_3 | ADC_CR2_EXTSEL_0))ADC_EXTERNALTRIGCONV_T8_TRGO2((uint32_t)ADC_CR2_EXTSEL_3)ADC_EXTERNALTRIGCONV_T8_TRGO((uint32_t)(ADC_CR2_EXTSEL_2 | ADC_CR2_EXTSEL_1 | ADC_CR2_EXTSEL_0))ADC_EXTERNALTRIGCONV_T3_CC4((uint32_t)(ADC_CR2_EXTSEL_2 | ADC_CR2_EXTSEL_1))ADC_EXTERNALTRIGCONV_T4_CC4((uint32_t)(ADC_CR2_EXTSEL_2 | ADC_CR2_EXTSEL_0))ADC_EXTERNALTRIGCONV_T5_TRGO((uint32_t)ADC_CR2_EXTSEL_2)ADC_EXTERNALTRIGCONV_T2_CC2((uint32_t)(ADC_CR2_EXTSEL_1 | ADC_CR2_EXTSEL_0))ADC_EXTERNALTRIGCONV_T1_CC3((uint32_t)ADC_CR2_EXTSEL_1)ADC_EXTERNALTRIGCONV_T1_CC2((uint32_t)ADC_CR2_EXTSEL_0)((uint32_t)ADC_CR2_EXTEN)((uint32_t)ADC_CR2_EXTEN_1)((uint32_t)ADC_CR2_EXTEN_0)((uint32_t)ADC_CR1_RES)((uint32_t)ADC_CR1_RES_1)((uint32_t)ADC_CR1_RES_0)ADC_TWOSAMPLINGDELAY_20CYCLES((uint32_t)ADC_CCR_DELAY)ADC_TWOSAMPLINGDELAY_19CYCLES((uint32_t)(ADC_CCR_DELAY_3 | ADC_CCR_DELAY_2 | ADC_CCR_DELAY_1))ADC_TWOSAMPLINGDELAY_18CYCLES((uint32_t)(ADC_CCR_DELAY_3 | ADC_CCR_DELAY_2 | ADC_CCR_DELAY_0))ADC_TWOSAMPLINGDELAY_17CYCLES((uint32_t)(ADC_CCR_DELAY_3 | ADC_CCR_DELAY_2))ADC_TWOSAMPLINGDELAY_16CYCLES((uint32_t)(ADC_CCR_DELAY_3 | ADC_CCR_DELAY_1 | ADC_CCR_DELAY_0))ADC_TWOSAMPLINGDELAY_15CYCLES((uint32_t)(ADC_CCR_DELAY_3 | ADC_CCR_DELAY_1))ADC_TWOSAMPLINGDELAY_14CYCLES((uint32_t)(ADC_CCR_DELAY_3 | ADC_CCR_DELAY_0))ADC_TWOSAMPLINGDELAY_13CYCLES((uint32_t)ADC_CCR_DELAY_3)ADC_TWOSAMPLINGDELAY_12CYCLES((uint32_t)(ADC_CCR_DELAY_2 | ADC_CCR_DELAY_1 | ADC_CCR_DELAY_0))ADC_TWOSAMPLINGDELAY_11CYCLES((uint32_t)(ADC_CCR_DELAY_2 | ADC_CCR_DELAY_1))ADC_TWOSAMPLINGDELAY_10CYCLES((uint32_t)(ADC_CCR_DELAY_2 | ADC_CCR_DELAY_0))ADC_TWOSAMPLINGDELAY_9CYCLES((uint32_t)ADC_CCR_DELAY_2)ADC_TWOSAMPLINGDELAY_8CYCLES((uint32_t)(ADC_CCR_DELAY_1 | ADC_CCR_DELAY_0))ADC_TWOSAMPLINGDELAY_7CYCLES((uint32_t)ADC_CCR_DELAY_1)ADC_TWOSAMPLINGDELAY_6CYCLES((uint32_t)ADC_CCR_DELAY_0)ADC_TWOSAMPLINGDELAY_5CYCLES((uint32_t)ADC_CCR_ADCPRE)((uint32_t)ADC_CCR_ADCPRE_1)((uint32_t)ADC_CCR_ADCPRE_0)HAL_ADC_ERROR_DMA((uint32_t)0x04U)HAL_ADC_ERROR_OVR((uint32_t)0x02U)HAL_ADC_ERROR_INTERNAL((uint32_t)0x01U)HAL_ADC_ERROR_NONE((uint32_t)0x00U)HAL_ADC_STATE_MULTIMODE_SLAVEHAL_ADC_STATE_AWD3HAL_ADC_STATE_AWD2HAL_ADC_STATE_REG_OVRHAL_ADC_STATE_ERROR_DMAHAL_ADC_STATE_ERROR_CONFIGHAL_ADC_STATE_TIMEOUTHAL_ADC_STATE_READYHAL_ADC_STATE_RESETSTM32F7xx_ADC_H(USE_HAL_ADC_REGISTER_CALLBACKS == 1)/* STM32F7xx_ADC_H *//** @defgroup ADC_Private_Functions ADC Private Functions
  * @{
  *//**
  * @brief Return resolution bits in CR1 register.
  * @param __HANDLE__ ADC handle
  * @retval None
  *//**
  * @brief  Enable the ADC DMA continuous request.
  * @param  _DMAContReq_MODE_ DMA continuous request mode.
  * @retval None
  *//**
  * @brief  Enable the ADC end of conversion selection.
  * @param  _EOCSelection_MODE_ End of conversion selection mode.
  * @retval None
  *//**
  * @brief  Enable ADC scan mode.
  * @param  _SCANCONV_MODE_ Scan conversion mode.
  * @retval None
  *//**
  * @brief  Configures the number of discontinuous conversions for the regular group channels.
  * @param  _NBR_DISCONTINUOUSCONV_ Number of discontinuous conversions.
  * @retval None
  *//**
  * @brief  Enable ADC continuous conversion mode.
  * @param  _CONTINUOUS_MODE_ Continuous mode.
  * @retval None
  *//**
  * @brief  Set the selected regular channel rank for rank between 13 and 16.
  * @param  _CHANNELNB_ Channel number.
  * @param  _RANKNB_ Rank number.    
  * @retval None
  *//**
  * @brief  Set the selected regular channel rank for rank between 7 and 12.
  * @param  _CHANNELNB_ Channel number.
  * @param  _RANKNB_ Rank number.    
  * @retval None
  *//**
  * @brief  Set the selected regular channel rank for rank between 1 and 6.
  * @param  _CHANNELNB_ Channel number.
  * @param  _RANKNB_ Rank number.    
  * @retval None
  *//**
  * @brief  Set the ADC's sample time for channel numbers between 0 and 9.
  * @param  _SAMPLETIME_ Sample time parameter.
  * @param  _CHANNELNB_ Channel number.  
  * @retval None
  *//**
  * @brief  Set the ADC's sample time for channel numbers between 10 and 18.
  * @param  _SAMPLETIME_ Sample time parameter.
  * @param  _CHANNELNB_ Channel number.  
  * @retval None
  *//**
  * @brief  Set ADC Regular channel sequence length.
  * @param  _NbrOfConversion_ Regular channel sequence length. 
  * @retval None
  *//**
  * @brief Clear ADC error code (set it to error code: "no error")
  * @param __HANDLE__ ADC handle
  * @retval None
  *//**
  * @brief Simultaneously clears and sets specific bits of the handle State
  * @note: ADC_STATE_CLR_SET() macro is merely aliased to generic macro MODIFY_REG(),
  *        the first parameter is the ADC handle State, the second parameter is the
  *        bit field to clear, the third and last parameter is the bit field to set.
  * @retval None
  *//**
  * @brief Test if conversion trigger of injected group is software start
  *        or external trigger.
  * @param __HANDLE__ ADC handle
  * @retval SET (software start) or RESET (external trigger)
  *//**
  * @brief Test if conversion trigger of regular group is software start
  *        or external trigger.
  * @param __HANDLE__ ADC handle
  * @retval SET (software start) or RESET (external trigger)
  *//**
  * @brief Verification of ADC state: enabled or disabled
  * @param __HANDLE__ ADC handle
  * @retval SET (ADC enabled) or RESET (ADC disabled)
  *//* Macro reserved for internal HAL driver usage, not intended to be used in
   code of final user *//** @defgroup ADC_Private_Macros ADC Private Macros
  * @{
  *//* Unit: us                                                                 *//* Maximum delay is 10us (refer to device datasheet, parameter tSTART).     *//* Delay for temperature sensor stabilization time.                         *//* Maximum delay is 1us (refer to device datasheet, parameter tSTAB).       *//* Delay for ADC stabilization time.                                        *//** @defgroup ADC_Private_Constants ADC Private Constants
  * @{
  *//* Peripheral State functions ***************************************************//** @addtogroup ADC_Exported_Functions_Group4
  * @{
  *//** @addtogroup ADC_Exported_Functions_Group3
  * @{
  *//** @addtogroup ADC_Exported_Functions_Group2
  * @{
  *//* USE_HAL_ADC_REGISTER_CALLBACKS *//* Callbacks Register/UnRegister functions  ***********************************//* Initialization/de-initialization functions ***********************************//** @addtogroup ADC_Exported_Functions_Group1
  * @{
  *//** @addtogroup ADC_Exported_Functions
  * @{
  *//* Include ADC HAL Extension module *//**
  * @brief  Get the selected ADC's flag status.
  * @param  __HANDLE__ specifies the ADC Handle.
  * @param  __FLAG__ ADC flag.
  * @retval None
  *//**
  * @brief  Clear the ADC's pending flags.
  * @param  __HANDLE__ specifies the ADC Handle.
  * @param  __FLAG__ ADC flag.
  * @retval None
  *//** @brief  Check if the specified ADC interrupt source is enabled or disabled.
  * @param  __HANDLE__ specifies the ADC Handle.
  * @param  __INTERRUPT__ specifies the ADC interrupt source to check.
  * @retval The new state of __IT__ (TRUE or FALSE).
  *//**
  * @brief  Disable the ADC end of conversion interrupt.
  * @param  __HANDLE__ specifies the ADC Handle.
  * @param  __INTERRUPT__ ADC interrupt.
  * @retval None
  *//**
  * @brief  Enable the ADC end of conversion interrupt.
  * @param  __HANDLE__ specifies the ADC Handle.
  * @param  __INTERRUPT__ ADC Interrupt.
  * @retval None
  *//**
  * @brief  Disable the ADC peripheral.
  * @param  __HANDLE__ ADC handle
  * @retval None
  *//**
  * @brief  Enable the ADC peripheral.
  * @param  __HANDLE__ ADC handle
  * @retval None
  *//** @brief Reset ADC handle state
  * @param  __HANDLE__ ADC handle
  * @retval None
  *//*!< reserved for future use *//** @defgroup ADC_channels_type ADC Channels Type
  * @{
  *//** @defgroup ADC_flags_definition ADC Flags Definition
  * @{
  *//** @defgroup ADC_interrupts_definition ADC Interrupts Definition
  * @{
  *//** @defgroup ADC_analog_watchdog_selection ADC Analog Watchdog Selection
  * @{
  *//** @defgroup ADC_Event_type ADC Event Type
  * @{
  *//** @defgroup ADC_EOCSelection ADC EOC Selection
  * @{
  *//** @defgroup ADC_sampling_times ADC Sampling Times
  * @{
  *//** @defgroup ADC_channels ADC Common Channels
  * @{
  *//*!< ADC regular conversion rank 16 *//*!< ADC regular conversion rank 15 *//*!< ADC regular conversion rank 14 *//*!< ADC regular conversion rank 13 *//*!< ADC regular conversion rank 12 *//*!< ADC regular conversion rank 11 *//*!< ADC regular conversion rank 10 *//*!< ADC regular conversion rank 9  *//*!< ADC regular conversion rank 8  *//*!< ADC regular conversion rank 7  *//*!< ADC regular conversion rank 6  *//*!< ADC regular conversion rank 5  *//*!< ADC regular conversion rank 4  *//*!< ADC regular conversion rank 3  *//*!< ADC regular conversion rank 2  *//*!< ADC regular conversion rank 1  *//** @defgroup ADC_regular_rank ADC group regular sequencer rank
  * @{
  *//*!< Scan mode enabled  *//*!< Scan mode disabled *//** @defgroup ADC_Scan_mode ADC sequencer scan mode
  * @{
  *//** @defgroup ADC_Data_Align ADC Data Align
  * @{
  *//*       compatibility with other STM32 devices.                              *//* Note: Parameter ADC_SOFTWARE_START is a software parameter used for        *//** @defgroup ADC_External_trigger_Source_Regular ADC External Trigger Source Regular
  * @{
  *//** @defgroup ADC_External_trigger_edge_Regular ADC External Trigger Edge Regular
  * @{
  *//** @defgroup ADC_Resolution ADC Resolution
  * @{
  *//** @defgroup ADC_delay_between_2_sampling_phases ADC Delay Between 2 Sampling Phases
  * @{
  *//** @defgroup ADC_ClockPrescaler  ADC Clock Prescaler
  * @{
  *//*!< Invalid Callback error *//*!< DMA transfer error                                    *//*!< Overrun error                                         *//*!< ADC IP internal error: if problem of clocking, 
                                                          enable/disable, erroneous state                       *//*!< No error                                              *//** @defgroup ADC_Error_Code ADC Error Code
  * @{
  *//** @defgroup ADC_Exported_Constants ADC Exported Constants
  * @{
  *//*!< pointer to a ADC callback function *//**
  * @brief  HAL ADC Callback pointer definition
  *//*!< ADC Msp DeInit callback ID        *//*!< ADC Msp Init callback ID          *//*!< ADC group injected conversion complete callback ID *//*!< ADC error callback ID *//*!< ADC analog watchdog 1 callback ID *//*!< ADC conversion DMA half-transfer callback ID *//*!< ADC conversion complete callback ID *//**
  * @brief  HAL ADC Callback ID enumeration definition
  *//*!< ADC Msp DeInit callback *//*!< ADC Msp Init callback *//*!< ADC group injected conversion complete callback *//*!< ADC error callback *//*!< ADC analog watchdog 1 callback *//*!< ADC conversion DMA half-transfer callback *//*!< ADC conversion complete callback *//*!< ADC Error code *//*!< ADC communication state *//*!< ADC locking object *//*!< Pointer DMA Handler *//*!< ADC number of current conversion rank *//*!< ADC required parameters *//*!< Register base address *//** 
  * @brief  ADC handle Structure definition
  *//*!< Not available on STM32F7 device: ADC in multimode slave state, controlled by another ADC master ( *//* States of ADC multi-mode *//*!< Not available on STM32F7 device: Out-of-window occurrence of analog watchdog 3 *//*!< Not available on STM32F7 device: Out-of-window occurrence of analog watchdog 2 *//*!< Out-of-window occurrence of analog watchdog 1 *//* States of ADC analog watchdogs *//*!< Conversion data available on group injected *//*!< A conversion on group injected is ongoing or can occur (either by auto-injection mode,
                                                                       external trigger, low power auto power-on (if feature available), multimode ADC master control (if feature available)) *//* States of ADC group injected *//*!< Overrun occurrence *//*!< Conversion data available on group regular *//*!< A conversion on group regular is ongoing or can occur (either by continuous mode,
                                                                       external trigger, low power auto power-on (if feature available), multimode ADC master control (if feature available)) *//* States of ADC group regular *//*!< DMA error occurrence *//*!< Configuration error occurrence *//*!< Internal error occurrence *//* States of ADC errors *//*!< TimeOut occurrence *//*!< ADC is busy to internal process (initialization, calibration) *//*!< ADC peripheral ready for use *//*!< ADC not yet initialized or disabled *//* States of ADC global scope *//** 
  * @brief  HAL ADC state machine: ADC states definition (bitfields)
  *//*!< Reserved for future use, can be set to 0 *//*!< Specifies whether the analog watchdog is configured
                                   is interrupt mode or in polling mode.
                                   This parameter can be set to ENABLE or DISABLE *//*!< Configures ADC channel for the analog watchdog. 
                                   This parameter has an effect only if watchdog mode is configured on single channel 
                                   This parameter can be a value of @ref ADC_channels *//*!< Configures the ADC analog watchdog High threshold value.
                                   This parameter must be a 12-bit value. *//*!< Configures the ADC analog watchdog mode.
                                   This parameter can be a value of @ref ADC_analog_watchdog_selection *//*!< Sampling time value to be set for the selected channel.
                                        Unit: ADC clock cycles
                                        Conversion time is the addition of sampling time and processing time (12 ADC clock cycles at ADC resolution 12 bits, 11 cycles at 10 bits, 9 cycles at 8 bits, 7 cycles at 6 bits).
                                        This parameter can be a value of @ref ADC_sampling_times
                                        Caution: This parameter updates the parameter property of the channel, that can be used into regular and/or injected groups.
                                                 If this same channel has been previously configured in the other group (regular/injected), it will be updated to last setting.
                                        Note: In case of usage of internal measurement channels (VrefInt/Vbat/TempSensor),
                                              sampling time constraints must be respected (sampling time can be adjusted in function of ADC clock frequency and sampling time setting)
                                              Refer to device datasheet for timings values, parameters TS_vrefint, TS_temp (values rough order: 4us min). *//*!< Specifies the rank in the regular group sequencer.
                                        This parameter must be a number between Min_Data = 1 and Max_Data = 16 
                                        This parameter can be a value of @ref ADC_regular_rank *//*!< Specifies the channel to configure into ADC regular group.
                                        This parameter can be a value of @ref ADC_channels *//** 
  * @brief  Structure definition of ADC channel for regular group   
  * @note   The setting of these parameters with function HAL_ADC_ConfigChannel() is conditioned to ADC state.
  *         ADC can be either disabled or enabled without conversion on going on regular group.
  *//*!< Specifies whether the DMA requests are performed in one shot mode (DMA transfer stop when number of conversions is reached)
                                              or in Continuous mode (DMA transfer unlimited, whatever number of conversions).
                                              Note: In continuous mode, DMA must be configured in circular mode. Otherwise an overrun will be triggered when DMA buffer maximum pointer is reached.
                                              Note: This parameter must be modified when no conversion is on going on both regular and injected groups (ADC disabled, or ADC enabled without continuous mode or external trigger that could launch a conversion).
                                              This parameter can be set to ENABLE or DISABLE. *//*!< Selects the external trigger edge of regular group.
                                              If trigger is set to ADC_SOFTWARE_START, this parameter is discarded.
                                              This parameter can be a value of @ref ADC_External_trigger_edge_Regular *//*!< Selects the external event used to trigger the conversion start of regular group.
                                              If set to ADC_SOFTWARE_START, external triggers are disabled.
                                              If set to external trigger source, triggering is on event rising edge by default.
                                              This parameter can be a value of @ref ADC_External_trigger_Source_Regular *//*!< Specifies the number of discontinuous conversions in which the  main sequence of regular group (parameter NbrOfConversion) will be subdivided.
                                              If parameter 'DiscontinuousConvMode' is disabled, this parameter is discarded.
                                              This parameter must be a number between Min_Data = 1 and Max_Data = 8. *//*!< Specifies whether the conversions sequence of regular group is performed in Complete-sequence/Discontinuous-sequence (main sequence subdivided in successive parts).
                                              Discontinuous mode is used only if sequencer is enabled (parameter 'ScanConvMode'). If sequencer is disabled, this parameter is discarded.
                                              Discontinuous mode can be enabled only if continuous mode is disabled. If continuous mode is enabled, this parameter setting is discarded.
                                              This parameter can be set to ENABLE or DISABLE. *//*!< Specifies the number of ranks that will be converted within the regular group sequencer.
                                              To use regular group sequencer and convert several ranks, parameter 'ScanConvMode' must be enabled.
                                              This parameter must be a number between Min_Data = 1 and Max_Data = 16. *//*!< Specifies whether the conversion is performed in single mode (one conversion) or continuous mode for regular group,
                                              after the selected trigger occurred (software start or external trigger).
                                              This parameter can be set to ENABLE or DISABLE. *//*!< Specifies what EOC (End Of Conversion) flag is used for conversion by polling and interruption: end of conversion of each rank or complete sequence.
                                              This parameter can be a value of @ref ADC_EOCSelection.
                                              Note: For injected group, end of conversion (flag&IT) is raised only at the end of the sequence.
                                                    Therefore, if end of conversion is set to end of each conversion, injected group should not be used with interruption (HAL_ADCEx_InjectedStart_IT)
                                                    or polling (HAL_ADCEx_InjectedStart and HAL_ADCEx_InjectedPollForConversion). By the way, polling is still possible since driver will use an estimated timing for end of injected conversion.
                                              Note: If overrun feature is intended to be used, use ADC in mode 'interruption' (function HAL_ADC_Start_IT() ) with parameter EOCSelection set to end of each conversion or in mode 'transfer by DMA' (function HAL_ADC_Start_DMA()).
                                              If overrun feature is intended to be bypassed, use ADC in mode 'polling' or 'interruption' with parameter EOCSelection must be set to end of sequence *//*!< Configures the sequencer of regular and injected groups.
                                              This parameter can be associated to parameter 'DiscontinuousConvMode' to have main sequence subdivided in successive parts.
                                              If disabled: Conversion is performed in single mode (one channel converted, the one defined in rank 1).
                                                           Parameters 'NbrOfConversion' and 'InjectedNbrOfConversion' are discarded (equivalent to set to 1).
                                              If enabled:  Conversions are performed in sequence mode (multiple ranks defined by 'NbrOfConversion'/'InjectedNbrOfConversion' and each channel rank).
                                                           Scan direction is upward: from rank1 to rank 'n'.
                                              This parameter can be a value of @ref ADC_Scan_mode.
                                              This parameter can be set to ENABLE or DISABLE *//*!< Specifies ADC data alignment to right (MSB on register bit 11 and LSB on register bit 0) (default setting)
                                              or to left (if regular group: MSB on register bit 15 and LSB on register bit 4, if injected group (MSB kept as signed value due to potential negative value after offset application): MSB on register bit 14 and LSB on register bit 3).
                                              This parameter can be a value of @ref ADC_Data_Align *//*!< Configures the ADC resolution.
                                              This parameter can be a value of @ref ADC_Resolution *//*!< Select ADC clock prescaler. The clock is common for 
                                              all the ADCs.
                                              This parameter can be a value of @ref ADC_ClockPrescaler *//** 
  * @brief  Structure definition of ADC and regular group initialization 
  * @note   Parameters of this structure are shared within 2 scopes:
  *          - Scope entire ADC (affects regular and injected groups): ClockPrescaler, Resolution, ScanConvMode, DataAlign, ScanConvMode, EOCSelection, LowPowerAutoWait, LowPowerAutoPowerOff, ChannelsBank.
  *          - Scope regular group: ContinuousConvMode, NbrOfConversion, DiscontinuousConvMode, NbrOfDiscConversion, ExternalTrigConvEdge, ExternalTrigConv.
  * @note   The setting of these parameters with function HAL_ADC_Init() is conditioned to ADC state.
  *         ADC state can be either:
  *          - For all parameters: ADC disabled
  *          - For all parameters except 'Resolution', 'ScanConvMode', 'DiscontinuousConvMode', 'NbrOfDiscConversion' : ADC enabled without conversion on going on regular group.
  *          - For parameters 'ExternalTrigConv' and 'ExternalTrigConvEdge': ADC enabled, even with conversion on going.
  *         If ADC is not in the appropriate state to modify some parameters, these parameters setting is bypassed
  *         without error reporting (as it can be the expected behaviour in case of intended action to update another parameter (which fulfills the ADC state condition) on the fly).
  *//** @defgroup ADC_Exported_Types ADC Exported Types
  * @{
  *//** @addtogroup ADC
  * @{
  *//**
  ******************************************************************************
  * @file    stm32f7xx_hal_adc.h
  * @author  MCD Application Team
  * @brief   Header file of ADC HAL extension module.
  ******************************************************************************
  * @attention
  *
  * Copyright (c) 2017 STMicroelectronics.
  * All rights reserved.
  *
  * This software is licensed under terms that can be found in the LICENSE file
  * in the root directory of this software component.
  * If no LICENSE file comes with this software, it is provided AS-IS.
  *
  ******************************************************************************
  */AnalogWDGConfigsConfigEventTypeHAL_DMA2D_GetErrorHAL_DMA2D_GetStateHAL_DMA2D_ConfigDeadTimeHAL_DMA2D_DisableDeadTimeHAL_DMA2D_EnableDeadTimeHAL_DMA2D_ProgramLineEventHAL_DMA2D_ConfigCLUTHAL_DMA2D_ConfigLayerHAL_DMA2D_CLUTLoadingCpltCallbackHAL_DMA2D_LineEventCallbackHAL_DMA2D_IRQHandlerHAL_DMA2D_PollForTransferHAL_DMA2D_CLUTLoading_ResumeHAL_DMA2D_CLUTLoading_SuspendHAL_DMA2D_CLUTLoad_ITHAL_DMA2D_CLUTLoadHAL_DMA2D_CLUTStartLoad_ITDMA2D_CLUTCfgTypeDef *HAL_DMA2D_CLUTStartLoadHAL_DMA2D_EnableCLUTHAL_DMA2D_AbortHAL_DMA2D_ResumeHAL_DMA2D_SuspendHAL_DMA2D_BlendingStart_ITHAL_DMA2D_Start_ITHAL_DMA2D_BlendingStartHAL_DMA2D_StartHAL_DMA2D_MspDeInitHAL_DMA2D_MspInitHAL_DMA2D_DeInitHAL_DMA2D_InitDMA2D_HandleTypeDef__DMA2D_HandleTypeDefHAL_DMA2D_StateTypeDefHAL_DMA2D_STATE_RESETHAL_DMA2D_STATE_READYHAL_DMA2D_STATE_BUSYHAL_DMA2D_STATE_TIMEOUTHAL_DMA2D_STATE_ERRORHAL_DMA2D_STATE_SUSPENDDMA2D_LayerCfgTypeDefDMA2D_InitTypeDefDMA2D_CLUTCfgTypeDefvolatile HAL_DMA2D_StateTypeDefMAX_DMA2D_LAYERLayerCfgRedBlueSwapAlphaInvertedInputAlphaAlphaModeInputOffsetOutputOffsetCLUTColorModepCLUTIS_DMA2D_GET_FLAG(FLAG)(((FLAG) == DMA2D_FLAG_CTC) || ((FLAG) == DMA2D_FLAG_CAE) || ((FLAG) == DMA2D_FLAG_TW) || ((FLAG) == DMA2D_FLAG_TC) || ((FLAG) == DMA2D_FLAG_TE) || ((FLAG) == DMA2D_FLAG_CE))IS_DMA2D_IT(IT)(((IT) == DMA2D_IT_CTC) || ((IT) == DMA2D_IT_CAE) || ((IT) == DMA2D_IT_TW) || ((IT) == DMA2D_IT_TC) || ((IT) == DMA2D_IT_TE) || ((IT) == DMA2D_IT_CE))IS_DMA2D_LINEWATERMARK(LineWatermark)((LineWatermark) <= DMA2D_LINE_WATERMARK_MAX)IS_DMA2D_CLUT_SIZE(CLUT_SIZE)((CLUT_SIZE) <= DMA2D_CLUT_SIZE)IS_DMA2D_CLUT_CM(CLUT_CM)(((CLUT_CM) == DMA2D_CCM_ARGB8888) || ((CLUT_CM) == DMA2D_CCM_RGB888))IS_DMA2D_RB_SWAP(RB_Swap)(((RB_Swap) == DMA2D_RB_REGULAR) || ((RB_Swap) == DMA2D_RB_SWAP))IS_DMA2D_ALPHA_INVERTED(Alpha_Inverted)(((Alpha_Inverted) == DMA2D_REGULAR_ALPHA) || ((Alpha_Inverted) == DMA2D_INVERTED_ALPHA))IS_DMA2D_ALPHA_MODE(AlphaMode)(((AlphaMode) == DMA2D_NO_MODIF_ALPHA) || ((AlphaMode) == DMA2D_REPLACE_ALPHA) || ((AlphaMode) == DMA2D_COMBINE_ALPHA))IS_DMA2D_INPUT_COLOR_MODE(INPUT_CM)(((INPUT_CM) == DMA2D_INPUT_ARGB8888) || ((INPUT_CM) == DMA2D_INPUT_RGB888) || ((INPUT_CM) == DMA2D_INPUT_RGB565) || ((INPUT_CM) == DMA2D_INPUT_ARGB1555) || ((INPUT_CM) == DMA2D_INPUT_ARGB4444) || ((INPUT_CM) == DMA2D_INPUT_L8) || ((INPUT_CM) == DMA2D_INPUT_AL44) || ((INPUT_CM) == DMA2D_INPUT_AL88) || ((INPUT_CM) == DMA2D_INPUT_L4) || ((INPUT_CM) == DMA2D_INPUT_A8) || ((INPUT_CM) == DMA2D_INPUT_A4))IS_DMA2D_OFFSET(OOFFSET)((OOFFSET) <= DMA2D_OFFSET)IS_DMA2D_PIXEL(PIXEL)((PIXEL) <= DMA2D_PIXEL)IS_DMA2D_LINE(LINE)((LINE) <= DMA2D_LINE)IS_DMA2D_COLOR(COLOR)((COLOR) <= DMA2D_COLOR_VALUE)IS_DMA2D_CMODE(MODE_ARGB)(((MODE_ARGB) == DMA2D_OUTPUT_ARGB8888) || ((MODE_ARGB) == DMA2D_OUTPUT_RGB888) || ((MODE_ARGB) == DMA2D_OUTPUT_RGB565) || ((MODE_ARGB) == DMA2D_OUTPUT_ARGB1555) || ((MODE_ARGB) == DMA2D_OUTPUT_ARGB4444))IS_DMA2D_MODE(MODE)(((MODE) == DMA2D_M2M) || ((MODE) == DMA2D_M2M_PFC) || ((MODE) == DMA2D_M2M_BLEND) || ((MODE) == DMA2D_R2M))IS_DMA2D_LAYER(LAYER)(((LAYER) == DMA2D_BACKGROUND_LAYER) || ((LAYER) == DMA2D_FOREGROUND_LAYER))DMA2D_CLUT_SIZE(DMA2D_FGPFCCR_CS >> 8U)DMA2D_LINEDMA2D_PIXEL(DMA2D_NLR_PL >> 16U)DMA2D_OFFSETDMA2D_FOREGROUND_LAYERDMA2D_BACKGROUND_LAYERDMA2D_MAX_LAYERDMA2D_COLOR_VALUEDMA2D_LINE_WATERMARK_MAX__HAL_DMA2D_GET_IT_SOURCE(__HANDLE__,__INTERRUPT__)((__HANDLE__)->Instance->CR & (__INTERRUPT__))__HAL_DMA2D_DISABLE_IT(__HANDLE__,__INTERRUPT__)((__HANDLE__)->Instance->CR &= ~(__INTERRUPT__))__HAL_DMA2D_ENABLE_IT(__HANDLE__,__INTERRUPT__)((__HANDLE__)->Instance->CR |= (__INTERRUPT__))__HAL_DMA2D_CLEAR_FLAG(__HANDLE__,__FLAG__)((__HANDLE__)->Instance->IFCR = (__FLAG__))__HAL_DMA2D_GET_FLAG(__HANDLE__,__FLAG__)((__HANDLE__)->Instance->ISR & (__FLAG__))__HAL_DMA2D_ENABLE(__HANDLE__)((__HANDLE__)->Instance->CR |= DMA2D_CR_START)__HAL_DMA2D_RESET_HANDLE_STATE(__HANDLE__)((__HANDLE__)->State = HAL_DMA2D_STATE_RESET)DMA2D_FLAG_TEDMA2D_FLAG_TCDMA2D_FLAG_TWDMA2D_FLAG_CAEDMA2D_FLAG_CTCDMA2D_FLAG_CEDMA2D_IT_TEDMA2D_IT_TCDMA2D_IT_TWDMA2D_IT_CAEDMA2D_IT_CTCDMA2D_IT_CEDMA2D_CCM_RGB888DMA2D_CCM_ARGB8888DMA2D_RB_SWAPDMA2D_RB_REGULARDMA2D_INVERTED_ALPHADMA2D_REGULAR_ALPHADMA2D_COMBINE_ALPHADMA2D_REPLACE_ALPHA(DMA2D_OPFCCR_CM_0|DMA2D_OPFCCR_CM_1)DMA2D_R2MDMA2D_M2M_BLENDDMA2D_M2M_PFCDMA2D_M2MHAL_DMA2D_ERROR_TIMEOUTHAL_DMA2D_ERROR_CAEHAL_DMA2D_ERROR_CEHAL_DMA2D_ERROR_TEHAL_DMA2D_ERROR_NONESTM32F7xx_HAL_DMA2D_Hdefined (DMA2D)defined (DMA2D_ALPHA_INV_RB_SWAP_SUPPORT)(USE_HAL_DMA2D_REGISTER_CALLBACKS == 1)/* STM32F7xx_HAL_DMA2D_H *//* defined (DMA2D) *//* DMA2D_ALPHA_INV_RB_SWAP_SUPPORT *//** @defgroup DMA2D_Private_Macros DMA2D Private Macros
  * @{
  *//*!< DMA2D maximum CLUT size *//** @defgroup DMA2D_CLUT_Size DMA2D CLUT Size
  * @{
  *//*!< DMA2D maximum number of lines           *//*!< DMA2D maximum number of pixels per line *//** @defgroup DMA2D_Size DMA2D Size
  * @{
  *//*!< maximum Line Offset *//** @defgroup DMA2D_Offset DMA2D Offset
  * @{
  *//*!< DMA2D Foreground Layer (layer 1) *//*!< DMA2D Background Layer (layer 0) *//** @defgroup DMA2D_Layers DMA2D Layers
  * @{
  *//*!< DMA2D maximum number of layers *//** @defgroup DMA2D_Max_Layer DMA2D Maximum Number of Layers
  * @{
  *//*!< Color value mask *//** @defgroup DMA2D_Color_Value DMA2D Color Value
  * @{
  *//*!< DMA2D maximum line watermark *//** @defgroup DMA2D_Maximum_Line_WaterMark DMA2D Maximum Line Watermark
  * @{
  *//** @addtogroup DMA2D_Private_Constants DMA2D Private Constants
  * @{
  *//** @addtogroup DMA2D_Exported_Functions_Group4 Peripheral State and Error functions
  * @{
  *//** @addtogroup DMA2D_Exported_Functions_Group3 Peripheral Control functions
  * @{
  *//** @addtogroup DMA2D_Exported_Functions_Group2 IO operation functions
  * @{
  *//* USE_HAL_DMA2D_REGISTER_CALLBACKS *//* Initialization and de-initialization functions *******************************//** @addtogroup DMA2D_Exported_Functions_Group1 Initialization and de-initialization functions
  * @{
  *//** @addtogroup DMA2D_Exported_Functions DMA2D Exported Functions
  * @{
  *//**
  * @brief  Check whether the specified DMA2D interrupt source is enabled or not.
  * @param  __HANDLE__ DMA2D handle
  * @param  __INTERRUPT__ specifies the DMA2D interrupt source to check.
  *          This parameter can be one of the following values:
  *            @arg DMA2D_IT_CE:  Configuration error interrupt mask
  *            @arg DMA2D_IT_CTC: CLUT transfer complete interrupt mask
  *            @arg DMA2D_IT_CAE: CLUT access error interrupt mask
  *            @arg DMA2D_IT_TW:  Transfer Watermark interrupt mask
  *            @arg DMA2D_IT_TC:  Transfer complete interrupt mask
  *            @arg DMA2D_IT_TE:  Transfer error interrupt mask
  * @retval The state of INTERRUPT source.
  *//**
  * @brief  Disable the specified DMA2D interrupts.
  * @param  __HANDLE__ DMA2D handle
  * @param __INTERRUPT__ specifies the DMA2D interrupt sources to be disabled.
  *          This parameter can be any combination of the following values:
  *            @arg DMA2D_IT_CE:  Configuration error interrupt mask
  *            @arg DMA2D_IT_CTC: CLUT transfer complete interrupt mask
  *            @arg DMA2D_IT_CAE: CLUT access error interrupt mask
  *            @arg DMA2D_IT_TW:  Transfer Watermark interrupt mask
  *            @arg DMA2D_IT_TC:  Transfer complete interrupt mask
  *            @arg DMA2D_IT_TE:  Transfer error interrupt mask
  * @retval None
  *//**
  * @brief  Enable the specified DMA2D interrupts.
  * @param  __HANDLE__ DMA2D handle
  * @param __INTERRUPT__ specifies the DMA2D interrupt sources to be enabled.
  *          This parameter can be any combination of the following values:
  *            @arg DMA2D_IT_CE:  Configuration error interrupt mask
  *            @arg DMA2D_IT_CTC: CLUT transfer complete interrupt mask
  *            @arg DMA2D_IT_CAE: CLUT access error interrupt mask
  *            @arg DMA2D_IT_TW:  Transfer Watermark interrupt mask
  *            @arg DMA2D_IT_TC:  Transfer complete interrupt mask
  *            @arg DMA2D_IT_TE:  Transfer error interrupt mask
  * @retval None
  *//**
  * @brief  Clear the DMA2D pending flags.
  * @param  __HANDLE__ DMA2D handle
  * @param  __FLAG__ specifies the flag to clear.
  *          This parameter can be any combination of the following values:
  *            @arg DMA2D_FLAG_CE:  Configuration error flag
  *            @arg DMA2D_FLAG_CTC: CLUT transfer complete flag
  *            @arg DMA2D_FLAG_CAE: CLUT access error flag
  *            @arg DMA2D_FLAG_TW:  Transfer Watermark flag
  *            @arg DMA2D_FLAG_TC:  Transfer complete flag
  *            @arg DMA2D_FLAG_TE:  Transfer error flag
  * @retval None
  *//**
  * @brief  Get the DMA2D pending flags.
  * @param  __HANDLE__ DMA2D handle
  * @param  __FLAG__ flag to check.
  *          This parameter can be any combination of the following values:
  *            @arg DMA2D_FLAG_CE:  Configuration error flag
  *            @arg DMA2D_FLAG_CTC: CLUT transfer complete flag
  *            @arg DMA2D_FLAG_CAE: CLUT access error flag
  *            @arg DMA2D_FLAG_TW:  Transfer Watermark flag
  *            @arg DMA2D_FLAG_TC:  Transfer complete flag
  *            @arg DMA2D_FLAG_TE:  Transfer error flag
  * @retval The state of FLAG.
  *//**
  * @brief  Enable the DMA2D.
  * @param  __HANDLE__ DMA2D handle
  * @retval None.
  *//** @brief Reset DMA2D handle state
  * @param  __HANDLE__ specifies the DMA2D handle.
  * @retval None
  *//** @defgroup DMA2D_Exported_Macros DMA2D Exported Macros
  * @{
  *//*!< DMA2D CLUT loading completion callback ID *//*!< DMA2D line event callback ID              *//*!< DMA2D transfer error callback ID          *//*!< DMA2D transfer complete callback ID       *//*!< DMA2D MspDeInit callback ID               *//*!< DMA2D MspInit callback ID                 *//**
  * @brief  HAL DMA2D common Callback ID enumeration definition
  *//*!< Transfer Complete Interrupt Flag *//*!< Transfer Watermark Interrupt Flag *//*!< CLUT Access Error Interrupt Flag *//*!< Configuration Error Interrupt Flag *//** @defgroup DMA2D_Flags DMA2D Flags
  * @{
  *//*!< Transfer Error Interrupt *//*!< Transfer Complete Interrupt *//*!< Transfer Watermark Interrupt *//*!< CLUT Access Error Interrupt *//*!< CLUT Transfer Complete Interrupt *//*!< Configuration Error Interrupt *//** @defgroup DMA2D_Interrupts DMA2D Interrupts
  * @{
  *//*!< RGB888 DMA2D CLUT color mode   *//*!< ARGB8888 DMA2D CLUT color mode *//** @defgroup DMA2D_CLUT_CM DMA2D CLUT Color Mode
  * @{
  *//*!< Select swap mode (BGR or ABGR) *//*!< Select regular mode (RGB or ARGB) *//** @defgroup DMA2D_RB_Swap DMA2D Red and Blue Swap
  * @{
  *//*!< Invert the alpha channel value *//*!< No modification of the alpha channel value *//** @defgroup DMA2D_Alpha_Inverted DMA2D Alpha Inversion
  * @{
  *//*!< Replace original alpha channel value by programmed alpha value
                                                      with original alpha channel value                              *//*!< Replace original alpha channel value by programmed alpha value *//*!< No modification of the alpha channel value                     *//** @defgroup DMA2D_Alpha_Mode DMA2D Alpha Mode
  * @{
  *//*!< A4 color mode       *//*!< A8 color mode       *//*!< L4 color mode       *//*!< AL88 color mode     *//*!< AL44 color mode     *//*!< L8 color mode       *//*!< ARGB4444 color mode *//*!< ARGB1555 color mode *//*!< RGB565 color mode   *//*!< RGB888 color mode   *//*!< ARGB8888 color mode *//** @defgroup DMA2D_Input_Color_Mode DMA2D Input Color Mode
  * @{
  *//*!< ARGB4444 DMA2D color mode *//*!< ARGB1555 DMA2D color mode *//*!< RGB565 DMA2D color mode   *//*!< RGB888 DMA2D color mode   *//*!< ARGB8888 DMA2D color mode *//** @defgroup DMA2D_Output_Color_Mode DMA2D Output Color Mode
  * @{
  *//*!< DMA2D register to memory transfer mode *//*!< DMA2D memory to memory with blending transfer mode *//*!< DMA2D memory to memory with pixel format conversion transfer mode *//*!< DMA2D memory to memory transfer mode *//** @defgroup DMA2D_Mode DMA2D Mode
  * @{
  *//* USE_HAL_UART_REGISTER_CALLBACKS *//*!< Invalid callback error  *//*!< Timeout error        *//*!< CLUT access error    *//*!< Configuration error  *//*!< Transfer error       *//*!< No error             *//** @defgroup DMA2D_Error_Code DMA2D Error Code
  * @{
  *//** @defgroup DMA2D_Exported_Constants DMA2D Exported Constants
  * @{
  *//*!< Pointer to a DMA2D common callback function *//**
  * @brief  HAL DMA2D Callback pointer definition
  *//*!< DMA2D error code.                      *//*!< DMA2D transfer state.                  *//*!< DMA2D lock.                            *//*!< DMA2D Layers parameters                *//* (USE_HAL_DMA2D_REGISTER_CALLBACKS) *//*!< DMA2D Msp DeInit callback.             *//*!< DMA2D Msp Init callback.               *//*!< DMA2D CLUT loading completion callback *//*!< DMA2D line event callback.             *//*!< DMA2D transfer error callback.         *//*!< DMA2D transfer complete callback.      *//*!< DMA2D communication parameters.        *//*!< DMA2D register base address.           *//**
  * @brief  DMA2D handle Structure definition
  *//*!< DMA2D process is suspended                  *//*!< DMA2D state error                           *//*!< Timeout state                               *//*!< An internal process is ongoing              *//*!< Peripheral Initialized and ready for use    *//*!< DMA2D not yet initialized or disabled       *//**
  * @brief  HAL DMA2D State structures definition
  *//* DMA2D_ALPHA_INV_RB_SWAP_SUPPORT  *//*!< Select regular mode (RGB or ARGB) or swap mode (BGR or ABGR).
                                               This parameter can be one value of @ref DMA2D_RB_Swap. *//*!< Select regular or inverted alpha value.
                                               This parameter can be one value of @ref DMA2D_Alpha_Inverted. *//*!< Specifies the DMA2D foreground or background alpha value and color value
                                               in case of A8 or A4 color mode.
                                               This parameter must be a number between Min_Data = 0x00
                                               and Max_Data = 0xFF except for the color modes detailed below.
                                               @note In case of A8 or A4 color mode (ARGB),
                                               this parameter must be a number between
                                               Min_Data = 0x00000000 and Max_Data = 0xFFFFFFFF where
                                               - InputAlpha[24:31] is the alpha value ALPHA[0:7]
                                               - InputAlpha[16:23] is the red value RED[0:7]
                                               - InputAlpha[8:15] is the green value GREEN[0:7]
                                               - InputAlpha[0:7] is the blue value BLUE[0:7]. *//*!< Configures the DMA2D foreground or background alpha mode.
                                               This parameter can be one value of @ref DMA2D_Alpha_Mode. *//*!< Configures the DMA2D foreground or background color mode.
                                               This parameter can be one value of @ref DMA2D_Input_Color_Mode. *//*!< Configures the DMA2D foreground or background offset.
                                               This parameter must be a number between
                                               Min_Data = 0x0000 and Max_Data = 0x3FFF. *//**
  * @brief DMA2D Layer structure definition
  *//*!< Select regular mode (RGB or ARGB) or swap mode (BGR or ABGR)
                                               for the output pixel format converter.
                                               This parameter can be one value of @ref DMA2D_RB_Swap. *//*!< Select regular or inverted alpha value
                                               for the output pixel format converter.
                                               This parameter can be one value of @ref DMA2D_Alpha_Inverted. *//*!< Specifies the Offset value.
                                                This parameter must be a number between
                                                Min_Data = 0x0000 and Max_Data = 0x3FFF. *//*!< Configures the color format of the output image.
                                                This parameter can be one value of @ref DMA2D_Output_Color_Mode. *//*!< Configures the DMA2D transfer mode.
                                                This parameter can be one value of @ref DMA2D_Mode. *//**
  * @brief DMA2D Init structure definition
  *//*!< Configures the DMA2D CLUT size.
                                         This parameter must be a number between Min_Data = 0x00 and Max_Data = 0xFF.*//*!< Configures the DMA2D CLUT color mode.
                                         This parameter can be one value of @ref DMA2D_CLUT_CM. *//*!< Configures the DMA2D CLUT memory address.*//**
  * @brief DMA2D CLUT Structure definition
  *//** @defgroup DMA2D_Exported_Types DMA2D Exported Types
  * @{
  *//** @addtogroup DMA2D DMA2D
  * @brief DMA2D HAL module driver
  * @{
  *//**
  ******************************************************************************
  * @file    stm32f7xx_hal_dma2d.h
  * @author  MCD Application Team
  * @brief   Header file of DMA2D HAL module.
  ******************************************************************************
  * @attention
  *
  * Copyright (c) 2017 STMicroelectronics.
  * All rights reserved.
  *
  * This software is licensed under terms that can be found in the LICENSE file
  * in the root directory of this software component.
  * If no LICENSE file comes with this software, it is provided AS-IS.
  *
  ******************************************************************************
  */hdma2dDeadTimeCLUTCfgLayerIdxSrcAddress1SrcAddress2pdataHAL_DCMI_GetErrorconst DCMI_HandleTypeDefconst DCMI_HandleTypeDef *HAL_DCMI_GetStateHAL_DCMI_ConfigSyncUnmaskDCMI_HandleTypeDef *DCMI_SyncUnmaskTypeDef *HAL_DCMI_IRQHandlerHAL_DCMI_VsyncEventCallbackHAL_DCMI_FrameEventCallbackHAL_DCMI_LineEventCallbackHAL_DCMI_ErrorCallbackHAL_DCMI_ResumeHAL_DCMI_SuspendHAL_DCMI_StopHAL_DCMI_Start_DMAHAL_DCMI_MspDeInitHAL_DCMI_MspInitHAL_DCMI_DeInitHAL_DCMI_InitDCMI_HandleTypeDefDCMI_InitTypeDefDCMI_SyncUnmaskTypeDefDCMI_CodesInitTypeDefHAL_DCMI_StateTypeDefHAL_DCMI_STATE_RESETHAL_DCMI_STATE_READYHAL_DCMI_STATE_BUSYHAL_DCMI_STATE_TIMEOUTHAL_DCMI_STATE_ERRORHAL_DCMI_STATE_SUSPENDEDpBuffPtrXferTransferNumberXferSizeXferCountvolatile HAL_DCMI_StateTypeDefDCMI_TypeDef *LineSelectStartLineSelectModeByteSelectStartByteSelectModeJPEGModeSyncroCodeExtendedDataModeCaptureRateHSPolarityVSPolarityPCKPolaritySynchroModeFrameEndUnmaskLineEndUnmaskLineStartUnmaskFrameStartUnmaskFrameEndCodeLineEndCodeLineStartCodeFrameStartCodeIS_DCMI_LINE_SELECT_START(POLARITY)(((POLARITY) == DCMI_OELS_ODD) || ((POLARITY) == DCMI_OELS_EVEN))IS_DCMI_LINE_SELECT_MODE(MODE)(((MODE) == DCMI_LSM_ALL) || ((MODE) == DCMI_LSM_ALTERNATE_2))IS_DCMI_BYTE_SELECT_START(POLARITY)(((POLARITY) == DCMI_OEBS_ODD) || ((POLARITY) == DCMI_OEBS_EVEN))IS_DCMI_BYTE_SELECT_MODE(MODE)(((MODE) == DCMI_BSM_ALL) || ((MODE) == DCMI_BSM_OTHER) || ((MODE) == DCMI_BSM_ALTERNATE_4) || ((MODE) == DCMI_BSM_ALTERNATE_2))IS_DCMI_WINDOW_HEIGHT(HEIGHT)((HEIGHT) <= DCMI_WINDOW_HEIGHT)IS_DCMI_WINDOW_COORDINATE(COORDINATE)((COORDINATE) <= DCMI_WINDOW_COORDINATE)IS_DCMI_EXTENDED_DATA(DATA)(((DATA) == DCMI_EXTEND_DATA_8B) || ((DATA) == DCMI_EXTEND_DATA_10B) || ((DATA) == DCMI_EXTEND_DATA_12B) || ((DATA) == DCMI_EXTEND_DATA_14B))IS_DCMI_CAPTURE_RATE(RATE)(((RATE) == DCMI_CR_ALL_FRAME) || ((RATE) == DCMI_CR_ALTERNATE_2_FRAME) || ((RATE) == DCMI_CR_ALTERNATE_4_FRAME))IS_DCMI_MODE_JPEG(JPEG_MODE)(((JPEG_MODE) == DCMI_JPEG_DISABLE) || ((JPEG_MODE) == DCMI_JPEG_ENABLE))IS_DCMI_HSPOLARITY(POLARITY)(((POLARITY) == DCMI_HSPOLARITY_LOW) || ((POLARITY) == DCMI_HSPOLARITY_HIGH))IS_DCMI_VSPOLARITY(POLARITY)(((POLARITY) == DCMI_VSPOLARITY_LOW) || ((POLARITY) == DCMI_VSPOLARITY_HIGH))IS_DCMI_PCKPOLARITY(POLARITY)(((POLARITY) == DCMI_PCKPOLARITY_FALLING) || ((POLARITY) == DCMI_PCKPOLARITY_RISING))IS_DCMI_SYNCHRO(MODE)(((MODE) == DCMI_SYNCHRO_HARDWARE) || ((MODE) == DCMI_SYNCHRO_EMBEDDED))IS_DCMI_CAPTURE_MODE(MODE)(((MODE) == DCMI_MODE_CONTINUOUS) || ((MODE) == DCMI_MODE_SNAPSHOT))DCMI_SR_INDEXDCMI_MIS_INDEX__HAL_DCMI_GET_IT_SOURCE(__HANDLE__,__INTERRUPT__)((__HANDLE__)->Instance->MISR & (__INTERRUPT__))__HAL_DCMI_DISABLE_IT(__HANDLE__,__INTERRUPT__)((__HANDLE__)->Instance->IER &= ~(__INTERRUPT__))__HAL_DCMI_ENABLE_IT(__HANDLE__,__INTERRUPT__)((__HANDLE__)->Instance->IER |= (__INTERRUPT__))__HAL_DCMI_CLEAR_FLAG(__HANDLE__,__FLAG__)((__HANDLE__)->Instance->ICR = (__FLAG__))__HAL_DCMI_GET_FLAG(__HANDLE__,__FLAG__)((((__FLAG__) & (DCMI_SR_INDEX|DCMI_MIS_INDEX)) == 0x0)? ((__HANDLE__)->Instance->RIS & (__FLAG__)) : (((__FLAG__) & DCMI_SR_INDEX) == 0x0)? ((__HANDLE__)->Instance->MIS & (__FLAG__)) : ((__HANDLE__)->Instance->SR & (__FLAG__)))__HAL_DCMI_DISABLE(__HANDLE__)((__HANDLE__)->Instance->CR &= ~(DCMI_CR_ENABLE))__HAL_DCMI_ENABLE(__HANDLE__)((__HANDLE__)->Instance->CR |= DCMI_CR_ENABLE)__HAL_DCMI_RESET_HANDLE_STATE(__HANDLE__)((__HANDLE__)->State = HAL_DCMI_STATE_RESET)DCMI_OELS_EVEN((uint32_t)DCMI_CR_OELS)DCMI_OELS_ODD(0x00000000U)DCMI_LSM_ALTERNATE_2((uint32_t)DCMI_CR_LSM)DCMI_LSM_ALLDCMI_OEBS_EVEN((uint32_t)DCMI_CR_OEBS)DCMI_OEBS_ODDDCMI_BSM_ALTERNATE_2((uint32_t)(DCMI_CR_BSM_0 | DCMI_CR_BSM_1))DCMI_BSM_ALTERNATE_4((uint32_t)DCMI_CR_BSM_1)DCMI_BSM_OTHER((uint32_t)DCMI_CR_BSM_0)DCMI_BSM_ALLDCMI_FLAG_LINEMI((uint32_t)DCMI_MIS_INDEX|DCMI_MIS_LINE_MIS )DCMI_FLAG_VSYNCMI((uint32_t)DCMI_MIS_INDEX|DCMI_MIS_VSYNC_MIS)DCMI_FLAG_ERRMI((uint32_t)DCMI_MIS_INDEX|DCMI_MIS_ERR_MIS )((uint32_t)DCMI_MIS_INDEX|DCMI_MIS_OVR_MIS )DCMI_FLAG_FRAMEMI((uint32_t)DCMI_MIS_INDEX|DCMI_MIS_FRAME_MIS)DCMI_FLAG_LINERI((uint32_t)DCMI_RIS_LINE_RIS)DCMI_FLAG_VSYNCRI((uint32_t)DCMI_RIS_VSYNC_RIS)DCMI_FLAG_ERRRI((uint32_t)DCMI_RIS_ERR_RIS)((uint32_t)DCMI_RIS_OVR_RIS)DCMI_FLAG_FRAMERI((uint32_t)DCMI_RIS_FRAME_RIS)DCMI_FLAG_FNE((uint32_t)DCMI_SR_INDEX|DCMI_SR_FNE)DCMI_FLAG_VSYNC((uint32_t)DCMI_SR_INDEX|DCMI_SR_VSYNC)DCMI_FLAG_HSYNC((uint32_t)DCMI_SR_INDEX|DCMI_SR_HSYNC)DCMI_IT_LINE((uint32_t)DCMI_IER_LINE_IE)DCMI_IT_VSYNC((uint32_t)DCMI_IER_VSYNC_IE)DCMI_IT_ERR((uint32_t)DCMI_IER_ERR_IE)((uint32_t)DCMI_IER_OVR_IE)DCMI_IT_FRAME((uint32_t)DCMI_IER_FRAME_IE)DCMI_WINDOW_HEIGHT(0x1FFFU)DCMI_WINDOW_COORDINATE(0x3FFFU)DCMI_EXTEND_DATA_14B((uint32_t)(DCMI_CR_EDM_0 | DCMI_CR_EDM_1))DCMI_EXTEND_DATA_12B((uint32_t)DCMI_CR_EDM_1)DCMI_EXTEND_DATA_10B((uint32_t)DCMI_CR_EDM_0)DCMI_EXTEND_DATA_8BDCMI_CR_ALTERNATE_4_FRAME((uint32_t)DCMI_CR_FCRC_1)DCMI_CR_ALTERNATE_2_FRAME((uint32_t)DCMI_CR_FCRC_0)DCMI_CR_ALL_FRAMEDCMI_JPEG_ENABLE((uint32_t)DCMI_CR_JPEG)DCMI_JPEG_DISABLEDCMI_HSPOLARITY_HIGH((uint32_t)DCMI_CR_HSPOL)DCMI_HSPOLARITY_LOWDCMI_VSPOLARITY_HIGH((uint32_t)DCMI_CR_VSPOL)DCMI_VSPOLARITY_LOWDCMI_PCKPOLARITY_RISING((uint32_t)DCMI_CR_PCKPOL)DCMI_PCKPOLARITY_FALLINGDCMI_SYNCHRO_EMBEDDED((uint32_t)DCMI_CR_ESS)DCMI_SYNCHRO_HARDWAREDCMI_MODE_SNAPSHOT((uint32_t)DCMI_CR_CM)DCMI_MODE_CONTINUOUSHAL_DCMI_ERROR_DMA(0x00000040U)HAL_DCMI_ERROR_TIMEOUT(0x00000020U)HAL_DCMI_ERROR_SYNC(0x00000002U)(0x00000001U)HAL_DCMI_ERROR_NONESTM32F7xx_HAL_DCMI_Hdefined (DCMI)(USE_HAL_DCMI_REGISTER_CALLBACKS == 1)/* STM32F7xx_HAL_DCMI_H *//* DCMI *//** @addtogroup DCMI_Private_Functions DCMI Private Functions
  * @{
  *//** @defgroup DCMI_Private_Macros DCMI Private Macros
  * @{
  *//*!< DCMI SR register index  *//** @defgroup DCMI_SR_INDEX  DCMI SR Index
  * @{
  *//*!< DCMI MIS register index *//** @defgroup DCMI_MIS_INDEX DCMI Mis Index
  * @{
  *//** @defgroup DCMI_Private_Constants DCMI Private Constants
  * @{
  *//* Peripheral State functions *************************************************//** @addtogroup DCMI_Exported_Functions_Group4 Peripheral State functions
  * @{
  *//** @addtogroup DCMI_Exported_Functions_Group3 Peripheral Control functions
  * @{
  *//** @addtogroup DCMI_Exported_Functions_Group2 IO operation functions
  * @{
  *//* USE_HAL_DCMI_REGISTER_CALLBACKS *//** @addtogroup DCMI_Exported_Functions_Group1 Initialization and Configuration functions
  * @{
  *//** @addtogroup DCMI_Exported_Functions DCMI Exported Functions
  * @{
  *//**
  * @brief  Check whether the specified DCMI interrupt has occurred or not.
  * @param  __HANDLE__ DCMI handle
  * @param  __INTERRUPT__ specifies the DCMI interrupt source to check.
  *         This parameter can be one of the following values:
  *            @arg DCMI_IT_FRAME: Frame capture complete interrupt mask
  *            @arg DCMI_IT_OVF: Overflow interrupt mask
  *            @arg DCMI_IT_ERR: Synchronization error interrupt mask
  *            @arg DCMI_IT_VSYNC: VSYNC interrupt mask
  *            @arg DCMI_IT_LINE: Line interrupt mask
  * @retval The state of INTERRUPT.
  *//**
  * @brief  Disable the specified DCMI interrupts.
  * @param  __HANDLE__ DCMI handle
  * @param  __INTERRUPT__ specifies the DCMI interrupt sources to be enabled.
  *         This parameter can be any combination of the following values:
  *            @arg DCMI_IT_FRAME: Frame capture complete interrupt mask
  *            @arg DCMI_IT_OVF: Overflow interrupt mask
  *            @arg DCMI_IT_ERR: Synchronization error interrupt mask
  *            @arg DCMI_IT_VSYNC: VSYNC interrupt mask
  *            @arg DCMI_IT_LINE: Line interrupt mask
  * @retval None
  *//**
  * @brief  Enable the specified DCMI interrupts.
  * @param  __HANDLE__    DCMI handle
  * @param  __INTERRUPT__ specifies the DCMI interrupt sources to be enabled.
  *         This parameter can be any combination of the following values:
  *            @arg DCMI_IT_FRAME: Frame capture complete interrupt mask
  *            @arg DCMI_IT_OVF: Overflow interrupt mask
  *            @arg DCMI_IT_ERR: Synchronization error interrupt mask
  *            @arg DCMI_IT_VSYNC: VSYNC interrupt mask
  *            @arg DCMI_IT_LINE: Line interrupt mask
  * @retval None
  *//**
  * @brief  Clear the DCMI pending flags.
  * @param  __HANDLE__ DCMI handle
  * @param  __FLAG__ specifies the flag to clear.
  *         This parameter can be any combination of the following values:
  *            @arg DCMI_FLAG_FRAMERI: Frame capture complete flag mask
  *            @arg DCMI_FLAG_OVFRI: Overflow flag mask
  *            @arg DCMI_FLAG_ERRRI: Synchronization error flag mask
  *            @arg DCMI_FLAG_VSYNCRI: VSYNC flag mask
  *            @arg DCMI_FLAG_LINERI: Line flag mask
  * @retval None
  *//**
  * @brief  Get the DCMI pending flag.
  * @param  __HANDLE__ DCMI handle
  * @param  __FLAG__ Get the specified flag.
  *         This parameter can be one of the following values (no combination allowed)
  *            @arg DCMI_FLAG_HSYNC: HSYNC pin state (active line / synchronization between lines)
  *            @arg DCMI_FLAG_VSYNC: VSYNC pin state (active frame / synchronization between frames)
  *            @arg DCMI_FLAG_FNE: FIFO empty flag
  *            @arg DCMI_FLAG_FRAMERI: Frame capture complete flag mask
  *            @arg DCMI_FLAG_OVRRI: Overrun flag mask
  *            @arg DCMI_FLAG_ERRRI: Synchronization error flag mask
  *            @arg DCMI_FLAG_VSYNCRI: VSYNC flag mask
  *            @arg DCMI_FLAG_LINERI: Line flag mask
  *            @arg DCMI_FLAG_FRAMEMI: DCMI Capture complete masked interrupt status
  *            @arg DCMI_FLAG_OVRMI: DCMI Overrun masked interrupt status
  *            @arg DCMI_FLAG_ERRMI: DCMI Synchronization error masked interrupt status
  *            @arg DCMI_FLAG_VSYNCMI: DCMI VSYNC masked interrupt status
  *            @arg DCMI_FLAG_LINEMI: DCMI Line masked interrupt status
  * @retval The state of FLAG.
  *//**
  * @brief  Disable the DCMI.
  * @param  __HANDLE__ DCMI handle
  * @retval None
  *//**
  * @brief  Enable the DCMI.
  * @param  __HANDLE__ DCMI handle
  * @retval None
  *//** @brief Reset DCMI handle state
  * @param  __HANDLE__ specifies the DCMI handle.
  * @retval None
  *//** @defgroup DCMI_Exported_Macros DCMI Exported Macros
  * @{
  *//*!< Interface captures second line from the frame start,
                                                                  first one being dropped *//*!< Interface captures first line from the frame start,
                                                       second one being dropped *//** @defgroup DCMI_Line_Select_Start DCMI Line Select Start
  * @{
  *//*!< Interface captures one line out of two *//*!< Interface captures all received lines *//** @defgroup DCMI_Line_Select_Mode DCMI Line Select Mode
  * @{
  *//*!< Interface captures second data from 
                                                                  the frame/line start, first one being dropped *//*!< Interface captures first data from the frame/line start, 
                                                       second one being dropped *//** @defgroup DCMI_Byte_Select_Start DCMI Byte Select Start
  * @{
  *//*!< Interface captures two bytes out of four *//*!< Interface captures one byte out of four *//*!< Interface captures every other byte 
                                                                    from the received data *//*!< Interface captures all received data *//** @defgroup DCMI_Byte_Select_Mode DCMI Byte Select Mode
  * @{
  *//*!< DCMI Line masked interrupt status                   *//*!< DCMI VSYNC masked interrupt status                  *//*!< DCMI Synchronization error masked interrupt status  *//*!< DCMI Overrun masked interrupt status                *//*!< DCMI Frame capture complete masked 
                                   interrupt status *//**
  * @brief   DCMI MIS register
  *//*!< Line interrupt flag                   *//*!< VSYNC interrupt flag                  *//*!< Synchronization error interrupt flag  *//*!< Overrun interrupt flag                *//*!< Frame capture complete interrupt flag *//**
  * @brief   DCMI RIS register
  *//*!< FIFO not empty flag                          *//*!< VSYNC pin state (active frame / synchronization 
                                                                         between frames) *//*!< HSYNC pin state (active line / synchronization 
                                                                         between lines)   *//**
  * @brief   DCMI SR register
  *//** @defgroup DCMI_Flags DCMI Flags
  * @{
  *//*!< Line interrupt                  *//*!< VSYNC interrupt                 *//*!< Synchronization error interrupt *//*!< Overrun interrupt               *//*!< Capture complete interrupt      *//** @defgroup DCMI_interrupt_sources  DCMI interrupt sources
  * @{
  *//*!< Window Height *//** @defgroup DCMI_Window_Height DCMI Window Height
  * @{
  *//*!< Window coordinate *//** @defgroup DCMI_Window_Coordinate DCMI Window Coordinate
  * @{
  *//*!< Interface captures 14-bit data on every pixel clock *//*!< Interface captures 12-bit data on every pixel clock *//*!< Interface captures 10-bit data on every pixel clock *//*!< Interface captures 8-bit data on every pixel clock  *//** @defgroup DCMI_Extended_Data_Mode DCMI Extended Data Mode
  * @{
  *//*!< One frame in 4 frames captured *//*!< Every alternate frame captured *//*!< All frames are captured        *//** @defgroup DCMI_Capture_Rate DCMI Capture Rate
  * @{
  *//*!< Mode JPEG Enabled   *//*!< Mode JPEG Disabled  *//** @defgroup DCMI_MODE_JPEG DCMI MODE JPEG
  * @{
  *//*!< Horizontal synchronization active High *//*!< Horizontal synchronization active Low  *//** @defgroup DCMI_HSYNC_Polarity DCMI HSYNC Polarity
  * @{
  *//*!< Vertical synchronization active High *//*!< Vertical synchronization active Low  *//** @defgroup DCMI_VSYNC_Polarity DCMI VSYNC Polarity
  * @{
  *//*!< Pixel clock active on Rising edge  *//*!< Pixel clock active on Falling edge *//** @defgroup DCMI_PIXCK_Polarity DCMI PIXCK Polarity
  * @{
  *//*!< Embedded synchronization data capture is synchronized 
                                                                 with synchronization codes embedded in the data flow *//*!< Hardware synchronization data capture (frame/line start/stop)
                                                          is synchronized with the HSYNC/VSYNC signals               *//** @defgroup DCMI_Synchronization_Mode DCMI Synchronization Mode
  * @{
  *//*!< Once activated, the interface waits for the start of 
                                                                   frame and then transfers a single frame 
                                                                   through the DMA *//*!< The received data are transferred continuously
                                                                   into the destination memory through the DMA    *//** @defgroup DCMI_Capture_Mode DCMI Capture Mode
  * @{
  *//*!< Invalid callback error *//*!< DMA error             *//*!< Timeout error         *//*!< Synchronization error *//*!< Overrun error         *//*!< No error              *//** @defgroup DCMI_Error_Code DCMI Error Code
  * @{
  *//** @defgroup DCMI_Exported_Constants DCMI Exported Constants
  * @{
  *//*!< pointer to a DCMI callback function *//**
  * @brief  HAL DCMI Callback pointer definition
  *//*!< DCMI MspDeInit callback ID   *//*!< DCMI MspInit callback ID     *//*!< DCMI Error Callback ID       *//*!< DCMI Line Event Callback ID  *//*!< DCMI Vsync Event Callback ID *//*!< DCMI Frame Event Callback ID *//**
  * @brief  HAL DCMI Callback ID enumeration definition
  *//*!< DCMI Msp DeInit callback  *//*!< DCMI Msp Init callback    *//*!< DCMI Error Callback       *//*!< DCMI Line Event Callback  *//*!< DCMI Vsync Event Callback *//*!< DCMI Frame Event Callback *//*!< DCMI Error code              *//*!< Pointer to the DMA handler   *//*!< Pointer to DMA output buffer *//*!< DMA transfer number          *//*!< DMA transfer size            *//*!< DMA transfer counter         *//*!< DCMI state                   *//*!< DCMI locking object          *//*!< DCMI parameters              *//*!< DCMI Register base address   *//**
  * @brief  DCMI handle Structure definition
  *//*!< Specifies if the line of data to be captured by the interface is even or odd
                                            by the interface is even or odd
                                            This parameter can be a value of @ref DCMI_Line_Select_Start     *//*!< Specifies the line of data to be captured by the interface
                                            This parameter can be a value of @ref DCMI_Line_Select_Mode      *//*!< Specifies if the data to be captured by the interface is even or odd
                                            This parameter can be a value of @ref DCMI_Byte_Select_Start     *//*!< Specifies the data to be captured by the interface
                                            This parameter can be a value of @ref DCMI_Byte_Select_Mode      *//*!< Enable or Disable the JPEG mode.
                                             This parameter can be a value of @ref DCMI_MODE_JPEG            *//*!< Specifies the code of the line/frame start delimiter and the
                                             line/frame end delimiter *//*!< Specifies the data width: 8-bit, 10-bit, 12-bit or 14-bit.
                                             This parameter can be a value of @ref DCMI_Extended_Data_Mode   *//*!< Specifies the frequency of frame capture: All, 1/2 or 1/4.
                                             This parameter can be a value of @ref DCMI_Capture_Rate         *//*!< Specifies the Horizontal synchronization polarity: High or Low.
                                             This parameter can be a value of @ref DCMI_HSYNC_Polarity       *//*!< Specifies the Vertical synchronization polarity: High or Low.
                                             This parameter can be a value of @ref DCMI_VSYNC_Polarity       *//*!< Specifies the Pixel clock polarity: Falling or Rising.
                                             This parameter can be a value of @ref DCMI_PIXCK_Polarity       *//*!< Specifies the Synchronization Mode: Hardware or Embedded.
                                             This parameter can be a value of @ref DCMI_Synchronization_Mode *//**
  * @brief   DCMI Init structure definition
  *//*!< Specifies the frame end delimiter unmask.   *//*!< Specifies the line end delimiter unmask.    *//*!< Specifies the line start delimiter unmask.  *//*!< Specifies the frame start delimiter unmask. *//**
  * @brief   DCMI Embedded Synchronisation UNMASK Init structure definition
  *//*!< Specifies the code of the frame end delimiter.   *//*!< Specifies the code of the line end delimiter.    *//*!< Specifies the code of the line start delimiter.  *//*!< Specifies the code of the frame start delimiter. *//**
  * @brief   DCMI Embedded Synchronisation CODE Init structure definition
  *//*!< DCMI suspend state                    *//*!< DCMI error state                      *//*!< DCMI timeout state                    *//*!< DCMI internal processing is ongoing   *//*!< DCMI initialized and ready for use    *//*!< DCMI not yet initialized or disabled  *//**
  * @brief  HAL DCMI State structures definition
  *//** @defgroup DCMI_Exported_Types DCMI Exported Types
  * @{
  *//** @addtogroup DCMI DCMI
  * @brief DCMI HAL module driver
  * @{
  *//**
  ******************************************************************************
  * @file    stm32f7xx_hal_dcmi.h
  * @author  MCD Application Team
  * @brief   Header file of DCMI HAL module.
  ******************************************************************************
  * @attention
  *
  * Copyright (c) 2017 STMicroelectronics.
  * All rights reserved.
  *
  * This software is licensed under terms that can be found in the LICENSE file
  * in the root directory of this software component.
  * If no LICENSE file comes with this software, it is provided AS-IS.
  *
  ******************************************************************************
  */hdcmiSyncUnmaskX0Y0XSizeYSizeDCMI_ModeHAL_ETH_GetMACWakeUpSourceconst ETH_HandleTypeDefconst ETH_HandleTypeDef *HAL_ETH_GetMACErrorHAL_ETH_GetDMAErrorHAL_ETH_GetErrorHAL_ETH_GetStateHAL_ETH_SetWakeUpFilterETH_HandleTypeDef *HAL_ETH_ExitPowerDownModeHAL_ETH_EnterPowerDownModeconst ETH_PowerDownConfigTypeDefconst ETH_PowerDownConfigTypeDef *HAL_ETH_SetSourceMACAddrMatchHAL_ETH_SetHashTableHAL_ETH_SetMACFilterConfigconst ETH_MACFilterConfigTypeDefconst ETH_MACFilterConfigTypeDef *HAL_ETH_GetMACFilterConfigETH_MACFilterConfigTypeDef *HAL_ETH_SetRxVLANIdentifierHAL_ETH_SetMDIOClockRangeHAL_ETH_SetDMAConfigETH_DMAConfigTypeDef *HAL_ETH_SetMACConfigETH_MACConfigTypeDef *HAL_ETH_GetDMAConfigHAL_ETH_GetMACConfigHAL_ETH_TxPtpCallbackETH_TimeStampTypeDef *HAL_ETH_TxFreeCallbackHAL_ETH_RxLinkCallbackvoid **HAL_ETH_RxAllocateCallbackuint8_t **unsigned char **HAL_ETH_WakeUpCallbackHAL_ETH_PMTCallbackHAL_ETH_ErrorCallbackHAL_ETH_RxCpltCallbackHAL_ETH_TxCpltCallbackHAL_ETH_IRQHandlerHAL_ETH_ReadPHYRegisterHAL_ETH_WritePHYRegisterHAL_ETH_Transmit_ITETH_TxPacketConfigTypeDef *HAL_ETH_TransmitHAL_ETH_ReleaseTxPacketHAL_ETH_UnRegisterTxFreeCallbackHAL_ETH_RegisterTxFreeCallbackHAL_ETH_GetRxDataErrorCodeHAL_ETH_UnRegisterRxLinkCallbackHAL_ETH_RegisterRxLinkCallbackHAL_ETH_UnRegisterRxAllocateCallbackHAL_ETH_RegisterRxAllocateCallbackHAL_ETH_ReadDataHAL_ETH_Stop_ITHAL_ETH_StopHAL_ETH_Start_ITHAL_ETH_StartHAL_ETH_MspDeInitHAL_ETH_MspInitHAL_ETH_DeInitHAL_ETH_InitETH_PowerDownConfigTypeDefETH_MACFilterConfigTypeDefETH_HandleTypeDefpETH_txPtpCallbackTypeDefpETH_txFreeCallbackTypeDefpETH_rxLinkCallbackTypeDefpETH_rxAllocateCallbackTypeDefHAL_ETH_StateTypeDefETH_InitTypeDefETH_MediaInterfaceTypeDefHAL_ETH_MII_MODEHAL_ETH_RMII_MODEETH_DMAConfigTypeDefETH_MACConfigTypeDefETH_RxDescListTypeDefETH_TimeStampTypeDefETH_TxDescListTypeDefETH_BufferTypeDef__ETH_BufferTypeDefETH_DMADescTypeDefWakeUpForwardGlobalUnicastMagicPacketWakeUpPacketControlPacketsFilterBroadcastFilterDestAddrInverseFilteringSrcAddrInverseFilteringSrcAddrFilteringPassAllMulticastHashMulticastHashUnicastHachOrPerfectFilterReceiveAllModePromiscuousModetxPtpCallbacktxFreeCallbackrxLinkCallbackrxAllocateCallbackIsPtpConfiguredMACLPIEventMACWakeUpEventMACErrorCodeDMAErrorCodevolatile HAL_ETH_StateTypeDefgStateRxDescListTxDescListETH_TypeDef *RxBuffLenETH_DMADescTypeDef *RxDescTxDescMediaInterfaceMACAddrDescriptorSkipLengthEnhancedDescriptorFormatSecondFrameOperateReceiveThresholdControlForwardUndersizedGoodFramesFlushRxPacketForwardErrorFramesRxDMABurstLengthTransmitThresholdControlTxDMABurstLengthTransmitStoreForwardReceiveStoreForwardDropTCPIPChecksumErrorFrameBurstModeAddressAlignedBeatsDMAArbitrationForwardRxUndersizedGoodPacketForwardRxErrorPacketDropTCPIPChecksumErrorPacketReceiveQueueModeTransmitQueueModeReceiveFlowControlUnicastPausePacketDetectTransmitFlowControlPauseLowThresholdZeroQuantaPausePauseTimeWatchdogTimeoutProgrammableWatchdogExtendedInterPacketGapValExtendedInterPacketGapGiantPacketSizeLimitCRCCheckingRxPacketsSlowProtocolDetectPreambleLengthDeferralCheckBackOffLimitRetryTransmissionCarrierSenseDuringTransmitReceiveOwnCarrierSenseBeforeTransmitLoopbackModeDuplexModeJumboPacketJabberWatchdogAutomaticPadCRCStripCRCStripTypePacketSupport2KPacketGiantPacketSizeLimitControlInterPacketGapValChecksumOffloadSourceAddrControlpRxEndpRxStartTimeStamppRxLastRxDescRxBuildDescCntRxBuildDescIdxRxDataLengthRxDescCntRxDescIdxItModeETH_RX_DESC_CNTTimeStampHighTimeStampLowInnerVlanCtrlInnerVlanTagVlanCtrlVlanTagTCPHeaderLenPayloadLenMaxSegmentSizeChecksumCtrlCRCPadCtrlSrcAddrCtrlETH_BufferTypeDef *__ETH_BufferTypeDef *TxBufferAttributesreleaseIndexBuffersInUseCurrentPacketAddressuint32_t *[4]unsigned long *[4]ETH_TX_DESC_CNTPacketAddressCurTxDescnextBackupAddr1BackupAddr0DESC7DESC6DESC5DESC4DESC3DESC2DESC1DESC0__HAL_ETH_SET_PTP_CONTROL(__HANDLE__,__FLAG__)((__HANDLE__)->Instance->PTPTSCR |= (__FLAG__))__HAL_ETH_GET_PTP_CONTROL(__HANDLE__,__FLAG__)(((((__HANDLE__)->Instance->PTPTSCR) & (__FLAG__)) == (__FLAG__)) ? SET : RESET)__HAL_ETH_WAKEUP_EXTI_GENERATE_SWIT(__EXTI_LINE__)__HAL_ETH_WAKEUP_EXTI_ENABLE_RISING_FALLING_EDGE(__EXTI_LINE__)(EXTI->RTSR |= (__EXTI_LINE__)); (EXTI->FTSR |= (__EXTI_LINE__))__HAL_ETH_WAKEUP_EXTI_ENABLE_FALLING_EDGE(__EXTI_LINE__)(EXTI->RTSR &= ~(__EXTI_LINE__)); (EXTI->FTSR |= (__EXTI_LINE__))__HAL_ETH_WAKEUP_EXTI_ENABLE_RISING_EDGE(__EXTI_LINE__)(EXTI->FTSR &= ~(__EXTI_LINE__)); (EXTI->RTSR |= (__EXTI_LINE__))__HAL_ETH_WAKEUP_EXTI_CLEAR_FLAG(__EXTI_LINE__)__HAL_ETH_WAKEUP_EXTI_GET_FLAG(__EXTI_LINE__)__HAL_ETH_WAKEUP_EXTI_ENABLE_IT(__EXTI_LINE__)(EXTI->IMR |= (__EXTI_LINE__))ETH_WAKEUP_EXTI_LINE__HAL_ETH_MAC_GET_IT(__HANDLE__,__INTERRUPT__)(((__HANDLE__)->Instance->MACSR & ( __INTERRUPT__)) == ( __INTERRUPT__))__HAL_ETH_DMA_CLEAR_FLAG(__HANDLE__,__FLAG__)((__HANDLE__)->Instance->DMASR = ( __FLAG__))__HAL_ETH_DMA_GET_FLAG(__HANDLE__,__FLAG__)(((__HANDLE__)->Instance->DMASR & ( __FLAG__)) == ( __FLAG__))__HAL_ETH_DMA_CLEAR_IT(__HANDLE__,__INTERRUPT__)((__HANDLE__)->Instance->DMASR = (__INTERRUPT__))__HAL_ETH_DMA_GET_IT(__HANDLE__,__INTERRUPT__)(((__HANDLE__)->Instance->DMASR & (__INTERRUPT__)) == (__INTERRUPT__))__HAL_ETH_DMA_GET_IT_SOURCE(__HANDLE__,__INTERRUPT__)(((__HANDLE__)->Instance->DMAIER & (__INTERRUPT__)) == (__INTERRUPT__))__HAL_ETH_DMA_DISABLE_IT(__HANDLE__,__INTERRUPT__)((__HANDLE__)->Instance->DMAIER &= ~(__INTERRUPT__))__HAL_ETH_DMA_ENABLE_IT(__HANDLE__,__INTERRUPT__)((__HANDLE__)->Instance->DMAIER |= (__INTERRUPT__))__HAL_ETH_RESET_HANDLE_STATE(__HANDLE__)do{ (__HANDLE__)->gState = HAL_ETH_STATE_RESET; } while(0)HAL_ETH_PTP_CONFIGUREDHAL_ETH_PTP_NOT_CONFIGUREDETH_DMA_OVERFLOW_MISSEDFRAMECOUNTERETH_DMA_OVERFLOW_RXFIFOCOUNTERETH_DMA_RECEIVEPROCESS_QUEUINGETH_DMA_RECEIVEPROCESS_CLOSINGETH_DMA_RECEIVEPROCESS_SUSPENDEDETH_DMA_RECEIVEPROCESS_WAITINGETH_DMA_RECEIVEPROCESS_FETCHINGETH_DMA_RECEIVEPROCESS_STOPPEDETH_DMA_TRANSMITPROCESS_CLOSING0x00700000UETH_DMA_TRANSMITPROCESS_SUSPENDED0x00600000UETH_DMA_TRANSMITPROCESS_READINGETH_DMA_TRANSMITPROCESS_WAITINGETH_DMA_TRANSMITPROCESS_FETCHINGETH_DMA_TRANSMITPROCESS_STOPPEDETH_DMA_IT_TETH_DMA_IT_TPSETH_DMA_IT_TBUETH_DMA_IT_TJTETH_DMA_IT_ROETH_DMA_IT_TUETH_DMA_IT_RETH_DMA_IT_RBUETH_DMA_IT_RPSETH_DMA_IT_RWTETH_DMA_IT_ETETH_DMA_IT_FBEETH_DMA_IT_ERETH_DMA_IT_AISETH_DMA_IT_NISETH_DMA_IT_MMCETH_DMA_IT_PMTETH_DMA_IT_TSTETH_MAC_IT_PMTETH_MAC_IT_MMCETH_MAC_IT_MMCRETH_MAC_IT_MMCTETH_MAC_IT_TSTETH_DMA_FLAG_TETH_DMA_FLAG_TPSETH_DMA_FLAG_TBUETH_DMA_FLAG_TJTETH_DMA_FLAG_ROETH_DMA_FLAG_TUETH_DMA_FLAG_RETH_DMA_FLAG_RBUETH_DMA_FLAG_RPSETH_DMA_FLAG_RWTETH_DMA_FLAG_ETETH_DMA_FLAG_FBEETH_DMA_FLAG_ERETH_DMA_FLAG_AISETH_DMA_FLAG_NISETH_DMA_FLAG_ACCESSERRORETH_DMA_FLAG_READWRITEERRORETH_DMA_FLAG_DATATRANSFERERRORETH_DMA_FLAG_MMCETH_DMA_FLAG_PMTETH_DMA_FLAG_TSTETH_MAC_FLAG_PMTETH_MAC_FLAG_MMCETH_MAC_FLAG_MMCRETH_MAC_FLAG_MMCTETH_MAC_FLAG_TSTETH_MMC_IT_RFCE0x10000020UETH_MMC_IT_RFAE0x10000040UETH_MMC_IT_RGUF0x10020000UETH_MMC_IT_TGFSCETH_MMC_IT_TGFMSCETH_MMC_IT_TGFETH_PMT_FLAG_MPRETH_PMT_FLAG_WUFRETH_PMT_FLAG_WUFFRPRETH_DMARXDESC_BUFFER2ETH_DMARXDESC_BUFFER1ETH_DMATXDESC_CHECKSUMTCPUDPICMPFULL0x00C00000UETH_DMATXDESC_CHECKSUMTCPUDPICMPSEGMENTETH_DMATXDESC_CHECKSUMIPV4HEADERETH_DMATXDESC_CHECKSUMBYPASSETH_DMATXDESC_FIRSTSEGMENTETH_DMATXDESC_LASTSEGMENTS0x40000000UETH_DMAARBITRATION_RXPRIORTXETH_DMAARBITRATION_ROUNDROBIN_RXTX_4_1ETH_DMAARBITRATION_ROUNDROBIN_RXTX_3_1ETH_DMAARBITRATION_ROUNDROBIN_RXTX_2_1ETH_DMAARBITRATION_ROUNDROBIN_RXTX_1_1ETH_RECEIVEDTHRESHOLDCONTROL_128BYTESETH_RECEIVEDTHRESHOLDCONTROL_96BYTESETH_RECEIVEDTHRESHOLDCONTROL_32BYTESETH_RECEIVEDTHRESHOLDCONTROL_64BYTESETH_TRANSMITTHRESHOLDCONTROL_16BYTESETH_TRANSMITTHRESHOLDCONTROL_24BYTESETH_TRANSMITTHRESHOLDCONTROL_32BYTESETH_TRANSMITTHRESHOLDCONTROL_40BYTESETH_TRANSMITTHRESHOLDCONTROL_256BYTESETH_TRANSMITTHRESHOLDCONTROL_192BYTESETH_TRANSMITTHRESHOLDCONTROL_128BYTESETH_TRANSMITTHRESHOLDCONTROL_64BYTESETH_MAC_ADDRESSMASK_BYTE1ETH_MAC_ADDRESSMASK_BYTE2ETH_MAC_ADDRESSMASK_BYTE3ETH_MAC_ADDRESSMASK_BYTE4ETH_MAC_ADDRESSMASK_BYTE5ETH_MAC_ADDRESSMASK_BYTE6ETH_MAC_ADDRESSFILTER_DAETH_MAC_ADDRESSFILTER_SAETH_TRANSMITFLOWCONTROL_DISABLEETH_TRANSMITFLOWCONTROL_ENABLEETH_RECEIVEFLOWCONTROL_DISABLEETH_RECEIVEFLOWCONTROL_ENABLEETH_UNICASTPAUSEFRAMEDETECT_DISABLEETH_UNICASTPAUSEFRAMEDETECT_ENABLEETH_PAUSELOWTHRESHOLD_MINUS2560x00000030UETH_PAUSELOWTHRESHOLD_MINUS144ETH_PAUSELOWTHRESHOLD_MINUS28ETH_PAUSELOWTHRESHOLD_MINUS4ETH_ZEROQUANTAPAUSE_DISABLEETH_ZEROQUANTAPAUSE_ENABLEETH_UNICASTFRAMESFILTER_PERFECTETH_UNICASTFRAMESFILTER_HASHTABLEETH_UNICASTFRAMESFILTER_PERFECTHASHTABLE0x00000402UETH_MULTICASTFRAMESFILTER_NONEETH_MULTICASTFRAMESFILTER_PERFECTETH_MULTICASTFRAMESFILTER_HASHTABLEETH_MULTICASTFRAMESFILTER_PERFECTHASHTABLE0x00000404UETH_DESTINATIONADDRFILTER_INVERSEETH_DESTINATIONADDRFILTER_NORMALETH_BROADCASTFRAMESRECEPTION_DISABLEETH_BROADCASTFRAMESRECEPTION_ENABLEETH_PASSCONTROLFRAMES_FORWARDPASSEDADDRFILTERETH_PASSCONTROLFRAMES_FORWARDALLETH_PASSCONTROLFRAMES_BLOCKALLETH_SOURCEADDRFILTER_DISABLEETH_SOURCEADDRFILTER_INVERSE_ENABLEETH_SOURCEADDRFILTER_NORMAL_ENABLEETH_RECEIVEALL_DISABLEETH_RECEIVEALL_ENABLEETH_DEFFERRALCHECK_DISABLEETH_DEFFERRALCHECK_ENABLEETH_AUTOMATICPADCRCSTRIP_DISABLEETH_AUTOMATICPADCRCSTRIP_ENABLEETH_RETRYTRANSMISSION_DISABLEETH_RETRYTRANSMISSION_ENABLEETH_CHECKSUMOFFLAOD_DISABLEETH_CHECKSUMOFFLAOD_ENABLEETH_LOOPBACKMODE_DISABLEETH_LOOPBACKMODE_ENABLEETH_RECEIVEOWN_DISABLEETH_RECEIVEOWN_ENABLEETH_CARRIERSENCE_DISABLEETH_CARRIERSENCE_ENABLEETH_INTERFRAMEGAP_40BITETH_INTERFRAMEGAP_48BITETH_INTERFRAMEGAP_56BITETH_INTERFRAMEGAP_64BITETH_INTERFRAMEGAP_72BITETH_INTERFRAMEGAP_80BITETH_INTERFRAMEGAP_88BITETH_INTERFRAMEGAP_96BITETH_JABBER_DISABLEETH_JABBER_ENABLEETH_WATCHDOG_DISABLEETH_WATCHDOG_ENABLEETH_MEDIA_INTERFACE_RMII(SYSCFG_PMC_MII_RMII_SEL)ETH_MEDIA_INTERFACE_MIIETH_CHECKSUM_BY_SOFTWAREETH_CHECKSUM_BY_HARDWAREETH_RXINTERRUPT_MODEETH_RXPOLLING_MODEETH_AUTONEGOTIATION_DISABLEETH_AUTONEGOTIATION_ENABLEHAL_ETH_STATE_ERRORHAL_ETH_STATE_STARTED0x00000023UHAL_ETH_STATE_BUSYHAL_ETH_STATE_READYHAL_ETH_STATE_RESETETH_MAGIC_PACKET_RECIEVEDETH_WAKEUP_FRAME_RECIEVEDETH_MAC_PMT_ITETH_MAC_ADDRESS3ETH_MAC_ADDRESS2ETH_MAC_ADDRESS1ETH_MAC_ADDRESS0ETH_VLANTAGCOMPARISON_16BITETH_VLANTAGCOMPARISON_12BITETH_SOURCEADDRESS_REPLACE_ADDR1ETH_MACCR_SARC_REPADDR1ETH_SOURCEADDRESS_REPLACE_ADDR0ETH_MACCR_SARC_REPADDR0ETH_SOURCEADDRESS_INSERT_ADDR1ETH_MACCR_SARC_INSADDR1ETH_SOURCEADDRESS_INSERT_ADDR0ETH_MACCR_SARC_INSADDR0ETH_SOURCEADDRESS_DISABLEETH_BACKOFFLIMIT_1ETH_BACKOFFLIMIT_4ETH_BACKOFFLIMIT_8ETH_BACKOFFLIMIT_10ETH_HALFDUPLEX_MODEETH_FULLDUPLEX_MODEETH_SPEED_100METH_SPEED_10METH_PAUSELOWTHRESHOLD_MINUS_256ETH_PAUSELOWTHRESHOLD_MINUS_144ETH_PAUSELOWTHRESHOLD_MINUS_28ETH_PAUSELOWTHRESHOLD_MINUS_4ETH_RECEIVETHRESHOLD8_128ETH_RECEIVETHRESHOLD8_96ETH_RECEIVETHRESHOLD8_32ETH_RECEIVETHRESHOLD8_64ETH_RECEIVESTOREFORWARDETH_TRANSMITTHRESHOLD_256ETH_TRANSMITTHRESHOLD_192ETH_TRANSMITTHRESHOLD_128ETH_TRANSMITTHRESHOLD_64ETH_TRANSMITTHRESHOLD_40ETH_TRANSMITTHRESHOLD_32ETH_TRANSMITTHRESHOLD_24ETH_TRANSMITTHRESHOLD_16ETH_TRANSMITSTOREFORWARDETH_DMA_TX_PROCESS_STOPPED_FLAGETH_DMA_RX_BUFFER_UNAVAILABLE_FLAGETH_DMA_RX_PROCESS_STOPPED_FLAGETH_DMA_RX_WATCHDOG_TIMEOUT_FLAGETH_DMA_EARLY_TX_IT_FLAGETH_DMA_FATAL_BUS_ERROR_FLAGETH_DMA_DATA_BUFF_ACCESS_ERROR_FLAGETH_DMA_DESC_ACCESS_ERROR_FLAGETH_DMA_WRITE_TRANS_ERROR_FLAGETH_DMA_READ_TRANS_ERROR_FLAGETH_DMA_RX_DATA_TRANS_ERROR_FLAGETH_DMA_TX_DATA_TRANS_ERROR_FLAGETH_DMA_NO_ERROR_FLAGETH_DMA_TX_ITETH_DMA_TX_PROCESS_STOPPED_ITETH_DMA_TX_BUFFER_UNAVAILABLE_ITETH_DMA_RX_ITETH_DMA_RX_BUFFER_UNAVAILABLE_ITETH_DMA_RX_PROCESS_STOPPED_ITETH_DMA_RX_WATCHDOG_TIMEOUT_ITETH_DMA_EARLY_TX_ITETH_DMA_EARLY_RX_ITETH_DMA_FATAL_BUS_ERROR_ITETH_DMA_ABNORMAL_ITETH_DMA_NORMAL_ITETH_RXDMABURSTLENGTH_4XPBL_128BEATETH_RXDMABURSTLENGTH_4XPBL_64BEATETH_RXDMABURSTLENGTH_4XPBL_32BEATETH_RXDMABURSTLENGTH_4XPBL_16BEATETH_RXDMABURSTLENGTH_4XPBL_8BEATETH_RXDMABURSTLENGTH_4XPBL_4BEATETH_RXDMABURSTLENGTH_32BEATETH_RXDMABURSTLENGTH_16BEATETH_RXDMABURSTLENGTH_8BEATETH_RXDMABURSTLENGTH_4BEATETH_RXDMABURSTLENGTH_2BEATETH_RXDMABURSTLENGTH_1BEATETH_TXDMABURSTLENGTH_4XPBL_128BEATETH_TXDMABURSTLENGTH_4XPBL_64BEATETH_TXDMABURSTLENGTH_4XPBL_32BEATETH_TXDMABURSTLENGTH_4XPBL_16BEATETH_TXDMABURSTLENGTH_4XPBL_8BEATETH_TXDMABURSTLENGTH_4XPBL_4BEATETH_TXDMABURSTLENGTH_32BEATETH_TXDMABURSTLENGTH_16BEATETH_TXDMABURSTLENGTH_8BEATETH_TXDMABURSTLENGTH_4BEATETH_TXDMABURSTLENGTH_2BEATETH_TXDMABURSTLENGTH_1BEATETH_BURSTLENGTH_UNSPECIFIEDETH_BURSTLENGTH_MIXEDETH_BURSTLENGTH_FIXEDETH_DMAARBITRATION_TX8_RX1(ETH_DMAMR_TXPR | ETH_DMAMR_PR_8_1)ETH_DMAARBITRATION_TX7_RX1(ETH_DMAMR_TXPR | ETH_DMAMR_PR_7_1)ETH_DMAARBITRATION_TX6_RX1(ETH_DMAMR_TXPR | ETH_DMAMR_PR_6_1)ETH_DMAARBITRATION_TX5_RX1(ETH_DMAMR_TXPR | ETH_DMAMR_PR_5_1)ETH_DMAARBITRATION_TX4_RX1(ETH_DMAMR_TXPR | ETH_DMAMR_PR_4_1)ETH_DMAARBITRATION_TX3_RX1(ETH_DMAMR_TXPR | ETH_DMAMR_PR_3_1)ETH_DMAARBITRATION_TX2_RX1(ETH_DMAMR_TXPR | ETH_DMAMR_PR_2_1)ETH_DMAARBITRATION_TX1_RX1ETH_DMAARBITRATION_TX(ETH_DMAMR_TXPR | ETH_DMAMR_DA)ETH_DMAARBITRATION_RX4_TX1ETH_DMAARBITRATION_RX3_TX1ETH_DMAARBITRATION_RX2_TX1ETH_DMAARBITRATION_RX1_TX1ETH_DMAARBITRATION_RXETH_CRC_ERRORETH_DMARXDESC_CEETH_GIANT_PACKETETH_DMARXDESC_IPV4HCETH_WATCHDOG_TIMEOUTETH_DMARXDESC_RWTETH_RECEIVE_OVERFLOWETH_DMARXDESC_OEETH_RECEIVE_ERRORETH_DMARXDESC_REETH_DRIBBLE_BIT_ERRORETH_DMARXDESC_DBEETH_SOURCE_ADDRESS_FAILETH_DMARXDESC_SAFETH_DEST_ADDRESS_FAILETH_DMARXDESC_AFMETH_VLAN_FILTER_PASSETH_DMARXDESC_VLANETH_CHECKSUM_IPHDR_PAYLOAD_INSERT_PHDR_CALCETH_DMATXDESC_CIC_TCPUDPICMP_FULLETH_CHECKSUM_IPHDR_PAYLOAD_INSERTETH_DMATXDESC_CIC_TCPUDPICMP_SEGMENTETH_CHECKSUM_IPHDR_INSERTETH_DMATXDESC_CIC_IPV4HEADERETH_CHECKSUM_DISABLEETH_DMATXDESC_CIC_BYPASSETH_CRC_INSERTETH_DMATXDESC_DPETH_CRC_PAD_INSERTETH_CRC_PAD_DISABLE(uint32_t)(ETH_DMATXDESC_DP | ETH_DMATXDESC_DC)ETH_TX_PACKETS_FEATURES_CRCPADETH_TX_PACKETS_FEATURES_TSOETH_TX_PACKETS_FEATURES_INNERVLANTAGETH_TX_PACKETS_FEATURES_VLANTAGETH_TX_PACKETS_FEATURES_SAICETH_TX_PACKETS_FEATURES_CSUMHAL_ETH_ERROR_MACHAL_ETH_ERROR_DMAHAL_ETH_ERROR_TIMEOUTHAL_ETH_ERROR_BUSYHAL_ETH_ERROR_PARAMHAL_ETH_ERROR_NONE9000UETH_MAX_PAYLOAD1500UETH_MIN_PAYLOAD46UETH_CRCETH_HEADERETH_MAX_PACKET_SIZE1528UETH_DMAPTPRXDESC_RTSHETH_DMAPTPRXDESC_RTSLETH_DMAPTPRXDESC_IPPT_ICMPETH_DMAPTPRXDESC_IPPT_TCPETH_DMAPTPRXDESC_IPPT_UDPETH_DMAPTPRXDESC_IPPTETH_DMAPTPRXDESC_IPHEETH_DMAPTPRXDESC_IPPEETH_DMAPTPRXDESC_IPCBETH_DMAPTPRXDESC_IPV4PRETH_DMAPTPRXDESC_IPV6PRETH_DMAPTPRXDESC_PTPMT_PDELAYRESPFOLLOWUP_SIGNAL0x00000700UETH_DMAPTPRXDESC_PTPMT_PDELAYRESP_MANAG0x00000600UETH_DMAPTPRXDESC_PTPMT_PDELAYREQ_ANNOUNCE0x00000500UETH_DMAPTPRXDESC_PTPMT_DELAYRESPETH_DMAPTPRXDESC_PTPMT_DELAYREQETH_DMAPTPRXDESC_PTPMT_FOLLOWUPETH_DMAPTPRXDESC_PTPMT_SYNCETH_DMAPTPRXDESC_PTPMTETH_DMAPTPRXDESC_PTPFTETH_DMAPTPRXDESC_PTPVETH_DMARXDESC_B2APETH_DMARXDESC_B1APETH_DMARXDESC_RBS10x00001FFFUETH_DMARXDESC_RCHETH_DMARXDESC_RERETH_DMARXDESC_RBS20x1FFF0000UETH_DMARXDESC_DICETH_DMARXDESC_MAMPCEETH_DMARXDESC_FTETH_DMARXDESC_LCETH_DMARXDESC_IPV4HCEETH_DMARXDESC_LSETH_DMARXDESC_FSETH_DMARXDESC_LEETH_DMARXDESC_DEETH_DMARXDESC_ESETH_DMARXDESC_FL0x3FFF0000UETH_DMARXDESC_OWNETH_DMAPTPTXDESC_TTSHETH_DMAPTPTXDESC_TTSLETH_DMATXDESC_B2APETH_DMATXDESC_B1APETH_DMATXDESC_TBS1ETH_DMATXDESC_TBS2ETH_DMATXDESC_DBETH_DMATXDESC_UFETH_DMATXDESC_EDETH_DMATXDESC_CC0x00000078UETH_DMATXDESC_VFETH_DMATXDESC_ECETH_DMATXDESC_LCOETH_DMATXDESC_NCETH_DMATXDESC_LCAETH_DMATXDESC_PCEETH_DMATXDESC_FFETH_DMATXDESC_JTETH_DMATXDESC_ESETH_DMATXDESC_IHEETH_DMATXDESC_TTSSETH_DMATXDESC_TCHETH_DMATXDESC_TERETH_DMATXDESC_CICETH_DMATXDESC_TTSEETH_DMATXDESC_DCETH_DMATXDESC_FSETH_DMATXDESC_LSETH_DMATXDESC_ICETH_DMATXDESC_OWNSTM32F7xx_HAL_ETH_Hdefined(ETH)HAL_ETH_USE_PTP(USE_HAL_ETH_REGISTER_CALLBACKS == 1)/* STM32F7xx_HAL_ETH_H *//* ETH *//* Peripheral State functions  **************************************************//** @addtogroup ETH_Exported_Functions_Group4
  * @{
  *//* MAC Power Down APIs    *****************************************************//* MAC L2 Packet Filtering APIs  **********************************************//* MAC VLAN Processing APIs    ************************************************//* MAC & DMA Configuration APIs  **********************************************//* Peripheral Control functions  **********************************************//** @addtogroup ETH_Exported_Functions_Group3
  * @{
  *//* HAL_ETH_USE_PTP *//** @addtogroup ETH_Exported_Functions_Group2
  * @{
  *//* USE_HAL_ETH_REGISTER_CALLBACKS *//* Initialization and de initialization functions  **********************************//** @addtogroup ETH_Exported_Functions_Group1
  * @{
  *//** @addtogroup ETH_Exported_Functions
  * @{
  *//**
  * @brief  Generates a Software interrupt on selected EXTI line.
  * @param  __EXTI_LINE__: specifies the ETH WAKEUP EXTI sources to be disabled.
  *  @arg ETH_WAKEUP_EXTI_LINE
  * @retval None
  *//**
  * @brief  enable falling edge interrupt on selected EXTI line.
  * @param  __EXTI_LINE__: specifies the ETH WAKEUP EXTI sources to be disabled.
  *  @arg ETH_WAKEUP_EXTI_LINE
  * @retval None
  *//**
  * @brief  enable rising edge interrupt on selected EXTI line.
  * @param  __EXTI_LINE__: specifies the ETH WAKEUP EXTI sources to be disabled.
  *  @arg ETH_WAKEUP_EXTI_LINE
  * @retval None
  *//**
  * @brief Clear the ETH WAKEUP Exti flag.
  * @param  __EXTI_LINE__: specifies the ETH WAKEUP Exti sources to be cleared.
  *   @arg ETH_WAKEUP_EXTI_LINE
  * @retval None.
  *//**
  * @brief checks whether the specified ETH WAKEUP Exti interrupt flag is set or not.
  * @param  __EXTI_LINE__: specifies the ETH WAKEUP Exti sources to be cleared.
  *   @arg ETH_WAKEUP_EXTI_LINE
  * @retval EXTI ETH WAKEUP Line Status.
  *//**
  * @brief Enable the ETH WAKEUP Exti Line.
  * @param  __EXTI_LINE__: specifies the ETH WAKEUP Exti sources to be enabled.
  *   @arg ETH_WAKEUP_EXTI_LINE
  * @retval None.
  *//*!< External interrupt line 19 Connected to the ETH wakeup EXTI Line *//**
  * @brief  Checks whether the specified ETHERNET MAC flag is set or not.
  * @param  __HANDLE__: ETH Handle
  * @param  __INTERRUPT__: specifies the flag to check. @ref ETH_MAC_Interrupts
  * @retval The state of ETH MAC IT (SET or RESET).
  *//**
  * @brief  Clears the specified ETHERNET DMA flag.
  * @param  __HANDLE__: ETH Handle
  * @param  __FLAG__: specifies the flag to check. @ref ETH_DMA_Status_Flags
  * @retval The state of ETH DMA FLAG (SET or RESET).
  *//**
  * @brief  Checks whether the specified ETHERNET DMA flag is set or not.
  * @param  __HANDLE__: ETH Handle
  * @param  __FLAG__: specifies the flag to check. @ref ETH_DMA_Status_Flags
  * @retval The state of ETH DMA FLAG (SET or RESET).
  *//**
  * @brief  Clears the ETHERNET DMA IT pending bit.
  * @param  __HANDLE__   : ETH Handle
  * @param  __INTERRUPT__: specifies the interrupt pending bit to clear. @ref ETH_DMA_Interrupts
  * @retval None
  *//**
  * @brief  Gets the ETHERNET DMA IT pending bit.
  * @param  __HANDLE__   : ETH Handle
  * @param  __INTERRUPT__: specifies the interrupt source to get . @ref ETH_DMA_Interrupts
  * @retval The state of ETH DMA IT (SET or RESET)
  *//**
  * @brief  Gets the ETHERNET DMA IT source enabled or disabled.
  * @param  __HANDLE__   : ETH Handle
  * @param  __INTERRUPT__: specifies the interrupt source to get . @ref ETH_DMA_Interrupts
  * @retval The ETH DMA IT Source enabled or disabled
  *//**
  * @brief  Disables the specified ETHERNET DMA interrupts.
  * @param  __HANDLE__   : ETH Handle
  * @param  __INTERRUPT__: specifies the ETHERNET DMA interrupt sources to be
  *   disabled. @ref ETH_DMA_Interrupts
  * @retval None
  *//**
  * @brief  Enables the specified ETHERNET DMA interrupts.
  * @param  __HANDLE__   : ETH Handle
  * @param  __INTERRUPT__: specifies the ETHERNET DMA interrupt sources to be
  *   enabled @ref ETH_DMA_Interrupts
  * @retval None
  *//*USE_HAL_ETH_REGISTER_CALLBACKS *//** @brief Reset ETH handle state
  * @param  __HANDLE__: specifies the ETH handle.
  * @retval None
  *//** @defgroup ETH_Exported_Macros ETH Exported Macros
  * @{
  *//*!< ETH PTP Configuration done     *//*!< ETH PTP Configuration not done *//** @defgroup ETH_PTP_Config_Status ETH PTP Config Status
  * @{
  *//*!< Overflow bit for missed frame counter *//*!< Overflow bit for FIFO overflow counter *//** @defgroup ETH_DMA_overflow ETH DMA overflow
  * @{
  *//*!< Running - queuing the receive frame into host memory *//*!< Running - closing descriptor *//*!< Suspended - Rx Descriptor unavailable *//*!< Running - waiting for packet *//*!< Running - fetching the Rx descriptor *//*!< Stopped - Reset or Stop Rx Command issued *//** @defgroup ETH_DMA_receive_process_state ETH DMA receive process state
  * @{
  *//*!< Running - closing Rx descriptor *//*!< Suspended - Tx Descriptor unavailable *//*!< Running - reading the data from host memory *//*!< Running - waiting for status *//*!< Running - fetching the Tx descriptor *//*!< Stopped - Reset or Stop Tx Command issued *//** @defgroup ETH_DMA_transmit_process_state ETH DMA transmit process state
  * @{
  *//*!< Transmit interrupt *//*!< Transmit process stopped interrupt *//*!< Transmit buffer unavailable interrupt *//*!< Transmit jabber timeout interrupt *//*!< Overflow interrupt *//*!< Underflow interrupt *//*!< Receive interrupt *//*!< Receive buffer unavailable interrupt *//*!< Receive process stopped interrupt *//*!< Receive watchdog timeout interrupt *//*!< Early transmit interrupt *//*!< Fatal bus error interrupt *//*!< Early receive interrupt *//*!< Abnormal interrupt summary *//*!< Normal interrupt summary *//*!< MMC interrupt (on DMA) *//*!< PMT interrupt (on DMA) *//*!< Time-stamp trigger interrupt (on DMA) *//** @defgroup ETH_DMA_Interrupts ETH DMA Interrupts
  * @{
  *//*!< PMT interrupt (on MAC) *//*!< MMC interrupt (on MAC) *//*!< MMC receive interrupt *//*!< MMC transmit interrupt *//*!< Time stamp trigger interrupt (on MAC) *//** @defgroup ETH_MAC_Interrupts ETH MAC Interrupts
  * @{
  *//*!< Transmit flag *//*!< Transmit process stopped flag *//*!< Transmit buffer unavailable flag *//*!< Transmit jabber timeout flag *//*!< Overflow flag *//*!< Underflow flag *//*!< Receive flag *//*!< Receive buffer unavailable flag *//*!< Receive process stopped flag *//*!< Receive watchdog timeout flag *//*!< Early transmit flag *//*!< Fatal bus error flag *//*!< Early receive flag *//*!< Abnormal interrupt summary flag *//*!< Normal interrupt summary flag *//*!< Error bits 0-data buffer, 1-desc. access *//*!< Error bits 0-write transfer, 1-read transfer *//*!< Error bits 0-Rx DMA, 1-Tx DMA *//** @defgroup ETH_DMA_Flags ETH DMA Flags
  * @{
  *//*!< PMT flag (on MAC) *//*!< MMC flag (on MAC) *//*!< MMC receive flag *//*!< MMC transmit flag  *//*!< Time stamp trigger flag (on MAC) *//** @defgroup ETH_MAC_Flags ETH MAC Flags
  * @{
  *//*!< When Rx crc error counter reaches half the maximum value *//*!< When Rx alignment error counter reaches half the maximum value *//*!< When Rx good unicast frames counter reaches half the maximum value *//** @defgroup ETH_MMC_Rx_Interrupts ETH MMC Rx Interrupts
  * @{
  *//*!< When Tx good single col counter reaches half the maximum value *//*!< When Tx good multi col counter reaches half the maximum value *//*!< When Tx good frame counter reaches half the maximum value *//** @defgroup ETH_MMC_Tx_Interrupts ETH MMC Tx Interrupts
  * @{
  *//*!< Magic Packet Received *//*!< Wake-Up Frame Received *//*!< Wake-Up Frame Filter Register Pointer Reset *//** @defgroup ETH_PMT_Flags ETH PMT Flags
  * @{
  *//*!< DMA Rx Desc Buffer2 *//*!< DMA Rx Desc Buffer1 *//** @defgroup ETH_DMA_Rx_descriptor_buffers ETH DMA Rx descriptor buffers
  * @{
  *//*!< TCP/UDP/ICMP checksum fully in hardware including pseudo header *//*!< TCP/UDP/ICMP checksum insertion. Pseudo header checksum is assumed to be present *//*!< IPv4 header checksum insertion  *//*!< Checksum engine bypass *//** @defgroup ETH_DMA_Tx_descriptor_Checksum_Insertion_Control ETH DMA Tx descriptor Checksum Insertion Control
  * @{
  *//*!< First Segment *//*!< Last Segment *//** @defgroup ETH_DMA_Tx_descriptor_segment ETH DMA Tx descriptor segment
  * @{
  *//** @defgroup ETH_DMA_Arbitration ETH DMA Arbitration
  * @{
  *//*!< threshold level of the MTL Receive FIFO is 128 Bytes *//*!< threshold level of the MTL Receive FIFO is 96 Bytes *//*!< threshold level of the MTL Receive FIFO is 32 Bytes *//*!< threshold level of the MTL Receive FIFO is 64 Bytes *//** @defgroup ETH_Receive_Threshold_Control ETH Receive Threshold Control
  * @{
  *//*!< threshold level of the MTL Transmit FIFO is 16 Bytes *//*!< threshold level of the MTL Transmit FIFO is 24 Bytes *//*!< threshold level of the MTL Transmit FIFO is 32 Bytes *//*!< threshold level of the MTL Transmit FIFO is 40 Bytes *//*!< threshold level of the MTL Transmit FIFO is 256 Bytes *//*!< threshold level of the MTL Transmit FIFO is 192 Bytes *//*!< threshold level of the MTL Transmit FIFO is 128 Bytes *//*!< threshold level of the MTL Transmit FIFO is 64 Bytes *//** @defgroup ETH_Transmit_Threshold_Control ETH Transmit Threshold Control
  * @{
  *//*!< Mask MAC Address low reg bits [70] *//*!< Mask MAC Address low reg bits [15:8] *//*!< Mask MAC Address low reg bits [23:16] *//*!< Mask MAC Address low reg bits [31:24] *//*!< Mask MAC Address high reg bits [7:0] *//*!< Mask MAC Address high reg bits [15:8] *//** @defgroup ETH_MAC_addresses_filter_Mask_bytes ETH MAC addresses filter Mask bytes
  * @{
  *//** @defgroup ETH_MAC_addresses_filter_SA_DA ETH MAC addresses filter SA DA
  * @{
  *//** @defgroup ETH_Transmit_Flow_Control ETH Transmit Flow Control
  * @{
  *//** @defgroup ETH_Receive_Flow_Control ETH Receive Flow Control
  * @{
  *//** @defgroup ETH_Unicast_Pause_Frame_Detect ETH Unicast Pause Frame Detect
  * @{
  *//*!< Pause time minus 256 slot times *//*!< Pause time minus 144 slot times *//*!< Pause time minus 28 slot times *//*!< Pause time minus 4 slot times *//** @defgroup ETH_Pause_Low_Threshold ETH Pause Low Threshold
  * @{
  *//** @defgroup ETH_Zero_Quanta_Pause ETH Zero Quanta Pause
  * @{
  *//** @defgroup ETH_Unicast_Frames_Filter ETH Unicast Frames Filter
  * @{
  *//** @defgroup ETH_Multicast_Frames_Filter ETH Multicast Frames Filter
  * @{
  *//** @defgroup ETH_Promiscuous_Mode ETH Promiscuous Mode
  * @{
  *//** @defgroup ETH_Destination_Addr_Filter ETH Destination Addr Filter
  * @{
  *//** @defgroup ETH_Broadcast_Frames_Reception ETH Broadcast Frames Reception
  * @{
  *//*!< MAC forwards control frames that pass the Address Filter. *//*!< MAC forwards all control frames to application even if they fail the Address Filter *//*!< MAC filters all control frames from reaching the application *//** @defgroup ETH_Pass_Control_Frames ETH Pass Control Frames
  * @{
  *//** @defgroup ETH_Source_Addr_Filter ETH Source Addr Filter
  * @{
  *//** @defgroup ETH_Receive_All ETH Receive All
  * @{
  *//** @defgroup ETH_Deferral_Check ETH Deferral Check
  * @{
  *//** @defgroup ETH_Automatic_Pad_CRC_Strip ETH Automatic Pad CRC Strip
  * @{
  *//** @defgroup ETH_Retry_Transmission ETH Retry Transmission
  * @{
  *//** @defgroup ETH_Checksum_Offload ETH Checksum Offload
  * @{
  *//** @defgroup ETH_Loop_Back_Mode ETH Loop Back Mode
  * @{
  *//** @defgroup ETH_Receive_Own ETH Receive Own
  * @{
  *//** @defgroup ETH_Carrier_Sense ETH Carrier Sense
  * @{
  *//*!< minimum IFG between frames during transmission is 40Bit *//*!< minimum IFG between frames during transmission is 48Bit *//*!< minimum IFG between frames during transmission is 56Bit *//*!< minimum IFG between frames during transmission is 64Bit *//*!< minimum IFG between frames during transmission is 72Bit *//*!< minimum IFG between frames during transmission is 80Bit *//*!< minimum IFG between frames during transmission is 88Bit *//*!< minimum IFG between frames during transmission is 96Bit *//** @defgroup ETH_Inter_Frame_Gap ETH Inter Frame Gap
  * @{
  *//** @defgroup ETH_Jabber ETH Jabber
  * @{
  *//** @defgroup ETH_Watchdog ETH Watchdog
  * @{
  *//** @defgroup ETH_Media_Interface ETH Media Interface
  * @{
  *//** @defgroup ETH_Checksum_Mode ETH Checksum Mode
  * @{
  *//** @defgroup ETH_Rx_Mode ETH Rx Mode
  * @{
  *//** @defgroup ETH_AutoNegotiation ETH AutoNegotiation
  * @{
  *//*!< Error State                                *//*!< an internal process is started             *//*!< an internal process is ongoing             *//*!< Peripheral Communication started           *//*!< Peripheral not yet Initialized or disabled *//** @defgroup ETH_State_Codes ETH States
  * @{
  *//** @defgroup ETH_MAC_Wake_Up_Event ETH MAC Wake Up Event
  * @{
  *//** @defgroup ETH_MAC_addresses ETH MAC addresses
  * @{
  *//** @defgroup ETH_VLAN_Tag_Comparison ETH VLAN Tag Comparison
  * @{
  *//** @defgroup ETH_Source_Addr_Control ETH Source Addr Control
  * @{
  *//** @defgroup ETH_Back_Off_Limit ETH Back Off Limit
  * @{
  *//** @defgroup ETH_Duplex_Mode ETH Duplex Mode
  * @{
  *//** @defgroup ETH_Speed  ETH Speed
  * @{
  *//** @defgroup ETH_Pause_Low_Threshold  ETH Pause Low Threshold
  * @{
  *//** @defgroup ETH_Receive_Mode ETH Receive Mode
  * @{
  *//** @defgroup ETH_Transmit_Mode ETH Transmit Mode
  * @{
  *//** @defgroup ETH_DMA_Status_Flags ETH DMA Status Flags
  * @{
  *//*!< maximum number of beats to be transferred in one RxDMA transaction is 128 *//*!< maximum number of beats to be transferred in one RxDMA transaction is 64 *//*!< maximum number of beats to be transferred in one RxDMA transaction is 32 *//*!< maximum number of beats to be transferred in one RxDMA transaction is 16 *//*!< maximum number of beats to be transferred in one RxDMA transaction is 8 *//*!< maximum number of beats to be transferred in one RxDMA transaction is 4 *//*!< maximum number of beats to be transferred in one RxDMA transaction is 2 *//*!< maximum number of beats to be transferred in one RxDMA transaction is 1 *//** @defgroup ETH_Rx_DMA_Burst_Length ETH Rx DMA Burst Length
  * @{
  *//*!< maximum number of beats to be transferred in one TxDMA (or both) transaction is 128 *//*!< maximum number of beats to be transferred in one TxDMA (or both) transaction is 64 *//*!< maximum number of beats to be transferred in one TxDMA (or both) transaction is 32 *//*!< maximum number of beats to be transferred in one TxDMA (or both) transaction is 16 *//*!< maximum number of beats to be transferred in one TxDMA (or both) transaction is 8 *//*!< maximum number of beats to be transferred in one TxDMA (or both) transaction is 4 *//*!< maximum number of beats to be transferred in one TxDMA (or both) transaction is 2 *//*!< maximum number of beats to be transferred in one TxDMA (or both) transaction is 1 *//** @defgroup ETH_Tx_DMA_Burst_Length ETH Tx DMA Burst Length
  * @{
  *//** @defgroup ETH_Burst_Mode ETH Burst Mode
  * @{
  *//** @defgroup ETH_Rx_Error_Code ETH Rx Error Code
  * @{
  *//** @defgroup ETH_Rx_MAC_Filter_Status ETH Rx MAC Filter Status
  * @{
  *//** @defgroup ETH_Tx_Packet_Checksum_Control ETH Tx Packet Checksum Control
  * @{
  *//** @defgroup ETH_Tx_Packet_CRC_Pad_Control ETH Tx Packet CRC Pad Control
  * @{
  *//** @defgroup ETH_Tx_Packet_Attributes ETH Tx Packet Attributes
  * @{
  *//*!< Invalid Callback error  *//*!< MAC transfer error  *//*!< DMA transfer error  *//*!< Timeout error       *//*!< Parameter error     *//*!< Busy error          *//*!< No error            *//** @defgroup ETH_Error_Code ETH Error Code
  * @{
  *//*!< Jumbo frame payload size *//*!< Maximum Ethernet payload size *//*!< Minimum Ethernet payload size *//*!< optional 802.1q VLAN Tag *//*!< Ethernet CRC *//*!< 6 byte Dest addr, 6 byte Src addr, 2 byte length/type *//*!< ETH_HEADER + 2*VLAN_TAG + MAX_ETH_PAYLOAD + ETH_CRC *//** @defgroup ETH_Frame_settings ETH frame settings
  * @{
  *//* Receive Time Stamp High *//* Bit definition of RDES7 register *//* Receive Time Stamp Low *//* Bit definition of RDES6 register *//* ICMP payload encapsulated in
                                                                                     the IP datagram *//* TCP payload encapsulated in
                                                                                   the IP datagram *//* UDP payload encapsulated in
                                                                                   the IP datagram *//* IP Payload Type *//* IP Header Error *//* IP Payload Error *//* IP Checksum Bypassed *//* IPv4 Packet Received *//* IPv6 Packet Received *//* PdelayRespFollowUp message
                                                                                  (peer-to-peer transparent clock)
                                                                                   or Signaling message (Ordinary
                                                                                   or Boundary clock) *//* PdelayResp message
                                                                                   (peer-to-peer transparent clock)
                                                                                    or Management message (Ordinary
                                                                                    or Boundary clock)  *//* PdelayReq message
                                                                                   (peer-to-peer transparent clock)
                                                                                    or Announce message (Ordinary
                                                                                    or Boundary clock) *//* DelayResp message
                                                                                   (all clock types) *//* DelayReq message
                                                                                   (all clock types) *//* FollowUp message
                                                                                   (all clock types) *//* SYNC message
                                                                                   (all clock types) *//* PTP Message Type *//* PTP Frame Type *//* PTP Version *//* Bit definition of RDES4 register *//*---------------------------------------------------------------------------------------------------------------------
  RDES4 |                   Reserved[31:15]              |             Extended Status [14:0]                          |
  ---------------------------------------------------------------------------------------------------------------------
  RDES5 |                                            Reserved[31:0]                                                    |
  ---------------------------------------------------------------------------------------------------------------------
  RDES6 |                                       Receive Time Stamp Low [31:0]                                          |
  ---------------------------------------------------------------------------------------------------------------------
  RDES7 |                                       Receive Time Stamp High [31:0]                                         |
  --------------------------------------------------------------------------------------------------------------------*//*!< Buffer2 Address Pointer *//**
  * @brief  Bit definition of RDES3 register
  *//*!< Buffer1 Address Pointer *//**
  * @brief  Bit definition of RDES2 register
  *//*!< Receive Buffer1 Size *//*!< Second Address Chained *//*!< Receive End of Ring *//*!< Receive Buffer2 Size *//*!< Disable Interrupt on Completion *//**
  * @brief  Bit definition of RDES1 register
  *//*!< Rx MAC Address/Payload Checksum Error: Rx MAC address matched/ Rx Payload Checksum Error *//*!< CRC error *//*!< Dribble bit error: frame contains non int multiple of 8 bits  *//*!< Receive error: error reported by MII interface  *//*!< Receive Watchdog Timeout: watchdog timer expired during reception    *//*!< Frame type - Ethernet, otherwise 802.3    *//*!< Late collision occurred during reception   *//*!< IPC Checksum Error: Rx Ipv4 header checksum error   *//*!< Last descriptor of the frame  *//*!< First descriptor of the frame  *//*!< VLAN Tag: received frame is a VLAN frame *//*!< Overflow Error: Frame was damaged due to buffer overflow *//*!< Frame size not matching with length field *//*!< SA Filter Fail for the received frame *//*!< Descriptor error: no more descriptors for receive frame  *//*!< Error summary: OR of the following bits: DE || OE || IPC || LC || RWT || RE || CE *//*!< Receive descriptor frame length  *//*!< DA Filter Fail for the rx frame  *//*!< OWN bit: descriptor is owned by DMA engine  *//**
  * @brief  Bit definition of RDES0 register: DMA Rx descriptor status register
  *//*
  DMA Rx Normal Descriptor read format
  --------------------------------------------------------------------------------------------------------------------
  RDES0 | OWN(31) |                                             Status [30:0]                                          |
  ---------------------------------------------------------------------------------------------------------------------
  RDES1 | CTRL(31) | Reserved[30:29] | Buffer2 ByteCount[28:16] | CTRL[15:14] | Reserved(13) | Buffer1 ByteCount[12:0] |
  ---------------------------------------------------------------------------------------------------------------------
  RDES2 |                                       Buffer1 Address [31:0]                                                 |
  ---------------------------------------------------------------------------------------------------------------------
  RDES3 |                          Buffer2 Address [31:0] / Next Descriptor Address [31:0]                             |
  ---------------------------------------------------------------------------------------------------------------------
*//** @defgroup ETH_DMA_Rx_Descriptor_Bit_Definition ETH DMA Rx Descriptor Bit Definition
  * @{
  *//* Transmit Time Stamp High *//* Bit definition of TDES7 register *//* Transmit Time Stamp Low *//* Bit definition of TDES6 register *//*---------------------------------------------------------------------------------------------
TDES6 |                         Transmit Time Stamp Low [31:0]                                 |
-----------------------------------------------------------------------------------------------
TDES7 |                         Transmit Time Stamp High [31:0]                                |
----------------------------------------------------------------------------------------------*//**
  * @brief  Bit definition of TDES3 register
  *//**
  * @brief  Bit definition of TDES2 register
  *//*!< Transmit Buffer1 Size *//*!< Transmit Buffer2 Size *//**
  * @brief  Bit definition of TDES1 register
  *//*!< Deferred Bit *//*!< Underflow Error: late data arrival from the memory *//*!< Excessive Deferral *//*!< Collision Count *//*!< VLAN Frame *//*!< Excessive Collision: transmission aborted after 16 collisions *//*!< Late Collision: transmission aborted due to collision *//*!< No Carrier: no carrier signal from the transceiver *//*!< Loss of Carrier: carrier lost during transmission *//*!< Payload Checksum Error *//*!< Frame Flushed: DMA/MTL flushed the frame due to SW flush *//*!< Jabber Timeout *//*!< Error summary: OR of the following bits: UE || ED || EC || LCO || NC || LCA || FF || JT *//*!< IP Header Error *//*!< Tx Time Stamp Status *//*!< Transmit End of Ring *//*!< TCP/UDP/ICMP Checksum Insertion fully calculated *//*!< TCP/UDP/ICMP Checksum Insertion calculated over segment only *//*!< IPV4 header Checksum Insertion *//*!< Do Nothing: Checksum Engine is bypassed *//*!< Checksum Insertion Control: 4 cases *//*!< Transmit Time Stamp Enable *//*!< Disable Padding *//*!< Disable CRC *//*!< Interrupt on Completion *//*!< OWN bit: descriptor is owned by DMA engine *//**
  * @brief  Bit definition of TDES0 register: DMA Tx descriptor status register
  *//*
   DMA Tx Normal Descriptor Read Format
  -----------------------------------------------------------------------------------------------
  TDES0 | OWN(31) | CTRL[30:26] | Reserved[25:24] | CTRL[23:20] | Reserved[19:17] | Status[16:0] |
  -----------------------------------------------------------------------------------------------
  TDES1 | Reserved[31:29] | Buffer2 ByteCount[28:16] | Reserved[15:13] | Buffer1 ByteCount[12:0] |
  -----------------------------------------------------------------------------------------------
  TDES2 |                         Buffer1 Address [31:0]                                         |
  -----------------------------------------------------------------------------------------------
  TDES3 |                   Buffer2 Address [31:0] / Next Descriptor Address [31:0]              |
  -----------------------------------------------------------------------------------------------
*//** @defgroup ETH_DMA_Tx_Descriptor_Bit_Definition ETH DMA Tx Descriptor Bit Definition
  * @{
  *//** @defgroup ETH_Exported_Constants ETH Exported Constants
  * @{
  *//**
  *
  *//*!< Enable or Disable Forwarding Wake up packets *//*!< Enable or Disable Global unicast packet detection in power down mode *//*!< Enable or Disable Magic packet detection in power down mode *//*!< Enable or Disable Wake up packet detection in power down mode *//**
  * @brief  ETH Power Down structure definition
  *//*!< Set the control packets filter
                                                 This parameter can be a value of @ref ETH_Control_Packets_Filter *//*!< Enable or Disable broadcast filter *//*!< Enable or Disable destination address inverse filtering *//*!< Enable or Disable source address inverse filtering *//*!< Enable or Disable source address filtering module *//*!< Enable or Disable passing all multicast packets *//*!< Enable or Disable Hash filtering on multicast packets *//*!< Enable or Disable Hash filtering on unicast packets *//*!< Enable or Disable Perfect filtering in addition to Hash filtering *//*!< Enable or Disable Receive All Mode *//*!< Enable or Disable Promiscuous Mode *//**
  * @brief  ETH MAC filter structure definition
  *//*!< pointer to an ETH callback function *//**
  * @brief  HAL ETH Callback pointer definition
  *//*!< ETH Wake UP Callback ID           *//*!< ETH Power Management Callback ID  *//*!< ETH Error Callback ID             *//*!< ETH Rx Complete Callback ID       *//*!< ETH Tx Complete Callback ID       *//*!< ETH MspDeInit callback ID         *//*!< ETH MspInit callback ID           *//**
  * @brief  HAL ETH Callback ID enumeration definition
  *//*!< ETH Tx Handle Ptp Function *//*!< ETH Tx Free Function         *//*!< ETH Rx Set App Data Function *//*!< ETH Rx Get Buffer Function   *//*!< ETH Msp DeInit callback            *//*!< ETH Msp Init callback              *//*!< ETH Wake UP Callback   *//*!< ETH Power Management Callback            *//*!< ETH Error Callback   *//*!< ETH Rx  Complete Callback     *//*!< ETH Tx Complete Callback *//*!< Holds the PTP configuration status.
                                                             This parameter can be a value of
                                                             @ref ETH_PTP_Config_Status *//*!< Holds the LPI event when the an LPI status interrupt occurs.
                                                             This parameter can be a value of @ref ETHEx_LPI_Event *//*!< Holds the Wake Up event when the MAC exit the power down mode
                                                             This parameter can be a value of
                                                             @ref ETH_MAC_Wake_Up_Event *//*!< Holds the MAC Rx Tx Error code when a MAC Rx or Tx status interrupt occurs
                                                             This parameter can be a combination of
                                                             @ref ETH_MAC_Rx_Tx_Status *//*!< Holds the DMA Rx Tx Error code when a DMA AIS interrupt occurs
                                                             This parameter can be a combination of
                                                             @ref ETH_DMA_Status_Flags *//*!< Holds the global Error code of the ETH HAL status machine
                                                             This parameter can be a value of @ref ETH_Error_Code.*//*!< ETH state information related to global Handle management
                                                              and also related to Tx operations. This parameter can
                                                              be a value of @ref ETH_State_Codes *//*!< Tx Timestamp *//*!< Rx descriptor wrapper: holds all Rx descriptors list
                                                            addresses and current descriptor index  *//*!< Tx descriptor wrapper: holds all Tx descriptors list
                                                            addresses and current descriptor index  *//*!< Ethernet Init Configuration *//*!< Register base address       *//**
  * @brief  ETH Handle Structure definition
  *//*!< pointer to an ETH Tx Free function *//**
  * @brief  HAL ETH Tx Free Function definition
  *//*!< pointer to an ETH Rx Set App Data Function *//**
  * @brief  HAL ETH Rx Set App Data Function definition
  *//*!< pointer to an ETH Rx Get Buffer Function *//**
  * @brief  HAL ETH Rx Get Buffer Function definition
  *//**
  * @brief  HAL State structures definition
  *//*!< Subsecond Increment *//*!< Timestamp addend value *//*!< Time stamp clock node type *//*!< Enable MAC Address for PTP Packet Filtering *//*!< Enable Timestamp Snapshot for Event Messages *//*!< Enable Processing of PTP Packets Sent over IPv4-UDP *//*!< Enable Processing of PTP Packets Sent over IPv6-UDP *//*!< Enable Processing of PTP over Ethernet Packets *//*!< Enable PTP Packet Processing for Version 2 Format *//*!< Timestamp Digital or Binary Rollover Control *//*!< Enable Timestamp for All Packets *//*!< Timestamp Addend Update *//*!< Timestamp Update *//*!< Initialize Timestamp *//*!< Fine or Coarse Timestamp Update *//*!< Enable Timestamp *//**
  * @brief  ETH PTP Init Structure definition
  *//*!< Provides the length of Rx buffers size *//*!< Provides the address of the first DMA Rx descriptor in the list *//*!< Provides the address of the first DMA Tx descriptor in the list *//*!< Selects the MII interface or the RMII interface. *//*!< MAC Address of used Hardware: must be pointer on an array of 6 bytes *//**
  * @brief  ETH Init Structure definition
  *//*!<  PTP negative time update       *//*!<  PTP positive time update       *//**
  * @brief  HAL ETH PTP Update type enum definition
  *//*!<   Reduced Media Independent Interface       *//*!<  Media Independent Interface               *//**
  * @brief  HAL ETH Media Interfaces enum definition
  *//*!< Specifies the number of word to skip between two unchained descriptors (Ring mode)
                                                             This parameter must be a number between
                                                             Min_Data = 0 and Max_Data = 32 *//*!< Enables the enhanced descriptor format *//*!< Selects or not the Operate on second frame mode, which allows the DMA to process a second
                                                             frame of Transmit data even before obtaining
                                                             the status for the first frame *//*!< Selects the threshold level of the Receive FIFO.
                                                             This parameter can be a value of
                                                             @ref ETH_Receive_Threshold_Control *//*!< Enables or disables the Rx FIFO to forward Undersized frames (frames with no Error
                                                             and length less than 64 bytes)
                                                             including pad-bytes and CRC) *//*!< Enables or disables the Rx Packet Flush *//*!< Selects or not the forward to the DMA of erroneous frames *//*!< Indicates the maximum number of beats to be transferred in one Rx DMA transaction.
                                                    This parameter can be a value of @ref ETH_Rx_DMA_Burst_Length *//*!< Selects or not the Transmit Threshold Control.
                                                             This parameter can be a value of
                                                             @ref ETH_Transmit_Threshold_Control *//*!< Indicates the maximum number of beats to be transferred in one Tx DMA transaction.
                                                     This parameter can be a value of @ref ETH_Tx_DMA_Burst_Length *//*!< Enables or disables Transmit store and forward mode *//*!< Enables or disables the Receive store and forward mode *//*!< Selects or not the Dropping of TCP/IP Checksum Error Frames *//*!< Sets the AHB Master interface burst transfers.
                                                     This parameter can be a value of @ref ETH_Burst_Mode *//*!< Enables or disables the AHB Master interface address aligned
                                                            burst transfers on Read and Write channels  *//*!< Sets the arbitration scheme between DMA Tx and Rx
                                                         This parameter can be a value of @ref ETH_DMA_Arbitration *//**
  * @brief  ETH DMA Configuration Structure definition
  *//*!< Enables or disables  forwarding Undersized Good Packets.*//*!< Enables or disables  forwarding Error Packets. *//*!< Enables or disables Dropping of TCPIP Checksum Error Packets. *//*!< Specifies the Receive Queue operating mode.
                                                             This parameter can be a value of @ref ETH_Receive_Mode *//*!< Specifies the Transmit Queue operating mode.
                                                      This parameter can be a value of @ref ETH_Transmit_Mode *//*!< Enables or disables the MAC to decodes the received Pause packet
                                                  and disables its transmitter for a specified (Pause) time *//*!< Enables or disables the MAC to detect Pause packets with unicast address of the station *//*!< Enables or disables the MAC to transmit Pause packets in Full Duplex mode
                                                   or the MAC back pressure operation in Half Duplex mode *//*!< This field configures the threshold of the PAUSE to be checked for automatic retransmission of PAUSE Packet.
                                                   This parameter can be a value of @ref ETH_Pause_Low_Threshold *//*!< Enable or disables the automatic generation of Zero Quanta Pause Control packets.*//*!< This field holds the value to be used in the Pause Time field in the transmit control packet.
                                                   This parameter must be a number between
                                                   Min_Data = 0x0 and Max_Data = 0xFFFF.*//*!< This field is used as watchdog timeout for a received packet
                                                        This parameter can be a value of @ref ETH_Watchdog_Timeout *//*!< Enable or disables the Programmable Watchdog.*//*!< Sets the Extended IPG between Packet during transmission.
                                                           This parameter can be a value from 0x0 to 0xFF *//*!< Enable or disables the extended inter packet gap. *//*!< Specifies the packet size that the MAC will declare it as Giant, If it's size is
                                                    greater than the value programmed in this field in units of bytes
                                                    This parameter must be a number between
                                                    Min_Data = 0x618 (1518 byte) and Max_Data = 0x3FFF (32 Kbyte). *//*!< Enable or disables the CRC Checking for Received Packets. *//*!< Enable or disables the Slow Protocol Detection. *//*!< Selects or not the Preamble Length for Transmit packets (Full Duplex mode).
                                                           This parameter can be a value of @ref ETH_Preamble_Length *//*!< Enables or disables the deferral check function in Half Duplex mode. *//*!< Selects the BackOff limit value.
                                                        This parameter can be a value of @ref ETH_Back_Off_Limit *//*!< Enables or disables the MAC retry transmission, when a collision occurs in Half Duplex mode.*//*!< Enables or disables the Carrier Sense During Transmission in the Half Duplex mode *//*!< Enables or disables the Receive Own in Half Duplex mode. *//*!< Enables or disables the Carrier Sense Before Transmission in Full Duplex Mode. *//*!< Enables or disables the loopback mode *//*!< Selects the MAC duplex mode: Half-Duplex or Full-Duplex mode
                                                           This parameter can be a value of @ref ETH_Duplex_Mode *//*!< Sets the Ethernet speed: 10/100 Mbps.
                                                           This parameter can be a value of @ref ETH_Speed *//*!< Enables or disables receiving Jumbo Packet
                                                           When enabled, the MAC allows jumbo packets of 9,018 bytes
                                                           without reporting a giant packet error *//*!< Enables or disables Jabber timer on Tx path.*//*!< Enables or disables the Watchdog timer on Rx path.*//*!< Enables or disables  the Automatic MAC Pad/CRC Stripping.*//*!< Enables or disables the CRC stripping for Type packets.*//*!< Enables or disables the IEEE 802.3as Support for 2K length Packets *//*!< Enables or disables the Giant Packet Size Limit Control. *//*!< Sets the minimum IPG between Packet during transmission.
                                                     This parameter can be a value of @ref ETH_Inter_Packet_Gap *//*!< Enables or Disable the checksum checking for received packet payloads TCP, UDP or ICMP headers *//*!< Selects the Source Address Insertion or Replacement Control.
                                                     This parameter can be a value of @ref ETH_Source_Addr_Control *//**
  * @brief  ETH MAC Configuration Structure definition
  *//*<! Pointer to the last buff. *//*<! Pointer to the first buff. *//*<! Time Stamp Low value for receive. *//*<! Last received descriptor. *//*<! Number of Rx Descriptors awaiting building. *//*<! Current Rx Descriptor for building descriptors. *//*<! Received Data Length. *//*<! Number of descriptors . *//*<! Current Rx descriptor. *//*<! If 1, DMA will generate the Rx complete interrupt.
                                             If 0, DMA will not generate the Rx complete interrupt. *//*<! Rx DMA descriptors addresses. *//**
  * @brief  DMA Receive Descriptors Wrapper structure definition
  *//**
  * @brief  ETH Timeupdate structure definition
  *//**
  * @brief  ETH Timestamp structure definition
  *//*!< Specifies Application packet pointer to save   *//*!< Specifies Inner VLAN Tag insertion control only when Inner VLAN is enabled.
                                        This parameter can be a value of @ref ETH_Tx_Packet_Inner_VLAN_Control   *//*!< Sets Inner VLAN Tag only when Inner VLAN is enabled.
                                        This parameter can be a value from 0x0 to 0x3FFFF *//*!< Specifies VLAN Tag insertion control only when VLAN is enabled.
                                        This parameter can be a value of @ref ETH_Tx_Packet_VLAN_Control *//*!< Sets VLAN Tag only when VLAN is enabled.
                                        This parameter can be a value from 0x0 to 0xFFFF*//*!< Sets TCP header length only when TCP segmentation is enabled.
                                        This parameter can be a value from 0x5 to 0xF *//*!< Sets Total payload length only when TCP segmentation is enabled.
                                        This parameter can be a value from 0x0 to 0x3FFFF *//*!< Sets TCP maximum segment size only when TCP segmentation is enabled.
                                        This parameter can be a value from 0x0 to 0x3FFF *//*!< Specifies the checksum insertion control.
                                        This parameter can be a value of @ref ETH_Tx_Packet_Checksum_Control  *//*!< Specifies the CRC and Pad insertion and replacement control.
                                        This parameter can be a value of @ref ETH_Tx_Packet_CRC_Pad_Control  *//*!< Specifies the source address insertion control.
                                         This parameter can be a value of @ref ETH_Tx_Packet_Source_Addr_Control *//*!< Tx buffers pointers *//*!< Total packet length   *//*!< Tx packet HW features capabilities.
                                         This parameter can be a combination of @ref ETH_Tx_Packet_Attributes*//**
  * @brief  Transmit Packet Configuration structure definition
  *//*<! Release index *//*<! Buffers in Use *//*<! Current transmit NX_PACKET addresses *//*<! Ethernet packet addresses array *//*<! Current Tx descriptor index for packet transmission *//*<! Tx DMA descriptors addresses *//**
  * @brief  DMA Transmit Descriptors Wrapper structure definition
  *//*<! Pointer to the next buffer in the list *//*<! buffer length *//*<! buffer address *//**
  * @brief  ETH Buffers List structure definition
  *//* used to store rx buffer 2 address *//* used to store rx buffer 1 address *//**
  * @brief  ETH DMA Descriptor structure definition
  *//** @defgroup ETH_Exported_Types ETH Exported Types
  * @{
  *//*********************** Descriptors struct def section ************************//* ETH_RX_DESC_CNT *//* ETH_TX_DESC_CNT *//** @addtogroup ETH
  * @{
  *//**
  ******************************************************************************
  * @file    stm32f7xx_hal_eth.h
  * @author  MCD Application Team
  * @brief   Header file of ETH HAL module.
  ******************************************************************************
  * @attention
  *
  * Copyright (c) 2017 STMicroelectronics.
  * All rights reserved.
  *
  * This software is licensed under terms that can be found in the LICENSE file
  * in the root directory of this software component.
  * If no LICENSE file comes with this software, it is provided AS-IS.
  *
  ******************************************************************************
  */hethpFilterCountpPowerDownConfigAddrNbrpMACAddrpHashTablepFilterConfigComparisonBitsVLANIdentifierdmaconfmacconfbufftimestamppStartpEndPHYAddrPHYRegpRegValueRegValuepTxConfigpErrorCodepAppBuffFLASH_Erase_SectorHAL_FLASHEx_OBGetConfigFLASH_OBProgramInitTypeDef *HAL_FLASHEx_OBProgramHAL_FLASHEx_Erase_ITFLASH_EraseInitTypeDef *HAL_FLASHEx_EraseFLASH_OBProgramInitTypeDefFLASH_EraseInitTypeDefBootAddr1BootAddr0USERConfigBORLevelRDPLevelWRPSectorWRPStateOptionTypeVoltageRangeNbSectorsSectorBanksTypeEraseIS_OB_NDBOOT(VALUE)(((VALUE) == OB_DUAL_BOOT_DISABLE) || ((VALUE) == OB_DUAL_BOOT_ENABLE))IS_FLASH_BANK(BANK)(((BANK) == FLASH_BANK_1) || ((BANK) == FLASH_BANK_2) || ((BANK) == FLASH_BANK_BOTH))IS_OB_NDBANK(VALUE)(((VALUE) == OB_NDBANK_SINGLE_BANK) || ((VALUE) == OB_NDBANK_DUAL_BANK))IS_OB_WRP_SECTOR(SECTOR)((((SECTOR) & 0xF000FFFFU) == 0x00000000U) && ((SECTOR) != 0x00000000U))IS_FLASH_SECTOR(SECTOR)(((SECTOR) == FLASH_SECTOR_0) || ((SECTOR) == FLASH_SECTOR_1) || ((SECTOR) == FLASH_SECTOR_2) || ((SECTOR) == FLASH_SECTOR_3) || ((SECTOR) == FLASH_SECTOR_4) || ((SECTOR) == FLASH_SECTOR_5) || ((SECTOR) == FLASH_SECTOR_6) || ((SECTOR) == FLASH_SECTOR_7) || ((SECTOR) == FLASH_SECTOR_8) || ((SECTOR) == FLASH_SECTOR_9) || ((SECTOR) == FLASH_SECTOR_10) || ((SECTOR) == FLASH_SECTOR_11) || ((SECTOR) == FLASH_SECTOR_12) || ((SECTOR) == FLASH_SECTOR_13) || ((SECTOR) == FLASH_SECTOR_14) || ((SECTOR) == FLASH_SECTOR_15) || ((SECTOR) == FLASH_SECTOR_16) || ((SECTOR) == FLASH_SECTOR_17) || ((SECTOR) == FLASH_SECTOR_18) || ((SECTOR) == FLASH_SECTOR_19) || ((SECTOR) == FLASH_SECTOR_20) || ((SECTOR) == FLASH_SECTOR_21) || ((SECTOR) == FLASH_SECTOR_22) || ((SECTOR) == FLASH_SECTOR_23))IS_FLASH_NBSECTORS(NBSECTORS)(((NBSECTORS) != 0U) && ((NBSECTORS) <= FLASH_SECTOR_TOTAL))IS_FLASH_ADDRESS(ADDRESS)((((ADDRESS) >= FLASH_BASE) && ((ADDRESS) <= FLASH_END)) || (((ADDRESS) >= FLASH_OTP_BASE) && ((ADDRESS) <= FLASH_OTP_END)))IS_FLASH_LATENCY(LATENCY)(((LATENCY) == FLASH_LATENCY_0) || ((LATENCY) == FLASH_LATENCY_1) || ((LATENCY) == FLASH_LATENCY_2) || ((LATENCY) == FLASH_LATENCY_3) || ((LATENCY) == FLASH_LATENCY_4) || ((LATENCY) == FLASH_LATENCY_5) || ((LATENCY) == FLASH_LATENCY_6) || ((LATENCY) == FLASH_LATENCY_7) || ((LATENCY) == FLASH_LATENCY_8) || ((LATENCY) == FLASH_LATENCY_9) || ((LATENCY) == FLASH_LATENCY_10) || ((LATENCY) == FLASH_LATENCY_11) || ((LATENCY) == FLASH_LATENCY_12) || ((LATENCY) == FLASH_LATENCY_13) || ((LATENCY) == FLASH_LATENCY_14) || ((LATENCY) == FLASH_LATENCY_15))IS_OB_BOR_LEVEL(LEVEL)(((LEVEL) == OB_BOR_LEVEL1) || ((LEVEL) == OB_BOR_LEVEL2) || ((LEVEL) == OB_BOR_LEVEL3) || ((LEVEL) == OB_BOR_OFF))IS_OB_IWDG_STDBY_FREEZE(FREEZE)(((FREEZE) == OB_IWDG_STDBY_FREEZE) || ((FREEZE) == OB_IWDG_STDBY_ACTIVE))IS_OB_IWDG_STOP_FREEZE(FREEZE)(((FREEZE) == OB_IWDG_STOP_FREEZE) || ((FREEZE) == OB_IWDG_STOP_ACTIVE))IS_OB_STDBY_SOURCE(SOURCE)(((SOURCE) == OB_STDBY_NO_RST) || ((SOURCE) == OB_STDBY_RST))IS_OB_STOP_SOURCE(SOURCE)(((SOURCE) == OB_STOP_NO_RST) || ((SOURCE) == OB_STOP_RST))IS_OB_IWDG_SOURCE(SOURCE)(((SOURCE) == OB_IWDG_SW) || ((SOURCE) == OB_IWDG_HW))IS_OB_WWDG_SOURCE(SOURCE)(((SOURCE) == OB_WWDG_SW) || ((SOURCE) == OB_WWDG_HW))IS_OB_RDP_LEVEL(LEVEL)(((LEVEL) == OB_RDP_LEVEL_0) || ((LEVEL) == OB_RDP_LEVEL_1) || ((LEVEL) == OB_RDP_LEVEL_2))IS_OB_BOOT_ADDRESS(ADDRESS)((ADDRESS) <= 0x8013)IS_OPTIONBYTE(VALUE)(((VALUE) <= (OPTIONBYTE_WRP | OPTIONBYTE_RDP | OPTIONBYTE_USER | OPTIONBYTE_BOR | OPTIONBYTE_BOOTADDR_0 | OPTIONBYTE_BOOTADDR_1)))IS_WRPSTATE(VALUE)(((VALUE) == OB_WRPSTATE_DISABLE) || ((VALUE) == OB_WRPSTATE_ENABLE))IS_VOLTAGERANGE(RANGE)(((RANGE) == FLASH_VOLTAGE_RANGE_1) || ((RANGE) == FLASH_VOLTAGE_RANGE_2) || ((RANGE) == FLASH_VOLTAGE_RANGE_3) || ((RANGE) == FLASH_VOLTAGE_RANGE_4))IS_FLASH_TYPEERASE(VALUE)(((VALUE) == FLASH_TYPEERASE_SECTORS) || ((VALUE) == FLASH_TYPEERASE_MASSERASE))__HAL_FLASH_CALC_BOOT_BASE_ADR(__ADDRESS__)((__ADDRESS__) >> 14)OB_WRP_DB_SECTOR_All((uint32_t)0x0FFF0000U)OB_WRP_DB_SECTOR_23OB_WRP_DB_SECTOR_22OB_WRP_DB_SECTOR_21OB_WRP_DB_SECTOR_20OB_WRP_DB_SECTOR_19OB_WRP_DB_SECTOR_18OB_WRP_DB_SECTOR_17OB_WRP_DB_SECTOR_16OB_WRP_DB_SECTOR_15OB_WRP_DB_SECTOR_14OB_WRP_DB_SECTOR_13OB_WRP_DB_SECTOR_12OB_WRP_DB_SECTOR_11OB_WRP_DB_SECTOR_10OB_WRP_DB_SECTOR_9OB_WRP_DB_SECTOR_8OB_WRP_DB_SECTOR_7OB_WRP_DB_SECTOR_6OB_WRP_DB_SECTOR_5OB_WRP_DB_SECTOR_4OB_WRP_DB_SECTOR_3OB_WRP_DB_SECTOR_2OB_WRP_DB_SECTOR_1OB_WRP_DB_SECTOR_0OB_WRP_SECTOR_AllOB_WRP_SECTOR_11OB_WRP_SECTOR_10OB_WRP_SECTOR_9OB_WRP_SECTOR_8OB_WRP_SECTOR_7OB_WRP_SECTOR_6OB_WRP_SECTOR_5OB_WRP_SECTOR_4OB_WRP_SECTOR_3OB_WRP_SECTOR_2OB_WRP_SECTOR_1OB_WRP_SECTOR_0FLASH_SECTOR_23((uint32_t)23U)FLASH_SECTOR_22((uint32_t)22U)FLASH_SECTOR_21((uint32_t)21U)FLASH_SECTOR_20((uint32_t)20U)FLASH_SECTOR_19((uint32_t)19U)FLASH_SECTOR_18((uint32_t)18U)FLASH_SECTOR_17((uint32_t)17U)FLASH_SECTOR_16((uint32_t)16U)FLASH_SECTOR_15((uint32_t)15U)FLASH_SECTOR_14((uint32_t)14U)FLASH_SECTOR_13((uint32_t)13U)FLASH_SECTOR_12((uint32_t)12U)FLASH_SECTOR_11((uint32_t)11U)FLASH_SECTOR_10((uint32_t)10U)FLASH_SECTOR_9((uint32_t)9U)FLASH_SECTOR_8((uint32_t)8U)FLASH_MER_BIT(FLASH_CR_MER1 | FLASH_CR_MER2)FLASH_BANK_BOTH((uint32_t)(FLASH_BANK_1 | FLASH_BANK_2))FLASH_BANK_2FLASH_BANK_1FLASH_LATENCY_15FLASH_LATENCY_14FLASH_LATENCY_13FLASH_LATENCY_12FLASH_LATENCY_11FLASH_LATENCY_10FLASH_LATENCY_9FLASH_LATENCY_8FLASH_LATENCY_7FLASH_LATENCY_6FLASH_LATENCY_5FLASH_LATENCY_4FLASH_LATENCY_3FLASH_LATENCY_2FLASH_LATENCY_1FLASH_LATENCY_0OB_BOOTADDR_SRAM2((uint32_t)0x8013U)OB_BOOTADDR_SRAM1((uint32_t)0x8004U)OB_BOOTADDR_DTCM_RAM((uint32_t)0x8000U)OB_BOOTADDR_AXIM_FLASH((uint32_t)0x2000U)OB_BOOTADDR_ITCM_FLASH((uint32_t)0x0080U)OB_BOOTADDR_SYSTEM((uint32_t)0x0040U)OB_BOOTADDR_ITCM_RAM((uint32_t)0x0000U)OB_NDBANK_DUAL_BANKOB_NDBANK_SINGLE_BANK((uint32_t)0x20000000U)OB_DUAL_BOOT_ENABLEOB_DUAL_BOOT_DISABLEOB_BOR_OFF((uint32_t)0x0CU)OB_BOR_LEVEL1((uint32_t)0x08U)OB_BOR_LEVEL2OB_BOR_LEVEL3OB_IWDG_STDBY_ACTIVE((uint32_t)0x40000000U)OB_IWDG_STOP_ACTIVE((uint32_t)0x80000000U)OB_STDBY_RSTOB_STDBY_NO_RST((uint32_t)0x80U)OB_STOP_RSTOB_STOP_NO_RST((uint32_t)0x40U)((uint32_t)0x20U)OB_WWDG_HWOB_WWDG_SW((uint8_t)0xCCU)((uint8_t)0x55U)((uint8_t)0xAAU)OPTIONBYTE_BOOTADDR_1OPTIONBYTE_BOOTADDR_0OPTIONBYTE_BOROPTIONBYTE_USEROPTIONBYTE_RDPOPTIONBYTE_WRP((uint32_t)0x03U)__STM32F7xx_HAL_FLASH_EX_Hdefined (FLASH_OPTCR_nDBANK)defined (FLASH_OPTCR2_PCROP)defined (FLASH_OPTCR_nDBOOT)(SRAM2_BASE == 0x2003C000U)(FLASH_SECTOR_TOTAL == 24)(FLASH_SECTOR_TOTAL == 8)(FLASH_SECTOR_TOTAL == 4)(FLASH_SECTOR_TOTAL == 2)/* __STM32F7xx_HAL_FLASH_EX_H *//** @defgroup FLASHEx_Private_Functions FLASH Private Functions
  * @{
  *//* FLASH_OPTCR2_PCROP *//* FLASH_OPTCR_nDBOOT *//* FLASH_OPTCR_nDBANK *//* FLASH_SECTOR_TOTAL == 2 *//* FLASH_SECTOR_TOTAL == 4 *//* FLASH_SECTOR_TOTAL == 24 *//* FLASH_SECTOR_TOTAL == 8 *//** @defgroup FLASHEx_IS_FLASH_Definitions FLASH Private macros to check input parameters
  * @{
  *//** @defgroup FLASHEx_Private_Macros FLASH Private Macros
  * @{
  *//* Extension Program operation functions  *************************************//** @addtogroup FLASHEx_Exported_Functions_Group1
  * @{
  *//** @addtogroup FLASHEx_Exported_Functions
  * @{
  *//**
  * @brief  Calculate the FLASH Boot Base Address (BOOT_ADD0 or BOOT_ADD1)
  * @note   Returned value BOOT_ADDx[15:0] corresponds to boot address [29:14].
  * @param  __ADDRESS__ FLASH Boot Address (in the range 0x0000 0000 to 0x2004 FFFF with a granularity of 16KB)
  * @retval The FLASH Boot Base Address
  *//** @defgroup FLASH_Exported_Macros FLASH Exported Macros
  * @{
  *//*!< PCROP_RDP Disable     *//*!< PCROP_RDP Enable      *//** @defgroup FLASHEx_Option_Bytes_PCROP_RDP FLASH Option Bytes PCROP_RDP Bit
  * @{
  *//*!< PC Readout protection of all Sectors  *//*!< PC Readout protection of Sector3      *//*!< PC Readout protection of Sector2      *//*!< PC Readout protection of Sector1      *//*!< PC Readout protection of Sector0      *//** @defgroup FLASHEx_Option_Bytes_PCROP_Sectors FLASH Option Bytes PCROP Sectors
  * @{
  *//*!< PC Readout protection of Sector7      *//*!< PC Readout protection of Sector6      *//*!< PC Readout protection of Sector5      *//*!< PC Readout protection of Sector4      *//*!< Write protection of all Sectors *//*!< Write protection of Sector1     *//*!< Write protection of Sector0     *//** @defgroup FLASHEx_Option_Bytes_Write_Protection FLASH Option Bytes Write Protection
  * @{
  *//*!< Write protection of Sector3     *//*!< Write protection of Sector2     *//*!< Write protection of Sector7     *//*!< Write protection of Sector6     *//*!< Write protection of Sector5     *//*!< Write protection of Sector4     *//*!< Write protection of all Sectors for Dual Bank Flash *//*!< Write protection of Dual Bank Sector23    *//*!< Write protection of Dual Bank Sector22    *//*!< Write protection of Dual Bank Sector21    *//*!< Write protection of Dual Bank Sector20    *//*!< Write protection of Dual Bank Sector19    *//*!< Write protection of Dual Bank Sector18    *//*!< Write protection of Dual Bank Sector17    *//*!< Write protection of Dual Bank Sector16    *//*!< Write protection of Dual Bank Sector15    *//*!< Write protection of Dual Bank Sector14    *//*!< Write protection of Dual Bank Sector13    *//*!< Write protection of Dual Bank Sector12    *//*!< Write protection of Dual Bank Sector11    *//*!< Write protection of Dual Bank Sector10    *//*!< Write protection of Dual Bank Sector9     *//*!< Write protection of Dual Bank Sector8     *//*!< Write protection of Dual Bank Sector7     *//*!< Write protection of Dual Bank Sector6     *//*!< Write protection of Dual Bank Sector5     *//*!< Write protection of Dual Bank Sector4     *//*!< Write protection of Dual Bank Sector3     *//*!< Write protection of Dual Bank Sector2     *//*!< Write protection of Dual Bank Sector1     *//*!< Write protection of Dual Bank Sector0     *//* Dual Bank Sectors *//*!< Write protection of all Sectors for Single Bank Flash *//*!< Write protection of Single Bank Sector11  *//*!< Write protection of Single Bank Sector10  *//*!< Write protection of Single Bank Sector9   *//*!< Write protection of Single Bank Sector8   *//*!< Write protection of Single Bank Sector7   *//*!< Write protection of Single Bank Sector6   *//*!< Write protection of Single Bank Sector5   *//*!< Write protection of Single Bank Sector4   *//*!< Write protection of Single Bank Sector3   *//*!< Write protection of Single Bank Sector2   *//*!< Write protection of Single Bank Sector1   *//*!< Write protection of Single Bank Sector0   *//* Single Bank Sectors *//** @defgroup FLASHEx_Option_Bytes_Write_Protection FLASH Option Bytes Write Protection
  * @note For Single Bank mode, use OB_WRP_SECTOR_x defines: In fact, in FLASH_OPTCR register,
  *       nWRP[11:0] bits contain the value of the write-protection option bytes for sectors 0 to 11.
  *       For Dual Bank mode, use OB_WRP_DB_SECTOR_x defines: In fact, in FLASH_OPTCR register,
  *       nWRP[11:0] bits are divided on two groups, one group dedicated for bank 1 and
  *       a second one dedicated for bank 2 (nWRP[i] activates Write protection on sector 2*i and 2*i+1).
  *       This behavior is applicable only for STM32F76xxx / STM32F77xxx devices.
  * @{
  *//*!< Sector Number 23  *//*!< Sector Number 22  *//*!< Sector Number 21  *//*!< Sector Number 20  *//*!< Sector Number 19  *//*!< Sector Number 18  *//*!< Sector Number 17  *//*!< Sector Number 16  *//*!< Sector Number 15  *//*!< Sector Number 14  *//*!< Sector Number 13  *//*!< Sector Number 12  *//*!< Sector Number 11  *//*!< Sector Number 10  *//*!< Sector Number 9   *//*!< Sector Number 8   *//** @defgroup FLASHEx_Sectors FLASH Sectors
  * @{
  *//*!< only 1 MER bit *//*!< 2 MER bits *//** @defgroup FLASHEx_MassErase_bit FLASH Mass Erase bit
  * @{
  *//*!< Bank1 and Bank2  *//*!< Bank 2   *//*!< Bank 1   *//** @defgroup FLASHEx_Banks FLASH Banks
  * @{
  *//*!< FLASH Fifteen Latency cycles  *//*!< FLASH Fourteen Latency cycles *//*!< FLASH Thirteen Latency cycles *//*!< FLASH Twelve Latency cycles   *//*!< FLASH Eleven Latency cycles   *//*!< FLASH Ten Latency cycles      *//*!< FLASH Nine Latency cycles     *//*!< FLASH Eight Latency cycles    *//*!< FLASH Seven Latency cycles    *//*!< FLASH Six Latency cycles      *//*!< FLASH Five Latency cycles     *//*!< FLASH Four Latency cycles     *//*!< FLASH Three Latency cycles    *//*!< FLASH Two Latency cycles      *//*!< FLASH One Latency cycle       *//*!< FLASH Zero Latency cycle      *//** @defgroup FLASH_Latency FLASH Latency
  * @{
  *//* SRAM2_BASE == 0x2003C000U *//*!< Boot from SRAM2 (0x2004C000)                    *//*!< Boot from SRAM2 (0x2003C000)                    *//*!< Boot from SRAM1 (0x20010000)                    *//*!< Boot from DTCM RAM (0x20000000)                 *//*!< Boot from Flash on AXIM interface (0x08000000)  *//*!< Boot from Flash on ITCM interface (0x00200000)  *//*!< Boot from System memory bootloader (0x00100000) *//*!< Boot from ITCM RAM (0x00000000)                 *//** @defgroup FLASHEx_Boot_Address FLASH Boot Address
  * @{
  *//*!< NDBANK bit is reset : Dual Bank mode *//*!< NDBANK bit is set : Single Bank mode *//** @defgroup FLASHEx_Option_Bytes_nDBank FLASH Single Bank or Dual Bank
  * @{
  *//* !< Dual Boot enable. Boot always from system memory if boot address in flash
                                                              (Dual bank Boot mode), or RAM if Boot address option in RAM    *//* !< Dual Boot disable. Boot according to boot address option *//** @defgroup FLASHEx_Option_Bytes_nDBOOT FLASH Option Bytes nDBOOT
  * @{
  *//*!< Supply voltage ranges from 1.62 to 2.10 V *//*!< Supply voltage ranges from 2.10 to 2.40 V *//*!< Supply voltage ranges from 2.40 to 2.70 V *//*!< Supply voltage ranges from 2.70 to 3.60 V *//** @defgroup FLASHEx_BOR_Reset_Level FLASH BOR Reset Level
  * @{
  *//*!< IWDG counter active in STANDBY mode *//*!< Freeze IWDG counter in STANDBY mode *//** @defgroup FLASHEx_Option_Bytes_IWDG_FREEZE_SANDBY FLASH IWDG Counter Freeze in STANDBY
  * @{
  *//*!< IWDG counter active in STOP mode *//*!< Freeze IWDG counter in STOP mode *//** @defgroup FLASHEx_Option_Bytes_IWDG_FREEZE_STOP FLASH IWDG Counter Freeze in STOP
  * @{
  *//*!< Reset generated when entering in STANDBY    *//*!< No reset generated when entering in STANDBY *//** @defgroup FLASHEx_Option_Bytes_nRST_STDBY FLASH Option Bytes nRST_STDBY
  * @{
  *//*!< Reset generated when entering in STOP    *//*!< No reset generated when entering in STOP *//** @defgroup FLASHEx_Option_Bytes_nRST_STOP FLASH Option Bytes nRST_STOP
  * @{
  *//*!< Hardware IWDG selected *//*!< Software IWDG selected *//** @defgroup FLASHEx_Option_Bytes_IWatchdog FLASH Option Bytes IWatchdog
  * @{
  *//*!< Hardware WWDG selected *//*!< Software WWDG selected *//** @defgroup FLASHEx_Option_Bytes_WWatchdog FLASH Option Bytes WWatchdog
  * @{
  *//*!< Warning: When enabling read protection level 2
                                                  it s no more possible to go back to level 1 or 0 *//** @defgroup FLASHEx_Option_Bytes_Read_Protection FLASH Option Bytes Read Protection
  * @{
  *//*!< PCROP_RDP configuration        *//*!< PCROP configuration            *//*!< Boot 1 Address configuration   *//*!< Boot 0 Address configuration   *//*!< BOR option byte configuration  *//*!< USER option byte configuration *//*!< RDP option byte configuration  *//*!< WRP option byte configuration  *//** @defgroup FLASHEx_Option_Type FLASH Option Type
  * @{
  *//*!< Enable the write protection of the desired bank 1 sectors  *//*!< Disable the write protection of the desired bank 1 sectors *//** @defgroup FLASHEx_WRP_State FLASH WRP State
  * @{
  *//*!< Device operating range: 2.7V to 3.6V + External Vpp *//*!< Device operating range: 2.7V to 3.6V                *//*!< Device operating range: 2.1V to 2.7V                *//*!< Device operating range: 1.8V to 2.1V                *//** @defgroup FLASHEx_Voltage_Range FLASH Voltage Range
  * @{
  *//*!< Flash Mass erase activation *//*!< Sectors erase only          *//** @defgroup FLASHEx_Type_Erase FLASH Type Erase
  * @{
  *//** @defgroup FLASHEx_Exported_Constants FLASH Exported Constants
  * @{
  *//*!< Set the PCROP_RDP option.
                              This parameter can be a value of @ref FLASHEx_Option_Bytes_PCROP_RDP *//*!< Set the PCROP sector.
                              This parameter can be a value of @ref FLASHEx_Option_Bytes_PCROP_Sectors *//*!< Boot base address when Boot pin = 1.
                              This parameter can be a value of @ref FLASHEx_Boot_Address *//*!< Boot base address when Boot pin = 0.
                              This parameter can be a value of @ref FLASHEx_Boot_Address *//*!< Program the FLASH User Option Byte: WWDG_SW / IWDG_SW / RST_STOP / RST_STDBY /
                              IWDG_FREEZE_STOP / IWDG_FREEZE_SANDBY / nDBANK / nDBOOT.
                              nDBANK / nDBOOT are only available for STM32F76xxx/STM32F77xxx devices *//*!< Set the BOR Level.
                              This parameter can be a value of @ref FLASHEx_BOR_Reset_Level *//*!< Set the read protection level.
                              This parameter can be a value of @ref FLASHEx_Option_Bytes_Read_Protection *//*!< Specifies the sector(s) to be write protected.
                              The value of this parameter depend on device used within the same series *//*!< Write protection activation or deactivation.
                              This parameter can be a value of @ref FLASHEx_WRP_State *//*!< Option byte to be configured.
                              This parameter can be a value of @ref FLASHEx_Option_Type *//**
  * @brief  FLASH Option Bytes Program structure definition
  *//*!< The device voltage range which defines the erase parallelism
                             This parameter must be a value of @ref FLASHEx_Voltage_Range *//*!< Number of sectors to be erased.
                             This parameter must be a value between 1 and (max number of sectors - value of Initial sector)*//*!< Initial FLASH sector to erase when Mass erase is disabled
                             This parameter must be a value of @ref FLASHEx_Sectors *//*!< Select banks to erase when Mass erase is enabled.
                             This parameter must be a value of @ref FLASHEx_Banks *//*!< Mass erase or sector Erase.
                             This parameter can be a value of @ref FLASHEx_Type_Erase *//**
  * @brief  FLASH Erase structure definition
  *//** @defgroup FLASHEx_Exported_Types FLASH Exported Types
  * @{
  *//** @addtogroup FLASHEx
  * @{
  *//**
  ******************************************************************************
  * @file    stm32f7xx_hal_flash_ex.h
  * @author  MCD Application Team
  * @brief   Header file of FLASH HAL Extension module.
  ******************************************************************************
  * @attention
  *
  * Copyright (c) 2017 STMicroelectronics.
  * All rights reserved.
  *
  * This software is licensed under terms that can be found in the LICENSE file in
  * the root directory of this software component.
  * If no LICENSE file comes with this software, it is provided AS-IS.
  ******************************************************************************
  */pOBInitpEraseInitSectorError"stm32f7xx_hal_flash_ex.h"FLASH_WaitForLastOperationHAL_FLASH_GetErrorHAL_FLASH_OB_LaunchHAL_FLASH_OB_LockHAL_FLASH_OB_UnlockHAL_FLASH_LockHAL_FLASH_UnlockHAL_FLASH_OperationErrorCallbackHAL_FLASH_EndOfOperationCallbackHAL_FLASH_IRQHandlerHAL_FLASH_Program_ITHAL_FLASH_ProgramFLASH_ProcessTypeDefFLASH_ProcedureTypeDefFLASH_PROC_NONEFLASH_PROC_SECTERASEFLASH_PROC_MASSERASEFLASH_PROC_PROGRAMVoltageForEraseNbSectorsToErasevolatile FLASH_ProcedureTypeDefProcedureOnGoingIS_FLASH_TYPEPROGRAM(VALUE)(((VALUE) == FLASH_TYPEPROGRAM_BYTE) || ((VALUE) == FLASH_TYPEPROGRAM_HALFWORD) || ((VALUE) == FLASH_TYPEPROGRAM_WORD) || ((VALUE) == FLASH_TYPEPROGRAM_DOUBLEWORD))OPTCR_BYTE1_ADDRESS((uint32_t)0x40023C15)__HAL_FLASH_CLEAR_FLAG(__FLAG__)(FLASH->SR = (__FLAG__))__HAL_FLASH_GET_FLAG(__FLAG__)((FLASH->SR & (__FLAG__)))__HAL_FLASH_DISABLE_IT(__INTERRUPT__)(FLASH->CR &= ~(uint32_t)(__INTERRUPT__))__HAL_FLASH_ENABLE_IT(__INTERRUPT__)(FLASH->CR |= (__INTERRUPT__))__HAL_FLASH_ART_RESET()(FLASH->ACR |= FLASH_ACR_ARTRST)__HAL_FLASH_ART_DISABLE()CLEAR_BIT(FLASH->ACR, FLASH_ACR_ARTEN)__HAL_FLASH_ART_ENABLE()SET_BIT(FLASH->ACR, FLASH_ACR_ARTEN)__HAL_FLASH_PREFETCH_BUFFER_DISABLE()(FLASH->ACR &= (~FLASH_ACR_PRFTEN))__HAL_FLASH_PREFETCH_BUFFER_ENABLE()(FLASH->ACR |= FLASH_ACR_PRFTEN)__HAL_FLASH_GET_LATENCY()(READ_BIT((FLASH->ACR), FLASH_ACR_LATENCY))__HAL_FLASH_SET_LATENCY(__LATENCY__)MODIFY_REG(FLASH->ACR, FLASH_ACR_LATENCY, (uint32_t)(__LATENCY__))FLASH_SECTOR_7((uint32_t)7U)FLASH_SECTOR_6((uint32_t)6U)FLASH_SECTOR_5((uint32_t)5U)FLASH_SECTOR_4((uint32_t)4U)FLASH_SECTOR_3((uint32_t)3U)FLASH_SECTOR_2((uint32_t)2U)FLASH_SECTOR_1((uint32_t)1U)FLASH_SECTOR_0((uint32_t)0U)FLASH_OPT_KEY2((uint32_t)0x4C5D6E7FU)FLASH_OPT_KEY1((uint32_t)0x08192A3BU)FLASH_KEY2((uint32_t)0xCDEF89ABU)FLASH_KEY1((uint32_t)0x45670123U)CR_PSIZE_MASK((uint32_t)0xFFFFFCFFU)FLASH_PSIZE_DOUBLE_WORD((uint32_t)FLASH_CR_PSIZE)FLASH_PSIZE_WORD((uint32_t)FLASH_CR_PSIZE_1)FLASH_PSIZE_HALF_WORD((uint32_t)FLASH_CR_PSIZE_0)FLASH_PSIZE_BYTEFLASH_IT_ERRFLASH_IT_EOPFLASH_FLAG_ALL_ERRORS(FLASH_FLAG_OPERR | FLASH_FLAG_WRPERR | FLASH_FLAG_PGAERR | FLASH_FLAG_PGPERR | FLASH_FLAG_ERSERR)FLASH_FLAG_BSYFLASH_FLAG_ERSERRFLASH_FLAG_PGPERRFLASH_FLAG_PGAERRFLASH_FLAG_WRPERRFLASH_FLAG_OPERRFLASH_FLAG_EOPHAL_FLASH_ERROR_PGP__STM32F7xx_HAL_FLASH_H/* __STM32F7xx_HAL_FLASH_H *//** @defgroup FLASH_Private_Functions FLASH Private Functions
  * @{
  *//** @defgroup FLASH_IS_FLASH_Definitions FLASH Private macros to check input parameters
  * @{
  *//** @defgroup FLASH_Private_Macros FLASH Private Macros
  * @{
  *//**
  * @brief   OPTCR register byte 1 (Bits[15:8]) base address
  *//** @defgroup FLASH_Private_Constants FLASH Private Constants
  * @{
  *//** @defgroup FLASH_Private_Variables FLASH Private Variables
  * @{
  *//* Peripheral State functions  ************************************************//** @addtogroup FLASH_Exported_Functions_Group3
  * @{
  *//* Option bytes control *//** @addtogroup FLASH_Exported_Functions_Group2
  * @{
  *//* Callbacks in non blocking modes *//* FLASH IRQ handler method *//* Program operation functions  ***********************************************//** @addtogroup FLASH_Exported_Functions_Group1
  * @{
  *//** @addtogroup FLASH_Exported_Functions
  * @{
  *//* Include FLASH HAL Extension module *//**
  * @brief  Clear the specified FLASH flag.
  * @param  __FLAG__ specifies the FLASH flags to clear.
  *          This parameter can be any combination of the following values:
  *            @arg FLASH_FLAG_EOP   : FLASH End of Operation flag
  *            @arg FLASH_FLAG_OPERR : FLASH operation Error flag
  *            @arg FLASH_FLAG_WRPERR: FLASH Write protected error flag
  *            @arg FLASH_FLAG_PGAERR: FLASH Programming Alignment error flag
  *            @arg FLASH_FLAG_PGPERR: FLASH Programming Parallelism error flag
  *            @arg FLASH_FLAG_ERSERR : FLASH Erasing Sequence error flag
  * @retval none
  *//**
  * @brief  Get the specified FLASH flag status.
  * @param  __FLAG__ specifies the FLASH flag to check.
  *          This parameter can be one of the following values:
  *            @arg FLASH_FLAG_EOP   : FLASH End of Operation flag
  *            @arg FLASH_FLAG_OPERR : FLASH operation Error flag
  *            @arg FLASH_FLAG_WRPERR: FLASH Write protected error flag
  *            @arg FLASH_FLAG_PGAERR: FLASH Programming Alignment error flag
  *            @arg FLASH_FLAG_PGPERR: FLASH Programming Parallelism error flag
  *            @arg FLASH_FLAG_ERSERR : FLASH Erasing Sequence error flag
  *            @arg FLASH_FLAG_BSY   : FLASH Busy flag
  * @retval The new state of __FLAG__ (SET or RESET).
  *//**
  * @brief  Disable the specified FLASH interrupt.
  * @param  __INTERRUPT__  FLASH interrupt
  *         This parameter can be any combination of the following values:
  *     @arg FLASH_IT_EOP: End of FLASH Operation Interrupt
  *     @arg FLASH_IT_ERR: Error Interrupt
  * @retval none
  *//**
  * @brief  Enable the specified FLASH interrupt.
  * @param  __INTERRUPT__  FLASH interrupt
  *         This parameter can be any combination of the following values:
  *     @arg FLASH_IT_EOP: End of FLASH Operation Interrupt
  *     @arg FLASH_IT_ERR: Error Interrupt
  * @retval none
  *//**
  * @brief  Resets the FLASH Adaptive Real-Time memory accelerator.
  * @note   This function must be used only when the Adaptive Real-Time memory accelerator
  *         is disabled.
  * @retval None
  *//**
  * @brief  Disable the FLASH Adaptive Real-Time memory accelerator.
  * @retval none
  *//**
  * @brief  Enable the FLASH Adaptive Real-Time memory accelerator.
  * @note   The ART accelerator is available only for flash access on ITCM interface.
  * @retval none
  *//**
  * @brief  Disable the FLASH prefetch buffer.
  * @retval none
  *//**
  * @brief  Enable the FLASH prefetch buffer.
  * @retval none
  *//**
  * @brief  Get the FLASH Latency.
  * @retval FLASH Latency
  *          The value of this parameter depend on device used within the same series
  *//**
  * @brief  Set the FLASH Latency.
  * @param  __LATENCY__ FLASH Latency
  *         The value of this parameter depend on device used within the same series
  * @retval none
  *//* FLASH_SECTOR_TOTAL *//*!< Sector Number 7   *//*!< Sector Number 6   *//*!< Sector Number 5   *//*!< Sector Number 4   *//*!< Sector Number 3   *//*!< Sector Number 2   *//*!< Sector Number 1   *//*!< Sector Number 0   *//** @defgroup FLASH_Sectors FLASH Sectors
  * @{
  *//** @defgroup FLASH_Keys FLASH Keys
  * @{
  *//** @defgroup FLASH_Program_Parallelism FLASH Program Parallelism
  * @{
  *//*!< Error Interrupt source                  *//*!< End of FLASH Operation Interrupt source *//** @defgroup FLASH_Interrupt_definition FLASH Interrupt definition
  * @brief FLASH Interrupt definition
  * @{
  *//*!< FLASH Read protection error flag          *//*!< FLASH Busy flag                           *//*!< FLASH Erasing Sequence error flag         *//*!< FLASH Programming Parallelism error flag  *//*!< FLASH Programming Alignment error flag    *//*!< FLASH Write protected error flag          *//*!< FLASH operation Error flag                *//*!< FLASH End of Operation flag               *//** @defgroup FLASH_Flag_definition FLASH Flag definition
  * @brief Flag definition
  * @{
  *//*!< Program a double word (64-bit) at a specified address *//*!< Program a word (32-bit) at a specified address        *//*!< Program a half-word (16-bit) at a specified address   *//*!< Program byte (8-bit) at a specified address           *//** @defgroup FLASH_Type_Program FLASH Type Program
  * @{
  *//*!< Read Protection Error         *//*!< Operation Error               *//*!< Write protection error        *//*!< Programming Alignment error   *//*!< Programming Parallelism error *//*!< Programming Sequence error    *//*!< No error                      *//** @defgroup FLASH_Error_Code FLASH Error Code
  * @brief    FLASH Error Code
  * @{
  *//** @defgroup FLASH_Exported_Constants FLASH Exported Constants
  * @{
  *//* FLASH error code                                                              *//* FLASH locking object                                                          *//* Internal variable to save address selected for program                        *//* Internal variable to define the current sector which is erasing               *//* Internal variable to provide voltage range selected by user in IT context     *//* Internal variable to save the remaining sectors to erase in IT context        *//* Internal variable to indicate which procedure is ongoing or not in IT context *//**
  * @brief  FLASH handle Structure definition
  *//**
  * @brief  FLASH Procedure structure definition
  *//** @defgroup FLASH_Exported_Types FLASH Exported Types
  * @{
  *//** @addtogroup FLASH
  * @{
  *//**
  ******************************************************************************
  * @file    stm32f7xx_hal_flash.h
  * @author  MCD Application Team
  * @brief   Header file of FLASH HAL module.
  ******************************************************************************
  * @attention
  *
  * Copyright (c) 2017 STMicroelectronics.
  * All rights reserved.
  *
  * This software is licensed under terms that can be found in the LICENSE file in
  * the root directory of this software component.
  * If no LICENSE file comes with this software, it is provided AS-IS.
  ******************************************************************************
  */ReturnValueTypeProgramDataFMC_SDRAM_GetModeStatusconst FMC_Bank5_6_TypeDefconst FMC_Bank5_6_TypeDef *FMC_SDRAM_SetAutoRefreshNumberFMC_SDRAM_ProgramRefreshRateFMC_SDRAM_SendCommandFMC_SDRAM_WriteProtection_DisableFMC_SDRAM_WriteProtection_EnableFMC_SDRAM_DeInitFMC_SDRAM_Timing_InitFMC_SDRAM_InitFMC_SDRAM_InitTypeDef *FMC_NAND_GetECCFMC_Bank3_TypeDef *FMC_NAND_ECC_DisableFMC_NAND_ECC_EnableFMC_NAND_DeInitFMC_NAND_AttributeSpace_Timing_InitFMC_NAND_PCC_TimingTypeDef *FMC_NAND_CommonSpace_Timing_InitFMC_NAND_InitFMC_NAND_InitTypeDef *FMC_NORSRAM_WriteOperation_DisableFMC_NORSRAM_WriteOperation_EnableFMC_NORSRAM_DeInitFMC_NORSRAM_Extended_Timing_InitFMC_NORSRAM_Timing_InitFMC_NORSRAM_InitFMC_NORSRAM_InitTypeDef *FMC_SDRAM_CommandTypeDefFMC_SDRAM_TimingTypeDefFMC_SDRAM_InitTypeDefFMC_NAND_PCC_TimingTypeDefFMC_NAND_InitTypeDefFMC_NORSRAM_TimingTypeDefFMC_NORSRAM_InitTypeDefModeRegisterDefinitionAutoRefreshNumberCommandTargetCommandModeRCDDelayRPDelayWriteRecoveryTimeRowCycleDelaySelfRefreshTimeExitSelfRefreshDelayLoadToActiveDelayReadPipeDelayReadBurstSDClockPeriodWriteProtectionCASLatencyInternalBankNumberMemoryDataWidthRowBitsNumberColumnBitsNumberSDBankHiZSetupTimeHoldSetupTimeWaitSetupTimeSetupTimeTARSetupTimeTCLRSetupTimeECCPageSizeEccComputationWaitfeatureNandBankAccessModeDataLatencyCLKDivisionBusTurnAroundDurationDataSetupTimeAddressHoldTimeAddressSetupTimePageSizeWriteFifoContinuousClockWriteBurstAsynchronousWaitExtendedModeWaitSignalWriteOperationWaitSignalActiveWaitSignalPolarityBurstAccessModeMemoryTypeDataAddressMuxNSBank__FMC_SDRAM_CLEAR_FLAG(__INSTANCE__,__FLAG__)((__INSTANCE__)->SDRTR |= (__FLAG__))__FMC_SDRAM_GET_FLAG(__INSTANCE__,__FLAG__)(((__INSTANCE__)->SDSR &(__FLAG__)) == (__FLAG__))__FMC_SDRAM_DISABLE_IT(__INSTANCE__,__INTERRUPT__)((__INSTANCE__)->SDRTR &= ~(__INTERRUPT__))__FMC_SDRAM_ENABLE_IT(__INSTANCE__,__INTERRUPT__)((__INSTANCE__)->SDRTR |= (__INTERRUPT__))__FMC_NAND_CLEAR_FLAG(__INSTANCE__,__FLAG__)((__INSTANCE__)->SR &= ~(__FLAG__))__FMC_NAND_GET_FLAG(__INSTANCE__,__BANK__,__FLAG__)(((__INSTANCE__)->SR &(__FLAG__)) == (__FLAG__))__FMC_NAND_DISABLE_IT(__INSTANCE__,__INTERRUPT__)((__INSTANCE__)->SR &= ~(__INTERRUPT__))__FMC_NAND_ENABLE_IT(__INSTANCE__,__INTERRUPT__)((__INSTANCE__)->SR |= (__INTERRUPT__))__FMC_NAND_DISABLE(__INSTANCE__,__BANK__)CLEAR_BIT((__INSTANCE__)->PCR, FMC_PCR_PBKEN)__FMC_NAND_ENABLE(__INSTANCE__)((__INSTANCE__)->PCR |= FMC_PCR_PBKEN)__FMC_NORSRAM_DISABLE(__INSTANCE__,__BANK__)((__INSTANCE__)->BTCR[(__BANK__)] &= ~FMC_BCR1_MBKEN)__FMC_NORSRAM_ENABLE(__INSTANCE__,__BANK__)((__INSTANCE__)->BTCR[(__BANK__)] |= FMC_BCR1_MBKEN)FMC_SDRAM_FLAG_REFRESH_ERRORFMC_SDRAM_FLAG_BUSYFMC_SDRAM_FLAG_REFRESH_ITFMC_FLAG_FEMPTFMC_FLAG_FALLING_EDGE(0x00000004U)FMC_FLAG_LEVELFMC_FLAG_RISING_EDGEFMC_IT_REFRESH_ERROR(0x00004000U)FMC_IT_FALLING_EDGEFMC_IT_LEVEL(0x00000010U)FMC_IT_RISING_EDGE(0x00000008U)FMC_SDRAM_POWER_DOWN_MODEFMC_SDRAM_SELF_REFRESH_MODEFMC_SDRAM_NORMAL_MODEFMC_SDRAM_CMD_TARGET_BANK1_2(0x00000018U)FMC_SDRAM_CMD_TARGET_BANK1FMC_SDRAM_CMD_TARGET_BANK2FMC_SDRAM_CMD_POWERDOWN_MODE(0x00000006U)FMC_SDRAM_CMD_SELFREFRESH_MODE(0x00000005U)(0x00000003U)FMC_SDRAM_CMD_NORMAL_MODEFMC_SDRAM_RPIPE_DELAY_2FMC_SDRAM_RPIPE_DELAY_1(0x00002000U)(0x00001000U)FMC_SDRAM_RBURST_DISABLEFMC_SDRAM_CLOCK_PERIOD_3(0x00000C00U)(0x00000800U)FMC_SDRAM_CLOCK_DISABLEFMC_SDRAM_WRITE_PROTECTION_ENABLE(0x00000200U)(0x00000180U)FMC_SDRAM_CAS_LATENCY_2(0x00000100U)FMC_SDRAM_CAS_LATENCY_1(0x00000080U)FMC_SDRAM_INTERN_BANKS_NUM_2FMC_SDRAM_MEM_BUS_WIDTH_16FMC_SDRAM_MEM_BUS_WIDTH_8FMC_SDRAM_ROW_BITS_NUM_13FMC_SDRAM_ROW_BITS_NUM_11FMC_SDRAM_COLUMN_BITS_NUM_11FMC_SDRAM_COLUMN_BITS_NUM_10FMC_SDRAM_COLUMN_BITS_NUM_8FMC_SDRAM_BANK2FMC_NAND_ECC_PAGE_SIZE_8192BYTE(0x000A0000U)FMC_NAND_ECC_PAGE_SIZE_4096BYTE(0x00080000U)FMC_NAND_ECC_PAGE_SIZE_2048BYTE(0x00060000U)FMC_NAND_ECC_PAGE_SIZE_1024BYTE(0x00040000U)FMC_NAND_ECC_PAGE_SIZE_512BYTE(0x00020000U)FMC_NAND_ECC_PAGE_SIZE_256BYTEFMC_NAND_ECC_ENABLEFMC_NAND_ECC_DISABLEFMC_PCR_MEMORY_TYPE_NANDFMC_NAND_BANK3FMC_ACCESS_MODE_D(0x30000000U)FMC_ACCESS_MODE_C(0x20000000U)FMC_ACCESS_MODE_B(0x10000000U)FMC_WRITE_FIFO_ENABLEFMC_WRITE_FIFO_DISABLEFMC_CONTINUOUS_CLOCK_SYNC_ASYNC(0x00100000U)FMC_WRITE_BURST_ENABLEFMC_PAGE_SIZE_1024FMC_PAGE_SIZE_512(FMC_BCR1_CPSIZE_0 | FMC_BCR1_CPSIZE_1)FMC_PAGE_SIZE_256FMC_PAGE_SIZE_128FMC_PAGE_SIZE_NONEFMC_ASYNCHRONOUS_WAIT_ENABLE(0x00008000U)FMC_EXTENDED_MODE_ENABLEFMC_WAIT_SIGNAL_ENABLEFMC_WRITE_OPERATION_DISABLEFMC_WAIT_TIMING_DURING_WSFMC_WAIT_SIGNAL_POLARITY_HIGHFMC_BURST_ACCESS_MODE_ENABLEFMC_NORSRAM_FLASH_ACCESS_DISABLEFMC_NORSRAM_FLASH_ACCESS_ENABLEFMC_NORSRAM_MEM_BUS_WIDTH_32FMC_NORSRAM_MEM_BUS_WIDTH_8FMC_MEMORY_TYPE_NORFMC_MEMORY_TYPE_PSRAMFMC_DATA_ADDRESS_MUX_ENABLEFMC_NORSRAM_BANK4FMC_NORSRAM_BANK2FMC_NORSRAM_BANK1FMC_SDRAM_DEVICEFMC_NAND_DEVICEFMC_NORSRAM_EXTENDED_DEVICEFMC_NORSRAM_DEVICEFMC_SDRAM_TypeDefFMC_NAND_TypeDefFMC_NORSRAM_EXTENDED_TypeDefFMC_NORSRAM_TypeDefIS_FMC_CAS_LATENCY(__LATENCY__)(((__LATENCY__) == FMC_SDRAM_CAS_LATENCY_1) || ((__LATENCY__) == FMC_SDRAM_CAS_LATENCY_2) || ((__LATENCY__) == FMC_SDRAM_CAS_LATENCY_3))IS_FMC_INTERNALBANK_NUMBER(__NUMBER__)(((__NUMBER__) == FMC_SDRAM_INTERN_BANKS_NUM_2) || ((__NUMBER__) == FMC_SDRAM_INTERN_BANKS_NUM_4))IS_FMC_ROWBITS_NUMBER(__ROW__)(((__ROW__) == FMC_SDRAM_ROW_BITS_NUM_11) || ((__ROW__) == FMC_SDRAM_ROW_BITS_NUM_12) || ((__ROW__) == FMC_SDRAM_ROW_BITS_NUM_13))IS_FMC_COLUMNBITS_NUMBER(__COLUMN__)(((__COLUMN__) == FMC_SDRAM_COLUMN_BITS_NUM_8) || ((__COLUMN__) == FMC_SDRAM_COLUMN_BITS_NUM_9) || ((__COLUMN__) == FMC_SDRAM_COLUMN_BITS_NUM_10) || ((__COLUMN__) == FMC_SDRAM_COLUMN_BITS_NUM_11))IS_FMC_SDRAM_BANK(__BANK__)(((__BANK__) == FMC_SDRAM_BANK1) || ((__BANK__) == FMC_SDRAM_BANK2))IS_FMC_SDRAM_DEVICE(__INSTANCE__)((__INSTANCE__) == FMC_SDRAM_DEVICE)IS_FMC_REFRESH_RATE(__RATE__)((__RATE__) <= 8191U)IS_FMC_MODE_REGISTER(__CONTENT__)((__CONTENT__) <= 8191U)IS_FMC_AUTOREFRESH_NUMBER(__NUMBER__)(((__NUMBER__) > 0U) && ((__NUMBER__) <= 15U))IS_FMC_RCD_DELAY(__DELAY__)(((__DELAY__) > 0U) && ((__DELAY__) <= 16U))IS_FMC_RP_DELAY(__DELAY__)IS_FMC_WRITE_RECOVERY_TIME(__TIME__)(((__TIME__) > 0U) && ((__TIME__) <= 16U))IS_FMC_ROWCYCLE_DELAY(__DELAY__)IS_FMC_SELFREFRESH_TIME(__TIME__)IS_FMC_EXITSELFREFRESH_DELAY(__DELAY__)IS_FMC_LOADTOACTIVE_DELAY(__DELAY__)IS_FMC_COMMAND_TARGET(__TARGET__)(((__TARGET__) == FMC_SDRAM_CMD_TARGET_BANK1) || ((__TARGET__) == FMC_SDRAM_CMD_TARGET_BANK2) || ((__TARGET__) == FMC_SDRAM_CMD_TARGET_BANK1_2))IS_FMC_COMMAND_MODE(__COMMAND__)(((__COMMAND__) == FMC_SDRAM_CMD_NORMAL_MODE) || ((__COMMAND__) == FMC_SDRAM_CMD_CLK_ENABLE) || ((__COMMAND__) == FMC_SDRAM_CMD_PALL) || ((__COMMAND__) == FMC_SDRAM_CMD_AUTOREFRESH_MODE) || ((__COMMAND__) == FMC_SDRAM_CMD_LOAD_MODE) || ((__COMMAND__) == FMC_SDRAM_CMD_SELFREFRESH_MODE) || ((__COMMAND__) == FMC_SDRAM_CMD_POWERDOWN_MODE))IS_FMC_READPIPE_DELAY(__DELAY__)(((__DELAY__) == FMC_SDRAM_RPIPE_DELAY_0) || ((__DELAY__) == FMC_SDRAM_RPIPE_DELAY_1) || ((__DELAY__) == FMC_SDRAM_RPIPE_DELAY_2))IS_FMC_READ_BURST(__RBURST__)(((__RBURST__) == FMC_SDRAM_RBURST_DISABLE) || ((__RBURST__) == FMC_SDRAM_RBURST_ENABLE))IS_FMC_SDCLOCK_PERIOD(__PERIOD__)(((__PERIOD__) == FMC_SDRAM_CLOCK_DISABLE) || ((__PERIOD__) == FMC_SDRAM_CLOCK_PERIOD_2) || ((__PERIOD__) == FMC_SDRAM_CLOCK_PERIOD_3))IS_FMC_WRITE_PROTECTION(__WRITE__)(((__WRITE__) == FMC_SDRAM_WRITE_PROTECTION_DISABLE) || ((__WRITE__) == FMC_SDRAM_WRITE_PROTECTION_ENABLE))IS_FMC_SDMEMORY_WIDTH(__WIDTH__)(((__WIDTH__) == FMC_SDRAM_MEM_BUS_WIDTH_8) || ((__WIDTH__) == FMC_SDRAM_MEM_BUS_WIDTH_16) || ((__WIDTH__) == FMC_SDRAM_MEM_BUS_WIDTH_32))IS_FMC_NAND_DEVICE(__INSTANCE__)((__INSTANCE__) == FMC_NAND_DEVICE)IS_FMC_HIZ_TIME(__TIME__)((__TIME__) <= 254U)IS_FMC_HOLD_TIME(__TIME__)IS_FMC_WAIT_TIME(__TIME__)IS_FMC_SETUP_TIME(__TIME__)IS_FMC_TAR_TIME(__TIME__)((__TIME__) <= 255U)IS_FMC_TCLR_TIME(__TIME__)IS_FMC_ECCPAGE_SIZE(__SIZE__)(((__SIZE__) == FMC_NAND_ECC_PAGE_SIZE_256BYTE) || ((__SIZE__) == FMC_NAND_ECC_PAGE_SIZE_512BYTE) || ((__SIZE__) == FMC_NAND_ECC_PAGE_SIZE_1024BYTE) || ((__SIZE__) == FMC_NAND_ECC_PAGE_SIZE_2048BYTE) || ((__SIZE__) == FMC_NAND_ECC_PAGE_SIZE_4096BYTE) || ((__SIZE__) == FMC_NAND_ECC_PAGE_SIZE_8192BYTE))IS_FMC_ECC_STATE(__STATE__)(((__STATE__) == FMC_NAND_ECC_DISABLE) || ((__STATE__) == FMC_NAND_ECC_ENABLE))IS_FMC_NAND_MEMORY_WIDTH(__WIDTH__)(((__WIDTH__) == FMC_NAND_MEM_BUS_WIDTH_8) || ((__WIDTH__) == FMC_NAND_MEM_BUS_WIDTH_16))IS_FMC_WAIT_FEATURE(__FEATURE__)(((__FEATURE__) == FMC_NAND_WAIT_FEATURE_DISABLE) || ((__FEATURE__) == FMC_NAND_WAIT_FEATURE_ENABLE))IS_FMC_NAND_BANK(__BANK__)((__BANK__) == FMC_NAND_BANK3)IS_FMC_NORSRAM_EXTENDED_DEVICE(__INSTANCE__)((__INSTANCE__) == FMC_NORSRAM_EXTENDED_DEVICE)IS_FMC_NORSRAM_DEVICE(__INSTANCE__)((__INSTANCE__) == FMC_NORSRAM_DEVICE)IS_FMC_CLK_DIV(__DIV__)(((__DIV__) > 1U) && ((__DIV__) <= 16U))IS_FMC_TURNAROUND_TIME(__TIME__)((__TIME__) <= 15U)IS_FMC_DATAHOLD_DURATION(__DATAHOLD__)((__DATAHOLD__) <= 3U)IS_FMC_DATASETUP_TIME(__TIME__)(((__TIME__) > 0U) && ((__TIME__) <= 255U))IS_FMC_ADDRESS_HOLD_TIME(__TIME__)(((__TIME__) > 0U) && ((__TIME__) <= 15U))IS_FMC_ADDRESS_SETUP_TIME(__TIME__)IS_FMC_CONTINOUS_CLOCK(__CCLOCK__)(((__CCLOCK__) == FMC_CONTINUOUS_CLOCK_SYNC_ONLY) || ((__CCLOCK__) == FMC_CONTINUOUS_CLOCK_SYNC_ASYNC))IS_FMC_WRITE_BURST(__BURST__)(((__BURST__) == FMC_WRITE_BURST_DISABLE) || ((__BURST__) == FMC_WRITE_BURST_ENABLE))IS_FMC_DATA_LATENCY(__LATENCY__)(((__LATENCY__) > 1U) && ((__LATENCY__) <= 17U))IS_FMC_ASYNWAIT(__STATE__)(((__STATE__) == FMC_ASYNCHRONOUS_WAIT_DISABLE) || ((__STATE__) == FMC_ASYNCHRONOUS_WAIT_ENABLE))IS_FMC_EXTENDED_MODE(__MODE__)(((__MODE__) == FMC_EXTENDED_MODE_DISABLE) || ((__MODE__) == FMC_EXTENDED_MODE_ENABLE))IS_FMC_WAITE_SIGNAL(__SIGNAL__)(((__SIGNAL__) == FMC_WAIT_SIGNAL_DISABLE) || ((__SIGNAL__) == FMC_WAIT_SIGNAL_ENABLE))IS_FMC_WRITE_OPERATION(__OPERATION__)(((__OPERATION__) == FMC_WRITE_OPERATION_DISABLE) || ((__OPERATION__) == FMC_WRITE_OPERATION_ENABLE))IS_FMC_WAIT_SIGNAL_ACTIVE(__ACTIVE__)(((__ACTIVE__) == FMC_WAIT_TIMING_BEFORE_WS) || ((__ACTIVE__) == FMC_WAIT_TIMING_DURING_WS))IS_FMC_WAIT_POLARITY(__POLARITY__)(((__POLARITY__) == FMC_WAIT_SIGNAL_POLARITY_LOW) || ((__POLARITY__) == FMC_WAIT_SIGNAL_POLARITY_HIGH))IS_FMC_BURSTMODE(__STATE__)(((__STATE__) == FMC_BURST_ACCESS_MODE_DISABLE) || ((__STATE__) == FMC_BURST_ACCESS_MODE_ENABLE))IS_FMC_ACCESS_MODE(__MODE__)(((__MODE__) == FMC_ACCESS_MODE_A) || ((__MODE__) == FMC_ACCESS_MODE_B) || ((__MODE__) == FMC_ACCESS_MODE_C) || ((__MODE__) == FMC_ACCESS_MODE_D))IS_FMC_WRITE_FIFO(__FIFO__)(((__FIFO__) == FMC_WRITE_FIFO_DISABLE) || ((__FIFO__) == FMC_WRITE_FIFO_ENABLE))IS_FMC_PAGESIZE(__SIZE__)(((__SIZE__) == FMC_PAGE_SIZE_NONE) || ((__SIZE__) == FMC_PAGE_SIZE_128) || ((__SIZE__) == FMC_PAGE_SIZE_256) || ((__SIZE__) == FMC_PAGE_SIZE_512) || ((__SIZE__) == FMC_PAGE_SIZE_1024))IS_FMC_NORSRAM_MEMORY_WIDTH(__WIDTH__)(((__WIDTH__) == FMC_NORSRAM_MEM_BUS_WIDTH_8) || ((__WIDTH__) == FMC_NORSRAM_MEM_BUS_WIDTH_16) || ((__WIDTH__) == FMC_NORSRAM_MEM_BUS_WIDTH_32))IS_FMC_MEMORY(__MEMORY__)(((__MEMORY__) == FMC_MEMORY_TYPE_SRAM) || ((__MEMORY__) == FMC_MEMORY_TYPE_PSRAM)|| ((__MEMORY__) == FMC_MEMORY_TYPE_NOR))IS_FMC_MUX(__MUX__)(((__MUX__) == FMC_DATA_ADDRESS_MUX_DISABLE) || ((__MUX__) == FMC_DATA_ADDRESS_MUX_ENABLE))IS_FMC_NORSRAM_BANK(__BANK__)(((__BANK__) == FMC_NORSRAM_BANK1) || ((__BANK__) == FMC_NORSRAM_BANK2) || ((__BANK__) == FMC_NORSRAM_BANK3) || ((__BANK__) == FMC_NORSRAM_BANK4))STM32F7xx_LL_FMC_Hdefined(FMC_BCR1_WFDIS)/* STM32F7xx_LL_FMC_H *//** @defgroup FMC_LL_SDRAM_Private_Functions_Group2 SDRAM Control functions
  *  @{
  *//** @defgroup FMC_LL_SDRAM_Private_Functions_Group1 SDRAM Initialization/de-initialization functions
  *  @{
  *//** @defgroup FMC_LL_SDRAM SDRAM
  *  @{
  *//** @defgroup FMC_LL_NAND_Private_Functions_Group2 NAND Control functions
  *  @{
  *//** @defgroup FMC_LL_NAND_Private_Functions_Group1 NAND Initialization/de-initialization functions
  *  @{
  *//** @defgroup FMC_LL_NAND NAND
  *  @{
  *//** @defgroup FMC_LL_NORSRAM_Private_Functions_Group2 NOR SRAM Control functions
  *  @{
  *//** @defgroup FMC_LL_NORSRAM_Private_Functions_Group1 NOR SRAM Initialization/de-initialization functions
  *  @{
  *//** @defgroup FMC_LL_NORSRAM  NOR SRAM
  *  @{
  *//** @defgroup FMC_LL_Private_Functions FMC LL Private Functions
  *  @{
  *//**
  * @brief  Clear flag status of the SDRAM device.
  * @param  __INSTANCE__ FMC_SDRAM instance
  * @param  __FLAG__     FMC_SDRAM flag
  *         This parameter can be any combination of the following values:
  *           @arg FMC_SDRAM_FLAG_REFRESH_ERROR
  * @retval None
  *//**
  * @brief  Get flag status of the SDRAM device.
  * @param  __INSTANCE__ FMC_SDRAM instance
  * @param  __FLAG__     FMC_SDRAM flag
  *         This parameter can be any combination of the following values:
  *            @arg FMC_SDRAM_FLAG_REFRESH_IT: Interrupt refresh error.
  *            @arg FMC_SDRAM_FLAG_BUSY: SDRAM busy flag.
  *            @arg FMC_SDRAM_FLAG_REFRESH_ERROR: Refresh error flag.
  * @retval The state of FLAG (SET or RESET).
  *//**
  * @brief  Disable the SDRAM device interrupt.
  * @param  __INSTANCE__  FMC_SDRAM instance
  * @param  __INTERRUPT__ FMC_SDRAM interrupt
  *         This parameter can be any combination of the following values:
  *            @arg FMC_IT_REFRESH_ERROR: Interrupt refresh error
  * @retval None
  *//**
  * @brief  Enable the SDRAM device interrupt.
  * @param  __INSTANCE__  FMC_SDRAM instance
  * @param  __INTERRUPT__ FMC_SDRAM interrupt
  *         This parameter can be any combination of the following values:
  *            @arg FMC_IT_REFRESH_ERROR: Interrupt refresh error
  * @retval None
  *//** @defgroup FMC_LL_SDRAM_Interrupt FMC SDRAM Interrupt
  * @brief macros to handle SDRAM interrupts
  * @{
  *//**
  * @brief  Clear flag status of the NAND device.
  * @param  __INSTANCE__ FMC_NAND Instance
  * @param  __FLAG__     FMC_NAND flag
  *         This parameter can be any combination of the following values:
  *            @arg FMC_FLAG_RISING_EDGE: Interrupt rising edge flag.
  *            @arg FMC_FLAG_LEVEL: Interrupt level edge flag.
  *            @arg FMC_FLAG_FALLING_EDGE: Interrupt falling edge flag.
  *            @arg FMC_FLAG_FEMPT: FIFO empty flag.
  * @retval None
  *//**
  * @brief  Get flag status of the NAND device.
  * @param  __INSTANCE__ FMC_NAND Instance
  * @param  __BANK__     FMC_NAND Bank
  * @param  __FLAG__     FMC_NAND flag
  *         This parameter can be any combination of the following values:
  *            @arg FMC_FLAG_RISING_EDGE: Interrupt rising edge flag.
  *            @arg FMC_FLAG_LEVEL: Interrupt level edge flag.
  *            @arg FMC_FLAG_FALLING_EDGE: Interrupt falling edge flag.
  *            @arg FMC_FLAG_FEMPT: FIFO empty flag.
  * @retval The state of FLAG (SET or RESET).
  *//**
  * @brief  Disable the NAND device interrupt.
  * @param  __INSTANCE__  FMC_NAND Instance
  * @param  __INTERRUPT__ FMC_NAND interrupt
  *         This parameter can be any combination of the following values:
  *            @arg FMC_IT_RISING_EDGE: Interrupt rising edge.
  *            @arg FMC_IT_LEVEL: Interrupt level.
  *            @arg FMC_IT_FALLING_EDGE: Interrupt falling edge.
  * @retval None
  *//**
  * @brief  Enable the NAND device interrupt.
  * @param  __INSTANCE__  FMC_NAND instance
  * @param  __INTERRUPT__ FMC_NAND interrupt
  *         This parameter can be any combination of the following values:
  *            @arg FMC_IT_RISING_EDGE: Interrupt rising edge.
  *            @arg FMC_IT_LEVEL: Interrupt level.
  *            @arg FMC_IT_FALLING_EDGE: Interrupt falling edge.
  * @retval None
  *//** @defgroup FMC_LL_NAND_Interrupt FMC NAND Interrupt
  * @brief macros to handle NAND interrupts
  * @{
  *//**
  * @brief  Disable the NAND device access.
  * @param  __INSTANCE__ FMC_NAND Instance
  * @param  __BANK__     FMC_NAND Bank
  * @retval None
  *//**
  * @brief  Enable the NAND device access.
  * @param  __INSTANCE__ FMC_NAND Instance
  * @retval None
  *//** @defgroup FMC_LL_NAND_Macros FMC NAND Macros
  *  @brief macros to handle NAND device enable/disable
  *  @{
  *//**
  * @brief  Disable the NORSRAM device access.
  * @param  __INSTANCE__ FMC_NORSRAM Instance
  * @param  __BANK__ FMC_NORSRAM Bank
  * @retval None
  *//**
  * @brief  Enable the NORSRAM device access.
  * @param  __INSTANCE__ FMC_NORSRAM Instance
  * @param  __BANK__ FMC_NORSRAM Bank
  * @retval None
  *//** @defgroup FMC_LL_NOR_Macros FMC NOR/SRAM Macros
  * @brief macros to handle NOR device enable/disable and read/write operations
  * @{
  *//** @defgroup FMC_LL_Private_Macros FMC_LL  Private Macros
  * @{
  *//** @defgroup FMC_LL_Flag_definition FMC Low Layer Flag definition
  * @{
  *//** @defgroup FMC_LL_Interrupt_definition FMC Low Layer Interrupt definition
  * @{
  *//** @defgroup FMC_SDRAM_Mode_Status FMC SDRAM Mode Status
  * @{
  *//** @defgroup FMC_SDRAM_Command_Target FMC SDRAM Command Target
  * @{
  *//** @defgroup FMC_SDRAM_Command_Mode FMC SDRAM Command Mode
  * @{
  *//** @defgroup FMC_SDRAM_Read_Pipe_Delay FMC SDRAM Read Pipe Delay
  * @{
  *//** @defgroup FMC_SDRAM_Read_Burst FMC SDRAM Read Burst
  * @{
  *//** @defgroup FMC_SDRAM_Clock_Period FMC SDRAM Clock Period
  * @{
  *//** @defgroup FMC_SDRAM_Write_Protection FMC SDRAM Write Protection
  * @{
  *//** @defgroup FMC_SDRAM_CAS_Latency FMC SDRAM CAS Latency
  * @{
  *//** @defgroup FMC_SDRAM_Internal_Banks_Number FMC SDRAM Internal Banks Number
  * @{
  *//** @defgroup FMC_SDRAM_Memory_Bus_Width FMC SDRAM Memory Bus Width
  * @{
  *//** @defgroup FMC_SDRAM_Row_Bits_number FMC SDRAM Row Bits number
  * @{
  *//** @defgroup FMC_SDRAM_Column_Bits_number FMC SDRAM Column Bits number
  * @{
  *//** @defgroup FMC_SDRAM_Bank FMC SDRAM Bank
  * @{
  *//** @defgroup FMC_LL_SDRAM_Controller FMC SDRAM Controller
  * @{
  *//** @defgroup FMC_ECC_Page_Size FMC ECC Page Size
  * @{
  *//** @defgroup FMC_ECC FMC ECC
  * @{
  *//** @defgroup FMC_NAND_Data_Width FMC NAND Data Width
  * @{
  *//** @defgroup FMC_PCR_Memory_Type FMC PCR Memory Type
  * @{
  *//** @defgroup FMC_Wait_feature FMC Wait feature
  * @{
  *//** @defgroup FMC_NAND_Bank FMC NAND Bank
  * @{
  *//** @defgroup FMC_LL_NAND_Controller FMC NAND Controller
  * @{
  *//** @defgroup FMC_Access_Mode FMC Access Mode
  * @{
  *//* FMC_BCR1_WFDIS *//** @defgroup FMC_Write_FIFO FMC Write FIFO
  * @{
  *//** @defgroup FMC_Continous_Clock FMC Continuous Clock
  * @{
  *//** @defgroup FMC_Write_Burst FMC Write Burst
  * @{
  *//** @defgroup FMC_Page_Size FMC Page Size
  * @{
  *//** @defgroup FMC_AsynchronousWait FMC Asynchronous Wait
  * @{
  *//** @defgroup FMC_Extended_Mode FMC Extended Mode
  * @{
  *//** @defgroup FMC_Wait_Signal FMC Wait Signal
  * @{
  *//** @defgroup FMC_Write_Operation FMC Write Operation
  * @{
  *//** @defgroup FMC_Wait_Timing FMC Wait Timing
  * @{
  *//** @defgroup FMC_Wait_Signal_Polarity FMC Wait Signal Polarity
  * @{
  *//** @defgroup FMC_Burst_Access_Mode FMC Burst Access Mode
  * @{
  *//** @defgroup FMC_NORSRAM_Flash_Access FMC NOR/SRAM Flash Access
  * @{
  *//** @defgroup FMC_NORSRAM_Data_Width FMC NORSRAM Data Width
  * @{
  *//** @defgroup FMC_Memory_Type FMC Memory Type
  * @{
  *//** @defgroup FMC_Data_Address_Bus_Multiplexing FMC Data Address Bus Multiplexing
  * @{
  *//** @defgroup FMC_NORSRAM_Bank FMC NOR/SRAM Bank
  * @{
  *//** @defgroup FMC_LL_NOR_SRAM_Controller FMC NOR/SRAM Controller
  * @{
  *//** @addtogroup FMC_LL_Exported_Constants FMC Low Layer Exported Constants
  * @{
  *//*!< Defines the SDRAM Mode register content                                *//*!< Defines the number of consecutive auto refresh command issued
                                              in auto refresh mode.
                                              This parameter can be a value between Min_Data = 1 and Max_Data = 15   *//*!< Defines which device (1 or 2) the command will be issued to.
                                              This parameter can be a value of @ref FMC_SDRAM_Command_Target.        *//*!< Defines the command issued to the SDRAM device.
                                              This parameter can be a value of @ref FMC_SDRAM_Command_Mode.          *//**
  * @brief SDRAM command parameters structure definition
  *//*!< Defines the delay between the Activate Command and a Read/Write
                                              command in number of memory clock cycles.
                                              This parameter can be a value between Min_Data = 1 and Max_Data = 16  *//*!< Defines the delay between a Precharge Command and an other command
                                              in number of memory clock cycles.
                                              This parameter can be a value between Min_Data = 1 and Max_Data = 16  *//*!< Defines the Write recovery Time in number of memory clock cycles.
                                              This parameter can be a value between Min_Data = 1 and Max_Data = 16  *//*!< Defines the delay between the Refresh command and the Activate command
                                              and the delay between two consecutive Refresh commands in number of
                                              memory clock cycles.
                                              This parameter can be a value between Min_Data = 1 and Max_Data = 16  *//*!< Defines the minimum Self Refresh period in number of memory clock
                                              cycles.
                                              This parameter can be a value between Min_Data = 1 and Max_Data = 16  *//*!< Defines the delay from releasing the self refresh command to
                                              issuing the Activate command in number of memory clock cycles.
                                              This parameter can be a value between Min_Data = 1 and Max_Data = 16  *//*!< Defines the delay between a Load Mode Register command and
                                              an active or Refresh command in number of memory clock cycles.
                                              This parameter can be a value between Min_Data = 1 and Max_Data = 16  *//**
  * @brief FMC SDRAM Timing parameters structure definition
  *//*!< Define the delay in system clock cycles on read data path.
                                             This parameter can be a value of @ref FMC_SDRAM_Read_Pipe_Delay.    *//*!< This bit enable the SDRAM controller to anticipate the next read
                                             commands during the CAS latency and stores data in the Read FIFO.
                                             This parameter can be a value of @ref FMC_SDRAM_Read_Burst.         *//*!< Define the SDRAM Clock Period for both SDRAM devices and they allow
                                             to disable the clock before changing frequency.
                                             This parameter can be a value of @ref FMC_SDRAM_Clock_Period.       *//*!< Enables the SDRAM device to be accessed in write mode.
                                             This parameter can be a value of @ref FMC_SDRAM_Write_Protection.   *//*!< Defines the SDRAM CAS latency in number of memory clock cycles.
                                             This parameter can be a value of @ref FMC_SDRAM_CAS_Latency.        *//*!< Defines the number of the device's internal banks.
                                             This parameter can be of @ref FMC_SDRAM_Internal_Banks_Number.      *//*!< Defines the memory device width.
                                             This parameter can be a value of @ref FMC_SDRAM_Memory_Bus_Width.   *//*!< Defines the number of bits of column address.
                                             This parameter can be a value of @ref FMC_SDRAM_Row_Bits_number.    *//*!< Defines the number of bits of column address.
                                             This parameter can be a value of @ref FMC_SDRAM_Column_Bits_number. *//*!< Specifies the SDRAM memory device that will be used.
                                             This parameter can be a value of @ref FMC_SDRAM_Bank                *//**
  * @brief  FMC SDRAM Configuration Structure definition
  *//*!< Defines the number of HCLK clock cycles during which the
                                      data bus is kept in HiZ after the start of a NAND-Flash
                                      write access to common/Attribute or I/O memory space (depending
                                      on the memory space timing to be configured).
                                      This parameter can be a number between Min_Data = 0 and Max_Data = 254   *//*!< Defines the number of HCLK clock cycles to hold address
                                      (and data for write access) after the command de-assertion
                                      for NAND-Flash read or write access to common/Attribute
                                      or I/O memory space (depending on the memory space timing
                                      to be configured).
                                      This parameter can be a number between Min_Data = 0 and Max_Data = 254   *//*!< Defines the minimum number of HCLK cycles to assert the
                                      command for NAND-Flash read or write access to
                                      common/Attribute or I/O memory space (depending on the
                                      memory space timing to be configured).
                                      This parameter can be a number between Min_Data = 0 and Max_Data = 254   *//*!< Defines the number of HCLK cycles to setup address before
                                      the command assertion for NAND-Flash read or write access
                                      to common/Attribute or I/O memory space (depending on
                                      the memory space timing to be configured).
                                      This parameter can be a value between Min_Data = 0 and Max_Data = 254    *//**
  * @brief  FMC NAND Timing parameters structure definition
  *//*!< Defines the number of HCLK cycles to configure the
                                        delay between ALE low and RE low.
                                        This parameter can be a number between Min_Data = 0 and Max_Data = 255 *//*!< Defines the number of HCLK cycles to configure the
                                        delay between CLE low and RE low.
                                        This parameter can be a value between Min_Data = 0 and Max_Data = 255  *//*!< Defines the page size for the extended ECC.
                                        This parameter can be any value of @ref FMC_ECC_Page_Size            *//*!< Enables or disables the ECC computation.
                                        This parameter can be any value of @ref FMC_ECC                      *//*!< Specifies the external memory device width.
                                        This parameter can be any value of @ref FMC_NAND_Data_Width          *//*!< Enables or disables the Wait feature for the NAND Memory device.
                                        This parameter can be any value of @ref FMC_Wait_feature             *//*!< Specifies the NAND memory device that will be used.
                                        This parameter can be a value of @ref FMC_NAND_Bank                  *//**
  * @brief  FMC NAND Configuration Structure definition
  *//*!< Specifies the asynchronous access mode.
                                              This parameter can be a value of @ref FMC_Access_Mode                   *//*!< Defines the number of memory clock cycles to issue
                                              to the memory before getting the first data.
                                              The parameter value depends on the memory type as shown below:
                                              - It must be set to 0 in case of a CRAM
                                              - It is don't care in asynchronous NOR, SRAM or ROM accesses
                                              - It may assume a value between Min_Data = 2 and Max_Data = 17
                                                in NOR Flash memories with synchronous burst mode enable              *//*!< Defines the period of CLK clock output signal, expressed in number of
                                              HCLK cycles. This parameter can be a value between Min_Data = 2 and
                                              Max_Data = 16.
                                              @note This parameter is not used for asynchronous NOR Flash, SRAM or ROM
                                              accesses.                                                               *//*!< Defines the number of HCLK cycles to configure
                                              the duration of the bus turnaround.
                                              This parameter can be a value between Min_Data = 0 and Max_Data = 15.
                                              @note This parameter is only used for multiplexed NOR Flash memories.   *//*!< Defines the number of HCLK cycles to configure
                                              the duration of the data setup time.
                                              This parameter can be a value between Min_Data = 1 and Max_Data = 255.
                                              @note This parameter is used for SRAMs, ROMs and asynchronous multiplexed
                                              NOR Flash memories.                                                     *//*!< Defines the number of HCLK cycles to configure
                                              the duration of the address hold time.
                                              This parameter can be a value between Min_Data = 1 and Max_Data = 15.
                                              @note This parameter is not used with synchronous NOR Flash memories.   *//*!< Defines the number of HCLK cycles to configure
                                              the duration of the address setup time.
                                              This parameter can be a value between Min_Data = 0 and Max_Data = 15.
                                              @note This parameter is not used with synchronous NOR Flash memories.   *//**
  * @brief  FMC NORSRAM Timing parameters structure definition
  *//*!< Specifies the memory page size.
                                              This parameter can be a value of @ref FMC_Page_Size                     *//*!< Enables or disables the write FIFO used by the FMC controller.
                                              This parameter is only enabled through the FMC_BCR1 register,
                                              and don't care through FMC_BCR2..4 registers.
                                              This parameter can be a value of @ref FMC_Write_FIFO                    *//*!< Enables or disables the FMC clock output to external memory devices.
                                              This parameter is only enabled through the FMC_BCR1 register,
                                              and don't care through FMC_BCR2..4 registers.
                                              This parameter can be a value of @ref FMC_Continous_Clock               *//*!< Enables or disables the write burst operation.
                                              This parameter can be a value of @ref FMC_Write_Burst                   *//*!< Enables or disables wait signal during asynchronous transfers,
                                              valid only with asynchronous Flash memories.
                                              This parameter can be a value of @ref FMC_AsynchronousWait              *//*!< Enables or disables the extended mode.
                                              This parameter can be a value of @ref FMC_Extended_Mode                 *//*!< Enables or disables the wait state insertion via wait
                                              signal, valid for Flash memory access in burst mode.
                                              This parameter can be a value of @ref FMC_Wait_Signal                   *//*!< Enables or disables the write operation in the selected device by the FMC.
                                              This parameter can be a value of @ref FMC_Write_Operation               *//*!< Specifies if the wait signal is asserted by the memory one
                                              clock cycle before the wait state or during the wait state,
                                              valid only when accessing memories in burst mode.
                                              This parameter can be a value of @ref FMC_Wait_Timing                   *//*!< Specifies the wait signal polarity, valid only when accessing
                                              the Flash memory in burst mode.
                                              This parameter can be a value of @ref FMC_Wait_Signal_Polarity          *//*!< Enables or disables the burst access mode for Flash memory,
                                              valid only with synchronous burst Flash memories.
                                              This parameter can be a value of @ref FMC_Burst_Access_Mode             *//*!< Specifies the external memory device width.
                                              This parameter can be a value of @ref FMC_NORSRAM_Data_Width            *//*!< Specifies the type of external memory attached to
                                              the corresponding memory device.
                                              This parameter can be a value of @ref FMC_Memory_Type                   *//*!< Specifies whether the address and data values are
                                              multiplexed on the data bus or not.
                                              This parameter can be a value of @ref FMC_Data_Address_Bus_Multiplexing *//*!< Specifies the NORSRAM memory device that will be used.
                                              This parameter can be a value of @ref FMC_NORSRAM_Bank                  *//**
  * @brief  FMC NORSRAM Configuration Structure definition
  *//** @defgroup FMC_LL_Exported_typedef FMC Low Layer Exported Types
  * @{
  *//* Exported typedef ----------------------------------------------------------*//** @addtogroup FMC_LL_Private_Macros
  * @{
  *//** @addtogroup FMC_LL
  * @{
  *//**
  ******************************************************************************
  * @file    stm32f7xx_ll_fmc.h
  * @author  MCD Application Team
  * @brief   Header file of FMC HAL module.
  ******************************************************************************
  * @attention
  *
  * Copyright (c) 2017 STMicroelectronics.
  * All rights reserved.
  *
  * This software is licensed under terms that can be found in the LICENSE file
  * in the root directory of this software component.
  * If no LICENSE file comes with this software, it is provided AS-IS.
  *
  ******************************************************************************
  */DeviceBankRefreshRateECCvalExDevice"stm32f7xx_ll_fmc.h"HAL_SRAM_GetStateconst SRAM_HandleTypeDefconst SRAM_HandleTypeDef *HAL_SRAM_WriteOperation_DisableHAL_SRAM_WriteOperation_EnableHAL_SRAM_DMA_XferErrorCallbackHAL_SRAM_DMA_XferCpltCallbackHAL_SRAM_Write_DMAHAL_SRAM_Read_DMAHAL_SRAM_Write_32bHAL_SRAM_Read_32bHAL_SRAM_Write_16bHAL_SRAM_Read_16bHAL_SRAM_Write_8bHAL_SRAM_Read_8bHAL_SRAM_MspDeInitHAL_SRAM_MspInitHAL_SRAM_DeInitHAL_SRAM_InitSRAM_HandleTypeDefHAL_SRAM_StateTypeDefHAL_SRAM_STATE_RESETHAL_SRAM_STATE_READYHAL_SRAM_STATE_BUSYHAL_SRAM_STATE_ERRORHAL_SRAM_STATE_PROTECTEDvolatile HAL_SRAM_StateTypeDefExtended__HAL_SRAM_RESET_HANDLE_STATE(__HANDLE__)((__HANDLE__)->State = HAL_SRAM_STATE_RESET)STM32F7xx_HAL_SRAM_H(USE_HAL_SRAM_REGISTER_CALLBACKS == 1)/* STM32F7xx_HAL_SRAM_H *//* SRAM  State functions ******************************************************//** @addtogroup SRAM_Exported_Functions_Group4 Peripheral State functions
  * @{
  *//* SRAM Control functions  ****************************************************//** @addtogroup SRAM_Exported_Functions_Group3 Control functions
  * @{
  *//* USE_HAL_SRAM_REGISTER_CALLBACKS  *//* SRAM callback registering/unregistering *//* I/O operation functions  ***************************************************//** @addtogroup SRAM_Exported_Functions_Group2 Input Output and memory control functions
  * @{
  *//* Initialization/de-initialization functions  ********************************//** @addtogroup SRAM_Exported_Functions_Group1 Initialization and de-initialization functions
  * @{
  *//** @addtogroup SRAM_Exported_Functions SRAM Exported Functions
  * @{
  *//** @brief Reset SRAM handle state
  * @param  __HANDLE__ SRAM handle
  * @retval None
  *//** @defgroup SRAM_Exported_Macros SRAM Exported Macros
  * @{
  *//**
  * @brief  HAL SRAM Callback pointer definition
  *//*!< SRAM DMA Xfer Complete Callback ID *//*!< SRAM MspDeInit Callback ID         *//*!< SRAM MspInit Callback ID           *//**
  * @brief  HAL SRAM Callback ID enumeration definition
  *//*!< SRAM DMA Xfer Error callback        *//*!< SRAM DMA Xfer Complete callback     *//*!< SRAM Msp DeInit callback            *//*!< SRAM Msp Init callback              *//*!< Pointer DMA handler                          *//*!< SRAM device access state                     *//*!< SRAM locking object                          *//*!< SRAM device control configuration parameters *//*!< Extended mode register base address          *//*!< Register base address                        *//**
  * @brief  SRAM handle Structure definition
  *//*!< SRAM peripheral NORSRAM device write protected *//*!< SRAM error state                               *//*!< SRAM internal process is ongoing               *//*!< SRAM initialized and ready for use             *//*!< SRAM not yet initialized or disabled           *//**
  * @brief  HAL SRAM State structures definition
  *//** @defgroup SRAM_Exported_Types SRAM Exported Types
  * @{
  *//** @addtogroup SRAM
  * @{
  *//**
  ******************************************************************************
  * @file    stm32f7xx_hal_sram.h
  * @author  MCD Application Team
  * @brief   Header file of SRAM HAL module.
  ******************************************************************************
  * @attention
  *
  * Copyright (c) 2017 STMicroelectronics.
  * All rights reserved.
  *
  * This software is licensed under terms that can be found in the LICENSE file
  * in the root directory of this software component.
  * If no LICENSE file comes with this software, it is provided AS-IS.
  *
  ******************************************************************************
  */pAddresspSrcBufferpDstBufferExtTimingHAL_NOR_GetStatusNOR_HandleTypeDef *HAL_NOR_GetStateconst NOR_HandleTypeDefconst NOR_HandleTypeDef *HAL_NOR_WriteOperation_DisableHAL_NOR_WriteOperation_EnableHAL_NOR_Read_CFINOR_CFITypeDef *HAL_NOR_Erase_ChipHAL_NOR_Erase_BlockHAL_NOR_ProgramBufferHAL_NOR_ReadBufferHAL_NOR_ProgramHAL_NOR_ReadHAL_NOR_ReturnToReadModeHAL_NOR_Read_IDNOR_IDTypeDef *HAL_NOR_MspWaitHAL_NOR_MspDeInitHAL_NOR_MspInitHAL_NOR_DeInitHAL_NOR_InitNOR_HandleTypeDefNOR_CFITypeDefNOR_IDTypeDefHAL_NOR_StateTypeDefHAL_NOR_STATE_RESETHAL_NOR_STATE_READYHAL_NOR_STATE_BUSYHAL_NOR_STATE_ERRORHAL_NOR_STATE_PROTECTEDCommandSetvolatile HAL_NOR_StateTypeDefCFI_4CFI_3CFI_2CFI_1Device_Code3Device_Code2Device_Code1Manufacturer_CodeNOR_WRITE(__ADDRESS__,__DATA__)do{ (*(__IO uint16_t *)((uint32_t)(__ADDRESS__)) = (__DATA__)); __DSB(); } while(0)NOR_ADDR_SHIFT(__NOR_ADDRESS,__NOR_MEMORY_WIDTH_,__ADDRESS__)((uint32_t)(((__NOR_MEMORY_WIDTH_) == NOR_MEMORY_16B)? ((uint32_t)((__NOR_ADDRESS) + (2U * (__ADDRESS__)))): ((uint32_t)((__NOR_ADDRESS) + (__ADDRESS__)))))NOR_MEMORY_ADRESS4(0x6C000000U)NOR_MEMORY_ADRESS3(0x68000000U)NOR_MEMORY_ADRESS2(0x64000000U)NOR_MEMORY_ADRESS1(0x60000000U)NOR_MEMORY_16BNOR_MEMORY_8BNOR_TMEOUT((uint16_t)0xFFFF)CFI4_ADDRESS((uint16_t)0x0064)CFI3_ADDRESS((uint16_t)0x0063)CFI2_ADDRESS((uint16_t)0x0062)CFI1_ADDRESS((uint16_t)0x0061)DEVICE_CODE3_ADDR((uint16_t)0x000F)DEVICE_CODE2_ADDR((uint16_t)0x000E)DEVICE_CODE1_ADDRMC_ADDRESS__HAL_NOR_RESET_HANDLE_STATE(__HANDLE__)((__HANDLE__)->State = HAL_NOR_STATE_RESET)STM32F7xx_HAL_NOR_H(USE_HAL_NOR_REGISTER_CALLBACKS == 1)/* STM32F7xx_HAL_NOR_H *//**
  * @brief  NOR memory write data to specified address.
  * @param  __ADDRESS__ NOR memory address
  * @param  __DATA__ Data to write
  * @retval None
  *//**
  * @brief  NOR memory address shifting.
  * @param  __NOR_ADDRESS NOR base address
  * @param  __NOR_MEMORY_WIDTH_ NOR memory width
  * @param  __ADDRESS__ NOR memory address
  * @retval NOR shifted address value
  *//** @defgroup NOR_Private_Macros NOR Private Macros
  * @{
  *//* NOR memory device read/write start address *//* NOR memory data width *//* NOR operation wait timeout *//* NOR CFI IDs addresses *//* NOR device IDs addresses *//** @defgroup NOR_Private_Constants NOR Private Constants
  * @{
  *//* NOR State functions ********************************************************//** @addtogroup NOR_Exported_Functions_Group4 NOR State functions
  * @{
  *//* NOR Control functions  *****************************************************//** @addtogroup NOR_Exported_Functions_Group3 NOR Control functions
  * @{
  *//* USE_HAL_NOR_REGISTER_CALLBACKS *//* NOR callback registering/unregistering *//** @addtogroup NOR_Exported_Functions_Group2 Input and Output functions
  * @{
  *//** @addtogroup NOR_Exported_Functions_Group1 Initialization and de-initialization functions
  * @{
  *//** @addtogroup NOR_Exported_Functions NOR Exported Functions
  * @{
  *//** @brief Reset NOR handle state
  * @param  __HANDLE__ specifies the NOR handle.
  * @retval None
  *//** @defgroup NOR_Exported_Macros NOR Exported Macros
  * @{
  *//**
  * @brief  HAL NOR Callback pointer definition
  *//*!< NOR MspDeInit Callback ID        *//*!< NOR MspInit Callback ID          *//**
  * @brief  HAL NOR Callback ID enumeration definition
  *//*!< NOR Msp DeInit callback            *//*!< NOR Msp Init callback              *//*!< NOR algorithm command set and control        *//*!< NOR device access state                      *//*!< NOR locking object                           *//*!< NOR device control configuration parameters  *//* USE_HAL_NOR_REGISTER_CALLBACKS  *//**
  * @brief  NOR handle Structure definition
  *//*!< Defines the information stored in the memory's Common flash interface
       which contains a description of various electrical and timing parameters,
       density information and functions supported by the memory                   *//**
  * @brief  FMC NOR CFI typedef
  *//*!< Defines the device's codes used to identify the memory.
                                    These codes can be accessed by performing read operations with specific
                                    control signals and addresses set.They can also be accessed by issuing
                                    an Auto Select command                                                   *//*!< Defines the device's manufacturer code used to identify the memory       *//**
  * @brief  FMC NOR ID typedef
  *//**
  * @brief  FMC NOR Status typedef
  *//*!< NOR NORSRAM device write protected   *//*!< NOR error state                      *//*!< NOR internal processing is ongoing   *//*!< NOR initialized and ready for use    *//*!< NOR not yet initialized or disabled  *//** @defgroup NOR_Exported_Types NOR Exported Types
  * @{
  *//** @addtogroup NOR
  * @{
  *//**
  ******************************************************************************
  * @file    stm32f7xx_hal_nor.h
  * @author  MCD Application Team
  * @brief   Header file of NOR HAL module.
  ******************************************************************************
  * @attention
  *
  * Copyright (c) 2017 STMicroelectronics.
  * All rights reserved.
  *
  * This software is licensed under terms that can be found in the LICENSE file
  * in the root directory of this software component.
  * If no LICENSE file comes with this software, it is provided AS-IS.
  *
  ******************************************************************************
  */hnorpNOR_CFIBlockAddressuwAddressuwBufferSizepNOR_IDHAL_SDRAM_GetStateHAL_SDRAM_GetModeStatusHAL_SDRAM_SetAutoRefreshNumberHAL_SDRAM_ProgramRefreshRateHAL_SDRAM_SendCommandHAL_SDRAM_WriteProtection_DisableHAL_SDRAM_WriteProtection_EnableHAL_SDRAM_Write_DMAHAL_SDRAM_Read_DMAHAL_SDRAM_Write_32bHAL_SDRAM_Read_32bHAL_SDRAM_Write_16bHAL_SDRAM_Read_16bHAL_SDRAM_Write_8bHAL_SDRAM_Read_8bHAL_SDRAM_DMA_XferErrorCallbackHAL_SDRAM_DMA_XferCpltCallbackHAL_SDRAM_RefreshErrorCallbackHAL_SDRAM_IRQHandlerHAL_SDRAM_MspDeInitHAL_SDRAM_MspInitHAL_SDRAM_DeInitHAL_SDRAM_InitSDRAM_HandleTypeDefHAL_SDRAM_StateTypeDefHAL_SDRAM_STATE_RESETHAL_SDRAM_STATE_READYHAL_SDRAM_STATE_BUSYHAL_SDRAM_STATE_ERRORHAL_SDRAM_STATE_WRITE_PROTECTEDHAL_SDRAM_STATE_PRECHARGEDvolatile HAL_SDRAM_StateTypeDef__HAL_SDRAM_RESET_HANDLE_STATE(__HANDLE__)((__HANDLE__)->State = HAL_SDRAM_STATE_RESET)STM32F7xx_HAL_SDRAM_H(USE_HAL_SDRAM_REGISTER_CALLBACKS == 1)/* STM32F7xx_HAL_SDRAM_H *//* SDRAM State functions ********************************************************//** @addtogroup SDRAM_Exported_Functions_Group4
  * @{
  *//* SDRAM Control functions  *****************************************************//** @addtogroup SDRAM_Exported_Functions_Group3
  * @{
  *//* USE_HAL_SDRAM_REGISTER_CALLBACKS *//* SDRAM callback registering/unregistering *//* I/O operation functions ****************************************************//** @addtogroup SDRAM_Exported_Functions_Group2
  * @{
  *//* Initialization/de-initialization functions *********************************//** @addtogroup SDRAM_Exported_Functions_Group1
  * @{
  *//** @addtogroup SDRAM_Exported_Functions SDRAM Exported Functions
  * @{
  *//** @brief Reset SDRAM handle state
  * @param  __HANDLE__ specifies the SDRAM handle.
  * @retval None
  *//** @defgroup SDRAM_Exported_Macros SDRAM Exported Macros
  * @{
  *//**
  * @brief  HAL SDRAM Callback pointer definition
  *//*!< SDRAM DMA Xfer Error Callback ID    *//*!< SDRAM DMA Xfer Complete Callback ID *//*!< SDRAM Refresh Error Callback ID     *//*!< SDRAM MspDeInit Callback ID         *//*!< SDRAM MspInit Callback ID           *//**
  * @brief  HAL SDRAM Callback ID enumeration definition
  *//*!< SDRAM DMA Xfer Error callback        *//*!< SDRAM DMA Xfer Complete callback     *//*!< SDRAM Refresh Error callback         *//*!< SDRAM Msp DeInit callback            *//*!< SDRAM Msp Init callback              *//*!< Pointer DMA handler                   *//*!< SDRAM locking object                  *//*!< SDRAM access state                    *//*!< SDRAM device configuration parameters *//*!< Register base address                 *//* USE_HAL_SDRAM_REGISTER_CALLBACKS  *//**
  * @brief  SDRAM handle Structure definition
  *//*!< SDRAM device precharged               *//*!< SDRAM device write protected          *//*!< SDRAM error state                     *//*!< SDRAM internal process is ongoing     *//*!< SDRAM initialized and ready for use   *//*!< SDRAM not yet initialized or disabled *//**
  * @brief  HAL SDRAM State structure definition
  *//** @defgroup SDRAM_Exported_Types SDRAM Exported Types
  * @{
  *//** @addtogroup SDRAM
  * @{
  *//**
  ******************************************************************************
  * @file    stm32f7xx_hal_sdram.h
  * @author  MCD Application Team
  * @brief   Header file of SDRAM HAL module.
  ******************************************************************************
  * @attention
  *
  * Copyright (c) 2017 STMicroelectronics.
  * All rights reserved.
  *
  * This software is licensed under terms that can be found in the LICENSE file
  * in the root directory of this software component.
  * If no LICENSE file comes with this software, it is provided AS-IS.
  *
  ******************************************************************************
  */HAL_I2CEx_DisableFastModePlusHAL_I2CEx_EnableFastModePlusIS_I2C_FASTMODEPLUS(__CONFIG__)((((__CONFIG__) & I2C_FASTMODEPLUS_PB6) == I2C_FASTMODEPLUS_PB6) || (((__CONFIG__) & I2C_FASTMODEPLUS_PB7) == I2C_FASTMODEPLUS_PB7) || (((__CONFIG__) & I2C_FASTMODEPLUS_PB8) == I2C_FASTMODEPLUS_PB8) || (((__CONFIG__) & I2C_FASTMODEPLUS_PB9) == I2C_FASTMODEPLUS_PB9) || (((__CONFIG__) & I2C_FASTMODEPLUS_I2C1) == I2C_FASTMODEPLUS_I2C1) || (((__CONFIG__) & I2C_FASTMODEPLUS_I2C2) == I2C_FASTMODEPLUS_I2C2) || (((__CONFIG__) & I2C_FASTMODEPLUS_I2C3) == I2C_FASTMODEPLUS_I2C3) || (((__CONFIG__) & I2C_FASTMODEPLUS_I2C4) == I2C_FASTMODEPLUS_I2C4))IS_I2C_DIGITAL_FILTER(FILTER)((FILTER) <= 0x0000000FU)IS_I2C_ANALOG_FILTER(FILTER)(((FILTER) == I2C_ANALOGFILTER_ENABLE) || ((FILTER) == I2C_ANALOGFILTER_DISABLE))I2C_FASTMODEPLUS_I2C4I2C_FMP_NOT_SUPPORTED0xAAAA0000USTM32F7xx_HAL_I2C_EX_Hdefined(SYSCFG_PMC_I2C_PB6_FMP)defined(SYSCFG_PMC_I2C_PB8_FMP)defined(SYSCFG_PMC_I2C1_FMP)defined(SYSCFG_PMC_I2C2_FMP)defined(SYSCFG_PMC_I2C3_FMP)defined(SYSCFG_PMC_I2C4_FMP)(defined(SYSCFG_PMC_I2C_PB6_FMP) || defined(SYSCFG_PMC_I2C_PB7_FMP)) || (defined(SYSCFG_PMC_I2C_PB8_FMP) || defined(SYSCFG_PMC_I2C_PB9_FMP)) || (defined(SYSCFG_PMC_I2C1_FMP)) || (defined(SYSCFG_PMC_I2C2_FMP)) || defined(SYSCFG_PMC_I2C3_FMP) || defined(SYSCFG_PMC_I2C4_FMP)/* STM32F7xx_HAL_I2C_EX_H *//* Private functions are defined in stm32f7xx_hal_i2c_ex.c file *//** @defgroup I2CEx_Private_Functions I2C Extended Private Functions
  * @{
  *//* Private Functions ---------------------------------------------------------*//* SYSCFG_PMC_I2C1_FMP && SYSCFG_PMC_I2C2_FMP && SYSCFG_PMC_I2C3_FMP && SYSCFG_PMC_I2C4_FMP *//** @defgroup I2CEx_Private_Macro I2C Extended Private Macros
  * @{
  *//** @defgroup I2CEx_Private_Constants I2C Extended Private Constants
  * @{
  *//* Fast Mode Plus Availability *//** @addtogroup I2CEx_Exported_Functions_Group3 Fast Mode Plus Functions
  * @{
  *//** @addtogroup I2CEx_Exported_Functions_Group1 Filter Mode Functions
  * @{
  *//** @addtogroup I2CEx_Exported_Functions I2C Extended Exported Functions
  * @{
  *//** @defgroup I2CEx_Exported_Macros I2C Extended Exported Macros
  * @{
  *//* SYSCFG_PMC_I2C4_FMP *//*!< Fast Mode Plus I2C4 not supported  *//*!< Enable Fast Mode Plus on I2C4 pins *//* SYSCFG_PMC_I2C3_FMP *//*!< Fast Mode Plus I2C3 not supported  *//*!< Enable Fast Mode Plus on I2C3 pins *//* SYSCFG_PMC_I2C2_FMP *//*!< Fast Mode Plus I2C2 not supported  *//*!< Enable Fast Mode Plus on I2C2 pins *//* SYSCFG_PMC_I2C1_FMP *//*!< Fast Mode Plus I2C1 not supported  *//*!< Enable Fast Mode Plus on I2C1 pins *//* SYSCFG_PMC_I2C_PB8_FMP *//*!< Fast Mode Plus PB9 not supported   *//*!< Fast Mode Plus PB8 not supported   *//*!< Enable Fast Mode Plus on PB9       *//*!< Enable Fast Mode Plus on PB8       *//* SYSCFG_PMC_I2C_PB6_FMP *//*!< Fast Mode Plus PB7 not supported   *//*!< Fast Mode Plus PB6 not supported   *//*!< Enable Fast Mode Plus on PB7       *//*!< Enable Fast Mode Plus on PB6       *//*!< Fast Mode Plus not supported       *//** @defgroup I2CEx_FastModePlus I2C Extended Fast Mode Plus
  * @{
  *//** @defgroup I2CEx_Analog_Filter I2C Extended Analog Filter
  * @{
  *//** @defgroup I2CEx_Exported_Constants I2C Extended Exported Constants
  * @{
  *//** @addtogroup I2CEx
  * @{
  *//**
  ******************************************************************************
  * @file    stm32f7xx_hal_i2c_ex.h
  * @author  MCD Application Team
  * @brief   Header file of I2C HAL Extended module.
  ******************************************************************************
  * @attention
  *
  * Copyright (c) 2017 STMicroelectronics.
  * All rights reserved.
  *
  * This software is licensed under terms that can be found in the LICENSE file
  * in the root directory of this software component.
  * If no LICENSE file comes with this software, it is provided AS-IS.
  *
  ******************************************************************************
  */ConfigFastModePlushi2cDigitalFilterAnalogFilter"stm32f7xx_hal_i2c_ex.h"HAL_I2C_GetErrorHAL_I2C_GetModeHAL_I2C_GetStateHAL_I2C_AbortCpltCallbackHAL_I2C_ErrorCallbackHAL_I2C_MemRxCpltCallbackHAL_I2C_MemTxCpltCallbackHAL_I2C_ListenCpltCallbackHAL_I2C_AddrCallbackHAL_I2C_SlaveRxCpltCallbackHAL_I2C_SlaveTxCpltCallbackHAL_I2C_MasterRxCpltCallbackHAL_I2C_MasterTxCpltCallbackHAL_I2C_ER_IRQHandlerHAL_I2C_EV_IRQHandlerHAL_I2C_Mem_Read_DMAHAL_I2C_Mem_Write_DMAHAL_I2C_Slave_Receive_DMAHAL_I2C_Slave_Transmit_DMAHAL_I2C_Master_Receive_DMAHAL_I2C_Master_Transmit_DMAHAL_I2C_Master_Abort_ITHAL_I2C_DisableListen_ITHAL_I2C_EnableListen_ITHAL_I2C_Mem_Read_ITHAL_I2C_Mem_Write_ITHAL_I2C_Slave_Receive_ITHAL_I2C_Slave_Transmit_ITHAL_I2C_Master_Receive_ITHAL_I2C_Master_Transmit_ITHAL_I2C_IsDeviceReadyHAL_I2C_Mem_ReadHAL_I2C_Mem_WriteHAL_I2C_Slave_ReceiveHAL_I2C_Slave_TransmitHAL_I2C_Master_ReceiveHAL_I2C_Master_TransmitHAL_I2C_MspDeInitHAL_I2C_MspInitHAL_I2C_DeInitHAL_I2C_InitI2C_HandleTypeDef__I2C_HandleTypeDefHAL_I2C_ModeTypeDefHAL_I2C_MODE_NONEHAL_I2C_MODE_MASTER0x10UHAL_I2C_MODE_SLAVE0x20UHAL_I2C_MODE_MEM0x40UHAL_I2C_StateTypeDefHAL_I2C_STATE_READYHAL_I2C_STATE_BUSY0x24U0x21U0x22UHAL_I2C_STATE_LISTEN0x28UHAL_I2C_STATE_BUSY_TX_LISTEN0x29UHAL_I2C_STATE_BUSY_RX_LISTEN0x2AUHAL_I2C_STATE_ABORT0x60UI2C_InitTypeDefMemaddressDevaddressAddrEventCountvolatile HAL_I2C_ModeTypeDefvolatile HAL_I2C_StateTypeDefXferISRPreviousStateXferOptionsNoStretchModeGeneralCallModeOwnAddress2MasksOwnAddress2DualAddressModeAddressingModeOwnAddress1I2C_CHECK_IT_SOURCE(__CR1__,__IT__)((((__CR1__) & (__IT__)) == (__IT__)) ? SET : RESET)I2C_CHECK_FLAG(__ISR__,__FLAG__)((((__ISR__) & ((__FLAG__) & I2C_FLAG_MASK)) == ((__FLAG__) & I2C_FLAG_MASK)) ? SET : RESET)I2C_GENERATE_START(__ADDMODE__,__ADDRESS__)(((__ADDMODE__) == I2C_ADDRESSINGMODE_7BIT) ? (uint32_t)((((uint32_t)(__ADDRESS__) & (I2C_CR2_SADD)) | (I2C_CR2_START) | (I2C_CR2_AUTOEND)) & (~I2C_CR2_RD_WRN)) : (uint32_t)((((uint32_t)(__ADDRESS__) & (I2C_CR2_SADD)) | (I2C_CR2_ADD10) | (I2C_CR2_START) | (I2C_CR2_AUTOEND)) & (~I2C_CR2_RD_WRN)))I2C_MEM_ADD_LSB(__ADDRESS__)((uint8_t)((uint16_t)((__ADDRESS__) & (uint16_t)(0x00FFU))))I2C_MEM_ADD_MSB(__ADDRESS__)((uint8_t)((uint16_t)(((uint16_t)((__ADDRESS__) & (uint16_t)(0xFF00U))) >> 8U)))IS_I2C_OWN_ADDRESS2(ADDRESS2)((ADDRESS2) <= (uint16_t)0x00FFU)IS_I2C_OWN_ADDRESS1(ADDRESS1)((ADDRESS1) <= 0x000003FFU)I2C_GET_OWN_ADDRESS2(__HANDLE__)((uint16_t)((__HANDLE__)->Instance->OAR2 & I2C_OAR2_OA2))I2C_GET_OWN_ADDRESS1(__HANDLE__)((uint16_t)((__HANDLE__)->Instance->OAR1 & I2C_OAR1_OA1))I2C_GET_STOP_MODE(__HANDLE__)((__HANDLE__)->Instance->CR2 & I2C_CR2_AUTOEND)I2C_GET_DIR(__HANDLE__)((uint8_t)(((__HANDLE__)->Instance->ISR & I2C_ISR_DIR) >> 16U))I2C_GET_ADDR_MATCH(__HANDLE__)((uint16_t)(((__HANDLE__)->Instance->ISR & I2C_ISR_ADDCODE) >> 16U))I2C_RESET_CR2(__HANDLE__)((__HANDLE__)->Instance->CR2 &= (uint32_t)~((uint32_t)(I2C_CR2_SADD | I2C_CR2_HEAD10R | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_RD_WRN)))IS_I2C_TRANSFER_OTHER_OPTIONS_REQUEST(REQUEST)(((REQUEST) == I2C_OTHER_FRAME) || ((REQUEST) == I2C_OTHER_AND_LAST_FRAME))IS_I2C_TRANSFER_OPTIONS_REQUEST(REQUEST)(((REQUEST) == I2C_FIRST_FRAME) || ((REQUEST) == I2C_FIRST_AND_NEXT_FRAME) || ((REQUEST) == I2C_NEXT_FRAME) || ((REQUEST) == I2C_FIRST_AND_LAST_FRAME) || ((REQUEST) == I2C_LAST_FRAME) || ((REQUEST) == I2C_LAST_FRAME_NO_STOP) || IS_I2C_TRANSFER_OTHER_OPTIONS_REQUEST(REQUEST))IS_TRANSFER_REQUEST(REQUEST)(((REQUEST) == I2C_GENERATE_STOP) || ((REQUEST) == I2C_GENERATE_START_READ) || ((REQUEST) == I2C_GENERATE_START_WRITE) || ((REQUEST) == I2C_NO_STARTSTOP))IS_TRANSFER_MODE(MODE)(((MODE) == I2C_RELOAD_MODE) || ((MODE) == I2C_AUTOEND_MODE) || ((MODE) == I2C_SOFTEND_MODE))IS_I2C_MEMADD_SIZE(SIZE)(((SIZE) == I2C_MEMADD_SIZE_8BIT) || ((SIZE) == I2C_MEMADD_SIZE_16BIT))IS_I2C_NO_STRETCH(STRETCH)(((STRETCH) == I2C_NOSTRETCH_DISABLE) || ((STRETCH) == I2C_NOSTRETCH_ENABLE))IS_I2C_GENERAL_CALL(CALL)(((CALL) == I2C_GENERALCALL_DISABLE) || ((CALL) == I2C_GENERALCALL_ENABLE))IS_I2C_OWN_ADDRESS2_MASK(MASK)(((MASK) == I2C_OA2_NOMASK) || ((MASK) == I2C_OA2_MASK01) || ((MASK) == I2C_OA2_MASK02) || ((MASK) == I2C_OA2_MASK03) || ((MASK) == I2C_OA2_MASK04) || ((MASK) == I2C_OA2_MASK05) || ((MASK) == I2C_OA2_MASK06) || ((MASK) == I2C_OA2_MASK07))IS_I2C_DUAL_ADDRESS(ADDRESS)(((ADDRESS) == I2C_DUALADDRESS_DISABLE) || ((ADDRESS) == I2C_DUALADDRESS_ENABLE))IS_I2C_ADDRESSING_MODE(MODE)(((MODE) == I2C_ADDRESSINGMODE_7BIT) || ((MODE) == I2C_ADDRESSINGMODE_10BIT))__HAL_I2C_GENERATE_NACK(__HANDLE__)(SET_BIT((__HANDLE__)->Instance->CR2, I2C_CR2_NACK))__HAL_I2C_DISABLE(__HANDLE__)(CLEAR_BIT((__HANDLE__)->Instance->CR1, I2C_CR1_PE))__HAL_I2C_ENABLE(__HANDLE__)(SET_BIT((__HANDLE__)->Instance->CR1, I2C_CR1_PE))__HAL_I2C_CLEAR_FLAG(__HANDLE__,__FLAG__)(((__FLAG__) == I2C_FLAG_TXE) ? ((__HANDLE__)->Instance->ISR |= (__FLAG__)) : ((__HANDLE__)->Instance->ICR = (__FLAG__)))__HAL_I2C_GET_FLAG(__HANDLE__,__FLAG__)(((((__HANDLE__)->Instance->ISR) & (__FLAG__)) == (__FLAG__)) ? SET : RESET)I2C_FLAG_MASK(0x0001FFFFU)__HAL_I2C_GET_IT_SOURCE(__HANDLE__,__INTERRUPT__)((((__HANDLE__)->Instance->CR1 & (__INTERRUPT__)) == (__INTERRUPT__)) ? SET : RESET)__HAL_I2C_DISABLE_IT(__HANDLE__,__INTERRUPT__)((__HANDLE__)->Instance->CR1 &= (~(__INTERRUPT__)))__HAL_I2C_ENABLE_IT(__HANDLE__,__INTERRUPT__)((__HANDLE__)->Instance->CR1 |= (__INTERRUPT__))__HAL_I2C_RESET_HANDLE_STATE(__HANDLE__)((__HANDLE__)->State = HAL_I2C_STATE_RESET)I2C_FLAG_DIRI2C_FLAG_BUSYI2C_FLAG_ALERTI2C_FLAG_TIMEOUTI2C_FLAG_PECERRI2C_FLAG_OVRI2C_FLAG_ARLOI2C_FLAG_BERRI2C_FLAG_TCRI2C_FLAG_TCI2C_FLAG_STOPFI2C_FLAG_AFI2C_FLAG_ADDRI2C_FLAG_RXNEI2C_FLAG_TXISI2C_FLAG_TXEI2C_IT_TXII2C_IT_RXII2C_IT_ADDRII2C_IT_NACKII2C_IT_STOPII2C_IT_TCII2C_IT_ERRII2C_GENERATE_START_WRITE(uint32_t)(0x80000000U | I2C_CR2_START)I2C_GENERATE_START_READ(uint32_t)(0x80000000U | I2C_CR2_START | I2C_CR2_RD_WRN)I2C_GENERATE_STOP(uint32_t)(0x80000000U | I2C_CR2_STOP)I2C_NO_STARTSTOPI2C_SOFTEND_MODEI2C_AUTOEND_MODEI2C_RELOAD_MODEI2C_DIRECTION_RECEIVEI2C_DIRECTION_TRANSMITI2C_OA2_MASK07I2C_OA2_MASK06I2C_OA2_MASK05I2C_OA2_MASK04I2C_OA2_MASK03I2C_OA2_MASK02I2C_OA2_MASK01I2C_OA2_NOMASKI2C_ADDRESSINGMODE_10BITI2C_OTHER_AND_LAST_FRAME(0x0000AA00U)I2C_OTHER_FRAME(0x000000AAU)I2C_LAST_FRAME_NO_STOP((uint32_t)I2C_SOFTEND_MODE)I2C_LAST_FRAME((uint32_t)I2C_AUTOEND_MODE)I2C_FIRST_AND_LAST_FRAMEI2C_NEXT_FRAME((uint32_t)(I2C_RELOAD_MODE | I2C_SOFTEND_MODE))I2C_FIRST_AND_NEXT_FRAMEI2C_FIRST_FRAMEHAL_I2C_ERROR_INVALID_PARAMHAL_I2C_ERROR_DMA_PARAMHAL_I2C_ERROR_SIZEHAL_I2C_ERROR_TIMEOUTHAL_I2C_ERROR_DMAHAL_I2C_ERROR_OVRHAL_I2C_ERROR_AFHAL_I2C_ERROR_ARLOHAL_I2C_ERROR_BERRHAL_I2C_ERROR_NONESTM32F7xx_HAL_I2C_H(USE_HAL_I2C_REGISTER_CALLBACKS == 1)/* STM32F7xx_HAL_I2C_H *//* Private functions are defined in stm32f7xx_hal_i2c.c file *//** @defgroup I2C_Private_Functions I2C Private Functions
  * @{
  *//** @defgroup I2C_Private_Macro I2C Private Macros
  * @{
  *//** @defgroup I2C_Private_Constants I2C Private Constants
  * @{
  *//* Peripheral State, Mode and Error functions  *********************************//** @addtogroup I2C_Exported_Functions_Group3 Peripheral State, Mode and Error functions
  * @{
  *//******* I2C IRQHandler and Callbacks used in non blocking modes (Interrupt and DMA) *//** @addtogroup I2C_IRQ_Handler_and_Callbacks IRQ Handler and Callbacks
  * @{
  *//******* Non-Blocking mode: DMA *//******* Non-Blocking mode: Interrupt *//******* Blocking mode: Polling *//* IO operation functions  ****************************************************//** @addtogroup I2C_Exported_Functions_Group2 Input and Output operation functions
  * @{
  *//* USE_HAL_I2C_REGISTER_CALLBACKS *//* Initialization and de-initialization functions******************************//** @addtogroup I2C_Exported_Functions_Group1 Initialization and de-initialization functions
  * @{
  *//** @addtogroup I2C_Exported_Functions
  * @{
  *//* Include I2C HAL Extended module *//** @brief  Generate a Non-Acknowledge I2C peripheral in Slave mode.
  * @param  __HANDLE__ specifies the I2C Handle.
  * @retval None
  *//** @brief  Disable the specified I2C peripheral.
  * @param  __HANDLE__ specifies the I2C Handle.
  * @retval None
  *//** @brief  Enable the specified I2C peripheral.
  * @param  __HANDLE__ specifies the I2C Handle.
  * @retval None
  *//** @brief  Clear the I2C pending flags which are cleared by writing 1 in a specific bit.
  * @param  __HANDLE__ specifies the I2C Handle.
  * @param  __FLAG__ specifies the flag to clear.
  *          This parameter can be any combination of the following values:
  *            @arg @ref I2C_FLAG_TXE     Transmit data register empty
  *            @arg @ref I2C_FLAG_ADDR    Address matched (slave mode)
  *            @arg @ref I2C_FLAG_AF      Acknowledge failure received flag
  *            @arg @ref I2C_FLAG_STOPF   STOP detection flag
  *            @arg @ref I2C_FLAG_BERR    Bus error
  *            @arg @ref I2C_FLAG_ARLO    Arbitration lost
  *            @arg @ref I2C_FLAG_OVR     Overrun/Underrun
  *            @arg @ref I2C_FLAG_PECERR  PEC error in reception
  *            @arg @ref I2C_FLAG_TIMEOUT Timeout or Tlow detection flag
  *            @arg @ref I2C_FLAG_ALERT   SMBus alert
  *
  * @retval None
  *//** @brief  Check whether the specified I2C flag is set or not.
  * @param  __HANDLE__ specifies the I2C Handle.
  * @param  __FLAG__ specifies the flag to check.
  *        This parameter can be one of the following values:
  *            @arg @ref I2C_FLAG_TXE     Transmit data register empty
  *            @arg @ref I2C_FLAG_TXIS    Transmit interrupt status
  *            @arg @ref I2C_FLAG_RXNE    Receive data register not empty
  *            @arg @ref I2C_FLAG_ADDR    Address matched (slave mode)
  *            @arg @ref I2C_FLAG_AF      Acknowledge failure received flag
  *            @arg @ref I2C_FLAG_STOPF   STOP detection flag
  *            @arg @ref I2C_FLAG_TC      Transfer complete (master mode)
  *            @arg @ref I2C_FLAG_TCR     Transfer complete reload
  *            @arg @ref I2C_FLAG_BERR    Bus error
  *            @arg @ref I2C_FLAG_ARLO    Arbitration lost
  *            @arg @ref I2C_FLAG_OVR     Overrun/Underrun
  *            @arg @ref I2C_FLAG_PECERR  PEC error in reception
  *            @arg @ref I2C_FLAG_TIMEOUT Timeout or Tlow detection flag
  *            @arg @ref I2C_FLAG_ALERT   SMBus alert
  *            @arg @ref I2C_FLAG_BUSY    Bus busy
  *            @arg @ref I2C_FLAG_DIR     Transfer direction (slave mode)
  *
  * @retval The new state of __FLAG__ (SET or RESET).
  *//** @brief  Check whether the specified I2C interrupt source is enabled or not.
  * @param  __HANDLE__ specifies the I2C Handle.
  * @param  __INTERRUPT__ specifies the I2C interrupt source to check.
  *          This parameter can be one of the following values:
  *            @arg @ref I2C_IT_ERRI  Errors interrupt enable
  *            @arg @ref I2C_IT_TCI   Transfer complete interrupt enable
  *            @arg @ref I2C_IT_STOPI STOP detection interrupt enable
  *            @arg @ref I2C_IT_NACKI NACK received interrupt enable
  *            @arg @ref I2C_IT_ADDRI Address match interrupt enable
  *            @arg @ref I2C_IT_RXI   RX interrupt enable
  *            @arg @ref I2C_IT_TXI   TX interrupt enable
  *
  * @retval The new state of __INTERRUPT__ (SET or RESET).
  *//** @brief  Disable the specified I2C interrupt.
  * @param  __HANDLE__ specifies the I2C Handle.
  * @param  __INTERRUPT__ specifies the interrupt source to disable.
  *        This parameter can be one of the following values:
  *            @arg @ref I2C_IT_ERRI  Errors interrupt enable
  *            @arg @ref I2C_IT_TCI   Transfer complete interrupt enable
  *            @arg @ref I2C_IT_STOPI STOP detection interrupt enable
  *            @arg @ref I2C_IT_NACKI NACK received interrupt enable
  *            @arg @ref I2C_IT_ADDRI Address match interrupt enable
  *            @arg @ref I2C_IT_RXI   RX interrupt enable
  *            @arg @ref I2C_IT_TXI   TX interrupt enable
  *
  * @retval None
  *//** @brief  Enable the specified I2C interrupt.
  * @param  __HANDLE__ specifies the I2C Handle.
  * @param  __INTERRUPT__ specifies the interrupt source to enable.
  *        This parameter can be one of the following values:
  *            @arg @ref I2C_IT_ERRI  Errors interrupt enable
  *            @arg @ref I2C_IT_TCI   Transfer complete interrupt enable
  *            @arg @ref I2C_IT_STOPI STOP detection interrupt enable
  *            @arg @ref I2C_IT_NACKI NACK received interrupt enable
  *            @arg @ref I2C_IT_ADDRI Address match interrupt enable
  *            @arg @ref I2C_IT_RXI   RX interrupt enable
  *            @arg @ref I2C_IT_TXI   TX interrupt enable
  *
  * @retval None
  *//** @brief Reset I2C handle state.
  * @param  __HANDLE__ specifies the I2C Handle.
  * @retval None
  *//** @defgroup I2C_Exported_Macros I2C Exported Macros
  * @{
  *//* Exported macros -----------------------------------------------------------*//** @defgroup I2C_Flag_definition I2C Flag definition
  * @{
  *//** @defgroup I2C_Interrupt_configuration_definition I2C Interrupt configuration definition
  * @brief I2C Interrupt definition
  *        Elements values convention: 0xXXXXXXXX
  *           - XXXXXXXX  : Interrupt control mask
  * @{
  *//** @defgroup I2C_START_STOP_MODE I2C Start or Stop Mode
  * @{
  *//** @defgroup I2C_RELOAD_END_MODE I2C Reload End Mode
  * @{
  *//** @defgroup I2C_XFERDIRECTION I2C Transfer Direction Master Point of View
  * @{
  *//** @defgroup I2C_MEMORY_ADDRESS_SIZE I2C Memory Address Size
  * @{
  *//** @defgroup I2C_NOSTRETCH_MODE I2C No-Stretch Mode
  * @{
  *//** @defgroup I2C_GENERAL_CALL_ADDRESSING_MODE I2C General Call Addressing Mode
  * @{
  *//** @defgroup I2C_OWN_ADDRESS2_MASKS I2C Own Address2 Masks
  * @{
  *//** @defgroup I2C_DUAL_ADDRESSING_MODE I2C Dual Addressing Mode
  * @{
  *//** @defgroup I2C_ADDRESSING_MODE I2C Addressing Mode
  * @{
  *//* List of XferOptions in usage of :
 * 1- Restart condition in all use cases (direction change or not)
 *//** @defgroup I2C_XFEROPTIONS  I2C Sequential Transfer Options
  * @{
  *//** @defgroup I2C_Exported_Constants I2C Exported Constants
  * @{
  *//*!< pointer to an I2C Address Match callback function *//*!< pointer to an I2C callback function *//**
  * @brief  HAL I2C Callback pointer definition
  *//*!< I2C Msp DeInit callback ID                    *//*!< I2C Msp Init callback ID                      *//*!< I2C Abort callback ID                         *//*!< I2C Error callback ID                         *//*!< I2C Memory Rx Transfer completed callback ID  *//*!< I2C Memory Tx Transfer callback ID            *//*!< I2C Listen Complete callback ID               *//*!< I2C Slave Rx Transfer completed callback ID   *//*!< I2C Slave Tx Transfer completed callback ID   *//*!< I2C Master Rx Transfer completed callback ID  *//*!< I2C Master Tx Transfer completed callback ID  *//**
  * @brief  HAL I2C Callback ID enumeration definition
  *//*!< I2C Msp DeInit callback                   *//*!< I2C Msp Init callback                     *//*!< I2C Slave Address Match callback *//*!< I2C Abort callback                        *//*!< I2C Error callback                        *//*!< I2C Memory Rx Transfer completed callback *//*!< I2C Memory Tx Transfer completed callback *//*!< I2C Listen Complete callback              *//*!< I2C Slave Rx Transfer completed callback  *//*!< I2C Slave Tx Transfer completed callback  *//*!< I2C Master Rx Transfer completed callback *//*!< I2C Master Tx Transfer completed callback *//*!< I2C Target memory address                 *//*!< I2C Target device address                 *//*!< I2C Address Event counter                 *//*!< I2C Error code                            *//*!< I2C communication mode                    *//*!< I2C communication state                   *//*!< I2C locking object                        *//*!< I2C Rx DMA handle parameters              *//*!< I2C Tx DMA handle parameters              *//*!< I2C transfer IRQ handler function pointer *//*!< I2C communication Previous state          *//*!< I2C sequantial transfer options, this parameter can
                                                  be a value of @ref I2C_XFEROPTIONS *//*!< I2C transfer counter                      *//*!< I2C transfer size                         *//*!< Pointer to I2C transfer buffer            *//*!< I2C communication parameters              *//*!< I2C registers base address                *//** @defgroup I2C_handle_Structure_definition I2C handle Structure definition
  * @brief  I2C handle Structure definition
  * @{
  *//*!< Invalid Parameters error  *//*!< DMA Parameter Error   *//*!< Size Management error *//*!< DMA transfer error    *//*!< OVR error             *//*!< ACKF error            *//*!< ARLO error            *//*!< BERR error            *//** @defgroup I2C_Error_Code_definition I2C Error Code definition
  * @brief  I2C Error Code definition
  * @{
  *//*!< I2C communication is in Memory Mode       *//*!< I2C communication is in Slave Mode        *//*!< I2C communication is in Master Mode       *//*!< No I2C communication on going             *//** @defgroup HAL_mode_structure_definition HAL mode structure definition
  * @brief  HAL Mode structure definition
  * @note  HAL I2C Mode value coding follow below described bitmap :\n
  *          b7     (not used)\n
  *             x  : Should be set to 0\n
  *          b6\n
  *             0  : None\n
  *             1  : Memory (HAL I2C communication is in Memory Mode)\n
  *          b5\n
  *             0  : None\n
  *             1  : Slave (HAL I2C communication is in Slave Mode)\n
  *          b4\n
  *             0  : None\n
  *             1  : Master (HAL I2C communication is in Master Mode)\n
  *          b3-b2-b1-b0  (not used)\n
  *             xxxx : Should be set to 0000
  * @{
  *//*!< Abort user request ongoing                *//*!< Address Listen Mode and Data Reception
                                                 process is ongoing                         *//*!< Address Listen Mode and Data Transmission
                                                 process is ongoing                         *//*!< Address Listen Mode is ongoing            *//*!< Data Reception process is ongoing         *//*!< Data Transmission process is ongoing      *//*!< An internal process is ongoing            *//*!< Peripheral Initialized and ready for use  *//*!< Peripheral is not yet Initialized         *//** @defgroup HAL_state_structure_definition HAL state structure definition
  * @brief  HAL State structure definition
  * @note  HAL I2C State value coding follow below described bitmap :\n
  *          b7-b6  Error information\n
  *             00 : No Error\n
  *             01 : Abort (Abort user request on going)\n
  *             10 : Timeout\n
  *             11 : Error\n
  *          b5     Peripheral initialization status\n
  *             0  : Reset (peripheral not initialized)\n
  *             1  : Init done (peripheral initialized and ready to use. HAL I2C Init function called)\n
  *          b4     (not used)\n
  *             x  : Should be set to 0\n
  *          b3\n
  *             0  : Ready or Busy (No Listen mode ongoing)\n
  *             1  : Listen (peripheral in Address Listen Mode)\n
  *          b2     Intrinsic process state\n
  *             0  : Ready\n
  *             1  : Busy (peripheral busy with some configuration or internal operations)\n
  *          b1     Rx state\n
  *             0  : Ready (no Rx operation ongoing)\n
  *             1  : Busy (Rx operation ongoing)\n
  *          b0     Tx state\n
  *             0  : Ready (no Tx operation ongoing)\n
  *             1  : Busy (Tx operation ongoing)
  * @{
  *//*!< Specifies if nostretch mode is selected.
                                     This parameter can be a value of @ref I2C_NOSTRETCH_MODE *//*!< Specifies if general call mode is selected.
                                     This parameter can be a value of @ref I2C_GENERAL_CALL_ADDRESSING_MODE *//*!< Specifies the acknowledge mask address second device own address if dual addressing
                                     mode is selected.
                                     This parameter can be a value of @ref I2C_OWN_ADDRESS2_MASKS *//*!< Specifies the second device own address if dual addressing mode is selected
                                     This parameter can be a 7-bit address. *//*!< Specifies if dual addressing mode is selected.
                                     This parameter can be a value of @ref I2C_DUAL_ADDRESSING_MODE *//*!< Specifies if 7-bit or 10-bit addressing mode is selected.
                                     This parameter can be a value of @ref I2C_ADDRESSING_MODE *//*!< Specifies the first device own address.
                                     This parameter can be a 7-bit or 10-bit address. *//*!< Specifies the I2C_TIMINGR_register value.
                                     This parameter calculated by referring to I2C initialization section
                                     in Reference manual *//** @defgroup I2C_Configuration_Structure_definition I2C Configuration Structure definition
  * @brief  I2C Configuration Structure definition
  * @{
  *//** @defgroup I2C_Exported_Types I2C Exported Types
  * @{
  *//** @addtogroup I2C
  * @{
  *//**
  ******************************************************************************
  * @file    stm32f7xx_hal_i2c.h
  * @author  MCD Application Team
  * @brief   Header file of I2C HAL module.
  ******************************************************************************
  * @attention
  *
  * Copyright (c) 2017 STMicroelectronics.
  * All rights reserved.
  *
  * This software is licensed under terms that can be found in the LICENSE file
  * in the root directory of this software component.
  * If no LICENSE file comes with this software, it is provided AS-IS.
  *
  ******************************************************************************
  */TransferDirectionAddrMatchCodeHAL_DSI_GetStateconst DSI_HandleTypeDefconst DSI_HandleTypeDef *HAL_DSI_GetErrorHAL_DSI_SetContentionDetectionOffHAL_DSI_SetPullDownHAL_DSI_ForceDataLanesInRXHAL_DSI_ForceRXLowPowerHAL_DSI_ForceTXStopModeHAL_DSI_SetPHYTimingsHAL_DSI_SetLanePinsConfigurationHAL_DSI_SetSDDHAL_DSI_SetLowPowerRXFilterHAL_DSI_SetSlewRateAndDelayTuningHAL_DSI_PatternGeneratorStopHAL_DSI_PatternGeneratorStartHAL_DSI_ExitULPMHAL_DSI_EnterULPMHAL_DSI_ExitULPMDataHAL_DSI_EnterULPMDataHAL_DSI_ReadHAL_DSI_LongWriteHAL_DSI_ShortWriteHAL_DSI_ShutdownHAL_DSI_ColorModeHAL_DSI_RefreshHAL_DSI_StopHAL_DSI_StartHAL_DSI_ConfigHostTimeoutsDSI_HOST_TimeoutTypeDef *HAL_DSI_ConfigPhyTimerDSI_PHY_TimerTypeDef *HAL_DSI_ConfigFlowControlHAL_DSI_ConfigCommandDSI_LPCmdTypeDef *HAL_DSI_ConfigAdaptedCommandModeDSI_CmdCfgTypeDef *HAL_DSI_ConfigVideoModeHAL_DSI_SetGenericVCIDHAL_DSI_ErrorCallbackHAL_DSI_EndOfRefreshCallbackHAL_DSI_TearingEffectCallbackHAL_DSI_IRQHandlerHAL_DSI_ConfigErrorMonitorHAL_DSI_MspDeInitHAL_DSI_MspInitHAL_DSI_DeInitHAL_DSI_InitDSI_HandleTypeDefHAL_DSI_StateTypeDefHAL_DSI_STATE_RESETHAL_DSI_STATE_READYHAL_DSI_STATE_ERRORHAL_DSI_STATE_BUSYHAL_DSI_STATE_TIMEOUTDSI_HOST_TimeoutTypeDefDSI_PHY_TimerTypeDefDSI_LPCmdTypeDefDSI_CmdCfgTypeDefDSI_VidCfgTypeDefDSI_PLLInitTypeDefDSI_InitTypeDefErrorMskvolatile HAL_DSI_StateTypeDefBTATimeoutLowPowerWriteTimeoutHighSpeedWritePrespModeHighSpeedWriteTimeoutLowPowerReadTimeoutHighSpeedReadTimeoutLowPowerReceptionTimeoutHighSpeedTransmissionTimeoutTimeoutCkdivStopWaitTimeDataLaneMaxReadTimeDataLaneLP2HSTimeDataLaneHS2LPTimeClockLaneLP2HSTimeClockLaneHS2LPTimeAcknowledgeRequestLPMaxReadPacketLPDcsLongWriteLPDcsShortReadNoPLPDcsShortWriteOnePLPDcsShortWriteNoPLPGenLongWriteLPGenShortReadTwoPLPGenShortReadOnePLPGenShortReadNoPLPGenShortWriteTwoPLPGenShortWriteOnePLPGenShortWriteNoPTEAcknowledgeRequestAutomaticRefreshVSyncPolDEPolarityTearingEffectPolarityTearingEffectSourceCommandSizeVirtualChannelIDFrameBTAAcknowledgeEnableLPVerticalSyncActiveEnableLPVerticalBackPorchEnableLPVerticalFrontPorchEnableLPVerticalActiveEnableLPHorizontalBackPorchEnableLPHorizontalFrontPorchEnableLPVACTLargestPacketSizeLPLargestPacketSizeLPCommandEnableVerticalActiveVerticalFrontPorchVerticalBackPorchVerticalSyncActiveHorizontalLineHorizontalBackPorchHorizontalSyncActiveNullPacketSizeNumberOfChunksPacketSizeLooselyPackedPLLODFPLLIDFPLLNDIVNumberOfLanesTXEscapeCkdivAutomaticClockLaneControlIS_DSI_PHY_TIMING(Timing)(((Timing) == DSI_TCLK_POST ) || ((Timing) == DSI_TLPX_CLK ) || ((Timing) == DSI_THS_EXIT ) || ((Timing) == DSI_TLPX_DATA ) || ((Timing) == DSI_THS_ZERO ) || ((Timing) == DSI_THS_TRAIL ) || ((Timing) == DSI_THS_PREPARE ) || ((Timing) == DSI_TCLK_ZERO ) || ((Timing) == DSI_TCLK_PREPARE))IS_DSI_LANE(Lane)(((Lane) == DSI_CLOCK_LANE) || ((Lane) == DSI_DATA_LANE0) || ((Lane) == DSI_DATA_LANE1))IS_DSI_CUSTOM_LANE(CustomLane)(((CustomLane) == DSI_SWAP_LANE_PINS) || ((CustomLane) == DSI_INVERT_HS_SIGNAL))IS_DSI_LANE_GROUP(Lane)(((Lane) == DSI_CLOCK_LANE) || ((Lane) == DSI_DATA_LANES))IS_DSI_COMMUNICATION_DELAY(CommDelay)(((CommDelay) == DSI_SLEW_RATE_HSTX) || ((CommDelay) == DSI_SLEW_RATE_LPTX) || ((CommDelay) == DSI_HS_DELAY))IS_DSI_READ_PACKET_TYPE(MODE)(((MODE) == DSI_DCS_SHORT_PKT_READ) || ((MODE) == DSI_GEN_SHORT_PKT_READ_P0) || ((MODE) == DSI_GEN_SHORT_PKT_READ_P1) || ((MODE) == DSI_GEN_SHORT_PKT_READ_P2))IS_DSI_LONG_WRITE_PACKET_TYPE(MODE)(((MODE) == DSI_DCS_LONG_PKT_WRITE) || ((MODE) == DSI_GEN_LONG_PKT_WRITE))IS_DSI_SHORT_WRITE_PACKET_TYPE(MODE)(((MODE) == DSI_DCS_SHORT_PKT_WRITE_P0) || ((MODE) == DSI_DCS_SHORT_PKT_WRITE_P1) || ((MODE) == DSI_GEN_SHORT_PKT_WRITE_P0) || ((MODE) == DSI_GEN_SHORT_PKT_WRITE_P1) || ((MODE) == DSI_GEN_SHORT_PKT_WRITE_P2))IS_DSI_LP_MRDP(LP_MRDP)(((LP_MRDP) == DSI_LP_MRDP_DISABLE) || ((LP_MRDP) == DSI_LP_MRDP_ENABLE))IS_DSI_LP_DLW(LP_DLW)(((LP_DLW) == DSI_LP_DLW_DISABLE) || ((LP_DLW) == DSI_LP_DLW_ENABLE))IS_DSI_LP_DSR0P(LP_DSR0P)(((LP_DSR0P) == DSI_LP_DSR0P_DISABLE) || ((LP_DSR0P) == DSI_LP_DSR0P_ENABLE))IS_DSI_LP_DSW1P(LP_DSW1P)(((LP_DSW1P) == DSI_LP_DSW1P_DISABLE) || ((LP_DSW1P) == DSI_LP_DSW1P_ENABLE))IS_DSI_LP_DSW0P(LP_DSW0P)(((LP_DSW0P) == DSI_LP_DSW0P_DISABLE) || ((LP_DSW0P) == DSI_LP_DSW0P_ENABLE))IS_DSI_LP_GLW(LP_GLW)(((LP_GLW) == DSI_LP_GLW_DISABLE) || ((LP_GLW) == DSI_LP_GLW_ENABLE))IS_DSI_LP_GSR2P(LP_GSR2P)(((LP_GSR2P) == DSI_LP_GSR2P_DISABLE) || ((LP_GSR2P) == DSI_LP_GSR2P_ENABLE))IS_DSI_LP_GSR1P(LP_GSR1P)(((LP_GSR1P) == DSI_LP_GSR1P_DISABLE) || ((LP_GSR1P) == DSI_LP_GSR1P_ENABLE))IS_DSI_LP_GSR0P(LP_GSR0P)(((LP_GSR0P) == DSI_LP_GSR0P_DISABLE) || ((LP_GSR0P) == DSI_LP_GSR0P_ENABLE))IS_DSI_LP_GSW2P(LP_GSW2P)(((LP_GSW2P) == DSI_LP_GSW2P_DISABLE) || ((LP_GSW2P) == DSI_LP_GSW2P_ENABLE))IS_DSI_LP_GSW1P(LP_GSW1P)(((LP_GSW1P) == DSI_LP_GSW1P_DISABLE) || ((LP_GSW1P) == DSI_LP_GSW1P_ENABLE))IS_DSI_LP_GSW0P(LP_GSW0P)(((LP_GSW0P) == DSI_LP_GSW0P_DISABLE) || ((LP_GSW0P) == DSI_LP_GSW0P_ENABLE))IS_DSI_ACK_REQUEST(AcknowledgeRequest)(((AcknowledgeRequest) == DSI_ACKNOWLEDGE_DISABLE) || ((AcknowledgeRequest) == DSI_ACKNOWLEDGE_ENABLE))IS_DSI_TE_ACK_REQUEST(TEAcknowledgeRequest)(((TEAcknowledgeRequest) == DSI_TE_ACKNOWLEDGE_DISABLE) || ((TEAcknowledgeRequest) == DSI_TE_ACKNOWLEDGE_ENABLE))IS_DSI_VS_POLARITY(VSPolarity)(((VSPolarity) == DSI_VSYNC_FALLING) || ((VSPolarity) == DSI_VSYNC_RISING))IS_DSI_AUTOMATIC_REFRESH(AutomaticRefresh)(((AutomaticRefresh) == DSI_AR_DISABLE) || ((AutomaticRefresh) == DSI_AR_ENABLE))IS_DSI_TE_POLARITY(TEPolarity)(((TEPolarity) == DSI_TE_RISING_EDGE) || ((TEPolarity) == DSI_TE_FALLING_EDGE))IS_DSI_TE_SOURCE(TESource)(((TESource) == DSI_TE_DSILINK) || ((TESource) == DSI_TE_EXTERNAL))IS_DSI_FBTAA(FrameBTAAcknowledge)(((FrameBTAAcknowledge) == DSI_FBTAA_DISABLE) || ((FrameBTAAcknowledge) == DSI_FBTAA_ENABLE))IS_DSI_LP_VSYNC(LPVSYNC)(((LPVSYNC) == DSI_LP_VSYNC_DISABLE) || ((LPVSYNC) == DSI_LP_VSYNC_ENABLE))IS_DSI_LP_VBP(LPVBP)(((LPVBP) == DSI_LP_VBP_DISABLE) || ((LPVBP) == DSI_LP_VBP_ENABLE))IS_DSI_LP_VFP(LPVFP)(((LPVFP) == DSI_LP_VFP_DISABLE) || ((LPVFP) == DSI_LP_VFP_ENABLE))IS_DSI_LP_VACTIVE(LPVActive)(((LPVActive) == DSI_LP_VACT_DISABLE) || ((LPVActive) == DSI_LP_VACT_ENABLE))IS_DSI_LP_HBP(LPHBP)(((LPHBP) == DSI_LP_HBP_DISABLE) || ((LPHBP) == DSI_LP_HBP_ENABLE))IS_DSI_LP_HFP(LPHFP)(((LPHFP) == DSI_LP_HFP_DISABLE) || ((LPHFP) == DSI_LP_HFP_ENABLE))IS_DSI_LP_COMMAND(LPCommand)(((LPCommand) == DSI_LP_COMMAND_DISABLE) || ((LPCommand) == DSI_LP_COMMAND_ENABLE))IS_DSI_SHUT_DOWN(ShutDown)(((ShutDown) == DSI_DISPLAY_ON) || ((ShutDown) == DSI_DISPLAY_OFF))IS_DSI_COLOR_MODE(ColorMode)(((ColorMode) == DSI_COLOR_MODE_FULL) || ((ColorMode) == DSI_COLOR_MODE_EIGHT))IS_DSI_VIDEO_MODE_TYPE(VideoModeType)(((VideoModeType) == DSI_VID_MODE_NB_PULSES) || ((VideoModeType) == DSI_VID_MODE_NB_EVENTS) || ((VideoModeType) == DSI_VID_MODE_BURST))IS_DSI_HSYNC_POLARITY(Hsync)(((Hsync) == DSI_HSYNC_ACTIVE_HIGH) || ((Hsync) == DSI_HSYNC_ACTIVE_LOW))IS_DSI_VSYNC_POLARITY(Vsync)(((Vsync) == DSI_VSYNC_ACTIVE_HIGH) || ((Vsync) == DSI_VSYNC_ACTIVE_LOW))IS_DSI_DE_POLARITY(DataEnable)(((DataEnable) == DSI_DATA_ENABLE_ACTIVE_HIGH) || ((DataEnable) == DSI_DATA_ENABLE_ACTIVE_LOW))IS_DSI_LOOSELY_PACKED(LooselyPacked)(((LooselyPacked) == DSI_LOOSELY_PACKED_ENABLE) || ((LooselyPacked) == DSI_LOOSELY_PACKED_DISABLE))IS_DSI_COLOR_CODING(ColorCoding)((ColorCoding) <= 5U)IS_DSI_FLOW_CONTROL(FlowControl)(((FlowControl) | DSI_FLOW_CONTROL_ALL) == DSI_FLOW_CONTROL_ALL)IS_DSI_NUMBER_OF_LANES(NumberOfLanes)(((NumberOfLanes) == DSI_ONE_DATA_LANE) || ((NumberOfLanes) == DSI_TWO_DATA_LANES))IS_DSI_AUTO_CLKLANE_CONTROL(AutoClkLane)(((AutoClkLane) == DSI_AUTO_CLK_LANE_CTRL_DISABLE) || ((AutoClkLane) == DSI_AUTO_CLK_LANE_CTRL_ENABLE))IS_DSI_PLL_ODF(ODF)(((ODF) == DSI_PLL_OUT_DIV1) || ((ODF) == DSI_PLL_OUT_DIV2) || ((ODF) == DSI_PLL_OUT_DIV4) || ((ODF) == DSI_PLL_OUT_DIV8))IS_DSI_PLL_IDF(IDF)(((IDF) == DSI_PLL_IN_DIV1) || ((IDF) == DSI_PLL_IN_DIV2) || ((IDF) == DSI_PLL_IN_DIV3) || ((IDF) == DSI_PLL_IN_DIV4) || ((IDF) == DSI_PLL_IN_DIV5) || ((IDF) == DSI_PLL_IN_DIV6) || ((IDF) == DSI_PLL_IN_DIV7))IS_DSI_PLL_NDIV(NDIV)((10U <= (NDIV)) && ((NDIV) <= 125U))DSI_MAX_RETURN_PKT_SIZE(0x00000037U)__HAL_DSI_GET_IT_SOURCE(__HANDLE__,__INTERRUPT__)((__HANDLE__)->Instance->WIER & (__INTERRUPT__))__HAL_DSI_DISABLE_IT(__HANDLE__,__INTERRUPT__)((__HANDLE__)->Instance->WIER &= ~(__INTERRUPT__))__HAL_DSI_ENABLE_IT(__HANDLE__,__INTERRUPT__)((__HANDLE__)->Instance->WIER |= (__INTERRUPT__))__HAL_DSI_CLEAR_FLAG(__HANDLE__,__FLAG__)((__HANDLE__)->Instance->WIFCR = (__FLAG__))__HAL_DSI_GET_FLAG(__HANDLE__,__FLAG__)((__HANDLE__)->Instance->WISR & (__FLAG__))__HAL_DSI_REG_DISABLE(__HANDLE__)do { __IO uint32_t tmpreg = 0x00U; CLEAR_BIT((__HANDLE__)->Instance->WRPCR, DSI_WRPCR_REGEN); tmpreg = READ_BIT((__HANDLE__)->Instance->WRPCR, DSI_WRPCR_REGEN); UNUSED(tmpreg); } while(0U)__HAL_DSI_REG_ENABLE(__HANDLE__)do { __IO uint32_t tmpreg = 0x00U; SET_BIT((__HANDLE__)->Instance->WRPCR, DSI_WRPCR_REGEN); tmpreg = READ_BIT((__HANDLE__)->Instance->WRPCR, DSI_WRPCR_REGEN); UNUSED(tmpreg); } while(0U)__HAL_DSI_PLL_DISABLE(__HANDLE__)do { __IO uint32_t tmpreg = 0x00U; CLEAR_BIT((__HANDLE__)->Instance->WRPCR, DSI_WRPCR_PLLEN); tmpreg = READ_BIT((__HANDLE__)->Instance->WRPCR, DSI_WRPCR_PLLEN); UNUSED(tmpreg); } while(0U)__HAL_DSI_PLL_ENABLE(__HANDLE__)do { __IO uint32_t tmpreg = 0x00U; SET_BIT((__HANDLE__)->Instance->WRPCR, DSI_WRPCR_PLLEN); tmpreg = READ_BIT((__HANDLE__)->Instance->WRPCR, DSI_WRPCR_PLLEN); UNUSED(tmpreg); } while(0U)__HAL_DSI_WRAPPER_DISABLE(__HANDLE__)do { __IO uint32_t tmpreg = 0x00U; CLEAR_BIT((__HANDLE__)->Instance->WCR, DSI_WCR_DSIEN); tmpreg = READ_BIT((__HANDLE__)->Instance->WCR, DSI_WCR_DSIEN); UNUSED(tmpreg); } while(0U)__HAL_DSI_WRAPPER_ENABLE(__HANDLE__)do { __IO uint32_t tmpreg = 0x00U; SET_BIT((__HANDLE__)->Instance->WCR, DSI_WCR_DSIEN); tmpreg = READ_BIT((__HANDLE__)->Instance->WCR, DSI_WCR_DSIEN); UNUSED(tmpreg); } while(0U)__HAL_DSI_DISABLE(__HANDLE__)do { __IO uint32_t tmpreg = 0x00U; CLEAR_BIT((__HANDLE__)->Instance->CR, DSI_CR_EN); tmpreg = READ_BIT((__HANDLE__)->Instance->CR, DSI_CR_EN); UNUSED(tmpreg); } while(0U)__HAL_DSI_ENABLE(__HANDLE__)do { __IO uint32_t tmpreg = 0x00U; SET_BIT((__HANDLE__)->Instance->CR, DSI_CR_EN); tmpreg = READ_BIT((__HANDLE__)->Instance->CR, DSI_CR_EN); UNUSED(tmpreg); } while(0U)__HAL_DSI_RESET_HANDLE_STATE(__HANDLE__)((__HANDLE__)->State = HAL_DSI_STATE_RESET)DSI_TCLK_PREPAREDSI_TCLK_ZERODSI_THS_PREPAREDSI_THS_TRAILDSI_THS_ZERODSI_TLPX_DATADSI_THS_EXITDSI_TLPX_CLKDSI_TCLK_POSTDSI_DATA_LANE1DSI_DATA_LANE0DSI_CLK_LANEDSI_INVERT_HS_SIGNALDSI_SWAP_LANE_PINSDSI_HS_DELAYDSI_SLEW_RATE_LPTXDSI_SLEW_RATE_HSTXDSI_DATA_LANESDSI_CLOCK_LANEHAL_DSI_ERROR_GENHAL_DSI_ERROR_OVFHAL_DSI_ERROR_EOTHAL_DSI_ERROR_PSEHAL_DSI_ERROR_CRCHAL_DSI_ERROR_ECCHAL_DSI_ERROR_RXHAL_DSI_ERROR_TXHAL_DSI_ERROR_PHYHAL_DSI_ERROR_ACKHAL_DSI_ERROR_NONEDSI_GEN_SHORT_PKT_READ_P20x00000024UDSI_GEN_SHORT_PKT_READ_P10x00000014UDSI_GEN_SHORT_PKT_READ_P0DSI_DCS_SHORT_PKT_READDSI_GEN_LONG_PKT_WRITE0x00000029U0x00000039UDSI_GEN_SHORT_PKT_WRITE_P2DSI_GEN_SHORT_PKT_WRITE_P10x00000013UDSI_GEN_SHORT_PKT_WRITE_P00x00000015UDSI_DCS_SHORT_PKT_WRITE_P0DSI_IT_RRDSI_IT_PLLUDSI_IT_PLLLDSI_IT_ERDSI_IT_TEDSI_FLAG_RRDSI_FLAG_RRSDSI_FLAG_PLLUDSI_FLAG_PLLLDSI_FLAG_PLLLSDSI_FLAG_BUSYDSI_FLAG_ERDSI_FLAG_TEDSI_PLL_OUT_DIV8DSI_PLL_OUT_DIV4DSI_PLL_OUT_DIV2DSI_PLL_IN_DIV7DSI_PLL_IN_DIV6DSI_PLL_IN_DIV4DSI_PLL_IN_DIV3DSI_PLL_IN_DIV2DSI_PLL_IN_DIV1DSI_DATA_ENABLE_ACTIVE_LOWDSI_VSYNC_ACTIVE_LOWDSI_HSYNC_ACTIVE_LOWDSI_LOOSELY_PACKED_DISABLEDSI_LOOSELY_PACKED_ENABLEDSI_RGB666DSI_FLOW_CONTROL_ALL(DSI_FLOW_CONTROL_CRC_RX | DSI_FLOW_CONTROL_ECC_RX | DSI_FLOW_CONTROL_BTA | DSI_FLOW_CONTROL_EOTP_RX | DSI_FLOW_CONTROL_EOTP_TX)DSI_FLOW_CONTROL_EOTP_TXDSI_FLOW_CONTROL_EOTP_RXDSI_FLOW_CONTROL_BTADSI_FLOW_CONTROL_ECC_RXDSI_FLOW_CONTROL_CRC_RXDSI_ONE_DATA_LANEDSI_AUTO_CLK_LANE_CTRL_ENABLEDSI_AUTO_CLK_LANE_CTRL_DISABLEDSI_HS_PM_ENABLEDSI_HS_PM_DISABLEDSI_LP_MRDP_ENABLEDSI_LP_MRDP_DISABLEDSI_LP_DLW_ENABLEDSI_LP_DLW_DISABLEDSI_LP_DSR0P_ENABLEDSI_LP_DSR0P_DISABLEDSI_LP_DSW1P_ENABLEDSI_LP_DSW1P_DISABLEDSI_LP_DSW0P_ENABLEDSI_LP_DSW0P_DISABLEDSI_LP_GLW_ENABLEDSI_LP_GLW_DISABLEDSI_LP_GSR2P_ENABLEDSI_LP_GSR2P_DISABLEDSI_LP_GSR1P_ENABLEDSI_LP_GSR1P_DISABLEDSI_LP_GSR0P_ENABLEDSI_LP_GSR0P_DISABLEDSI_LP_GSW2P_ENABLEDSI_LP_GSW2P_DISABLEDSI_LP_GSW1P_ENABLEDSI_LP_GSW1P_DISABLEDSI_LP_GSW0P_ENABLEDSI_LP_GSW0P_DISABLEDSI_ACKNOWLEDGE_ENABLEDSI_ACKNOWLEDGE_DISABLEDSI_TE_ACKNOWLEDGE_ENABLEDSI_TE_ACKNOWLEDGE_DISABLEDSI_AR_ENABLEDSI_AR_DISABLEDSI_VSYNC_RISINGDSI_VSYNC_FALLINGDSI_TE_FALLING_EDGEDSI_TE_RISING_EDGEDSI_TE_EXTERNALDSI_TE_DSILINKDSI_FBTAA_ENABLEDSI_FBTAA_DISABLEDSI_LP_VSYNC_ENABLEDSI_LP_VSYNC_DISABLEDSI_LP_VBP_ENABLEDSI_LP_VBP_DISABLEDSI_LP_VFP_ENABLEDSI_LP_VFP_DISABLEDSI_LP_VACT_ENABLEDSI_LP_VACT_DISABLEDSI_LP_HBP_ENABLEDSI_LP_HBP_DISABLEDSI_LP_HFP_ENABLEDSI_LP_HFP_DISABLEDSI_LP_COMMAND_ENABLEDSI_LP_COMMAND_DISABLEDSI_DISPLAY_OFFDSI_DISPLAY_ONDSI_COLOR_MODE_EIGHTDSI_COLOR_MODE_FULLDSI_VID_MODE_NB_EVENTSDSI_VID_MODE_NB_PULSESDSI_WRITE_MEMORY_START0x2CUDSI_WRITE_MEMORY_CONTINUE0x3CUDSI_WRITE_LUT0x2DUDSI_SOFT_RESETDSI_SET_VSYNC_TIMINGDSI_SET_TEAR_SCANLINE0x44UDSI_SET_TEAR_ON0x35UDSI_SET_TEAR_OFF0x34UDSI_SET_SCROLL_START0x37UDSI_SET_SCROLL_AREA0x33UDSI_SET_PIXEL_FORMAT0x3AUDSI_SET_PARTIAL_ROWS0x30UDSI_SET_PARTIAL_COLUMNS0x31UDSI_SET_PAGE_ADDRESS0x2BUDSI_SET_GAMMA_CURVE0x26UDSI_SET_DISPLAY_ONDSI_SET_DISPLAY_OFFDSI_SET_COLUMN_ADDRESSDSI_SET_ADDRESS_MODE0x36UDSI_SET_3D_CONTROL0x3DUDSI_READ_MEMORY_START0x2EUDSI_READ_MEMORY_CONTINUE0x3EUDSI_READ_DDB_START0xA1UDSI_READ_DDB_CONTINUE0xA8UDSI_NOPDSI_GET_SIGNAL_MODE0x0EUDSI_GET_SCANLINE0x45UDSI_GET_RED_CHANNELDSI_GET_POWER_MODE0x0AUDSI_GET_PIXEL_FORMAT0x0CUDSI_GET_GREEN_CHANNEL0x07UDSI_GET_DISPLAY_MODE0x0DUDSI_GET_DIAGNOSTIC_RESULT0x0FUDSI_GET_BLUE_CHANNEL0x08UDSI_GET_ADDRESS_MODE0x0BUDSI_GET_3D_CONTROL0x3FUDSI_EXIT_SLEEP_MODE0x11UDSI_EXIT_INVERT_MODEDSI_EXIT_IDLE_MODE0x38UDSI_ENTER_SLEEP_MODEDSI_ENTER_PARTIAL_MODE0x12UDSI_ENTER_NORMAL_MODE0x13UDSI_ENTER_INVERT_MODEDSI_ENTER_IDLE_MODE0x39USTM32F7xx_HAL_DSI_Hdefined(DSI)(USE_HAL_DSI_REGISTER_CALLBACKS == 1)/* STM32F7xx_HAL_DSI_H *//* DSI *//** @defgroup DSI_Private_Macros DSI Private Macros
  * @{
  *//*!< Maximum return packet configuration *//** @defgroup DSI_Private_Constants DSI Private Constants
  * @{
  *//* Private defines -----------------------------------------------------------*//** @defgroup DSI_Group4 Peripheral State and Errors functions
  *  @brief    Peripheral State and Errors functions
  * @{
  *//** @defgroup DSI_Group3 Peripheral Control functions
  *  @brief    Peripheral Control functions
  * @{
  *//** @defgroup DSI_Group2 IO operation functions
  *  @brief    IO operation functions
  * @{
  *//* USE_HAL_DSI_REGISTER_CALLBACKS *//** @defgroup DSI_Group1 Initialization and Configuration functions
  *  @brief   Initialization and Configuration functions
  * @{
  *//** @defgroup DSI_Exported_Functions DSI Exported Functions
  * @{
  *//**
  * @brief  Checks whether the specified DSI interrupt source is enabled or not.
  * @param  __HANDLE__  DSI handle
  * @param  __INTERRUPT__  specifies the DSI interrupt source to check.
  *          This parameter can be one of the following values:
  *            @arg DSI_IT_TE  : Tearing Effect Interrupt
  *            @arg DSI_IT_ER  : End of Refresh Interrupt
  *            @arg DSI_IT_PLLL: PLL Lock Interrupt
  *            @arg DSI_IT_PLLU: PLL Unlock Interrupt
  *            @arg DSI_IT_RR  : Regulator Ready Interrupt
  * @retval The state of INTERRUPT (SET or RESET).
  *//**
  * @brief  Disables the specified DSI interrupts.
  * @param  __HANDLE__  DSI handle
  * @param __INTERRUPT__  specifies the DSI interrupt sources to be disabled.
  *          This parameter can be any combination of the following values:
  *            @arg DSI_IT_TE  : Tearing Effect Interrupt
  *            @arg DSI_IT_ER  : End of Refresh Interrupt
  *            @arg DSI_IT_PLLL: PLL Lock Interrupt
  *            @arg DSI_IT_PLLU: PLL Unlock Interrupt
  *            @arg DSI_IT_RR  : Regulator Ready Interrupt
  * @retval None
  *//**
  * @brief  Enables the specified DSI interrupts.
  * @param  __HANDLE__  DSI handle.
  * @param __INTERRUPT__  specifies the DSI interrupt sources to be enabled.
  *          This parameter can be any combination of the following values:
  *            @arg DSI_IT_TE  : Tearing Effect Interrupt
  *            @arg DSI_IT_ER  : End of Refresh Interrupt
  *            @arg DSI_IT_PLLL: PLL Lock Interrupt
  *            @arg DSI_IT_PLLU: PLL Unlock Interrupt
  *            @arg DSI_IT_RR  : Regulator Ready Interrupt
  * @retval None
  *//**
  * @brief  Clears the DSI pending flags.
  * @param  __HANDLE__  DSI handle.
  * @param  __FLAG__  specifies the flag to clear.
  *          This parameter can be any combination of the following values:
  *            @arg DSI_FLAG_TE   : Tearing Effect Interrupt Flag
  *            @arg DSI_FLAG_ER   : End of Refresh Interrupt Flag
  *            @arg DSI_FLAG_PLLL : PLL Lock Interrupt Flag
  *            @arg DSI_FLAG_PLLU : PLL Unlock Interrupt Flag
  *            @arg DSI_FLAG_RR   : Regulator Ready Interrupt Flag
  * @retval None
  *//**
  * @brief  Get the DSI pending flags.
  * @param  __HANDLE__  DSI handle.
  * @param  __FLAG__  Get the specified flag.
  *          This parameter can be any combination of the following values:
  *            @arg DSI_FLAG_TE   : Tearing Effect Interrupt Flag
  *            @arg DSI_FLAG_ER   : End of Refresh Interrupt Flag
  *            @arg DSI_FLAG_BUSY : Busy Flag
  *            @arg DSI_FLAG_PLLLS: PLL Lock Status
  *            @arg DSI_FLAG_PLLL : PLL Lock Interrupt Flag
  *            @arg DSI_FLAG_PLLU : PLL Unlock Interrupt Flag
  *            @arg DSI_FLAG_RRS  : Regulator Ready Flag
  *            @arg DSI_FLAG_RR   : Regulator Ready Interrupt Flag
  * @retval The state of FLAG (SET or RESET).
  *//* Delay after an DSI regulator disabling *//**
  * @brief  Disables the DSI regulator.
  * @param  __HANDLE__  DSI handle
  * @retval None.
  *//* Delay after an DSI regulator enabling *//**
  * @brief  Enables the DSI regulator.
  * @param  __HANDLE__  DSI handle
  * @retval None.
  *//* Delay after an DSI PLL disabling *//**
  * @brief  Disables the DSI PLL.
  * @param  __HANDLE__  DSI handle
  * @retval None.
  *//* Delay after an DSI PLL enabling *//**
  * @brief  Enables the DSI PLL.
  * @param  __HANDLE__  DSI handle
  * @retval None.
  *//* Delay after an DSI wrapper disabling*//**
  * @brief  Disable the DSI wrapper.
  * @param  __HANDLE__  DSI handle
  * @retval None.
  *//* Delay after an DSI wrapper enabling *//**
  * @brief  Enables the DSI wrapper.
  * @param  __HANDLE__  DSI handle
  * @retval None.
  *//* Delay after an DSI Host disabling *//**
  * @brief  Disables the DSI host.
  * @param  __HANDLE__  DSI handle
  * @retval None.
  *//* Delay after an DSI Host enabling *//**
  * @brief  Enables the DSI host.
  * @param  __HANDLE__  DSI handle
  * @retval None.
  *//*USE_HAL_DSI_REGISTER_CALLBACKS *//**
  * @brief Reset DSI handle state.
  * @param  __HANDLE__ DSI handle
  * @retval None
  *//** @defgroup DSI_Exported_Macros DSI Exported Macros
  * @{
  *//** @defgroup DSI_PHY_Timing DSI PHY Timing
  * @{
  *//** @defgroup DSI_Lane_Select DSI Lane Select
  * @{
  *//** @defgroup DSI_CustomLane DSI CustomLane
  * @{
  *//** @defgroup DSI_Communication_Delay DSI Communication Delay
  * @{
  *//** @defgroup DSI_Lane_Group DSI Lane Group
  * @{
  *//*!< DSI Invalid Callback error      *//*!< Generic FIFO related errors    *//*!< FIFO overflow error            *//*!< End Of Transmission error      *//*!< Packet Size error              *//*!< CRC error                      *//*!< ECC errors                     *//*!< Reception error                *//*!< Transmission error             *//*!< PHY related errors             *//*!< Acknowledge errors             *//** @defgroup DSI_Error_Data_Type DSI Error Data Type
  * @{
  *//*!< Generic short read, two parameters *//*!< Generic short read, one parameter  *//*!< Generic short read, no parameters  *//*!< DCS short read                     *//** @defgroup DSI_SHORT_READ_PKT_Data_Type DSI SHORT READ PKT Data Type
  * @{
  *//*!< Generic long write *//*!< DCS long write     *//** @defgroup DSI_LONG_WRITE_PKT_Data_Type DSI LONG WRITE PKT Data Type
  * @{
  *//*!< Generic short write, two parameters *//*!< Generic short write, one parameter  *//*!< Generic short write, no parameters  *//*!< DCS short write, one parameter      *//*!< DCS short write, no parameters      *//** @defgroup DSI_SHORT_WRITE_PKT_Data_Type DSI SHORT WRITE PKT Data Type
  * @{
  *//** @defgroup DSI_Interrupts DSI Interrupts
  * @{
  *//** @defgroup DSI_Flags DSI Flags
  * @{
  *//** @defgroup DSI_PLL_ODF DSI PLL ODF
  * @{
  *//** @defgroup DSI_PLL_IDF DSI PLL IDF
  * @{
  *//** @defgroup DSI_DATA_ENABLE_Polarity DSI DATA ENABLE Polarity
  * @{
  *//** @defgroup DSI_VSYNC_Active_Polarity DSI VSYNC Active Polarity
  * @{
  *//** @defgroup DSI_HSYNC_Polarity DSI HSYNC Polarity
  * @{
  *//** @defgroup DSI_LooselyPacked DSI Loosely Packed
  * @{
  *//*!< The value 0x00000004 can also be used for the RGB666 color mode configuration                 *//*!< The values 0x00000001 and 0x00000002 can also be used for the RGB565 color mode configuration *//** @defgroup DSI_Color_Coding DSI Color Coding
  * @{
  *//** @defgroup DSI_FlowControl DSI Flow Control
  * @{
  *//** @defgroup DSI_Number_Of_Lanes DSI Number Of Lanes
  * @{
  *//** @defgroup DSI_Automatic_Clk_Lane_Control DSI Automatic Clk Lane Control
  * @{
  *//** @defgroup DSI_HS_PrespMode DSI HS Presp Mode
  * @{
  *//** @defgroup DSI_LP_LPMaxReadPacket DSI LP LPMax Read Packet
  * @{
  *//** @defgroup DSI_LP_LPDcsLongWrite DSI LP LPDcs Long Write
  * @{
  *//** @defgroup DSI_LP_LPDcsShortReadNoP DSI LP LPDcs Short Read NoP
  * @{
  *//** @defgroup DSI_LP_LPDcsShortWriteOneP DSI LP LPDcs Short Write OneP
  * @{
  *//** @defgroup DSI_LP_LPDcsShortWriteNoP DSI LP LPDcs Short Write NoP
  * @{
  *//** @defgroup DSI_LP_LPGenLongWrite DSI LP LPGen LongWrite
  * @{
  *//** @defgroup DSI_LP_LPGenShortReadTwoP DSI LP LPGen Short Read TwoP
  * @{
  *//** @defgroup DSI_LP_LPGenShortReadOneP DSI LP LPGen Short Read OneP
  * @{
  *//** @defgroup DSI_LP_LPGenShortReadNoP DSI LP LPGen Short Read NoP
  * @{
  *//** @defgroup DSI_LP_LPGenShortWriteTwoP DSI LP LPGen Short Write TwoP
  * @{
  *//** @defgroup DSI_LP_LPGenShortWriteOneP DSI LP LPGen Short Write OneP
  * @{
  *//** @defgroup DSI_LP_LPGenShortWriteNoP DSI LP LPGen Short Write NoP
  * @{
  *//** @defgroup DSI_AcknowledgeRequest DSI Acknowledge Request
  * @{
  *//** @defgroup DSI_TE_AcknowledgeRequest DSI TE Acknowledge Request
  * @{
  *//** @defgroup DSI_AutomaticRefresh DSI Automatic Refresh
  * @{
  *//** @defgroup DSI_Vsync_Polarity DSI Vsync Polarity
  * @{
  *//** @defgroup DSI_TearingEffectPolarity DSI Tearing Effect Polarity
  * @{
  *//** @defgroup DSI_TearingEffectSource DSI Tearing Effect Source
  * @{
  *//** @defgroup DSI_FBTA_acknowledge DSI FBTA Acknowledge
  * @{
  *//** @defgroup DSI_LP_VSYNC DSI LP VSYNC
  * @{
  *//** @defgroup DSI_LP_VBP DSI LP VBP
  * @{
  *//** @defgroup DSI_LP_VFP DSI LP VFP
  * @{
  *//** @defgroup DSI_LP_VACT DSI LP VACT
  * @{
  *//** @defgroup DSI_LP_HBP DSI LP HBP
  * @{
  *//** @defgroup DSI_LP_HFP DSI LP HFP
  * @{
  *//** @defgroup DSI_LP_Command DSI LP Command
  * @{
  *//** @defgroup DSI_ShutDown DSI ShutDown
  * @{
  *//** @defgroup DSI_Color_Mode DSI Color Mode
  * @{
  *//** @defgroup DSI_Video_Mode_Type DSI Video Mode Type
  * @{
  *//** @defgroup DSI_DCS_Command DSI DCS Command
  * @{
  *//** @defgroup DSI_Exported_Constants DSI Exported Constants
  * @{
  *//*!< pointer to an DSI callback function *//**
  * @brief  HAL DSI Callback pointer definition
  *//*!< DSI Error Callback ID          *//*!< DSI End Of Refresh Callback ID *//*!< DSI Tearing Effect Callback ID *//*!< DSI MspDeInit callback ID      *//*!< DSI MspInit callback ID        *//**
  * @brief  HAL DSI Callback ID enumeration definition
  *//*!< DSI Msp DeInit callback     *//*!< DSI Msp Init callback       *//*!< DSI Error Callback          *//*!< DSI End Of Refresh Callback *//*!< DSI Tearing Effect Callback *//*!< DSI Error monitoring mask  *//*!< DSI Error code             *//*!< DSI communication state    *//*!< DSI peripheral status      *//*!< DSI required parameters    *//*!< Register base address      *//**
  * @brief  DSI Handle Structure definition
  *//**
  * @brief  DSI States Structure definition
  *//*!< BTA time-out                                             *//*!< Low-speed write time-out                                 *//*!< High-speed write presp mode
                                              This parameter can be any value of @ref DSI_HS_PrespMode *//*!< High-speed write time-out                                *//*!< Low-power read time-out                                  *//*!< High-speed read time-out                                 *//*!< Low-power reception time-out                             *//*!< High-speed transmission time-out                         *//*!< Time-out clock division                                  *//**
  * @brief  DSI HOST Timeouts definition
  *//*!< The minimum wait period to request a High-Speed transmission after the
                                              Stop state                                                             *//*!< The maximum time required to perform a read command *//*!< The maximum time that the D-PHY data lanes takes to go from low-power
                                              to high-speed transmission                                             *//*!< The maximum time that the D-PHY data lanes takes to go from high-speed
                                              to low-power transmission                                              *//*!< The maximum time that the D-PHY clock lane takes to go from low-power
                                              to high-speed transmission                                             *//*!< The maximum time that the D-PHY clock lane takes to go from high-speed
                                              to low-power transmission                                              *//**
  * @brief  DSI PHY Timings definition
  *//*!< Acknowledge Request Enable
                                              This parameter can be any value of @ref DSI_AcknowledgeRequest     *//*!< Maximum Read Packet Size Transmission
                                              This parameter can be any value of @ref DSI_LP_LPMaxReadPacket     *//*!< DCS Long Write Transmission
                                              This parameter can be any value of @ref DSI_LP_LPDcsLongWrite      *//*!< DCS Short Read Zero parameters Transmission
                                              This parameter can be any value of @ref DSI_LP_LPDcsShortReadNoP   *//*!< DCS Short Write One parameter Transmission
                                              This parameter can be any value of @ref DSI_LP_LPDcsShortWriteOneP *//*!< DCS Short Write Zero parameters Transmission
                                              This parameter can be any value of @ref DSI_LP_LPDcsShortWriteNoP  *//*!< Generic Long Write Transmission
                                              This parameter can be any value of @ref DSI_LP_LPGenLongWrite      *//*!< Generic Short Read Two parameters Transmission
                                              This parameter can be any value of @ref DSI_LP_LPGenShortReadTwoP  *//*!< Generic Short Read One parameter Transmission
                                              This parameter can be any value of @ref DSI_LP_LPGenShortReadOneP  *//*!< Generic Short Read Zero parameters Transmission
                                              This parameter can be any value of @ref DSI_LP_LPGenShortReadNoP   *//*!< Generic Short Write Two parameters Transmission
                                              This parameter can be any value of @ref DSI_LP_LPGenShortWriteTwoP *//*!< Generic Short Write One parameter Transmission
                                              This parameter can be any value of @ref DSI_LP_LPGenShortWriteOneP *//*!< Generic Short Write Zero parameters Transmission
                                              This parameter can be any value of @ref DSI_LP_LPGenShortWriteNoP  *//**
  * @brief  DSI command transmission mode configuration
  *//*!< Tearing Effect Acknowledge Request Enable
                                              This parameter can be any value of @ref DSI_TE_AcknowledgeRequest *//*!< Automatic refresh mode
                                              This parameter can be any value of @ref DSI_AutomaticRefresh      *//*!< VSync edge on which the LTDC is halted
                                              This parameter can be any value of @ref DSI_Vsync_Polarity        *//*!< Data Enable pin polarity
                                              This parameter can be any value of @ref DSI_DATA_ENABLE_Polarity  *//*!< VSYNC pin polarity
                                              This parameter can be any value of @ref DSI_VSYNC_Active_Polarity *//*!< HSYNC pin polarity
                                              This parameter can be any value of @ref DSI_HSYNC_Polarity        *//*!< Tearing effect pin polarity
                                              This parameter can be any value of @ref DSI_TearingEffectPolarity *//*!< Tearing effect source
                                              This parameter can be any value of @ref DSI_TearingEffectSource   *//*!< Maximum allowed size for an LTDC write memory command, measured in
                                              pixels. This parameter can be any value between 0x00 and 0xFFFFU   *//*!< Color coding for LTDC interface
                                              This parameter can be any value of @ref DSI_Color_Coding          *//*!< Virtual channel ID                                                *//**
  * @brief  DSI Adapted command mode configuration
  *//*!< Frame bus-turn-around acknowledge enable
                                              This parameter can be any value of @ref DSI_FBTA_acknowledge       *//*!< Low-power vertical sync active enable
                                              This parameter can be any value of @ref DSI_LP_VSYNC               *//*!< Low-power vertical back-porch enable
                                              This parameter can be any value of @ref DSI_LP_VBP                 *//*!< Low-power vertical front-porch enable
                                              This parameter can be any value of @ref DSI_LP_VFP                 *//*!< Low-power vertical active enable
                                              This parameter can be any value of @ref DSI_LP_VACT                *//*!< Low-power horizontal back-porch enable
                                              This parameter can be any value of @ref DSI_LP_HBP                 *//*!< Low-power horizontal front-porch enable
                                              This parameter can be any value of @ref DSI_LP_HFP                 *//*!< The size, in bytes, of the low power largest packet that
                                              can fit in a line during VACT region                               *//*!< The size, in bytes, of the low power largest packet that
                                              can fit in a line during VSA, VBP and VFP regions                  *//*!< Low-power command enable
                                              This parameter can be any value of @ref DSI_LP_Command             *//*!< Vertical active duration                                           *//*!< Vertical front-porch duration                                      *//*!< Vertical back-porch duration                                       *//*!< Vertical synchronism active duration                               *//*!< Horizontal line duration (in lane byte clock cycles)               *//*!< Horizontal back-porch duration (in lane byte clock cycles)         *//*!< Horizontal synchronism active duration (in lane byte clock cycles) *//*!< Data Enable pin polarity
                                              This parameter can be any value of @ref DSI_DATA_ENABLE_Polarity   *//*!< VSYNC pin polarity
                                              This parameter can be any value of @ref DSI_VSYNC_Active_Polarity  *//*!< HSYNC pin polarity
                                              This parameter can be any value of @ref DSI_HSYNC_Polarity         *//*!< Null packet size                                                   *//*!< Number of chunks                                                   *//*!< Video packet size                                                  *//*!< Video mode type
                                              This parameter can be any value of @ref DSI_Video_Mode_Type        *//*!< Enable or disable loosely packed stream (needed only when using
                                              18-bit configuration).
                                              This parameter can be any value of @ref DSI_LooselyPacked          *//*!< Color coding for LTDC interface
                                              This parameter can be any value of @ref DSI_Color_Coding           *//*!< Virtual channel ID                                                 *//**
  * @brief  DSI Video mode configuration
  *//*!< PLL Output Division Factor
                                         This parameter can be any value of @ref DSI_PLL_ODF                  *//*!< PLL Input Division Factor
                                         This parameter can be any value of @ref DSI_PLL_IDF                  *//*!< PLL Loop Division Factor
                                         This parameter must be a value between 10 and 125                    *//**
  * @brief  DSI PLL Clock structure definition
  *//*!< Number of lanes
                                              This parameter can be any value of @ref DSI_Number_Of_Lanes            *//*!< TX Escape clock division
                                              The values 0 and 1 stop the TX_ESC clock generation                    *//*!< Automatic clock lane control
                                              This parameter can be any value of @ref DSI_Automatic_Clk_Lane_Control *//**
  * @brief  DSI Init Structure definition
  *//** @defgroup DSI_Exported_Types DSI Exported Types
  * @{
  *//** @defgroup DSI DSI
  * @brief DSI HAL module driver
  * @{
  *//**
  ******************************************************************************
  * @file    stm32f7xx_hal_dsi.h
  * @author  MCD Application Team
  * @brief   Header file of DSI HAL module.
  ******************************************************************************
  * @attention
  *
  * Copyright (c) 2017 STMicroelectronics.
  * All rights reserved.
  *
  * This software is licensed under terms that can be found in the LICENSE file
  * in the root directory of this software component.
  * If no LICENSE file comes with this software, it is provided AS-IS.
  *
  ******************************************************************************
  */hdsiLaneCustomLaneFrequencyCommDelayOrientationChannelNbrArrayDCSCmdParametersTableChannelIDNbParamsParam1Param2ShutdownHostTimeoutsPhyTimersFlowControlLPCmdCmdCfgVidCfgActiveErrorsPLLInit"stm32f7xx_hal_dsi.h"STM32F7xx_HAL_LTDC_EX_Hdefined (LTDC) && defined (DSI)/* STM32F7xx_HAL_LTDC_EX_H *//* LTDC && DSI *//** @addtogroup LTDCEx_Exported_Functions_Group1
  * @{
  *//** @addtogroup LTDCEx_Exported_Functions
  * @{
  *//** @addtogroup LTDCEx
  * @{
  *//**
  ******************************************************************************
  * @file    stm32f7xx_hal_ltdc_ex.h
  * @author  MCD Application Team
  * @brief   Header file of LTDC HAL Extension module.
  ******************************************************************************
  * @attention
  *
  * Copyright (c) 2017 STMicroelectronics.
  * All rights reserved.
  *
  * This software is licensed under terms that can be found in the LICENSE file
  * in the root directory of this software component.
  * If no LICENSE file comes with this software, it is provided AS-IS.
  *
  ******************************************************************************
  */hltdc"stm32f7xx_hal_ltdc_ex.h"HAL_LTDC_GetErrorHAL_LTDC_GetStateHAL_LTDC_DisableCLUT_NoReloadHAL_LTDC_EnableCLUT_NoReloadHAL_LTDC_DisableColorKeying_NoReloadHAL_LTDC_EnableColorKeying_NoReloadHAL_LTDC_ConfigColorKeying_NoReloadHAL_LTDC_SetPitch_NoReloadHAL_LTDC_SetAddress_NoReloadHAL_LTDC_SetAlpha_NoReloadHAL_LTDC_SetPixelFormat_NoReloadHAL_LTDC_SetWindowPosition_NoReloadHAL_LTDC_SetWindowSize_NoReloadHAL_LTDC_ConfigLayer_NoReloadHAL_LTDC_DisableDitherHAL_LTDC_EnableDitherHAL_LTDC_ProgramLineEventHAL_LTDC_DisableCLUTHAL_LTDC_EnableCLUTHAL_LTDC_DisableColorKeyingHAL_LTDC_EnableColorKeyingHAL_LTDC_ConfigCLUTHAL_LTDC_ConfigColorKeyingHAL_LTDC_SetPitchHAL_LTDC_SetAddressHAL_LTDC_SetAlphaHAL_LTDC_SetPixelFormatHAL_LTDC_SetWindowPositionHAL_LTDC_SetWindowSizeHAL_LTDC_ConfigLayerHAL_LTDC_IRQHandlerHAL_LTDC_ReloadEventCallbackHAL_LTDC_ErrorCallbackHAL_LTDC_MspDeInitHAL_LTDC_MspInitHAL_LTDC_DeInitHAL_LTDC_InitLTDC_HandleTypeDefHAL_LTDC_StateTypeDefHAL_LTDC_STATE_RESETHAL_LTDC_STATE_READYHAL_LTDC_STATE_BUSYHAL_LTDC_STATE_TIMEOUTHAL_LTDC_STATE_ERRORLTDC_InitTypeDefLTDC_ColorTypeDefvolatile HAL_LTDC_StateTypeDefMAX_LAYERBackcolorImageHeightImageWidthFBStartAdressBlendingFactor2BlendingFactor1Alpha0AlphaPixelFormatWindowY1WindowY0WindowX1WindowX0TotalHeighTotalWidthAccumulatedActiveHAccumulatedActiveWAccumulatedVBPAccumulatedHBPVerticalSyncHorizontalSyncPCPolarityRedGreenBlueIS_LTDC_RELOAD(__RELOADTYPE__)(((__RELOADTYPE__) == LTDC_RELOAD_IMMEDIATE) || ((__RELOADTYPE__) == LTDC_RELOAD_VERTICAL_BLANKING))IS_LTDC_LIPOS(__LIPOS__)((__LIPOS__) <= 0x7FFU)IS_LTDC_CFBLNBR(__CFBLNBR__)((__CFBLNBR__) <= LTDC_LINE_NUMBER)IS_LTDC_CFBLL(__CFBLL__)((__CFBLL__) <= LTDC_COLOR_FRAME_BUFFER)IS_LTDC_CFBP(__CFBP__)((__CFBP__) <= LTDC_COLOR_FRAME_BUFFER)IS_LTDC_VCONFIGSP(__VCONFIGSP__)((__VCONFIGSP__) <= LTDC_STOPPOSITION)IS_LTDC_VCONFIGST(__VCONFIGST__)((__VCONFIGST__) <= LTDC_STARTPOSITION)IS_LTDC_HCONFIGSP(__HCONFIGSP__)((__HCONFIGSP__) <= LTDC_STOPPOSITION)IS_LTDC_HCONFIGST(__HCONFIGST__)((__HCONFIGST__) <= LTDC_STARTPOSITION)IS_LTDC_ALPHA(__ALPHA__)((__ALPHA__) <= LTDC_ALPHA)IS_LTDC_PIXEL_FORMAT(__PIXEL_FORMAT__)(((__PIXEL_FORMAT__) == LTDC_PIXEL_FORMAT_ARGB8888) || ((__PIXEL_FORMAT__) == LTDC_PIXEL_FORMAT_RGB888) || ((__PIXEL_FORMAT__) == LTDC_PIXEL_FORMAT_RGB565) || ((__PIXEL_FORMAT__) == LTDC_PIXEL_FORMAT_ARGB1555) || ((__PIXEL_FORMAT__) == LTDC_PIXEL_FORMAT_ARGB4444) || ((__PIXEL_FORMAT__) == LTDC_PIXEL_FORMAT_L8) || ((__PIXEL_FORMAT__) == LTDC_PIXEL_FORMAT_AL44) || ((__PIXEL_FORMAT__) == LTDC_PIXEL_FORMAT_AL88))IS_LTDC_BLENDING_FACTOR2(__BLENDING_FACTOR1__)(((__BLENDING_FACTOR1__) == LTDC_BLENDING_FACTOR2_CA) || ((__BLENDING_FACTOR1__) == LTDC_BLENDING_FACTOR2_PAxCA))IS_LTDC_BLENDING_FACTOR1(__BLENDING_FACTOR1__)(((__BLENDING_FACTOR1__) == LTDC_BLENDING_FACTOR1_CA) || ((__BLENDING_FACTOR1__) == LTDC_BLENDING_FACTOR1_PAxCA))IS_LTDC_REDVALUE(__BRED__)((__BRED__) <= LTDC_COLOR)IS_LTDC_GREENVALUE(__BGREEN__)((__BGREEN__) <= LTDC_COLOR)IS_LTDC_BLUEVALUE(__BBLUE__)((__BBLUE__) <= LTDC_COLOR)IS_LTDC_TOTALH(__TOTALH__)((__TOTALH__) <= LTDC_VERTICALSYNC)IS_LTDC_TOTALW(__TOTALW__)((__TOTALW__) <= LTDC_HORIZONTALSYNC)IS_LTDC_AAH(__AAH__)((__AAH__) <= LTDC_VERTICALSYNC)IS_LTDC_AAW(__AAW__)((__AAW__) <= LTDC_HORIZONTALSYNC)IS_LTDC_AVBP(__AVBP__)((__AVBP__) <= LTDC_VERTICALSYNC)IS_LTDC_AHBP(__AHBP__)((__AHBP__) <= LTDC_HORIZONTALSYNC)IS_LTDC_VSYNC(__VSYNC__)((__VSYNC__) <= LTDC_VERTICALSYNC)IS_LTDC_HSYNC(__HSYNC__)((__HSYNC__) <= LTDC_HORIZONTALSYNC)IS_LTDC_PCPOL(__PCPOL__)(((__PCPOL__) == LTDC_PCPOLARITY_IPC) || ((__PCPOL__) == LTDC_PCPOLARITY_IIPC))IS_LTDC_DEPOL(__DEPOL__)(((__DEPOL__) == LTDC_DEPOLARITY_AL) || ((__DEPOL__) == LTDC_DEPOLARITY_AH))IS_LTDC_VSPOL(__VSPOL__)(((__VSPOL__) == LTDC_VSPOLARITY_AL) || ((__VSPOL__) == LTDC_VSPOLARITY_AH))IS_LTDC_HSPOL(__HSPOL__)(((__HSPOL__) == LTDC_HSPOLARITY_AL) || ((__HSPOL__) == LTDC_HSPOLARITY_AH))IS_LTDC_LAYER(__LAYER__)((__LAYER__) < MAX_LAYER)LTDC_LAYER(__HANDLE__,__LAYER__)((LTDC_Layer_TypeDef *)((uint32_t)( ((uint32_t)((__HANDLE__)->Instance)) + 0x84U + (0x80U*(__LAYER__)))))__HAL_LTDC_GET_IT_SOURCE(__HANDLE__,__INTERRUPT__)((__HANDLE__)->Instance->IER & (__INTERRUPT__))__HAL_LTDC_DISABLE_IT(__HANDLE__,__INTERRUPT__)__HAL_LTDC_ENABLE_IT(__HANDLE__,__INTERRUPT__)__HAL_LTDC_CLEAR_FLAG(__HANDLE__,__FLAG__)__HAL_LTDC_GET_FLAG(__HANDLE__,__FLAG__)__HAL_LTDC_VERTICAL_BLANKING_RELOAD_CONFIG(__HANDLE__)((__HANDLE__)->Instance->SRCR |= LTDC_SRCR_VBR)__HAL_LTDC_RELOAD_IMMEDIATE_CONFIG(__HANDLE__)((__HANDLE__)->Instance->SRCR |= LTDC_SRCR_IMR)__HAL_LTDC_LAYER_DISABLE(__HANDLE__,__LAYER__)((LTDC_LAYER((__HANDLE__), (__LAYER__)))->CR &= ~(uint32_t)LTDC_LxCR_LEN)__HAL_LTDC_LAYER_ENABLE(__HANDLE__,__LAYER__)((LTDC_LAYER((__HANDLE__), (__LAYER__)))->CR |= (uint32_t)LTDC_LxCR_LEN)__HAL_LTDC_DISABLE(__HANDLE__)((__HANDLE__)->Instance->GCR &= ~(LTDC_GCR_LTDCEN))__HAL_LTDC_ENABLE(__HANDLE__)((__HANDLE__)->Instance->GCR |= LTDC_GCR_LTDCEN)__HAL_LTDC_RESET_HANDLE_STATE(__HANDLE__)((__HANDLE__)->State = HAL_LTDC_STATE_RESET)LTDC_RELOAD_VERTICAL_BLANKINGLTDC_RELOAD_IMMEDIATELTDC_FLAG_RRLTDC_FLAG_TELTDC_FLAG_FULTDC_FLAG_LILTDC_IT_RRLTDC_IT_TELTDC_IT_FULTDC_IT_LILTDC_LINE_NUMBERLTDC_COLOR_FRAME_BUFFERLTDC_STARTPOSITIONLTDC_STOPPOSITION(LTDC_LxWHPCR_WHSPPOS >> 16U)LTDC_ALPHALTDC_PIXEL_FORMAT_AL44LTDC_PIXEL_FORMAT_L8LTDC_PIXEL_FORMAT_ARGB1555LTDC_BLENDING_FACTOR2_CALTDC_BLENDING_FACTOR1_CALTDC_COLORLTDC_VERTICALSYNCLTDC_HORIZONTALSYNC(LTDC_SSCR_HSW >> 16U)LTDC_PCPOLARITY_IIPCLTDC_DEPOLARITY_AHLTDC_DEPOLARITY_ALLTDC_VSPOLARITY_AHLTDC_VSPOLARITY_ALLTDC_HSPOLARITY_AHLTDC_HSPOLARITY_ALLTDC_LAYER_2LTDC_LAYER_1HAL_LTDC_ERROR_TIMEOUTHAL_LTDC_ERROR_FUHAL_LTDC_ERROR_TEHAL_LTDC_ERROR_NONESTM32F7xx_HAL_LTDC_Hdefined (LTDC)(USE_HAL_LTDC_REGISTER_CALLBACKS == 1)/* STM32F7xx_HAL_LTDC_H *//* LTDC *//** @defgroup LTDC_Private_Functions LTDC Private Functions
  * @{
  *//** @defgroup LTDC_Private_Macros LTDC Private Macros
  * @{
  *//** @addtogroup LTDC_Exported_Functions_Group4
  * @{
  *//** @addtogroup LTDC_Exported_Functions_Group3
  * @{
  *//** @addtogroup LTDC_Exported_Functions_Group2
  * @{
  *//* USE_HAL_LTDC_REGISTER_CALLBACKS *//** @addtogroup LTDC_Exported_Functions_Group1
  * @{
  *//** @addtogroup LTDC_Exported_Functions
  * @{
  *//* Include LTDC HAL Extension module *//**
  * @brief  Check whether the specified LTDC interrupt has occurred or not.
  * @param  __HANDLE__  LTDC handle
  * @param __INTERRUPT__ Specify the LTDC interrupt source to check.
  *          This parameter can be one of the following values:
  *            @arg LTDC_IT_LI: Line Interrupt flag
  *            @arg LTDC_IT_FU: FIFO Underrun Interrupt flag
  *            @arg LTDC_IT_TE: Transfer Error interrupt flag
  *            @arg LTDC_IT_RR: Register Reload Interrupt Flag
  * @retval The state of INTERRUPT (SET or RESET).
  *//**
  * @brief  Disables the specified LTDC interrupts.
  * @param  __HANDLE__  LTDC handle
  * @param __INTERRUPT__ Specify the LTDC interrupt sources to be disabled.
  *          This parameter can be any combination of the following values:
  *            @arg LTDC_IT_LI: Line Interrupt flag
  *            @arg LTDC_IT_FU: FIFO Underrun Interrupt flag
  *            @arg LTDC_IT_TE: Transfer Error interrupt flag
  *            @arg LTDC_IT_RR: Register Reload Interrupt Flag
  * @retval None
  *//**
  * @brief  Enables the specified LTDC interrupts.
  * @param  __HANDLE__  LTDC handle
  * @param __INTERRUPT__ Specify the LTDC interrupt sources to be enabled.
  *          This parameter can be any combination of the following values:
  *            @arg LTDC_IT_LI: Line Interrupt flag
  *            @arg LTDC_IT_FU: FIFO Underrun Interrupt flag
  *            @arg LTDC_IT_TE: Transfer Error interrupt flag
  *            @arg LTDC_IT_RR: Register Reload Interrupt Flag
  * @retval None
  *//**
  * @brief  Clears the LTDC pending flags.
  * @param  __HANDLE__  LTDC handle
  * @param  __FLAG__    Specify the flag to clear.
  *          This parameter can be any combination of the following values:
  *            @arg LTDC_FLAG_LI: Line Interrupt flag
  *            @arg LTDC_FLAG_FU: FIFO Underrun Interrupt flag
  *            @arg LTDC_FLAG_TE: Transfer Error interrupt flag
  *            @arg LTDC_FLAG_RR: Register Reload Interrupt Flag
  * @retval None
  *//**
  * @brief  Get the LTDC pending flags.
  * @param  __HANDLE__  LTDC handle
  * @param  __FLAG__    Get the specified flag.
  *          This parameter can be any combination of the following values:
  *            @arg LTDC_FLAG_LI: Line Interrupt flag
  *            @arg LTDC_FLAG_FU: FIFO Underrun Interrupt flag
  *            @arg LTDC_FLAG_TE: Transfer Error interrupt flag
  *            @arg LTDC_FLAG_RR: Register Reload Interrupt Flag
  * @retval The state of FLAG (SET or RESET).
  *//**
  * @brief  Reload during vertical blanking period all LTDC Layers.
  * @param  __HANDLE__  LTDC handle
  * @retval None.
  *//**
  * @brief  Reload immediately all LTDC Layers.
  * @param  __HANDLE__  LTDC handle
  * @retval None.
  *//**
  * @brief  Disable the LTDC Layer.
  * @param  __HANDLE__  LTDC handle
  * @param  __LAYER__   Specify the layer to be disabled.
  *                     This parameter can be LTDC_LAYER_1 (0) or LTDC_LAYER_2 (1).
  * @retval None.
  *//**
  * @brief  Enable the LTDC Layer.
  * @param  __HANDLE__  LTDC handle
  * @param  __LAYER__   Specify the layer to be enabled.
  *                     This parameter can be LTDC_LAYER_1 (0) or LTDC_LAYER_2 (1).
  * @retval None.
  *//**
  * @brief  Disable the LTDC.
  * @param  __HANDLE__  LTDC handle
  * @retval None.
  *//**
  * @brief  Enable the LTDC.
  * @param  __HANDLE__  LTDC handle
  * @retval None.
  *//*USE_HAL_LTDC_REGISTER_CALLBACKS *//** @brief Reset LTDC handle state.
  * @param  __HANDLE__  LTDC handle
  * @retval None
  *//** @defgroup LTDC_Exported_Macros LTDC Exported Macros
  * @{
  *//*!< Immediate Reload *//** @defgroup LTDC_Reload_Type LTDC Reload Type
  * @{
  *//*!< LTDC Register Reload interrupt Flag *//*!< LTDC Transfer Error interrupt Flag  *//*!< LTDC FIFO Underrun interrupt Flag   *//*!< LTDC Line Interrupt Flag            *//** @defgroup LTDC_Flags LTDC Flags
  * @{
  *//*!< LTDC Register Reload Interrupt *//*!< LTDC Transfer Error Interrupt  *//*!< LTDC FIFO Underrun Interrupt   *//*!< LTDC Line Interrupt            *//** @defgroup LTDC_Interrupts LTDC Interrupts
  * @{
  *//*!< LTDC Layer Line number    *//*!< LTDC Layer Line length    *//*!< LTDC Layer start position *//*!< LTDC Layer stop position  *//** @defgroup LTDC_LAYER_Config LTDC LAYER Config
  * @{
  *//*!< LTDC Constant Alpha mask *//** @defgroup LTDC_Alpha LTDC Alpha
  * @{
  *//*!< AL88 LTDC pixel format                 *//*!< AL44 LTDC pixel format                 *//*!< L8 LTDC pixel format                   *//*!< ARGB4444 LTDC pixel format             *//*!< ARGB1555 LTDC pixel format             *//*!< RGB565 LTDC pixel format               *//*!< RGB888 LTDC pixel format               *//*!< ARGB8888 LTDC pixel format             *//** @defgroup LTDC_Pixelformat LTDC Pixel format
  * @{
  *//*!< Blending factor : Cte Alpha x Pixel Alpha*//*!< Blending factor : Cte Alpha *//** @defgroup LTDC_BlendingFactor2 LTDC Blending Factor2
  * @{
  *//** @defgroup LTDC_BlendingFactor1 LTDC Blending Factor1
  * @{
  *//*!< Color mask *//** @defgroup LTDC_BACK_COLOR LTDC BACK COLOR
  * @{
  *//*!< Vertical synchronization height. *//*!< Horizontal synchronization width. *//** @defgroup LTDC_SYNC LTDC SYNC
  * @{
  *//*!< inverted input pixel clock. *//*!< input pixel clock. *//** @defgroup LTDC_PC_POLARITY LTDC PC POLARITY
  * @{
  *//*!< Data Enable, is active high. *//*!< Data Enable, is active low. *//** @defgroup LTDC_DE_POLARITY LTDC DE POLARITY
  * @{
  *//*!< Vertical Synchronization is active high. *//*!< Vertical Synchronization is active low. *//** @defgroup LTDC_VS_POLARITY LTDC VS POLARITY
  * @{
  *//*!< Horizontal Synchronization is active high. *//*!< Horizontal Synchronization is active low. *//** @defgroup LTDC_HS_POLARITY LTDC HS POLARITY
  * @{
  *//*!< LTDC Layer 2 *//*!< LTDC Layer 1 *//** @defgroup LTDC_Layer LTDC Layer
  * @{
  *//*!< LTDC Invalid Callback error  *//*!< LTDC Timeout error        *//*!< LTDC FIFO Underrun        *//*!< LTDC Transfer error       *//*!< LTDC No error             *//** @defgroup LTDC_Error_Code LTDC Error Code
  * @{
  *//** @defgroup LTDC_Exported_Constants LTDC Exported Constants
  * @{
  *//*!< pointer to an LTDC callback function *//**
  * @brief  HAL LTDC Callback pointer definition
  *//*!< LTDC Error Callback ID         *//*!< LTDC Reload Callback ID        *//*!< LTDC Line Event Callback ID    *//*!< LTDC MspDeInit callback ID     *//*!< LTDC MspInit callback ID       *//**
  * @brief  HAL LTDC Callback ID enumeration definition
  *//*!< LTDC Msp DeInit callback    *//*!< LTDC Msp Init callback      *//*!< LTDC Error Callback         *//*!< LTDC Reload Event Callback  *//*!< LTDC Line Event Callback    *//*!< LTDC Error code                           *//*!< LTDC state                                *//*!< LTDC Lock                                 *//*!< LTDC Layers parameters                    *//*!< LTDC parameters                           *//*!< LTDC Register base address                *//**
  * @brief  LTDC handle Structure definition
  *//*!< LTDC state error                     *//*!< LTDC Timeout state                   *//*!< LTDC internal process is ongoing     *//*!< LTDC initialized and ready for use   *//*!< LTDC not yet initialized or disabled *//**
  * @brief  HAL LTDC State structures definition
  *//*!< Configures the layer background color. *//*!< Specifies the number of line in frame buffer.
                                            This parameter must be a number between
                                            Min_Data = 0x000 and Max_Data = 0x7FF. *//*!< Configures the color frame buffer line length.
                                            This parameter must be a number between
                                            Min_Data = 0x0000 and Max_Data = 0x1FFF. *//*!< Configures the color frame buffer address *//*!< Select the blending factor 2.
                                            This parameter can be one of value of @ref LTDC_BlendingFactor2 *//*!< Select the blending factor 1.
                                            This parameter can be one of value of @ref LTDC_BlendingFactor1 *//*!< Configures the default alpha value.
                                            This parameter must be a number between
                                            Min_Data = 0x00 and Max_Data = 0xFF. *//*!< Specifies the constant alpha used for blending.
                                            This parameter must be a number between
                                            Min_Data = 0x00 and Max_Data = 0xFF. *//*!< Specifies the pixel format.
                                            This parameter can be one of value of @ref LTDC_Pixelformat *//*!< Configures the Window vertical Stop Position.
                                            This parameter must be a number between
                                            Min_Data = 0x0000 and Max_Data = 0x7FF. *//*!< Configures the Window vertical Start Position.
                                            This parameter must be a number between
                                            Min_Data = 0x000 and Max_Data = 0x7FF. *//*!< Configures the Window Horizontal Stop Position.
                                            This parameter must be a number between
                                            Min_Data = 0x000 and Max_Data = 0xFFF. *//*!< Configures the Window Horizontal Start Position.
                                            This parameter must be a number between
                                            Min_Data = 0x000 and Max_Data = 0xFFF. *//**
  * @brief  LTDC Layer structure definition
  *//*!< Configures the background color. *//*!< configures the total height.
                                                      This parameter must be a number between
                                                      Min_Data = LTDC_AccumulatedActiveH and Max_Data = 0x7FF. *//*!< configures the total width.
                                                      This parameter must be a number between
                                                      Min_Data = LTDC_AccumulatedActiveW and Max_Data = 0xFFF. *//*!< configures the accumulated active height.
                                                      This parameter must be a number between
                                                      Min_Data = LTDC_AccumulatedVBP and Max_Data = 0x7FF. *//*!< configures the accumulated active width.
                                                      This parameter must be a number between
                                                      Min_Data = LTDC_AccumulatedHBP and Max_Data = 0xFFF. *//*!< configures the accumulated vertical back porch height.
                                                      This parameter must be a number between
                                                      Min_Data = LTDC_VerticalSync and Max_Data = 0x7FF. *//*!< configures the accumulated horizontal back porch width.
                                                      This parameter must be a number between
                                                      Min_Data = LTDC_HorizontalSync and Max_Data = 0xFFF. *//*!< configures the number of Vertical synchronization height.
                                                      This parameter must be a number between
                                                      Min_Data = 0x000 and Max_Data = 0x7FF. *//*!< configures the number of Horizontal synchronization width.
                                                      This parameter must be a number between
                                                      Min_Data = 0x000 and Max_Data = 0xFFF. *//*!< configures the pixel clock polarity.
                                                      This parameter can be one of value of @ref LTDC_PC_POLARITY *//*!< configures the data enable polarity.
                                                      This parameter can be one of value of @ref LTDC_DE_POLARITY *//*!< configures the vertical synchronization polarity.
                                                      This parameter can be one value of @ref LTDC_VS_POLARITY *//*!< configures the horizontal synchronization polarity.
                                                      This parameter can be one value of @ref LTDC_HS_POLARITY *//**
  * @brief  LTDC Init structure definition
  *//*!< Reserved 0xFF *//*!< Configures the red value.
                                        This parameter must be a number between Min_Data = 0x00 and Max_Data = 0xFF. *//*!< Configures the green value.
                                        This parameter must be a number between Min_Data = 0x00 and Max_Data = 0xFF. *//*!< Configures the blue value.
                                        This parameter must be a number between Min_Data = 0x00 and Max_Data = 0xFF. *//**
  * @brief  LTDC color structure definition
  *//** @defgroup LTDC_Exported_Types LTDC Exported Types
  * @{
  *//** @defgroup LTDC LTDC
  * @brief LTDC HAL module driver
  * @{
  *//**
  ******************************************************************************
  * @file    stm32f7xx_hal_ltdc.h
  * @author  MCD Application Team
  * @brief   Header file of LTDC HAL module.
  ******************************************************************************
  * @attention
  *
  * Copyright (c) 2017 STMicroelectronics.
  * All rights reserved.
  *
  * This software is licensed under terms that can be found in the LICENSE file
  * in the root directory of this software component.
  * If no LICENSE file comes with this software, it is provided AS-IS.
  *
  ******************************************************************************
  */LinePitchInPixelsPixelformatpLayerCfgReloadTypeCLUTSizeHAL_PWREx_EnterUnderDriveSTOPModeHAL_PWREx_DisableLowRegulatorLowVoltageHAL_PWREx_EnableLowRegulatorLowVoltageHAL_PWREx_DisableMainRegulatorLowVoltageHAL_PWREx_EnableMainRegulatorLowVoltageHAL_PWREx_ControlVoltageScalingHAL_PWREx_GetVoltageRangeIS_PWR_WAKEUP_PIN(__PIN__)(((__PIN__) == PWR_WAKEUP_PIN1) || ((__PIN__) == PWR_WAKEUP_PIN2) || ((__PIN__) == PWR_WAKEUP_PIN3) || ((__PIN__) == PWR_WAKEUP_PIN4) || ((__PIN__) == PWR_WAKEUP_PIN5) || ((__PIN__) == PWR_WAKEUP_PIN6) || ((__PIN__) == PWR_WAKEUP_PIN1_HIGH) || ((__PIN__) == PWR_WAKEUP_PIN2_HIGH) || ((__PIN__) == PWR_WAKEUP_PIN3_HIGH) || ((__PIN__) == PWR_WAKEUP_PIN4_HIGH) || ((__PIN__) == PWR_WAKEUP_PIN5_HIGH) || ((__PIN__) == PWR_WAKEUP_PIN6_HIGH) || ((__PIN__) == PWR_WAKEUP_PIN1_LOW) || ((__PIN__) == PWR_WAKEUP_PIN2_LOW) || ((__PIN__) == PWR_WAKEUP_PIN3_LOW) || ((__PIN__) == PWR_WAKEUP_PIN4_LOW) || ((__PIN__) == PWR_WAKEUP_PIN5_LOW) || ((__PIN__) == PWR_WAKEUP_PIN6_LOW))IS_PWR_REGULATOR_UNDERDRIVE(REGULATOR)(((REGULATOR) == PWR_MAINREGULATOR_UNDERDRIVE_ON) || ((REGULATOR) == PWR_LOWPOWERREGULATOR_UNDERDRIVE_ON))__HAL_PWR_CLEAR_WAKEUP_FLAG(__WUFLAG__)(PWR->CR2 |= (__WUFLAG__))__HAL_PWR_GET_WAKEUP_FLAG(__WUFLAG__)(PWR->CSR2 & (__WUFLAG__))__HAL_PWR_CLEAR_ODRUDR_FLAG()(PWR->CSR1 |= (PWR_FLAG_UDRDY | PWR_CSR1_EIWUP))__HAL_PWR_GET_ODRUDR_FLAG(__FLAG__)((PWR->CSR1 & (__FLAG__)) == (__FLAG__))__HAL_PWR_UNDERDRIVE_DISABLE()(PWR->CR1 &= (uint32_t)(~PWR_CR1_UDEN))__HAL_PWR_UNDERDRIVE_ENABLE()(PWR->CR1 |= (uint32_t)PWR_CR1_UDEN)__HAL_PWR_OVERDRIVESWITCHING_DISABLE()(PWR->CR1 &= (uint32_t)(~PWR_CR1_ODSWEN))__HAL_PWR_OVERDRIVESWITCHING_ENABLE()(PWR->CR1 |= (uint32_t)PWR_CR1_ODSWEN)__HAL_PWR_OVERDRIVE_DISABLE()(PWR->CR1 &= (uint32_t)(~PWR_CR1_ODEN))__HAL_PWR_OVERDRIVE_ENABLE()(PWR->CR1 |= (uint32_t)PWR_CR1_ODEN)PWR_WAKEUP_PIN_FLAG6PWR_WAKEUP_PIN_FLAG5PWR_WAKEUP_PIN_FLAG4PWR_WAKEUP_PIN_FLAG3PWR_WAKEUP_PIN_FLAG2PWR_WAKEUP_PIN_FLAG1PWR_FLAG_UDRDYPWR_FLAG_ODSWRDYPWR_FLAG_ODRDYPWR_LOWPOWERREGULATOR_UNDERDRIVE_ON((uint32_t)(PWR_CR1_LPDS | PWR_CR1_LPUDS))PWR_MAINREGULATOR_UNDERDRIVE_ONPWR_WAKEUP_PIN6_LOW(uint32_t)((PWR_CR2_WUPP6<<6) | PWR_CSR2_EWUP6)PWR_WAKEUP_PIN5_LOW(uint32_t)((PWR_CR2_WUPP5<<6) | PWR_CSR2_EWUP5)PWR_WAKEUP_PIN4_LOW(uint32_t)((PWR_CR2_WUPP4<<6) | PWR_CSR2_EWUP4)PWR_WAKEUP_PIN3_LOW(uint32_t)((PWR_CR2_WUPP3<<6) | PWR_CSR2_EWUP3)PWR_WAKEUP_PIN2_LOW(uint32_t)((PWR_CR2_WUPP2<<6) | PWR_CSR2_EWUP2)PWR_WAKEUP_PIN1_LOW(uint32_t)((PWR_CR2_WUPP1<<6) | PWR_CSR2_EWUP1)PWR_WAKEUP_PIN6_HIGHPWR_WAKEUP_PIN5_HIGHPWR_WAKEUP_PIN4_HIGHPWR_WAKEUP_PIN3_HIGHPWR_WAKEUP_PIN2_HIGHPWR_WAKEUP_PIN1_HIGHPWR_WAKEUP_PIN6PWR_WAKEUP_PIN5PWR_WAKEUP_PIN4PWR_WAKEUP_PIN3PWR_WAKEUP_PIN2PWR_WAKEUP_PIN1__STM32F7xx_HAL_PWR_EX_H/* __STM32F7xx_HAL_PWR_EX_H *//** @defgroup PWREx_IS_PWR_Definitions PWREx Private macros to check input parameters
  * @{
  *//** @defgroup PWREx_Private_Macros PWREx Private Macros
  * @{
  *//** @addtogroup PWREx_Exported_Functions_Group1
  * @{
  *//** @addtogroup PWREx_Exported_Functions PWREx Exported Functions
  *  @{
  *//** @brief  Clear the WakeUp pins flags.
  * @param  __WUFLAG__ specifies the Wake Up pin flag to clear.
  *          This parameter can be one of the following values:
  *            @arg PWR_WAKEUP_PIN_FLAG1: Wakeup Pin Flag for PA0
  *            @arg PWR_WAKEUP_PIN_FLAG2: Wakeup Pin Flag for PA2
  *            @arg PWR_WAKEUP_PIN_FLAG3: Wakeup Pin Flag for PC1
  *            @arg PWR_WAKEUP_PIN_FLAG4: Wakeup Pin Flag for PC13
  *            @arg PWR_WAKEUP_PIN_FLAG5: Wakeup Pin Flag for PI8
  *            @arg PWR_WAKEUP_PIN_FLAG6: Wakeup Pin Flag for PI11          
  *//** @brief  Check Wake Up flag is set or not.
  * @param  __WUFLAG__ specifies the Wake Up flag to check.
  *          This parameter can be one of the following values:
  *            @arg PWR_WAKEUP_PIN_FLAG1: Wakeup Pin Flag for PA0
  *            @arg PWR_WAKEUP_PIN_FLAG2: Wakeup Pin Flag for PA2
  *            @arg PWR_WAKEUP_PIN_FLAG3: Wakeup Pin Flag for PC1
  *            @arg PWR_WAKEUP_PIN_FLAG4: Wakeup Pin Flag for PC13
  *            @arg PWR_WAKEUP_PIN_FLAG5: Wakeup Pin Flag for PI8
  *            @arg PWR_WAKEUP_PIN_FLAG6: Wakeup Pin Flag for PI11          
  *//** @brief Clear the Under-Drive Ready flag.
  *//** @brief  Check PWR flag is set or not.
  * @param  __FLAG__ specifies the flag to check.
  *         This parameter can be one of the following values:
  *            @arg PWR_FLAG_ODRDY: This flag indicates that the Over-drive mode
  *                                 is ready 
  *            @arg PWR_FLAG_ODSWRDY: This flag indicates that the Over-drive mode
  *                                   switching is ready  
  *            @arg PWR_FLAG_UDRDY: This flag indicates that the Under-drive mode
  *                                 is enabled in Stop mode
  * @retval The new state of __FLAG__ (TRUE or FALSE).
  *//** @brief Macros to enable or disable the Under drive mode.
  * @note  This mode is enabled only with STOP low power mode.
  *        In this mode, the 1.2V domain is preserved in reduced leakage mode. This 
  *        mode is only available when the main regulator or the low power regulator 
  *        is in low voltage mode.      
  * @note  If the Under-drive mode was enabled, it is automatically disabled after 
  *        exiting Stop mode. 
  *        When the voltage regulator operates in Under-drive mode, an additional  
  *        startup delay is induced when waking up from Stop mode.
  *//** @brief Macros to enable or disable the Over drive switching.
  *//** @brief Macros to enable or disable the Over drive mode.
  *//** @defgroup PWREx_Exported_Macro PWREx Exported Macro
  *  @{
  *//** @defgroup PWREx_Wakeup_Pins_Flag PWREx Wake Up Pin Flags
  * @{
  *//** @defgroup PWREx_Over_Under_Drive_Flag PWREx Over Under Drive Flag
  * @{
  *//** @defgroup PWREx_Regulator_state_in_UnderDrive_mode PWREx Regulator state in UnderDrive mode
  * @{
  *//** @defgroup PWREx_WakeUp_Pins PWREx Wake Up Pins
  * @{
  *//** @defgroup PWREx_Exported_Constants PWREx Exported Constants
  * @{
  *//** @addtogroup PWREx
  * @{
  *//**
  ******************************************************************************
  * @file    stm32f7xx_hal_pwr_ex.h
  * @author  MCD Application Team
  * @brief   Header file of PWR HAL Extension module.
  ******************************************************************************
  * @attention
  *
  * Copyright (c) 2017 STMicroelectronics.
  * All rights reserved.
  *
  * This software is licensed under terms that can be found in the LICENSE file
  * in the root directory of this software component.
  * If no LICENSE file comes with this software, it is provided AS-IS.
  *
  ******************************************************************************
  */RegulatorSTOPEntryVoltageScaling"stm32f7xx_hal_pwr_ex.h"HAL_PWR_DisableSEVOnPendHAL_PWR_EnableSEVOnPendHAL_PWR_DisableSleepOnExitHAL_PWR_EnableSleepOnExitHAL_PWR_PVDCallbackHAL_PWR_PVD_IRQHandlerHAL_PWR_EnterSTANDBYModeHAL_PWR_EnterSLEEPModeHAL_PWR_EnterSTOPModeHAL_PWR_DisableWakeUpPinHAL_PWR_EnableWakeUpPinHAL_PWR_DisablePVDHAL_PWR_EnablePVDPWR_PVDTypeDef *HAL_PWR_DisableBkUpAccessHAL_PWR_EnableBkUpAccessHAL_PWR_DeInitPWR_PVDTypeDefPVDLevelIS_PWR_REGULATOR_VOLTAGE(VOLTAGE)(((VOLTAGE) == PWR_REGULATOR_VOLTAGE_SCALE1) || ((VOLTAGE) == PWR_REGULATOR_VOLTAGE_SCALE2) || ((VOLTAGE) == PWR_REGULATOR_VOLTAGE_SCALE3))IS_PWR_STOP_ENTRY(ENTRY)(((ENTRY) == PWR_STOPENTRY_WFI) || ((ENTRY) == PWR_STOPENTRY_WFE))IS_PWR_SLEEP_ENTRY(ENTRY)(((ENTRY) == PWR_SLEEPENTRY_WFI) || ((ENTRY) == PWR_SLEEPENTRY_WFE))IS_PWR_REGULATOR(REGULATOR)(((REGULATOR) == PWR_MAINREGULATOR_ON) || ((REGULATOR) == PWR_LOWPOWERREGULATOR_ON))IS_PWR_PVD_MODE(MODE)(((MODE) == PWR_PVD_MODE_IT_RISING)|| ((MODE) == PWR_PVD_MODE_IT_FALLING) || ((MODE) == PWR_PVD_MODE_IT_RISING_FALLING) || ((MODE) == PWR_PVD_MODE_EVENT_RISING) || ((MODE) == PWR_PVD_MODE_EVENT_FALLING) || ((MODE) == PWR_PVD_MODE_EVENT_RISING_FALLING) || ((MODE) == PWR_PVD_MODE_NORMAL))IS_PWR_PVD_LEVEL(LEVEL)(((LEVEL) == PWR_PVDLEVEL_0) || ((LEVEL) == PWR_PVDLEVEL_1)|| ((LEVEL) == PWR_PVDLEVEL_2) || ((LEVEL) == PWR_PVDLEVEL_3)|| ((LEVEL) == PWR_PVDLEVEL_4) || ((LEVEL) == PWR_PVDLEVEL_5)|| ((LEVEL) == PWR_PVDLEVEL_6) || ((LEVEL) == PWR_PVDLEVEL_7))PWR_EXTI_LINE_PVD((uint32_t)EXTI_IMR_IM16)__HAL_PWR_PVD_EXTI_GENERATE_SWIT()(EXTI->SWIER |= (PWR_EXTI_LINE_PVD))__HAL_PWR_PVD_EXTI_CLEAR_FLAG()(EXTI->PR = (PWR_EXTI_LINE_PVD))__HAL_PWR_PVD_EXTI_GET_FLAG()(EXTI->PR & (PWR_EXTI_LINE_PVD))__HAL_PWR_PVD_EXTI_DISABLE_RISING_FALLING_EDGE()__HAL_PWR_PVD_EXTI_DISABLE_RISING_EDGE();__HAL_PWR_PVD_EXTI_DISABLE_FALLING_EDGE();__HAL_PWR_PVD_EXTI_ENABLE_RISING_FALLING_EDGE()__HAL_PWR_PVD_EXTI_ENABLE_RISING_EDGE();__HAL_PWR_PVD_EXTI_ENABLE_FALLING_EDGE();__HAL_PWR_PVD_EXTI_DISABLE_FALLING_EDGE()CLEAR_BIT(EXTI->FTSR, PWR_EXTI_LINE_PVD)__HAL_PWR_PVD_EXTI_ENABLE_FALLING_EDGE()SET_BIT(EXTI->FTSR, PWR_EXTI_LINE_PVD)__HAL_PWR_PVD_EXTI_DISABLE_RISING_EDGE()CLEAR_BIT(EXTI->RTSR, PWR_EXTI_LINE_PVD)__HAL_PWR_PVD_EXTI_ENABLE_RISING_EDGE()SET_BIT(EXTI->RTSR, PWR_EXTI_LINE_PVD)__HAL_PWR_PVD_EXTI_DISABLE_EVENT()(EXTI->EMR &= ~(PWR_EXTI_LINE_PVD))__HAL_PWR_PVD_EXTI_ENABLE_EVENT()(EXTI->EMR |= (PWR_EXTI_LINE_PVD))__HAL_PWR_PVD_EXTI_DISABLE_IT()(EXTI->IMR &= ~(PWR_EXTI_LINE_PVD))__HAL_PWR_PVD_EXTI_ENABLE_IT()(EXTI->IMR |= (PWR_EXTI_LINE_PVD))__HAL_PWR_CLEAR_FLAG(__FLAG__)(PWR->CR1 |= (__FLAG__) << 2)__HAL_PWR_GET_FLAG(__FLAG__)__HAL_PWR_VOLTAGESCALING_CONFIG(__REGULATOR__)do { __IO uint32_t tmpreg; MODIFY_REG(PWR->CR1, PWR_CR1_VOS, (__REGULATOR__)); tmpreg = READ_BIT(PWR->CR1, PWR_CR1_VOS); UNUSED(tmpreg); } while(0)PWR_FLAG_VOSRDYPWR_FLAG_BRRPWR_FLAG_PVDOPWR_FLAG_SBPWR_FLAG_WUPWR_REGULATOR_VOLTAGE_SCALE3PWR_REGULATOR_VOLTAGE_SCALE2PWR_REGULATOR_VOLTAGE_SCALE1PWR_STOPENTRY_WFEPWR_STOPENTRY_WFIPWR_SLEEPENTRY_WFEPWR_SLEEPENTRY_WFIPWR_LOWPOWERREGULATOR_ONPWR_MAINREGULATOR_ON((uint32_t)0x00020003U)((uint32_t)0x00020002U)((uint32_t)0x00020001U)((uint32_t)0x00010003U)((uint32_t)0x00010002U)((uint32_t)0x00010001U)PWR_PVDLEVEL_7PWR_PVDLEVEL_6PWR_PVDLEVEL_5PWR_PVDLEVEL_4PWR_PVDLEVEL_3PWR_PVDLEVEL_2PWR_PVDLEVEL_1PWR_PVDLEVEL_0__STM32F7xx_HAL_PWR_H/* __STM32F7xx_HAL_PWR_H *//** @defgroup PWR_IS_PWR_Definitions PWR Private macros to check input parameters
  * @{
  *//** @defgroup PWR_Private_Macros PWR Private Macros
  * @{
  *//*!< External interrupt line 16 Connected to the PVD EXTI Line *//** @defgroup PWR_PVD_EXTI_Line PWR PVD EXTI Line
  * @{
  *//** @defgroup PWR_Private_Constants PWR Private Constants
  * @{
  *//* Cortex System Control functions  *******************************************//* Power PVD IRQ Handler *//* Low Power modes entry *//* WakeUp pins configuration *//* PVD configuration *//** @addtogroup PWR_Exported_Functions_Group2 Peripheral Control functions 
  * @{
  *//** @addtogroup PWR_Exported_Functions_Group1 Initialization and de-initialization functions 
  * @{
  *//** @addtogroup PWR_Exported_Functions PWR Exported Functions
  * @{
  *//* Include PWR HAL Extension module *//**
  * @brief  Generates a Software interrupt on PVD EXTI line.
  * @retval None
  *//**
  * @brief Clear the PVD Exti flag.
  * @retval None.
  *//**
  * @brief checks whether the specified PVD Exti interrupt flag is set or not.
  * @retval EXTI PVD Line Status.
  *//**
  * @brief Disable the PVD Extended Interrupt Rising & Falling Trigger.
  * @retval None.
  *//**
  * @brief  PVD EXTI line configuration: set rising & falling edge trigger.
  * @retval None.
  *//**
  * @brief Disable the PVD Extended Interrupt Falling Trigger.
  * @retval None.
  *//**
  * @brief Enable the PVD Extended Interrupt Falling Trigger.
  * @retval None.
  *//**
  * @brief Disable the PVD Extended Interrupt Rising Trigger.
  * @retval None.
  *//**
  * @brief Enable the PVD Extended Interrupt Rising Trigger.
  * @retval None.
  *//**
  * @brief Disable event on PVD Exti Line 16.
  * @retval None.
  *//**
  * @brief Enable event on PVD Exti Line 16.
  * @retval None.
  *//**
  * @brief Disable the PVD EXTI Line 16.
  * @retval None.
  *//**
  * @brief Enable the PVD Exti Line 16.
  * @retval None.
  *//** @brief  Clear the PWR's pending flags.
  * @param  __FLAG__ specifies the flag to clear.
  *          This parameter can be one of the following values:
  *            @arg PWR_FLAG_SB: StandBy flag
  *//** @brief  Check PWR flag is set or not.
  * @param  __FLAG__ specifies the flag to check.
  *           This parameter can be one of the following values:
  *            @arg PWR_FLAG_WU: Wake Up flag. This flag indicates that a wakeup event 
  *                  was received on the internal wakeup line in standby mode (RTC alarm (Alarm A or Alarm B),
  *                  RTC Tamper event, RTC TimeStamp event or RTC Wakeup)).
  *            @arg PWR_FLAG_SB: StandBy flag. This flag indicates that the system was
  *                  resumed from StandBy mode.    
  *            @arg PWR_FLAG_PVDO: PVD Output. This flag is valid only if PVD is enabled 
  *                  by the HAL_PWR_EnablePVD() function. The PVD is stopped by Standby mode 
  *                  For this reason, this bit is equal to 0 after Standby or reset
  *                  until the PVDE bit is set.
  *            @arg PWR_FLAG_BRR: Backup regulator ready flag. This bit is not reset 
  *                  when the device wakes up from Standby mode or by a system reset 
  *                  or power reset.  
  *            @arg PWR_FLAG_VOSRDY: This flag indicates that the Regulator voltage 
  *                 scaling output selection is ready.
  * @retval The new state of __FLAG__ (TRUE or FALSE).
  *//** @brief  macros configure the main internal regulator output voltage.
  * @param  __REGULATOR__ specifies the regulator output voltage to achieve
  *         a tradeoff between performance and power consumption when the device does
  *         not operate at the maximum frequency (refer to the datasheets for more details).
  *          This parameter can be one of the following values:
  *            @arg PWR_REGULATOR_VOLTAGE_SCALE1: Regulator voltage output Scale 1 mode
  *            @arg PWR_REGULATOR_VOLTAGE_SCALE2: Regulator voltage output Scale 2 mode
  *            @arg PWR_REGULATOR_VOLTAGE_SCALE3: Regulator voltage output Scale 3 mode
  * @retval None
  *//** @defgroup PWR_Exported_Macro PWR Exported Macro
  * @{
  *//** @defgroup PWR_Flag PWR Flag
  * @{
  *//** @defgroup PWR_Regulator_Voltage_Scale PWR Regulator Voltage Scale
  * @{
  *//** @defgroup PWR_STOP_mode_entry PWR STOP mode entry
  * @{
  *//** @defgroup PWR_SLEEP_mode_entry PWR SLEEP mode entry
  * @{
  *//** @defgroup PWR_Regulator_state_in_STOP_mode PWR Regulator state in SLEEP/STOP mode
  * @{
  *//*!< Event Mode with Rising/Falling edge trigger detection *//*!< Event Mode with Falling edge trigger detection *//*!< Event Mode with Rising edge trigger detection *//*!< External Interrupt Mode with Rising/Falling edge trigger detection *//*!< External Interrupt Mode with Falling edge trigger detection *//*!< External Interrupt Mode with Rising edge trigger detection *//*!< basic mode is used *//** @defgroup PWR_PVD_Mode PWR PVD Mode
  * @{
  *//* External input analog voltage 
                                                          (Compare internally to VREFINT) *//** @defgroup PWR_PVD_detection_level PWR PVD detection level
  * @{
  *//** @defgroup PWR_Exported_Constants PWR Exported Constants
  * @{
  *//*!< Mode: Specifies the operating mode for the selected pins.
                           This parameter can be a value of @ref PWR_PVD_Mode *//*!< PVDLevel: Specifies the PVD detection level.
                            This parameter can be a value of @ref PWR_PVD_detection_level *//**
  * @brief  PWR PVD configuration structure definition
  *//** @defgroup PWR_Exported_Types PWR Exported Types
  * @{
  *//** @addtogroup PWR
  * @{
  *//**
  ******************************************************************************
  * @file    stm32f7xx_hal_pwr.h
  * @author  MCD Application Team
  * @brief   Header file of PWR HAL module.
  ******************************************************************************
  * @attention
  *
  * Copyright (c) 2017 STMicroelectronics.
  * All rights reserved.
  *
  * This software is licensed under terms that can be found in the LICENSE file
  * in the root directory of this software component.
  * If no LICENSE file comes with this software, it is provided AS-IS.
  *
  ******************************************************************************
  */SLEEPEntryWakeUpPinxWakeUpPinPolaritysConfigPVDHAL_SAI_GetErrorconst SAI_HandleTypeDefconst SAI_HandleTypeDef *__SAI_HandleTypeDef *HAL_SAI_GetStateHAL_SAI_ErrorCallbackSAI_HandleTypeDef *HAL_SAI_RxCpltCallbackHAL_SAI_RxHalfCpltCallbackHAL_SAI_TxCpltCallbackHAL_SAI_TxHalfCpltCallbackHAL_SAI_IRQHandlerHAL_SAI_DisableRxMuteModeHAL_SAI_EnableRxMuteModeHAL_SAI_DisableTxMuteModeHAL_SAI_EnableTxMuteModeHAL_SAI_AbortHAL_SAI_DMAStopHAL_SAI_DMAResumeHAL_SAI_DMAPauseHAL_SAI_Receive_DMAHAL_SAI_Transmit_DMAHAL_SAI_Receive_ITHAL_SAI_Transmit_ITHAL_SAI_ReceiveHAL_SAI_TransmitHAL_SAI_MspDeInitHAL_SAI_MspInitHAL_SAI_DeInitHAL_SAI_InitHAL_SAI_InitProtocolSAI_HandleTypeDef__SAI_HandleTypeDefSAI_SlotInitTypeDefSAI_FrameInitTypeDefSAI_InitTypeDefSAIcallbackHAL_SAI_StateTypeDefHAL_SAI_STATE_RESETHAL_SAI_STATE_READYHAL_SAI_STATE_BUSYHAL_SAI_STATE_BUSY_TXHAL_SAI_STATE_BUSY_RXvolatile HAL_SAI_StateTypeDefInterruptServiceRoutinemutecallbackSlotInitFrameInitSAI_Block_TypeDef *SlotActiveSlotNumberSlotSizeFirstBitOffsetFSOffsetFSPolarityFSDefinitionActiveFrameLengthFrameLengthClockStrobingFirstBitDataSizeProtocolTriStateCompandingModeMonoStereoModeMckdivAudioFrequencyNoDividerOutputDriveSynchroExtSynchroAudioModeIS_SAI_BLOCK_ACTIVE_FRAME(LENGTH)((1 <= (LENGTH)) && ((LENGTH) <= 128))IS_SAI_BLOCK_FRAME_LENGTH(LENGTH)((8 <= (LENGTH)) && ((LENGTH) <= 256))IS_SAI_BLOCK_MASTER_DIVIDER(DIVIDER)((DIVIDER) <= 15U)IS_SAI_BLOCK_FS_DEFINITION(DEFINITION)(((DEFINITION) == SAI_FS_STARTFRAME) || ((DEFINITION) == SAI_FS_CHANNEL_IDENTIFICATION))IS_SAI_BLOCK_FS_POLARITY(POLARITY)(((POLARITY) == SAI_FS_ACTIVE_LOW) || ((POLARITY) == SAI_FS_ACTIVE_HIGH))IS_SAI_BLOCK_FS_OFFSET(OFFSET)(((OFFSET) == SAI_FS_FIRSTBIT) || ((OFFSET) == SAI_FS_BEFOREFIRSTBIT))IS_SAI_BLOCK_FIRSTBIT_OFFSET(OFFSET)((OFFSET) <= 24)IS_SAI_BLOCK_SLOT_SIZE(SIZE)(((SIZE) == SAI_SLOTSIZE_DATASIZE) || ((SIZE) == SAI_SLOTSIZE_16B) || ((SIZE) == SAI_SLOTSIZE_32B))IS_SAI_BLOCK_SLOT_NUMBER(NUMBER)((1 <= (NUMBER)) && ((NUMBER) <= 16))IS_SAI_SLOT_ACTIVE(ACTIVE)((ACTIVE) <= SAI_SLOTACTIVE_ALL)IS_SAI_MONO_STEREO_MODE(MODE)(((MODE) == SAI_MONOMODE) || ((MODE) == SAI_STEREOMODE))IS_SAI_BLOCK_TRISTATE_MANAGEMENT(STATE)(((STATE) == SAI_OUTPUT_NOTRELEASED) || ((STATE) == SAI_OUTPUT_RELEASED))IS_SAI_BLOCK_FIFO_THRESHOLD(THRESHOLD)(((THRESHOLD) == SAI_FIFOTHRESHOLD_EMPTY) || ((THRESHOLD) == SAI_FIFOTHRESHOLD_1QF) || ((THRESHOLD) == SAI_FIFOTHRESHOLD_HF) || ((THRESHOLD) == SAI_FIFOTHRESHOLD_3QF) || ((THRESHOLD) == SAI_FIFOTHRESHOLD_FULL))IS_SAI_BLOCK_COMPANDING_MODE(MODE)(((MODE) == SAI_NOCOMPANDING) || ((MODE) == SAI_ULAW_1CPL_COMPANDING) || ((MODE) == SAI_ALAW_1CPL_COMPANDING) || ((MODE) == SAI_ULAW_2CPL_COMPANDING) || ((MODE) == SAI_ALAW_2CPL_COMPANDING))IS_SAI_BLOCK_MUTE_VALUE(VALUE)(((VALUE) == SAI_ZERO_VALUE) || ((VALUE) == SAI_LAST_SENT_VALUE))IS_SAI_BLOCK_MUTE_COUNTER(COUNTER)((COUNTER) <= 63)IS_SAI_BLOCK_NODIVIDER(NODIVIDER)(((NODIVIDER) == SAI_MASTERDIVIDER_ENABLE) || ((NODIVIDER) == SAI_MASTERDIVIDER_DISABLE))IS_SAI_BLOCK_OUTPUT_DRIVE(DRIVE)(((DRIVE) == SAI_OUTPUTDRIVE_DISABLE) || ((DRIVE) == SAI_OUTPUTDRIVE_ENABLE))IS_SAI_BLOCK_SYNCHRO(SYNCHRO)(((SYNCHRO) == SAI_ASYNCHRONOUS) || ((SYNCHRO) == SAI_SYNCHRONOUS) || ((SYNCHRO) == SAI_SYNCHRONOUS_EXT_SAI1) || ((SYNCHRO) == SAI_SYNCHRONOUS_EXT_SAI2))IS_SAI_BLOCK_CLOCK_STROBING(CLOCK)(((CLOCK) == SAI_CLOCKSTROBING_FALLINGEDGE) || ((CLOCK) == SAI_CLOCKSTROBING_RISINGEDGE))IS_SAI_BLOCK_FIRST_BIT(BIT)(((BIT) == SAI_FIRSTBIT_MSB) || ((BIT) == SAI_FIRSTBIT_LSB))IS_SAI_BLOCK_DATASIZE(DATASIZE)(((DATASIZE) == SAI_DATASIZE_8) || ((DATASIZE) == SAI_DATASIZE_10) || ((DATASIZE) == SAI_DATASIZE_16) || ((DATASIZE) == SAI_DATASIZE_20) || ((DATASIZE) == SAI_DATASIZE_24) || ((DATASIZE) == SAI_DATASIZE_32))IS_SAI_BLOCK_PROTOCOL(PROTOCOL)(((PROTOCOL) == SAI_FREE_PROTOCOL) || ((PROTOCOL) == SAI_AC97_PROTOCOL) || ((PROTOCOL) == SAI_SPDIF_PROTOCOL))IS_SAI_BLOCK_MODE(MODE)(((MODE) == SAI_MODEMASTER_TX) || ((MODE) == SAI_MODEMASTER_RX) || ((MODE) == SAI_MODESLAVE_TX) || ((MODE) == SAI_MODESLAVE_RX))IS_SAI_AUDIO_FREQUENCY(AUDIO)(((AUDIO) == SAI_AUDIO_FREQUENCY_192K) || ((AUDIO) == SAI_AUDIO_FREQUENCY_96K) || ((AUDIO) == SAI_AUDIO_FREQUENCY_48K) || ((AUDIO) == SAI_AUDIO_FREQUENCY_44K) || ((AUDIO) == SAI_AUDIO_FREQUENCY_32K) || ((AUDIO) == SAI_AUDIO_FREQUENCY_22K) || ((AUDIO) == SAI_AUDIO_FREQUENCY_16K) || ((AUDIO) == SAI_AUDIO_FREQUENCY_11K) || ((AUDIO) == SAI_AUDIO_FREQUENCY_8K) || ((AUDIO) == SAI_AUDIO_FREQUENCY_MCKDIV))IS_SAI_PROTOCOL_DATASIZE(DATASIZE)(((DATASIZE) == SAI_PROTOCOL_DATASIZE_16BIT) || ((DATASIZE) == SAI_PROTOCOL_DATASIZE_16BITEXTENDED) || ((DATASIZE) == SAI_PROTOCOL_DATASIZE_24BIT) || ((DATASIZE) == SAI_PROTOCOL_DATASIZE_32BIT))IS_SAI_SUPPORTED_PROTOCOL(PROTOCOL)(((PROTOCOL) == SAI_I2S_STANDARD) || ((PROTOCOL) == SAI_I2S_MSBJUSTIFIED) || ((PROTOCOL) == SAI_I2S_LSBJUSTIFIED) || ((PROTOCOL) == SAI_PCM_LONG) || ((PROTOCOL) == SAI_PCM_SHORT))IS_SAI_BLOCK_SYNCEXT(STATE)(((STATE) == SAI_SYNCEXT_DISABLE) || ((STATE) == SAI_SYNCEXT_OUTBLOCKA_ENABLE) || ((STATE) == SAI_SYNCEXT_OUTBLOCKB_ENABLE))__HAL_SAI_DISABLE(__HANDLE__)((__HANDLE__)->Instance->CR1 &= ~SAI_xCR1_SAIEN)__HAL_SAI_ENABLE(__HANDLE__)((__HANDLE__)->Instance->CR1 |= SAI_xCR1_SAIEN)__HAL_SAI_CLEAR_FLAG(__HANDLE__,__FLAG__)((__HANDLE__)->Instance->CLRFR = (__FLAG__))__HAL_SAI_GET_FLAG(__HANDLE__,__FLAG__)__HAL_SAI_GET_IT_SOURCE(__HANDLE__,__INTERRUPT__)((((__HANDLE__)->Instance->IMR & (__INTERRUPT__)) == (__INTERRUPT__)) ? SET : RESET)__HAL_SAI_DISABLE_IT(__HANDLE__,__INTERRUPT__)((__HANDLE__)->Instance->IMR &= (~(__INTERRUPT__)))__HAL_SAI_ENABLE_IT(__HANDLE__,__INTERRUPT__)((__HANDLE__)->Instance->IMR |= (__INTERRUPT__))__HAL_SAI_RESET_HANDLE_STATE(__HANDLE__)((__HANDLE__)->State = HAL_SAI_STATE_RESET)((uint32_t)0x00050000U)((uint32_t)0x00030000U)SAI_FLAG_LFSDET((uint32_t)SAI_xSR_LFSDET)SAI_FLAG_AFSDET((uint32_t)SAI_xSR_AFSDET)SAI_FLAG_CNRDY((uint32_t)SAI_xSR_CNRDY)SAI_FLAG_FREQ((uint32_t)SAI_xSR_FREQ)SAI_FLAG_WCKCFG((uint32_t)SAI_xSR_WCKCFG)SAI_FLAG_MUTEDET((uint32_t)SAI_xSR_MUTEDET)SAI_FLAG_OVRUDR((uint32_t)SAI_xSR_OVRUDR)SAI_IT_LFSDET((uint32_t)SAI_xIMR_LFSDETIE)SAI_IT_AFSDET((uint32_t)SAI_xIMR_AFSDETIE)SAI_IT_CNRDY((uint32_t)SAI_xIMR_CNRDYIE)SAI_IT_FREQ((uint32_t)SAI_xIMR_FREQIE)SAI_IT_WCKCFG((uint32_t)SAI_xIMR_WCKCFGIE)SAI_IT_MUTEDET((uint32_t)SAI_xIMR_MUTEDETIE)SAI_IT_OVRUDR((uint32_t)SAI_xIMR_OVRUDRIE)SAI_LAST_SENT_VALUE((uint32_t)SAI_xCR2_MUTEVAL)SAI_ZERO_VALUESAI_ALAW_2CPL_COMPANDING((uint32_t)(SAI_xCR2_COMP_1 | SAI_xCR2_COMP_0 | SAI_xCR2_CPL))SAI_ULAW_2CPL_COMPANDING((uint32_t)(SAI_xCR2_COMP_1 | SAI_xCR2_CPL))SAI_ALAW_1CPL_COMPANDING((uint32_t)(SAI_xCR2_COMP_1 | SAI_xCR2_COMP_0))SAI_ULAW_1CPL_COMPANDING((uint32_t)(SAI_xCR2_COMP_1))SAI_NOCOMPANDINGSAI_FIFOTHRESHOLD_FULL((uint32_t)(SAI_xCR2_FTH_2))SAI_FIFOTHRESHOLD_3QF((uint32_t)(SAI_xCR2_FTH_1 | SAI_xCR2_FTH_0))SAI_FIFOTHRESHOLD_HF((uint32_t)(SAI_xCR2_FTH_1))SAI_FIFOTHRESHOLD_1QF((uint32_t)(SAI_xCR2_FTH_0))SAI_FIFOTHRESHOLD_EMPTYSAI_OUTPUT_RELEASED((uint32_t)SAI_xCR2_TRIS)SAI_OUTPUT_NOTRELEASEDSAI_MONOMODE((uint32_t)SAI_xCR1_MONO)SAI_SLOTACTIVE_ALLSAI_SLOTACTIVE_15SAI_SLOTACTIVE_14SAI_SLOTACTIVE_13SAI_SLOTACTIVE_12SAI_SLOTACTIVE_11SAI_SLOTACTIVE_10SAI_SLOTACTIVE_9SAI_SLOTACTIVE_8SAI_SLOTACTIVE_7SAI_SLOTACTIVE_6SAI_SLOTACTIVE_5SAI_SLOTACTIVE_4SAI_SLOTACTIVE_3SAI_SLOTACTIVE_2SAI_SLOTACTIVE_1SAI_SLOTACTIVE_0SAI_SLOT_NOTACTIVESAI_SLOTSIZE_32B((uint32_t)SAI_xSLOTR_SLOTSZ_1)SAI_SLOTSIZE_16B((uint32_t)SAI_xSLOTR_SLOTSZ_0)SAI_SLOTSIZE_DATASIZESAI_FS_BEFOREFIRSTBIT((uint32_t)SAI_xFRCR_FSOFF)SAI_FS_FIRSTBITSAI_FS_ACTIVE_HIGH((uint32_t)SAI_xFRCR_FSPOL)SAI_FS_ACTIVE_LOWSAI_FS_CHANNEL_IDENTIFICATION((uint32_t)SAI_xFRCR_FSDEF)SAI_FS_STARTFRAME((uint32_t)SAI_xCR1_NODIV)((uint32_t)SAI_xCR1_OUTDRIV)SAI_SYNCHRONOUS_EXT_SAI2SAI_SYNCHRONOUSSAI_ASYNCHRONOUSSAI_CLOCKSTROBING_RISINGEDGESAI_CLOCKSTROBING_FALLINGEDGESAI_FIRSTBIT_LSB((uint32_t)SAI_xCR1_LSBFIRST)SAI_FIRSTBIT_MSBSAI_DATASIZE_32((uint32_t)(SAI_xCR1_DS_2 | SAI_xCR1_DS_1 | SAI_xCR1_DS_0))SAI_DATASIZE_24((uint32_t)(SAI_xCR1_DS_2 | SAI_xCR1_DS_1))SAI_DATASIZE_20((uint32_t)(SAI_xCR1_DS_2 | SAI_xCR1_DS_0))SAI_DATASIZE_16((uint32_t)SAI_xCR1_DS_2)SAI_DATASIZE_10((uint32_t)(SAI_xCR1_DS_1 | SAI_xCR1_DS_0))SAI_DATASIZE_8((uint32_t)SAI_xCR1_DS_1)SAI_AC97_PROTOCOL((uint32_t)SAI_xCR1_PRTCFG_1)SAI_SPDIF_PROTOCOL((uint32_t)SAI_xCR1_PRTCFG_0)SAI_FREE_PROTOCOLSAI_MODESLAVE_RX((uint32_t)(SAI_xCR1_MODE_1 | SAI_xCR1_MODE_0))SAI_MODESLAVE_TX((uint32_t)SAI_xCR1_MODE_1)SAI_MODEMASTER_RX((uint32_t)SAI_xCR1_MODE_0)SAI_MODEMASTER_TXSAI_AUDIO_FREQUENCY_MCKDIVSAI_AUDIO_FREQUENCY_8K((uint32_t)8000U)SAI_AUDIO_FREQUENCY_11K((uint32_t)11025U)SAI_AUDIO_FREQUENCY_16K((uint32_t)16000U)SAI_AUDIO_FREQUENCY_22K((uint32_t)22050U)SAI_AUDIO_FREQUENCY_32K((uint32_t)32000U)SAI_AUDIO_FREQUENCY_44K((uint32_t)44100U)SAI_AUDIO_FREQUENCY_48K((uint32_t)48000U)SAI_AUDIO_FREQUENCY_96K((uint32_t)96000U)SAI_AUDIO_FREQUENCY_192K((uint32_t)192000U)SAI_PROTOCOL_DATASIZE_32BITSAI_PROTOCOL_DATASIZE_24BITSAI_PROTOCOL_DATASIZE_16BITEXTENDEDSAI_PROTOCOL_DATASIZE_16BITSAI_PCM_SHORTSAI_PCM_LONGSAI_I2S_LSBJUSTIFIEDSAI_I2S_MSBJUSTIFIEDSAI_I2S_STANDARDSAI_SYNCEXT_OUTBLOCKB_ENABLESAI_SYNCEXT_DISABLEHAL_SAI_ERROR_DMAHAL_SAI_ERROR_TIMEOUTHAL_SAI_ERROR_WCKCFGHAL_SAI_ERROR_CNREADYHAL_SAI_ERROR_LFSDETHAL_SAI_ERROR_AFSDETHAL_SAI_ERROR_UDRHAL_SAI_ERROR_OVRHAL_SAI_ERROR_NONE__STM32F7xx_HAL_SAI_H(USE_HAL_SAI_REGISTER_CALLBACKS == 1)/* __STM32F7xx_HAL_SAI_H *//** @defgroup SAI_Private_Functions SAI Private Functions
  * @{
  *//** @addtogroup SAI_Private_Macros
  * @{
  *//** @addtogroup SAI_Exported_Functions_Group3
  * @{
  *//* SAI IRQHandler and Callbacks used in non blocking modes (Interrupt and DMA) *//* Mute management *//* Abort function *//* Non-Blocking mode: DMA *//* Non-Blocking mode: Interrupt *//* Blocking mode: Polling *//** @addtogroup SAI_Exported_Functions_Group2
  * @{
  *//* SAI callbacks register/unregister functions ********************************//** @addtogroup SAI_Exported_Functions_Group1
  * @{
  *//** @addtogroup SAI_Exported_Functions
  * @{
  *//**
 * @}
 *//** @brief  Clear the specified SAI pending flag.
  * @param  __HANDLE__ specifies the SAI Handle.
  * @param  __FLAG__ specifies the flag to check.
  *          This parameter can be any combination of the following values:
  *            @arg SAI_FLAG_OVRUDR: Clear Overrun underrun
  *            @arg SAI_FLAG_MUTEDET: Clear Mute detection
  *            @arg SAI_FLAG_WCKCFG: Clear Wrong Clock Configuration
  *            @arg SAI_FLAG_FREQ: Clear FIFO request
  *            @arg SAI_FLAG_CNRDY: Clear Codec not ready
  *            @arg SAI_FLAG_AFSDET: Clear Anticipated frame synchronization detection
  *            @arg SAI_FLAG_LFSDET: Clear Late frame synchronization detection
  *
  * @retval None
  *//** @brief  Check whether the specified SAI flag is set or not.
  * @param  __HANDLE__ specifies the SAI Handle.
  * @param  __FLAG__ specifies the flag to check.
  *         This parameter can be one of the following values:
  *            @arg SAI_FLAG_OVRUDR: Overrun underrun flag.
  *            @arg SAI_FLAG_MUTEDET: Mute detection flag.
  *            @arg SAI_FLAG_WCKCFG: Wrong Clock Configuration flag.
  *            @arg SAI_FLAG_FREQ: FIFO request flag.
  *            @arg SAI_FLAG_CNRDY: Codec not ready flag.
  *            @arg SAI_FLAG_AFSDET: Anticipated frame synchronization detection flag.
  *            @arg SAI_FLAG_LFSDET: Late frame synchronization detection flag.
  * @retval The new state of __FLAG__ (TRUE or FALSE).
  *//** @brief  Check whether the specified SAI interrupt source is enabled or not.
  * @param  __HANDLE__ specifies the SAI Handle.
  * @param  __INTERRUPT__ specifies the SAI interrupt source to check.
  *         This parameter can be one of the following values:
  *            @arg SAI_IT_OVRUDR: Overrun underrun interrupt enable
  *            @arg SAI_IT_MUTEDET: Mute detection interrupt enable
  *            @arg SAI_IT_WCKCFG: Wrong Clock Configuration interrupt enable
  *            @arg SAI_IT_FREQ: FIFO request interrupt enable
  *            @arg SAI_IT_CNRDY: Codec not ready interrupt enable
  *            @arg SAI_IT_AFSDET: Anticipated frame synchronization detection interrupt enable
  *            @arg SAI_IT_LFSDET: Late frame synchronization detection interrupt enable
  * @retval The new state of __INTERRUPT__ (TRUE or FALSE).
  *//** @brief  Enable or disable the specified SAI interrupts.
  * @param  __HANDLE__ specifies the SAI Handle.
  * @param  __INTERRUPT__ specifies the interrupt source to enable or disable.
  *         This parameter can be one of the following values:
  *            @arg SAI_IT_OVRUDR: Overrun underrun interrupt enable
  *            @arg SAI_IT_MUTEDET: Mute detection interrupt enable
  *            @arg SAI_IT_WCKCFG: Wrong Clock Configuration interrupt enable
  *            @arg SAI_IT_FREQ: FIFO request interrupt enable
  *            @arg SAI_IT_CNRDY: Codec not ready interrupt enable
  *            @arg SAI_IT_AFSDET: Anticipated frame synchronization detection interrupt enable
  *            @arg SAI_IT_LFSDET: Late frame synchronization detection interrupt enable
  * @retval None
  *//* USE_HAL_SAI_REGISTER_CALLBACKS *//** @brief Reset SAI handle state.
  * @param  __HANDLE__ specifies the SAI Handle.
  * @retval None
  *//** @defgroup SAI_Exported_Macros SAI Exported Macros
  * @brief macros to handle interrupts and specific configurations
  * @{
  *//** @defgroup SAI_Block_Fifo_Status_Level   SAI Block Fifo Status Level
  * @{
  *//** @defgroup SAI_Block_Flags_Definition  SAI Block Flags Definition
  * @{
  *//** @defgroup SAI_Block_Interrupts_Definition SAI Block Interrupts Definition
  * @{
  *//** @defgroup SAI_Block_Mute_Value SAI Block Mute Value
  * @{
  *//** @defgroup SAI_Block_Companding_Mode SAI Block Companding Mode
  * @{
  *//** @defgroup SAI_Block_Fifo_Threshold SAI Block Fifo Threshold
  * @{
  *//** @defgroup SAI_TRIState_Management SAI TRIState Management
  * @{
  *//** @defgroup SAI_Mono_Stereo_Mode SAI Mono Stereo Mode
  * @{
  *//** @defgroup SAI_Block_Slot_Active SAI Block Slot Active
  * @{
  *//** @defgroup SAI_Block_Slot_Size SAI Block Slot Size
  * @{
  *//** @defgroup SAI_Block_FS_Offset SAI Block FS Offset
  * @{
  *//** @defgroup SAI_Block_FS_Polarity SAI Block FS Polarity
  * @{
  *//** @defgroup SAI_Block_FS_Definition SAI Block FS Definition
  * @{
  *//** @defgroup SAI_Block_NoDivider SAI Block NoDivider
  * @{
  *//** @defgroup SAI_Block_Output_Drive SAI Block Output Drive
  * @{
  *//*!< Synchronous with other SAI, SAI2 *//*!< Synchronous with other SAI, SAI1 *//*!< Synchronous with other block of same SAI *//*!< Asynchronous *//** @defgroup SAI_Block_Synchronization SAI Block Synchronization
  * @{
  *//** @defgroup SAI_Block_Clock_Strobing SAI Block Clock Strobing
  * @{
  *//** @defgroup SAI_Block_MSB_LSB_transmission SAI Block MSB LSB transmission
  * @{
  *//** @defgroup SAI_Block_Data_Size SAI Block Data Size
  * @{
  *//** @defgroup SAI_Block_Protocol SAI Block Protocol
  * @{
  *//** @defgroup SAI_Block_Mode SAI Block Mode
  * @{
  *//** @defgroup SAI_Audio_Frequency SAI Audio Frequency
  * @{
  *//** @defgroup SAI_Protocol_DataSize SAI protocol data size
  * @{
  *//** @defgroup SAI_Protocol SAI Supported protocol
  * @{
  *//** @defgroup SAI_Block_SyncExt SAI External synchronisation
  * @{
  *//*!< DMA error                                   *//*!< Timeout error                               *//*!< Wrong clock configuration                   *//*!< codec not ready                             *//*!< Late Frame synchronisation detection        *//*!< Anticipated Frame synchronisation detection *//*!< Underrun error                              *//*!< Overrun Error                               *//*!< No error                                    *//** @defgroup SAI_Error_Code SAI Error Code
  * @{
  *//** @defgroup SAI_Exported_Constants SAI Exported Constants
  * @{
  *//**
  * @brief  SAI callback pointer definition
  *//*!< SAI MSP de-init callback ID *//*!< SAI MSP init callback ID *//*!< SAI error callback ID *//*!< SAI transmit half complete callback ID *//*!< SAI transmit complete callback ID *//*!< SAI receive half complete callback ID *//*!< SAI receive complete callback ID *//**
  * @brief  SAI callback ID enumeration definition
  *//*!< SAI MSP de-init callback *//*!< SAI MSP init callback *//*!< SAI error callback *//*!< SAI transmit half complete callback *//*!< SAI transmit complete callback *//*!< SAI receive half complete callback *//*!< SAI receive complete callback *//*!< SAI Error code *//*!< SAI communication state *//*!< SAI locking object *//* function pointer for IRQ handler *//*!< SAI mute callback *//*!< SAI Rx DMA handle parameters *//*!< SAI Tx DMA handle parameters *//*!< SAI transfer counter *//*!< SAI transfer size *//*!< Pointer to SAI transfer Buffer *//*!< SAI Slot configuration parameters *//*!< SAI Frame configuration parameters *//*!< SAI communication parameters *//*!< SAI Blockx registers base address *//** @defgroup SAI_Handle_Structure_definition SAI Handle Structure definition
  * @brief  SAI handle Structure definition
  * @{
  *//*!< Specifies the slots in audio frame that will be activated.
                                 This parameter can be a value of @ref SAI_Block_Slot_Active *//*!< Specifies the number of slot in the audio frame.
                                 This parameter must be a number between Min_Data = 1 and Max_Data = 16 *//*!< Specifies the Slot Size.
                                 This parameter can be a value of @ref SAI_Block_Slot_Size *//*!< Specifies the position of first data transfer bit in the slot.
                                 This parameter must be a number between Min_Data = 0 and Max_Data = 24 *//** @defgroup SAI_Slot_Structure_definition SAI Slot Structure definition
  * @brief   SAI Block Slot Init Structure definition
  * @note    For SPDIF protocol, these parameters are not used (set by hardware).
  * @note    For AC97 protocol, only SlotActive parameter is used (the others are set by hardware).
  * @{
  *//*!< Specifies the Frame synchronization Offset.
                                    This parameter can be a value of @ref SAI_Block_FS_Offset *//*!< Specifies the Frame synchronization Polarity.
                                    This parameter can be a value of @ref SAI_Block_FS_Polarity *//*!< Specifies the Frame synchronization definition.
                                    This parameter can be a value of @ref SAI_Block_FS_Definition *//*!< Specifies the Frame synchronization active level length.
                                    This Parameter specifies the length in number of bit clock (SCK + 1)
                                    of the active level of FS signal in audio frame.
                                    This parameter must be a number between Min_Data = 1 and Max_Data = 128 *//*!< Specifies the Frame length, the number of SCK clocks for each audio frame.
                                    This parameter must be a number between Min_Data = 8 and Max_Data = 256.
                                    @note: If master clock MCLK_x pin is declared as an output, the frame length
                                           should be aligned to a number equal to power of 2 in order to keep
                                           in an audio frame, an integer number of MCLK pulses by bit Clock. *//** @defgroup SAI_Frame_Structure_definition SAI Frame Structure definition
  * @brief  SAI Frame Init structure definition
  * @note   For SPDIF and AC97 protocol, these parameters are not used (set by hardware).
  * @{
  *//*!< Specifies the SAI Block clock strobing edge sensitivity.
                                 This parameter can be a value of @ref SAI_Block_Clock_Strobing *//*!< Specifies whether data transfers start from MSB or LSB bit.
                                 This parameter can be a value of @ref SAI_Block_MSB_LSB_transmission *//*!< Specifies the SAI Block data size.
                                 This parameter can be a value of @ref SAI_Block_Data_Size *//*!< Specifies the SAI Block protocol.
                                 This parameter can be a value of @ref SAI_Block_Protocol *//* This part of the structure is automatically filled if your are using the high level initialisation
     function HAL_SAI_InitProtocol *//*!< Specifies the companding mode type.
                                     This parameter can be a value of @ref SAI_TRIState_Management *//*!< Specifies the companding mode type.
                                     This parameter can be a value of @ref SAI_Block_Companding_Mode *//*!< Specifies if the mono or stereo mode is selected.
                                     This parameter can be a value of @ref SAI_Mono_Stereo_Mode *//*!< Specifies the master clock divider.
                                     This parameter must be a number between Min_Data = 0 and Max_Data = 15.
                                     @note This parameter is used only if AudioFrequency is set to
                                           SAI_AUDIO_FREQUENCY_MCKDIV otherwise it is internally computed. *//*!< Specifies the audio frequency sampling.
                                     This parameter can be a value of @ref SAI_Audio_Frequency *//*!< Specifies SAI Block FIFO threshold.
                                     This parameter can be a value of @ref SAI_Block_Fifo_Threshold *//*!< Specifies whether master clock will be divided or not.
                                     This parameter can be a value of @ref SAI_Block_NoDivider
                                     @note: If bit NODIV in the SAI_xCR1 register is cleared, the frame length
                                            should be aligned to a number equal to a power of 2, from 8 to 256.
                                            If bit NODIV in the SAI_xCR1 register is set, the frame length can
                                            take any of the values without constraint since the input clock of
                                            the audio block should be equal to the bit clock.
                                            There is no MCLK_x clock which can be output. *//*!< Specifies when SAI Block outputs are driven.
                                     This parameter can be a value of @ref SAI_Block_Output_Drive
                                     @note this value has to be set before enabling the audio block
                                     but after the audio block configuration. *//*!< Specifies SAI external output synchronization, this setup is common
                                     for BlockA and BlockB
                                     This parameter can be a value of @ref SAI_Block_SyncExt
                                     @note: If both audio blocks of same SAI are used, this parameter has
                                            to be set to the same value for each audio block *//*!< Specifies SAI Block synchronization
                                     This parameter can be a value of @ref SAI_Block_Synchronization *//*!< Specifies the SAI Block audio Mode.
                                     This parameter can be a value of @ref SAI_Block_Mode *//** @defgroup SAI_Init_Structure_definition SAI Init Structure definition
  * @brief  SAI Init Structure definition
  * @{
  *//**
  * @brief  SAI Callback prototype
  *//*!< Data reception process is ongoing                  *//*!< Data transmission process is ongoing               *//*!< SAI internal process is ongoing                    *//*!< SAI initialized and ready for use                  *//*!< SAI not yet initialized or disabled                *//** @defgroup SAI_Exported_Types SAI Exported Types
  * @{
  *//** @addtogroup SAI
  * @{
  *//**
  ******************************************************************************
  * @file    stm32f7xx_hal_sai.h
  * @author  MCD Application Team
  * @brief   Header file of SAI HAL module.
  ******************************************************************************
  * @attention
  *
  * Copyright (c) 2017 STMicroelectronics.
  * All rights reserved.
  *
  * This software is licensed under terms that can be found in the LICENSE file
  * in the root directory of this software component.
  * If no LICENSE file comes with this software, it is provided AS-IS.
  *
  ******************************************************************************
  */hsaicallbackvalprotocoldatasizenbslotSDMMC_GetCmdResp7SDMMC_GetCmdResp6SDMMC_GetCmdResp3SDMMC_GetCmdResp2SDMMC_GetCmdResp1SDMMC_CmdSendEXTCSDSDMMC_CmdSwitchSDMMC_CmdOpConditionSDMMC_CmdStatusRegisterSDMMC_CmdSendStatusSDMMC_CmdSetRelAddMmcSDMMC_CmdSetRelAddSDMMC_CmdSendCSDSDMMC_CmdSendCIDSDMMC_CmdSendSCRSDMMC_CmdBusWidthSDMMC_CmdAppOperCommandSDMMC_CmdAppCommandSDMMC_CmdOperCondSDMMC_CmdGoIdleStateSDMMC_CmdSelDeselSDMMC_CmdStopTransferSDMMC_CmdEraseSDMMC_CmdSDEraseEndAddSDMMC_CmdEraseEndAddSDMMC_CmdSDEraseStartAddSDMMC_CmdEraseStartAddSDMMC_CmdWriteMultiBlockSDMMC_CmdWriteSingleBlockSDMMC_CmdReadMultiBlockSDMMC_CmdReadSingleBlockSDMMC_CmdBlockLengthSDMMC_SetSDMMCReadWaitModeSDMMC_GetFIFOCountSDMMC_GetDataCounterSDMMC_ConfigDataSDMMC_DataInitTypeDef *SDMMC_GetResponseSDMMC_GetCommandResponseSDMMC_SendCommandSDMMC_CmdInitTypeDef *SDMMC_GetPowerStateSDMMC_PowerState_OFFSDMMC_PowerState_ONSDMMC_WriteFIFOSDMMC_ReadFIFOSDMMC_InitSDMMC_DataInitTypeDefSDMMC_CmdInitTypeDefSDMMC_InitTypeDefDPSMTransferModeTransferDirDataBlockSizeDataTimeOutCPSMWaitForInterruptResponseCmdIndexArgumentClockDivHardwareFlowControlBusWideClockPowerSaveClockBypassClockEdge__SDMMC_SUSPEND_CMD_DISABLE(__INSTANCE__)((__INSTANCE__)->CMD &= ~SDMMC_CMD_SDIOSUSPEND)__SDMMC_SUSPEND_CMD_ENABLE(__INSTANCE__)((__INSTANCE__)->CMD |= SDMMC_CMD_SDIOSUSPEND)__SDMMC_OPERATION_DISABLE(__INSTANCE__)((__INSTANCE__)->DCTRL &= ~SDMMC_DCTRL_SDIOEN)__SDMMC_OPERATION_ENABLE(__INSTANCE__)((__INSTANCE__)->DCTRL |= SDMMC_DCTRL_SDIOEN)__SDMMC_STOP_READWAIT_DISABLE(__INSTANCE__)((__INSTANCE__)->DCTRL &= ~SDMMC_DCTRL_RWSTOP)__SDMMC_STOP_READWAIT_ENABLE(__INSTANCE__)((__INSTANCE__)->DCTRL |= SDMMC_DCTRL_RWSTOP)__SDMMC_START_READWAIT_DISABLE(__INSTANCE__)((__INSTANCE__)->DCTRL &= ~SDMMC_DCTRL_RWSTART)__SDMMC_START_READWAIT_ENABLE(__INSTANCE__)((__INSTANCE__)->DCTRL |= SDMMC_DCTRL_RWSTART)__SDMMC_CLEAR_IT(__INSTANCE__,__INTERRUPT__)((__INSTANCE__)->ICR = (__INTERRUPT__))__SDMMC_GET_IT(__INSTANCE__, __INTERRUPT__) (((__INSTANCE__)->STA &(__INTERRUPT__)) == (__INTERRUPT__))__SDMMC_CLEAR_FLAG(__INSTANCE__,__FLAG__)((__INSTANCE__)->ICR = (__FLAG__))__SDMMC_GET_FLAG(__INSTANCE__,__FLAG__)(((__INSTANCE__)->STA &(__FLAG__)) != 0U)__SDMMC_DISABLE_IT(__INSTANCE__,__INTERRUPT__)((__INSTANCE__)->MASK &= ~(__INTERRUPT__))__SDMMC_ENABLE_IT(__INSTANCE__,__INTERRUPT__)((__INSTANCE__)->MASK |= (__INTERRUPT__))__SDMMC_DMA_DISABLE(__INSTANCE__)((__INSTANCE__)->DCTRL &= ~SDMMC_DCTRL_DMAEN)__SDMMC_DMA_ENABLE(__INSTANCE__)((__INSTANCE__)->DCTRL |= SDMMC_DCTRL_DMAEN)__SDMMC_DISABLE(__INSTANCE__)((__INSTANCE__)->CLKCR &= ~SDMMC_CLKCR_CLKEN)__SDMMC_ENABLE(__INSTANCE__)((__INSTANCE__)->CLKCR |= SDMMC_CLKCR_CLKEN)SDMMC_INIT_CLK_DIV((uint8_t)0x76)CMD_CLEAR_MASK((uint32_t)(SDMMC_CMD_CMDINDEX | SDMMC_CMD_WAITRESP | SDMMC_CMD_WAITINT | SDMMC_CMD_WAITPEND | SDMMC_CMD_CPSMEN | SDMMC_CMD_SDIOSUSPEND))DCTRL_CLEAR_MASK((uint32_t)(SDMMC_DCTRL_DTEN | SDMMC_DCTRL_DTDIR | SDMMC_DCTRL_DTMODE | SDMMC_DCTRL_DBLOCKSIZE))CLKCR_CLEAR_MASK((uint32_t)(SDMMC_CLKCR_CLKDIV | SDMMC_CLKCR_PWRSAV | SDMMC_CLKCR_BYPASS | SDMMC_CLKCR_WIDBUS | SDMMC_CLKCR_NEGEDGE | SDMMC_CLKCR_HWFC_EN))SDMMC_STATIC_DATA_FLAGS((uint32_t)(SDMMC_FLAG_DCRCFAIL | SDMMC_FLAG_DTIMEOUT | SDMMC_FLAG_TXUNDERR | SDMMC_FLAG_RXOVERR | SDMMC_FLAG_DATAEND | SDMMC_FLAG_DBCKEND))SDMMC_STATIC_CMD_FLAGS((uint32_t)(SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CTIMEOUT | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CMDSENT))((uint32_t)(SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_DCRCFAIL | SDMMC_FLAG_CTIMEOUT | SDMMC_FLAG_DTIMEOUT | SDMMC_FLAG_TXUNDERR | SDMMC_FLAG_RXOVERR | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CMDSENT | SDMMC_FLAG_DATAEND | SDMMC_FLAG_DBCKEND | SDMMC_FLAG_SDIOIT))SDMMC_FLAG_SDIOITSDMMC_FLAG_RXDAVLSDMMC_FLAG_TXDAVLSDMMC_FLAG_RXFIFOESDMMC_FLAG_TXFIFOESDMMC_FLAG_RXFIFOFSDMMC_FLAG_TXFIFOFSDMMC_FLAG_RXFIFOHFSDMMC_FLAG_TXFIFOHESDMMC_FLAG_RXACTSDMMC_FLAG_TXACTSDMMC_FLAG_CMDACTSDMMC_FLAG_DBCKENDSDMMC_FLAG_DATAENDSDMMC_FLAG_CMDSENTSDMMC_FLAG_CMDRENDSDMMC_FLAG_RXOVERRSDMMC_FLAG_TXUNDERRSDMMC_FLAG_DTIMEOUTSDMMC_FLAG_CTIMEOUTSDMMC_FLAG_DCRCFAILSDMMC_FLAG_CCRCFAILSDMMC_IT_SDIOITSDMMC_IT_RXDAVLSDMMC_IT_TXDAVLSDMMC_IT_RXFIFOESDMMC_IT_TXFIFOESDMMC_IT_RXFIFOFSDMMC_IT_TXFIFOFSDMMC_IT_RXFIFOHFSDMMC_IT_TXFIFOHESDMMC_IT_RXACTSDMMC_IT_TXACTSDMMC_IT_CMDACTSDMMC_IT_DBCKENDSDMMC_IT_DATAENDSDMMC_IT_CMDSENTSDMMC_IT_CMDRENDSDMMC_IT_RXOVERRSDMMC_IT_TXUNDERRSDMMC_IT_DTIMEOUTSDMMC_IT_CTIMEOUTSDMMC_IT_DCRCFAILSDMMC_IT_CCRCFAILIS_SDMMC_READWAIT_MODE(MODE)(((MODE) == SDMMC_READ_WAIT_MODE_CLK) || ((MODE) == SDMMC_READ_WAIT_MODE_DATA2))SDMMC_READ_WAIT_MODE_CLK(SDMMC_DCTRL_RWMOD)SDMMC_READ_WAIT_MODE_DATA2IS_SDMMC_DPSM(DPSM)(((DPSM) == SDMMC_DPSM_DISABLE) || ((DPSM) == SDMMC_DPSM_ENABLE))SDMMC_DPSM_ENABLESDMMC_DPSM_DISABLEIS_SDMMC_TRANSFER_MODE(MODE)(((MODE) == SDMMC_TRANSFER_MODE_BLOCK) || ((MODE) == SDMMC_TRANSFER_MODE_STREAM))SDMMC_TRANSFER_MODE_STREAMSDMMC_TRANSFER_MODE_BLOCKIS_SDMMC_TRANSFER_DIR(DIR)(((DIR) == SDMMC_TRANSFER_DIR_TO_CARD) || ((DIR) == SDMMC_TRANSFER_DIR_TO_SDMMC))SDMMC_TRANSFER_DIR_TO_SDMMCSDMMC_TRANSFER_DIR_TO_CARDIS_SDMMC_BLOCK_SIZE(SIZE)(((SIZE) == SDMMC_DATABLOCK_SIZE_1B) || ((SIZE) == SDMMC_DATABLOCK_SIZE_2B) || ((SIZE) == SDMMC_DATABLOCK_SIZE_4B) || ((SIZE) == SDMMC_DATABLOCK_SIZE_8B) || ((SIZE) == SDMMC_DATABLOCK_SIZE_16B) || ((SIZE) == SDMMC_DATABLOCK_SIZE_32B) || ((SIZE) == SDMMC_DATABLOCK_SIZE_64B) || ((SIZE) == SDMMC_DATABLOCK_SIZE_128B) || ((SIZE) == SDMMC_DATABLOCK_SIZE_256B) || ((SIZE) == SDMMC_DATABLOCK_SIZE_512B) || ((SIZE) == SDMMC_DATABLOCK_SIZE_1024B) || ((SIZE) == SDMMC_DATABLOCK_SIZE_2048B) || ((SIZE) == SDMMC_DATABLOCK_SIZE_4096B) || ((SIZE) == SDMMC_DATABLOCK_SIZE_8192B) || ((SIZE) == SDMMC_DATABLOCK_SIZE_16384B))SDMMC_DATABLOCK_SIZE_16384B(SDMMC_DCTRL_DBLOCKSIZE_1|SDMMC_DCTRL_DBLOCKSIZE_2|SDMMC_DCTRL_DBLOCKSIZE_3)SDMMC_DATABLOCK_SIZE_8192B(SDMMC_DCTRL_DBLOCKSIZE_0|SDMMC_DCTRL_DBLOCKSIZE_2|SDMMC_DCTRL_DBLOCKSIZE_3)SDMMC_DATABLOCK_SIZE_4096B(SDMMC_DCTRL_DBLOCKSIZE_2|SDMMC_DCTRL_DBLOCKSIZE_3)SDMMC_DATABLOCK_SIZE_2048B(SDMMC_DCTRL_DBLOCKSIZE_0|SDMMC_DCTRL_DBLOCKSIZE_1|SDMMC_DCTRL_DBLOCKSIZE_3)SDMMC_DATABLOCK_SIZE_1024B(SDMMC_DCTRL_DBLOCKSIZE_1|SDMMC_DCTRL_DBLOCKSIZE_3)SDMMC_DATABLOCK_SIZE_512B(SDMMC_DCTRL_DBLOCKSIZE_0|SDMMC_DCTRL_DBLOCKSIZE_3)SDMMC_DATABLOCK_SIZE_256BSDMMC_DATABLOCK_SIZE_128B(SDMMC_DCTRL_DBLOCKSIZE_0|SDMMC_DCTRL_DBLOCKSIZE_1|SDMMC_DCTRL_DBLOCKSIZE_2)SDMMC_DATABLOCK_SIZE_64B(SDMMC_DCTRL_DBLOCKSIZE_1|SDMMC_DCTRL_DBLOCKSIZE_2)SDMMC_DATABLOCK_SIZE_32B(SDMMC_DCTRL_DBLOCKSIZE_0|SDMMC_DCTRL_DBLOCKSIZE_2)SDMMC_DATABLOCK_SIZE_16BSDMMC_DATABLOCK_SIZE_8B(SDMMC_DCTRL_DBLOCKSIZE_0|SDMMC_DCTRL_DBLOCKSIZE_1)SDMMC_DATABLOCK_SIZE_4BSDMMC_DATABLOCK_SIZE_2BSDMMC_DATABLOCK_SIZE_1BIS_SDMMC_DATA_LENGTH(LENGTH)((LENGTH) <= 0x01FFFFFFU)IS_SDMMC_RESP(RESP)(((RESP) == SDMMC_RESP1) || ((RESP) == SDMMC_RESP2) || ((RESP) == SDMMC_RESP3) || ((RESP) == SDMMC_RESP4))SDMMC_RESP4SDMMC_RESP3SDMMC_RESP2SDMMC_RESP1IS_SDMMC_CPSM(CPSM)(((CPSM) == SDMMC_CPSM_DISABLE) || ((CPSM) == SDMMC_CPSM_ENABLE))SDMMC_CPSM_ENABLESDMMC_CPSM_DISABLEIS_SDMMC_WAIT(WAIT)(((WAIT) == SDMMC_WAIT_NO) || ((WAIT) == SDMMC_WAIT_IT) || ((WAIT) == SDMMC_WAIT_PEND))SDMMC_WAIT_PENDSDMMC_WAIT_ITSDMMC_WAIT_NOIS_SDMMC_RESPONSE(RESPONSE)(((RESPONSE) == SDMMC_RESPONSE_NO) || ((RESPONSE) == SDMMC_RESPONSE_SHORT) || ((RESPONSE) == SDMMC_RESPONSE_LONG))SDMMC_RESPONSE_LONGSDMMC_RESPONSE_SHORTSDMMC_RESPONSE_NOIS_SDMMC_CMD_INDEX(INDEX)((INDEX) < 0x40U)IS_SDMMC_CLKDIV(DIV)((DIV) <= 0xFFU)IS_SDMMC_HARDWARE_FLOW_CONTROL(CONTROL)(((CONTROL) == SDMMC_HARDWARE_FLOW_CONTROL_DISABLE) || ((CONTROL) == SDMMC_HARDWARE_FLOW_CONTROL_ENABLE))SDMMC_HARDWARE_FLOW_CONTROL_ENABLEIS_SDMMC_BUS_WIDE(WIDE)(((WIDE) == SDMMC_BUS_WIDE_1B) || ((WIDE) == SDMMC_BUS_WIDE_4B) || ((WIDE) == SDMMC_BUS_WIDE_8B))SDMMC_BUS_WIDE_8BSDMMC_BUS_WIDE_4BIS_SDMMC_CLOCK_POWER_SAVE(SAVE)(((SAVE) == SDMMC_CLOCK_POWER_SAVE_DISABLE) || ((SAVE) == SDMMC_CLOCK_POWER_SAVE_ENABLE))SDMMC_CLOCK_POWER_SAVE_ENABLEIS_SDMMC_CLOCK_BYPASS(BYPASS)(((BYPASS) == SDMMC_CLOCK_BYPASS_DISABLE) || ((BYPASS) == SDMMC_CLOCK_BYPASS_ENABLE))SDMMC_CLOCK_BYPASS_ENABLEIS_SDMMC_CLOCK_EDGE(EDGE)(((EDGE) == SDMMC_CLOCK_EDGE_RISING) || ((EDGE) == SDMMC_CLOCK_EDGE_FALLING))SDMMC_CLOCK_EDGE_FALLINGSDMMC_STOPTRANSFERTIMEOUT100000000USDMMC_MAXERASETIMEOUT63000USDMMC_CMDTIMEOUT5000USDMMC_CCCC_ERASESDMMC_HALFFIFOBYTESSDMMC_HALFFIFOSDMMC_MAX_DATA_LENGTH0x01FFFFFFUSDMMC_24TO31BITSSDMMC_16TO23BITSSDMMC_8TO15BITSSDMMC_0TO7BITSSDMMC_DATATIMEOUTSDMMC_CARD_LOCKEDSDMMC_SINGLE_BUS_SUPPORTSDMMC_WIDE_BUS_SUPPORTSDMMC_ALLZEROSDMMC_MAX_TRIAL0x0000FFFFUSDMMC_MAX_VOLT_TRIALSD_SWITCH_1_8V_CAPACITYSDMMC_CHECK_PATTERN0x000001AAUSDMMC_STD_CAPACITYSDMMC_HIGH_CAPACITYSDMMC_VOLTAGE_WINDOW_SD0x80100000USDMMC_R6_COM_CRC_FAILEDSDMMC_R6_ILLEGAL_CMDSDMMC_R6_GENERAL_UNKNOWN_ERRORSDMMC_OCR_ERRORBITS0xFDFFE008USDMMC_OCR_AKE_SEQ_ERRORSDMMC_OCR_ERASE_RESETSDMMC_OCR_CARD_ECC_DISABLEDSDMMC_OCR_WP_ERASE_SKIPSDMMC_OCR_CID_CSD_OVERWRITESDMMC_OCR_STREAM_WRITE_OVERRUNSDMMC_OCR_STREAM_READ_UNDERRUNSDMMC_OCR_GENERAL_UNKNOWN_ERRORSDMMC_OCR_CC_ERRORSDMMC_OCR_CARD_ECC_FAILEDSDMMC_OCR_ILLEGAL_CMDSDMMC_OCR_COM_CRC_FAILEDSDMMC_OCR_LOCK_UNLOCK_FAILEDSDMMC_OCR_WRITE_PROT_VIOLATIONSDMMC_OCR_BAD_ERASE_PARAMSDMMC_OCR_ERASE_SEQ_ERRSDMMC_OCR_BLOCK_LEN_ERRSDMMC_OCR_ADDR_MISALIGNEDSDMMC_OCR_ADDR_OUT_OF_RANGESDMMC_CMD_SD_APP_SECURE_WRITE_MKB48USDMMC_CMD_SD_APP_CHANGE_SECURE_AREA49USDMMC_CMD_SD_APP_SECURE_ERASE38USDMMC_CMD_SD_APP_SECURE_WRITE_MULTIPLE_BLOCKSDMMC_CMD_SD_APP_SECURE_READ_MULTIPLE_BLOCKSDMMC_CMD_SD_APP_GET_CER_RES1SDMMC_CMD_SD_APP_SET_CER_RES247USDMMC_CMD_SD_APP_GET_CER_RN2SDMMC_CMD_SD_APP_SET_CER_RN145USDMMC_CMD_SD_APP_GET_MID44USDMMC_CMD_SD_APP_GET_MKBSDMMC_CMD_SDMMC_RW_EXTENDED53USDMMC_CMD_SDMMC_RW_DIRECT52USDMMC_CMD_SD_APP_SEND_SCR51USDMMC_CMD_SD_APP_SET_CLR_CARD_DETECT42USDMMC_CMD_SD_APP_OP_COND41USDMMC_CMD_SD_APP_SEND_NUM_WRITE_BLOCKSSDMMC_CMD_SD_APP_STATUSSDMMC_CMD_APP_SD_SET_BUSWIDTHSDMMC_CMD_NO_CMD64USDMMC_CMD_GEN_CMDSDMMC_CMD_APP_CMDSDMMC_CMD_LOCK_UNLOCKSDMMC_CMD_GO_IRQ_STATESDMMC_CMD_FAST_IOSDMMC_CMD_ERASESDMMC_CMD_ERASE_GRP_END36USDMMC_CMD_ERASE_GRP_START35USDMMC_CMD_SD_ERASE_GRP_END33USDMMC_CMD_SD_ERASE_GRP_STARTSDMMC_CMD_SEND_WRITE_PROTSDMMC_CMD_CLR_WRITE_PROTSDMMC_CMD_SET_WRITE_PROTSDMMC_CMD_PROG_CSDSDMMC_CMD_PROG_CIDSDMMC_CMD_WRITE_MULT_BLOCKSDMMC_CMD_WRITE_SINGLE_BLOCKSDMMC_CMD_SET_BLOCK_COUNTSDMMC_CMD_WRITE_DAT_UNTIL_STOPSDMMC_CMD_HS_BUSTEST_WRITESDMMC_CMD_READ_MULT_BLOCKSDMMC_CMD_READ_SINGLE_BLOCKSDMMC_CMD_SET_BLOCKLENSDMMC_CMD_GO_INACTIVE_STATESDMMC_CMD_HS_BUSTEST_READSDMMC_CMD_SEND_STATUSSDMMC_CMD_STOP_TRANSMISSIONSDMMC_CMD_READ_DAT_UNTIL_STOPSDMMC_CMD_SEND_CIDSDMMC_CMD_SEND_CSDSDMMC_CMD_HS_SEND_EXT_CSDSDMMC_CMD_SEL_DESEL_CARDSDMMC_CMD_HS_SWITCHSDMMC_CMD_SDMMC_SEN_OP_CONDSDMMC_CMD_SET_DSRSDMMC_CMD_SET_REL_ADDRSDMMC_CMD_ALL_SEND_CIDSDMMC_CMD_SEND_OP_CONDSDMMC_CMD_GO_IDLE_STATESDMMC_ERROR_TIMEOUTSDMMC_ERROR_DMASDMMC_ERROR_BUSYSDMMC_ERROR_UNSUPPORTED_FEATURESDMMC_ERROR_INVALID_PARAMETERSDMMC_ERROR_REQUEST_NOT_APPLICABLESDMMC_ERROR_ADDR_OUT_OF_RANGESDMMC_ERROR_INVALID_VOLTRANGESDMMC_ERROR_AKE_SEQ_ERRSDMMC_ERROR_ERASE_RESETSDMMC_ERROR_CARD_ECC_DISABLEDSDMMC_ERROR_WP_ERASE_SKIPSDMMC_ERROR_CID_CSD_OVERWRITESDMMC_ERROR_STREAM_WRITE_OVERRUNSDMMC_ERROR_STREAM_READ_UNDERRUNSDMMC_ERROR_GENERAL_UNKNOWN_ERRSDMMC_ERROR_CC_ERRSDMMC_ERROR_CARD_ECC_FAILEDSDMMC_ERROR_ILLEGAL_CMDSDMMC_ERROR_COM_CRC_FAILEDSDMMC_ERROR_LOCK_UNLOCK_FAILEDSDMMC_ERROR_WRITE_PROT_VIOLATIONSDMMC_ERROR_BAD_ERASE_PARAMSDMMC_ERROR_ERASE_SEQ_ERRSDMMC_ERROR_BLOCK_LEN_ERRSDMMC_ERROR_ADDR_MISALIGNEDSDMMC_ERROR_RX_OVERRUNSDMMC_ERROR_TX_UNDERRUNSDMMC_ERROR_DATA_TIMEOUTSDMMC_ERROR_CMD_RSP_TIMEOUTSDMMC_ERROR_DATA_CRC_FAILSDMMC_ERROR_CMD_CRC_FAILSDMMC_ERROR_NONESTM32F7xx_LL_SDMMC_Hdefined(SDMMC1)/* STM32F7xx_LL_SDMMC_H *//* SDMMC1 *//** @addtogroup HAL_SDMMC_LL_Group5
  * @{
  *//* SDMMC Responses management functions *****************************************//** @addtogroup HAL_SDMMC_LL_Group4
  * @{
  *//* SDMMC Commands management functions *//* SDMMC Cards mode management functions *//* Data path state machine (DPSM) management functions *//* Command path state machine (CPSM) management functions *//** @addtogroup HAL_SDMMC_LL_Group3
  * @{
  *//** @addtogroup HAL_SDMMC_LL_Group2
  * @{
  *//* I/O operation functions  *****************************************************//** @addtogroup HAL_SDMMC_LL_Group1
  * @{
  *//* Initialization/de-initialization functions  **********************************//** @addtogroup SDMMC_LL_Exported_Functions
  * @{
  *//**
  * @brief  Disable the SD I/O Suspend command sending.
  * @param  __INSTANCE__ : Pointer to SDMMC register base  
  * @retval None
  *//**
  * @brief  Enable the SD I/O Suspend command sending.
  * @param  __INSTANCE__ : Pointer to SDMMC register base  
  * @retval None
  *//**
  * @brief  Disable the SD I/O Mode Operation.
  * @param  __INSTANCE__ : Pointer to SDMMC register base 
  * @retval None
  *//**
  * @brief  Enable the SD I/O Mode Operation.
  * @param  __INSTANCE__ : Pointer to SDMMC register base   
  * @retval None
  *//**
  * @brief  Disable Stop the SD I/O Read Wait operations.
  * @param  __INSTANCE__ : Pointer to SDMMC register base  
  * @retval None
  *//**
  * @brief  Enable Start the SD I/O Read Wait operation.
  * @param  __INSTANCE__ : Pointer to SDMMC register base   
  * @retval None
  *//**
  * @brief  Disable Start the SD I/O Read Wait operations.
  * @param  __INSTANCE__ : Pointer to SDMMC register base   
  * @retval None
  *//**
  * @brief  Enable Start the SD I/O Read Wait operation.
  * @param  __INSTANCE__ : Pointer to SDMMC register base  
  * @retval None
  *//**
  * @brief  Clears the SDMMC's interrupt pending bits.
  * @param  __INSTANCE__ : Pointer to SDMMC register base 
  * @param  __INTERRUPT__: specifies the interrupt pending bit to clear. 
  *          This parameter can be one or a combination of the following values:
  *            @arg SDMMC_IT_CCRCFAIL: Command response received (CRC check failed) interrupt
  *            @arg SDMMC_IT_DCRCFAIL: Data block sent/received (CRC check failed) interrupt
  *            @arg SDMMC_IT_CTIMEOUT: Command response timeout interrupt
  *            @arg SDMMC_IT_DTIMEOUT: Data timeout interrupt
  *            @arg SDMMC_IT_TXUNDERR: Transmit FIFO underrun error interrupt
  *            @arg SDMMC_IT_RXOVERR:  Received FIFO overrun error interrupt
  *            @arg SDMMC_IT_CMDREND:  Command response received (CRC check passed) interrupt
  *            @arg SDMMC_IT_CMDSENT:  Command sent (no response required) interrupt
  *            @arg SDMMC_IT_DATAEND:  Data end (data counter, DATACOUNT, is zero) interrupt
  *            @arg SDMMC_IT_SDIOIT:   SDIO interrupt received interrupt
  * @retval None
  *//**
  * @brief  Checks whether the specified SDMMC interrupt has occurred or not.
  * @param  __INSTANCE__ : Pointer to SDMMC register base   
  * @param  __INTERRUPT__: specifies the SDMMC interrupt source to check. 
  *          This parameter can be one of the following values:
  *            @arg SDMMC_IT_CCRCFAIL: Command response received (CRC check failed) interrupt
  *            @arg SDMMC_IT_DCRCFAIL: Data block sent/received (CRC check failed) interrupt
  *            @arg SDMMC_IT_CTIMEOUT: Command response timeout interrupt
  *            @arg SDMMC_IT_DTIMEOUT: Data timeout interrupt
  *            @arg SDMMC_IT_TXUNDERR: Transmit FIFO underrun error interrupt
  *            @arg SDMMC_IT_RXOVERR:  Received FIFO overrun error interrupt
  *            @arg SDMMC_IT_CMDREND:  Command response received (CRC check passed) interrupt
  *            @arg SDMMC_IT_CMDSENT:  Command sent (no response required) interrupt
  *            @arg SDMMC_IT_DATAEND:  Data end (data counter, DATACOUNT, is zero) interrupt
  *            @arg SDMMC_IT_DBCKEND:  Data block sent/received (CRC check passed) interrupt
  *            @arg SDMMC_IT_CMDACT:   Command transfer in progress interrupt
  *            @arg SDMMC_IT_TXACT:    Data transmit in progress interrupt
  *            @arg SDMMC_IT_RXACT:    Data receive in progress interrupt
  *            @arg SDMMC_IT_TXFIFOHE: Transmit FIFO Half Empty interrupt
  *            @arg SDMMC_IT_RXFIFOHF: Receive FIFO Half Full interrupt
  *            @arg SDMMC_IT_TXFIFOF:  Transmit FIFO full interrupt
  *            @arg SDMMC_IT_RXFIFOF:  Receive FIFO full interrupt
  *            @arg SDMMC_IT_TXFIFOE:  Transmit FIFO empty interrupt
  *            @arg SDMMC_IT_RXFIFOE:  Receive FIFO empty interrupt
  *            @arg SDMMC_IT_TXDAVL:   Data available in transmit FIFO interrupt
  *            @arg SDMMC_IT_RXDAVL:   Data available in receive FIFO interrupt
  *            @arg SDMMC_IT_SDIOIT:   SDIO interrupt received interrupt
  * @retval The new state of SDMMC_IT (SET or RESET).
  *//**
  * @brief  Clears the SDMMC pending flags.
  * @param  __INSTANCE__ : Pointer to SDMMC register base  
  * @param  __FLAG__: specifies the flag to clear.  
  *          This parameter can be one or a combination of the following values:
  *            @arg SDMMC_FLAG_CCRCFAIL: Command response received (CRC check failed)
  *            @arg SDMMC_FLAG_DCRCFAIL: Data block sent/received (CRC check failed)
  *            @arg SDMMC_FLAG_CTIMEOUT: Command response timeout
  *            @arg SDMMC_FLAG_DTIMEOUT: Data timeout
  *            @arg SDMMC_FLAG_TXUNDERR: Transmit FIFO underrun error
  *            @arg SDMMC_FLAG_RXOVERR:  Received FIFO overrun error
  *            @arg SDMMC_FLAG_CMDREND:  Command response received (CRC check passed)
  *            @arg SDMMC_FLAG_CMDSENT:  Command sent (no response required)
  *            @arg SDMMC_FLAG_DATAEND:  Data end (data counter, DATACOUNT, is zero)
  *            @arg SDMMC_FLAG_DBCKEND:  Data block sent/received (CRC check passed)
  *            @arg SDMMC_FLAG_SDIOIT:   SDIO interrupt received
  * @retval None
  *//**
  * @brief  Checks whether the specified SDMMC flag is set or not. 
  * @param  __INSTANCE__ : Pointer to SDMMC register base   
  * @param  __FLAG__: specifies the flag to check. 
  *          This parameter can be one of the following values:
  *            @arg SDMMC_FLAG_CCRCFAIL: Command response received (CRC check failed)
  *            @arg SDMMC_FLAG_DCRCFAIL: Data block sent/received (CRC check failed)
  *            @arg SDMMC_FLAG_CTIMEOUT: Command response timeout
  *            @arg SDMMC_FLAG_DTIMEOUT: Data timeout
  *            @arg SDMMC_FLAG_TXUNDERR: Transmit FIFO underrun error
  *            @arg SDMMC_FLAG_RXOVERR:  Received FIFO overrun error
  *            @arg SDMMC_FLAG_CMDREND:  Command response received (CRC check passed)
  *            @arg SDMMC_FLAG_CMDSENT:  Command sent (no response required)
  *            @arg SDMMC_FLAG_DATAEND:  Data end (data counter, DATACOUNT, is zero)
  *            @arg SDMMC_FLAG_DBCKEND:  Data block sent/received (CRC check passed)
  *            @arg SDMMC_FLAG_CMDACT:   Command transfer in progress
  *            @arg SDMMC_FLAG_TXACT:    Data transmit in progress
  *            @arg SDMMC_FLAG_RXACT:    Data receive in progress
  *            @arg SDMMC_FLAG_TXFIFOHE: Transmit FIFO Half Empty
  *            @arg SDMMC_FLAG_RXFIFOHF: Receive FIFO Half Full
  *            @arg SDMMC_FLAG_TXFIFOF:  Transmit FIFO full
  *            @arg SDMMC_FLAG_RXFIFOF:  Receive FIFO full
  *            @arg SDMMC_FLAG_TXFIFOE:  Transmit FIFO empty
  *            @arg SDMMC_FLAG_RXFIFOE:  Receive FIFO empty
  *            @arg SDMMC_FLAG_TXDAVL:   Data available in transmit FIFO
  *            @arg SDMMC_FLAG_RXDAVL:   Data available in receive FIFO
  *            @arg SDMMC_FLAG_SDIOIT:   SDIO interrupt received
  * @retval The new state of SDMMC_FLAG (SET or RESET).
  *//**
  * @brief  Disable the SDMMC device interrupt.
  * @param  __INSTANCE__ : Pointer to SDMMC register base   
  * @param  __INTERRUPT__ : specifies the SDMMC interrupt sources to be disabled.
  *          This parameter can be one or a combination of the following values:
  *            @arg SDMMC_IT_CCRCFAIL: Command response received (CRC check failed) interrupt
  *            @arg SDMMC_IT_DCRCFAIL: Data block sent/received (CRC check failed) interrupt
  *            @arg SDMMC_IT_CTIMEOUT: Command response timeout interrupt
  *            @arg SDMMC_IT_DTIMEOUT: Data timeout interrupt
  *            @arg SDMMC_IT_TXUNDERR: Transmit FIFO underrun error interrupt
  *            @arg SDMMC_IT_RXOVERR:  Received FIFO overrun error interrupt
  *            @arg SDMMC_IT_CMDREND:  Command response received (CRC check passed) interrupt
  *            @arg SDMMC_IT_CMDSENT:  Command sent (no response required) interrupt
  *            @arg SDMMC_IT_DATAEND:  Data end (data counter, DATACOUNT, is zero) interrupt
  *            @arg SDMMC_IT_DBCKEND:  Data block sent/received (CRC check passed) interrupt
  *            @arg SDMMC_IT_CMDACT:   Command transfer in progress interrupt
  *            @arg SDMMC_IT_TXACT:    Data transmit in progress interrupt
  *            @arg SDMMC_IT_RXACT:    Data receive in progress interrupt
  *            @arg SDMMC_IT_TXFIFOHE: Transmit FIFO Half Empty interrupt
  *            @arg SDMMC_IT_RXFIFOHF: Receive FIFO Half Full interrupt
  *            @arg SDMMC_IT_TXFIFOF:  Transmit FIFO full interrupt
  *            @arg SDMMC_IT_RXFIFOF:  Receive FIFO full interrupt
  *            @arg SDMMC_IT_TXFIFOE:  Transmit FIFO empty interrupt
  *            @arg SDMMC_IT_RXFIFOE:  Receive FIFO empty interrupt
  *            @arg SDMMC_IT_TXDAVL:   Data available in transmit FIFO interrupt
  *            @arg SDMMC_IT_RXDAVL:   Data available in receive FIFO interrupt
  *            @arg SDMMC_IT_SDIOIT:   SDIO interrupt received interrupt   
  * @retval None
  *//**
  * @brief  Enable the SDMMC device interrupt.
  * @param  __INSTANCE__ : Pointer to SDMMC register base  
  * @param  __INTERRUPT__ : specifies the SDMMC interrupt sources to be enabled.
  *         This parameter can be one or a combination of the following values:
  *            @arg SDMMC_IT_CCRCFAIL: Command response received (CRC check failed) interrupt
  *            @arg SDMMC_IT_DCRCFAIL: Data block sent/received (CRC check failed) interrupt
  *            @arg SDMMC_IT_CTIMEOUT: Command response timeout interrupt
  *            @arg SDMMC_IT_DTIMEOUT: Data timeout interrupt
  *            @arg SDMMC_IT_TXUNDERR: Transmit FIFO underrun error interrupt
  *            @arg SDMMC_IT_RXOVERR:  Received FIFO overrun error interrupt
  *            @arg SDMMC_IT_CMDREND:  Command response received (CRC check passed) interrupt
  *            @arg SDMMC_IT_CMDSENT:  Command sent (no response required) interrupt
  *            @arg SDMMC_IT_DATAEND:  Data end (data counter, DATACOUNT, is zero) interrupt
  *            @arg SDMMC_IT_DBCKEND:  Data block sent/received (CRC check passed) interrupt
  *            @arg SDMMC_IT_CMDACT:   Command transfer in progress interrupt
  *            @arg SDMMC_IT_TXACT:    Data transmit in progress interrupt
  *            @arg SDMMC_IT_RXACT:    Data receive in progress interrupt
  *            @arg SDMMC_IT_TXFIFOHE: Transmit FIFO Half Empty interrupt
  *            @arg SDMMC_IT_RXFIFOHF: Receive FIFO Half Full interrupt
  *            @arg SDMMC_IT_TXFIFOF:  Transmit FIFO full interrupt
  *            @arg SDMMC_IT_RXFIFOF:  Receive FIFO full interrupt
  *            @arg SDMMC_IT_TXFIFOE:  Transmit FIFO empty interrupt
  *            @arg SDMMC_IT_RXFIFOE:  Receive FIFO empty interrupt
  *            @arg SDMMC_IT_TXDAVL:   Data available in transmit FIFO interrupt
  *            @arg SDMMC_IT_RXDAVL:   Data available in receive FIFO interrupt
  *            @arg SDMMC_IT_SDIOIT:   SDIO interrupt received interrupt 
  * @retval None
  *//**
  * @brief  Disable the SDMMC DMA transfer.
  * @param  __INSTANCE__: SDMMC Instance   
  * @retval None
  *//**
  * @brief  Enable the SDMMC DMA transfer.
  * @param  __INSTANCE__: SDMMC Instance  
  * @retval None
  *//**
  * @brief  Disable the SDMMC device.
  * @param  __INSTANCE__: SDMMC Instance  
  * @retval None
  *//**
  * @brief  Enable the SDMMC device.
  * @param  __INSTANCE__: SDMMC Instance  
  * @retval None
  *//** @defgroup SDMMC_LL_Interrupt_Clock Interrupt And Clock Configuration
 *  @brief macros to handle interrupts and specific clock configurations
 * @{
 *//* 48MHz / (SDMMC_TRANSFER_CLK_DIV + 2) < 25MHz *//* SDMMC Data Transfer Frequency (25MHz max) *//* 48MHz / (SDMMC_INIT_CLK_DIV + 2) < 400KHz *//* SDMMC Initialization Frequency (400KHz max) *//* CMD Register clear mask *//* --- CMD Register ---*//* SDMMC DCTRL Clear Mask *//* --- DCTRL Register ---*//* CLKCR register clear mask *//* --- CLKCR Register ---*//* ---------------------- SDMMC registers bit mask --------------------------- *//** @defgroup SDMMC_LL_Register Bits And Addresses Definitions
  * @brief SDMMC_LL registers bit address in the alias region
  * @{
  *//** @defgroup SDMMC_LL_Exported_macros SDMMC_LL Exported Macros
  * @{
  *//** @defgroup SDMMC_LL_Flags Flags
  * @{
  *//** @defgroup SDMMC_LL_Interrupt_sources Interrupt Sources
  * @{
  *//** @defgroup SDMMC_LL_Read_Wait_Mode Read Wait Mode
  * @{
  *//** @defgroup SDMMC_LL_DPSM_State DPSM State
  * @{
  *//** @defgroup SDMMC_LL_Transfer_Type Transfer Type
  * @{
  *//** @defgroup SDMMC_LL_Transfer_Direction Transfer Direction
  * @{
  *//** @defgroup SDMMC_LL_Data_Block_Size  Data Block Size
  * @{
  *//** @defgroup SDMMC_LL_Data_Length Data Length
  * @{
  *//** @defgroup SDMMC_LL_Response_Registers Response Register
  * @{
  *//** @defgroup SDMMC_LL_CPSM_State CPSM State
  * @{
  *//** @defgroup SDMMC_LL_Wait_Interrupt_State Wait Interrupt
  * @{
  *//** @defgroup SDMMC_LL_Response_Type Response Type
  * @{
  *//** @defgroup SDMMC_LL_Command_Index Command Index
  * @{
  *//** @defgroup SDMMC_LL_Clock_Division Clock Division
  * @{
  *//** @defgroup SDMMC_LL_Hardware_Flow_Control Hardware Flow Control
  * @{
  *//** @defgroup SDMMC_LL_Bus_Wide Bus Width
  * @{
  *//** @defgroup SDMMC_LL_Clock_Power_Save Clock Power Saving
  * @{
  *//** @defgroup SDMMC_LL_Clock_Bypass Clock Bypass
  * @{
  *//** @defgroup SDMMC_LL_Clock_Edge Clock Edge
  * @{
  *//* Timeout for STOP TRANSMISSION command *//* Max erase Timeout 63 s            *//* Command send and response timeout *//** 
  * @brief  Command Class supported
  *//* SDMMC_DATATIMEOUT *//** 
  * @brief  Masks for R6 Response 
  *//** 
  * @brief  Masks for errors Card Status R1 (OCR Register) 
  *//** 
  * @brief Following commands are SD Card Specific security commands.
  *        SDMMC_CMD_APP_CMD should be sent before sending these commands. 
  *//*!< For SD I/O card only, reserved for security specification.                               *//*!< Reads the SD Configuration Register (SCR).                                               *//*!< (ACMD42) Connect/Disconnect the 50 KOhm pull-up resistor on CD/DAT3 (pin 1) of the card  *//*!< (ACMD41) Sends host capacity support information (HCS) and asks the accessed card to
                                                                           send its operating condition register (OCR) content in the response on the CMD line.     *//*!< (ACMD22) Sends the number of the written (without errors) write blocks. Responds with
                                                                           32bit+CRC data block.                                                                    *//*!< (ACMD13) Sends the SD status.                                                            *//*!< (ACMD6) Defines the data bus width to be used for data transfer. The allowed data bus
                                                                            widths are given in SCR register.                                                       *//** 
  * @brief Following commands are SD Card Specific commands.
  *        SDMMC_APP_CMD should be sent before sending these commands. 
  *//*!< No command                                                                               *//*!< Used either to transfer a data block to the card or to get a data block from the card
                                                                           for general purpose/application specific commands.                                       *//*!< Indicates to the card that the next command is an application specific command rather
                                                                           than a standard command.                                                                 *//*!< Sets/resets the password or lock/unlock the card. The size of the data block is set by
                                                                           the SET_BLOCK_LEN command.                                                               *//*!< SD card doesn't support it (Reserved).                                                   *//*!< Reserved for SD security applications.                                                   *//*!< Sets the address of the last write block of the continuous range to be erased.
                                                                           Reserved for each command system set by switch function command (CMD6).                  *//*!< Sets the address of the first write block to be erased. Reserved for each command
                                                                           system set by switch function command (CMD6).                                            *//*!< Sets the address of the last write block of the continuous range to be erased.           *//*!< Sets the address of the first write block to be erased. (For SD card only).              *//*!< Asks the card to send the status of the write protection bits.                           *//*!< Clears the write protection bit of the addressed group.                                  *//*!< Sets the write protection bit of the addressed group.                                    *//*!< Programming of the programmable bits of the CSD.                                         *//*!< Reserved for manufacturers.                                                              *//*!< Continuously writes blocks of data until a STOP_TRANSMISSION follows.                    *//*!< Writes single block of size selected by SET_BLOCKLEN in case of SDSC, and a block of
                                                                           fixed 512 bytes in case of SDHC and SDXC.                                                *//*!< Specify block count for CMD18 and CMD25.                                                 *//*!< Speed class control command.                                                             *//*!< 64 bytes tuning pattern is sent for SDR50 and SDR104.                                    *//*!< Continuously transfers data blocks from card to host until interrupted by
                                                                           STOP_TRANSMISSION command.                                                               *//*!< Reads single block of size selected by SET_BLOCKLEN in case of SDSC, and a block of
                                                                           fixed 512 bytes in case of SDHC and SDXC.                                                *//*!< Sets the block length (in bytes for SDSC) for all following block commands
                                                                           (read, write, lock). Default block length is fixed to 512 Bytes. Not effective 
                                                                           for SDHS and SDXC.                                                                       *//*!< Sends an addressed card into the inactive state.                                         *//*!< Reserved                                                                                 *//*!< Addressed card sends its status register.                                                *//*!< Forces the card to stop transmission.                                                    *//*!< SD card doesn't support it.                                                              *//*!< Addressed card sends its card identification (CID) on the CMD line.                      *//*!< Addressed card sends its card specific data (CSD) on the CMD line.                       *//*!< Sends SD Memory Card interface condition, which includes host supply voltage information
                                                                           and asks the card whether card supports voltage.                                         *//*!< Selects the card by its own relative address and gets deselected by any other address    *//*!< Checks switchable function (mode 0) and switch card function (mode 1).                   *//*!< Sends host capacity support information (HCS) and asks the accessed card to send its
                                                                           operating condition register (OCR) content in the response on the CMD line.              *//*!< Programs the DSR of all cards.                                                           *//*!< Asks the card to publish a new relative address (RCA).                                   *//*!< Asks any card connected to the host to send the CID numbers on the CMD line.             *//*!< Sends host capacity support information and activates the card's initialization process. *//*!< Resets the SD memory card.                                                               *//** 
  * @brief SDMMC Commands Index 
  *//*!< Timeout error                                                 *//*!< Error while DMA transfer                                      *//*!< Error when transfer process is busy                           *//*!< Error when feature is not insupported                         *//*!< the used parameter is not valid                               *//*!< Error when command request is not applicable                  *//*!< Error when addressed block is out of range                    *//*!< Error in case of invalid voltage range                        *//*!< Error in sequence of authentication                           *//*!< Erase sequence was cleared before executing because an out
                                                                            of erase sequence command was received                        *//*!< Command has been executed without using internal ECC          *//*!< Only partial address space was erased                         *//*!< CID/CSD overwrite error                                       *//*!< The card could not sustain data programming in stream mode    *//*!< The card could not sustain data reading in stream rmode       *//*!< General or unknown error                                      *//*!< Internal card controller error                                *//*!< Card internal ECC was applied but failed to correct the data  *//*!< Command is not legal for the card state                       *//*!< CRC check of the previous command failed                      *//*!< Sequence or password error has been detected in unlock
                                                                            command or if there was an attempt to access a locked card    *//*!< Attempt to program a write protect block                      *//*!< An invalid selection for erase groups                         *//*!< An error in the sequence of erase command occurs              *//*!< Transferred block length is not allowed for the card or the
                                                                            number of transferred bytes does not match the block length   *//*!< Misaligned address                                            *//*!< Receive FIFO overrun                                          *//*!< Transmit FIFO underrun                                        *//*!< Data timeout                                                  *//*!< Command response timeout                                      *//*!< Data block sent/received (CRC check failed)                   *//*!< Command response received (but CRC check failed)              *//*!< No error                                                      *//** @defgroup SDMMC_LL_Exported_Constants SDMMC_LL Exported Constants
  * @{
  *//*!< Specifies whether SDMMC Data path state machine (DPSM)
                                     is enabled or disabled.
                                     This parameter can be a value of @ref SDMMC_LL_DPSM_State         *//*!< Specifies whether data transfer is in stream or block mode.
                                     This parameter can be a value of @ref SDMMC_LL_Transfer_Type      *//*!< Specifies the data transfer direction, whether the transfer
                                     is a read or write.
                                     This parameter can be a value of @ref SDMMC_LL_Transfer_Direction *//*!< Specifies the data block size for block transfer.
                                     This parameter can be a value of @ref SDMMC_LL_Data_Block_Size    *//*!< Specifies the number of data bytes to be transferred.         *//*!< Specifies the data timeout period in card bus clock periods.  *//** 
  * @brief  SDMMC Data Control structure 
  *//*!< Specifies whether SDMMC Command path state machine (CPSM)
                                     is enabled or disabled.
                                     This parameter can be a value of @ref SDMMC_LL_CPSM_State            *//*!< Specifies whether SDMMC wait for interrupt request is 
                                     enabled or disabled.
                                     This parameter can be a value of @ref SDMMC_LL_Wait_Interrupt_State  *//*!< Specifies the SDMMC response type.
                                     This parameter can be a value of @ref SDMMC_LL_Response_Type         *//*!< Specifies the SDMMC command index. It must be Min_Data = 0 and 
                                     Max_Data = 64                                                    *//*!< Specifies the SDMMC command argument which is sent
                                     to a card as part of a command message. If a command
                                     contains an argument, it must be loaded into this register
                                     before writing the command to the command register.              *//** 
  * @brief  SDMMC Command Control structure 
  *//*!< Specifies the clock frequency of the SDMMC controller.
                                      This parameter can be a value between Min_Data = 0 and Max_Data = 255 *//*!< Specifies whether the SDMMC hardware flow control is enabled or disabled.
                                      This parameter can be a value of @ref SDMMC_LL_Hardware_Flow_Control      *//*!< Specifies the SDMMC bus width.
                                      This parameter can be a value of @ref SDMMC_LL_Bus_Wide                   *//*!< Specifies whether SDMMC Clock output is enabled or
                                      disabled when the bus is idle.
                                      This parameter can be a value of @ref SDMMC_LL_Clock_Power_Save           *//*!< Specifies whether the SDMMC Clock divider bypass is
                                      enabled or disabled.
                                      This parameter can be a value of @ref SDMMC_LL_Clock_Bypass               *//*!< Specifies the clock transition on which the bit capture is made.
                                      This parameter can be a value of @ref SDMMC_LL_Clock_Edge                 *//** 
  * @brief  SDMMC Configuration Structure definition  
  *//** @defgroup SDMMC_LL_Exported_Types SDMMC_LL Exported Types
  * @{
  *//** @addtogroup SDMMC_LL
  * @{
  *//** @addtogroup STM32F7xx_Driver
  * @{
  *//**
  ******************************************************************************
  * @file    stm32f7xx_ll_sdmmc.h
  * @author  MCD Application Team
  * @brief   Header file of SDMMC HAL module.
  ******************************************************************************
  * @attention
  *
  * Copyright (c) 2017 STMicroelectronics.
  * All rights reserved.
  *
  * This software is licensed under terms that can be found in the LICENSE file
  * in the root directory of this software component.
  * If no LICENSE file comes with this software, it is provided AS-IS.
  *
  ******************************************************************************
  */SDMMCxSD_CMDpRCARCABusWidthEndAddStartAddWriteAddReadAddBlockSizeSDMMC_ReadWaitModepWriteData"stm32f7xx_ll_sdmmc.h"HAL_SD_Abort_ITHAL_SD_AbortHAL_SD_GetErrorHAL_SD_GetStateHAL_SD_GetCardInfoHAL_SD_GetCardStatusHAL_SD_CardStatusTypeDef *HAL_SD_GetCardCSDHAL_SD_CardCSDTypeDef *HAL_SD_GetCardCIDHAL_SD_CardCIDTypeDef *HAL_SD_GetCardStateHAL_SD_SendSDStatusHAL_SD_ConfigWideBusOperationHAL_SD_ErrorCallbackHAL_SD_IRQHandlerHAL_SD_WriteBlocks_DMAHAL_SD_ReadBlocks_DMAHAL_SD_WriteBlocks_ITHAL_SD_ReadBlocks_ITHAL_SD_EraseHAL_SD_WriteBlocksHAL_SD_ReadBlocksHAL_SD_MspDeInitHAL_SD_MspInitHAL_SD_DeInitHAL_SD_InitCardHAL_SD_InitSD_HandleTypeDefHAL_SD_StateTypeDefHAL_SD_STATE_RESETHAL_SD_STATE_READYHAL_SD_STATE_TIMEOUTHAL_SD_STATE_BUSYHAL_SD_STATE_PROGRAMMINGHAL_SD_STATE_RECEIVINGHAL_SD_STATE_TRANSFERHAL_SD_STATE_ERROREraseOffsetEraseTimeoutEraseSizeAllocationUnitSizePerformanceMoveSpeedClassProtectedAreaSizeCardTypeSecuredModeDataBusWidthReserved2CID_CRCManufactDateReserved1ProdSNProdRevProdName2ProdName1OEM_AppliIDManufacturerIDReserved4CSD_CRCECCFileFormatTempWrProtectPermWrProtectCopyFlagFileFormatGroupContentProtectAppliReserved3WriteBlockPaPartialMaxWrBlockLenWrSpeedFactManDeflECCWrProtectGrEnableWrProtectGrSizeEraseGrMulEraseGrSizeDeviceSizeMulMaxWrCurrentVDDMaxMaxWrCurrentVDDMinMaxRdCurrentVDDMaxMaxRdCurrentVDDMinDeviceSizeDSRImplRdBlockMisalignWrBlockMisalignPartBlockReadRdBlockLenCardComdClassesMaxBusClkFrecNSACTAACSysSpecVersionCSDStructCSDvolatile HAL_SD_StateTypeDefContextRxXferSizepRxBuffPtrTxXferSizepTxBuffPtrLogBlockSizeLogBlockNbrBlockNbrRelCardAddClassCardVersion__HAL_SD_CLEAR_IT(__HANDLE__,__INTERRUPT__)__SDMMC_CLEAR_IT((__HANDLE__)->Instance, (__INTERRUPT__))__HAL_SD_GET_IT(__HANDLE__,__INTERRUPT__)__SDMMC_GET_IT((__HANDLE__)->Instance, (__INTERRUPT__))__HAL_SD_CLEAR_FLAG(__HANDLE__,__FLAG__)__SDMMC_CLEAR_FLAG((__HANDLE__)->Instance, (__FLAG__))__HAL_SD_GET_FLAG(__HANDLE__,__FLAG__)__SDMMC_GET_FLAG((__HANDLE__)->Instance, (__FLAG__))__HAL_SD_DISABLE_IT(__HANDLE__,__INTERRUPT__)__SDMMC_DISABLE_IT((__HANDLE__)->Instance, (__INTERRUPT__))__HAL_SD_ENABLE_IT(__HANDLE__,__INTERRUPT__)__SDMMC_ENABLE_IT((__HANDLE__)->Instance, (__INTERRUPT__))__HAL_SD_DMA_DISABLE(__HANDLE__)__SDMMC_DMA_DISABLE((__HANDLE__)->Instance)__HAL_SD_DMA_ENABLE(__HANDLE__)__SDMMC_DMA_ENABLE((__HANDLE__)->Instance)__HAL_SD_DISABLE(__HANDLE__)__SDMMC_DISABLE((__HANDLE__)->Instance)__HAL_SD_ENABLE(__HANDLE__)__SDMMC_ENABLE((__HANDLE__)->Instance)__HAL_SD_RESET_HANDLE_STATE(__HANDLE__)((__HANDLE__)->State = HAL_SD_STATE_RESET)CARD_V2_XCARD_V1_XCARD_SECUREDCARD_SDHC_SDXCCARD_SDSCSD_CONTEXT_DMASD_CONTEXT_ITSD_CONTEXT_WRITE_MULTIPLE_BLOCKSD_CONTEXT_WRITE_SINGLE_BLOCKSD_CONTEXT_READ_MULTIPLE_BLOCKSD_CONTEXT_READ_SINGLE_BLOCKSD_CONTEXT_NONEHAL_SD_ERROR_TIMEOUTHAL_SD_ERROR_DMAHAL_SD_ERROR_BUSYHAL_SD_ERROR_UNSUPPORTED_FEATUREHAL_SD_ERROR_PARAMHAL_SD_ERROR_REQUEST_NOT_APPLICABLEHAL_SD_ERROR_ADDR_OUT_OF_RANGEHAL_SD_ERROR_INVALID_VOLTRANGEHAL_SD_ERROR_AKE_SEQ_ERRHAL_SD_ERROR_ERASE_RESETHAL_SD_ERROR_CARD_ECC_DISABLEDHAL_SD_ERROR_WP_ERASE_SKIPHAL_SD_ERROR_CID_CSD_OVERWRITEHAL_SD_ERROR_STREAM_WRITE_OVERRUNHAL_SD_ERROR_STREAM_READ_UNDERRUNHAL_SD_ERROR_GENERAL_UNKNOWN_ERRHAL_SD_ERROR_CC_ERRHAL_SD_ERROR_CARD_ECC_FAILEDHAL_SD_ERROR_ILLEGAL_CMDHAL_SD_ERROR_COM_CRC_FAILEDHAL_SD_ERROR_LOCK_UNLOCK_FAILEDHAL_SD_ERROR_WRITE_PROT_VIOLATIONHAL_SD_ERROR_BAD_ERASE_PARAMHAL_SD_ERROR_ERASE_SEQ_ERRHAL_SD_ERROR_BLOCK_LEN_ERRHAL_SD_ERROR_ADDR_MISALIGNEDHAL_SD_ERROR_RX_OVERRUNHAL_SD_ERROR_TX_UNDERRUNHAL_SD_ERROR_DATA_TIMEOUTHAL_SD_ERROR_CMD_RSP_TIMEOUTHAL_SD_ERROR_DATA_CRC_FAILHAL_SD_ERROR_CMD_CRC_FAILHAL_SD_ERROR_NONEBLOCKSIZE512USD_TypeDefSD_InitTypeDefHAL_SD_CARD_ERRORHAL_SD_CARD_DISCONNECTEDHAL_SD_CARD_PROGRAMMINGHAL_SD_CARD_RECEIVINGHAL_SD_CARD_SENDINGHAL_SD_CARD_STANDBYHAL_SD_CARD_IDENTIFICATIONHAL_SD_CARD_READYSTM32F7xx_HAL_SD_Hdefined (USE_HAL_SD_REGISTER_CALLBACKS) && (USE_HAL_SD_REGISTER_CALLBACKS == 1U)/* STM32F7xx_HAL_SD_H *//** @defgroup SD_Private_Functions SD Private Functions
  * @{
  *//** @defgroup SD_Private_Functions_Prototypes SD Private Functions Prototypes
  * @{
  *//* Private functions prototypes ----------------------------------------------*//** @defgroup SD_Private_Macros SD Private Macros
  * @{
  *//** @defgroup SD_Private_Constants SD Private Constants
  * @{
  *//** @defgroup SD_Private_Variables SD Private Variables
  * @{
  *//** @defgroup SD_Private_Defines SD Private Defines
  * @{
  *//** @defgroup SD_Private_Types SD Private Types
  * @{
  *//** @defgroup SD_Exported_Functions_Group6 Perioheral Abort management
  * @{
  *//** @defgroup SD_Exported_Functions_Group5 Peripheral State and Errors functions
  * @{
  *//** @defgroup SD_Exported_Functions_Group4 SD card related functions
  * @{
  *//** @defgroup SD_Exported_Functions_Group3 Peripheral Control functions
  * @{
  *//* USE_HAL_SD_REGISTER_CALLBACKS *//* SD callback registering/unregistering *//* Callback in non blocking modes (DMA) *//* Non-Blocking mode: IT *//** @defgroup SD_Exported_Functions_Group2 Input and Output operation functions
  * @{
  *//** @defgroup SD_Exported_Functions_Group1 Initialization and de-initialization functions
  * @{
  *//** @defgroup SD_Exported_Functions SD Exported Functions
  * @{
  *//**
  * @brief  Clear the SD's interrupt pending bits.
  * @param  __HANDLE__: SD Handle
  * @param  __INTERRUPT__: specifies the interrupt pending bit to clear. 
  *          This parameter can be one or a combination of the following values:
  *            @arg SDMMC_IT_CCRCFAIL: Command response received (CRC check failed) interrupt
  *            @arg SDMMC_IT_DCRCFAIL: Data block sent/received (CRC check failed) interrupt
  *            @arg SDMMC_IT_CTIMEOUT: Command response timeout interrupt
  *            @arg SDMMC_IT_DTIMEOUT: Data timeout interrupt
  *            @arg SDMMC_IT_TXUNDERR: Transmit FIFO underrun error interrupt
  *            @arg SDMMC_IT_RXOVERR:  Received FIFO overrun error interrupt
  *            @arg SDMMC_IT_CMDREND:  Command response received (CRC check passed) interrupt
  *            @arg SDMMC_IT_CMDSENT:  Command sent (no response required) interrupt
  *            @arg SDMMC_IT_DATAEND:  Data end (data counter, DATACOUNT, is zero) interrupt
  *            @arg SDMMC_IT_SDIOIT:   SDIO interrupt received interrupt
  * @retval None
  *//**
  * @brief  Check whether the specified SD interrupt has occurred or not.
  * @param  __HANDLE__: SD Handle   
  * @param  __INTERRUPT__: specifies the SDMMC interrupt source to check. 
  *          This parameter can be one of the following values:
  *            @arg SDMMC_IT_CCRCFAIL: Command response received (CRC check failed) interrupt
  *            @arg SDMMC_IT_DCRCFAIL: Data block sent/received (CRC check failed) interrupt
  *            @arg SDMMC_IT_CTIMEOUT: Command response timeout interrupt
  *            @arg SDMMC_IT_DTIMEOUT: Data timeout interrupt
  *            @arg SDMMC_IT_TXUNDERR: Transmit FIFO underrun error interrupt
  *            @arg SDMMC_IT_RXOVERR:  Received FIFO overrun error interrupt
  *            @arg SDMMC_IT_CMDREND:  Command response received (CRC check passed) interrupt
  *            @arg SDMMC_IT_CMDSENT:  Command sent (no response required) interrupt
  *            @arg SDMMC_IT_DATAEND:  Data end (data counter, DATACOUNT, is zero) interrupt
  *            @arg SDMMC_IT_DBCKEND:  Data block sent/received (CRC check passed) interrupt
  *            @arg SDMMC_IT_CMDACT:   Command transfer in progress interrupt
  *            @arg SDMMC_IT_TXACT:    Data transmit in progress interrupt
  *            @arg SDMMC_IT_RXACT:    Data receive in progress interrupt
  *            @arg SDMMC_IT_TXFIFOHE: Transmit FIFO Half Empty interrupt
  *            @arg SDMMC_IT_RXFIFOHF: Receive FIFO Half Full interrupt
  *            @arg SDMMC_IT_TXFIFOF:  Transmit FIFO full interrupt
  *            @arg SDMMC_IT_RXFIFOF:  Receive FIFO full interrupt
  *            @arg SDMMC_IT_TXFIFOE:  Transmit FIFO empty interrupt
  *            @arg SDMMC_IT_RXFIFOE:  Receive FIFO empty interrupt
  *            @arg SDMMC_IT_TXDAVL:   Data available in transmit FIFO interrupt
  *            @arg SDMMC_IT_RXDAVL:   Data available in receive FIFO interrupt
  *            @arg SDMMC_IT_SDIOIT:   SDIO interrupt received interrupt
  * @retval The new state of SD IT (SET or RESET).
  *//**
  * @brief  Clear the SD's pending flags.
  * @param  __HANDLE__: SD Handle  
  * @param  __FLAG__: specifies the flag to clear.  
  *          This parameter can be one or a combination of the following values:
  *            @arg SDMMC_FLAG_CCRCFAIL: Command response received (CRC check failed)
  *            @arg SDMMC_FLAG_DCRCFAIL: Data block sent/received (CRC check failed)
  *            @arg SDMMC_FLAG_CTIMEOUT: Command response timeout
  *            @arg SDMMC_FLAG_DTIMEOUT: Data timeout
  *            @arg SDMMC_FLAG_TXUNDERR: Transmit FIFO underrun error
  *            @arg SDMMC_FLAG_RXOVERR:  Received FIFO overrun error
  *            @arg SDMMC_FLAG_CMDREND:  Command response received (CRC check passed)
  *            @arg SDMMC_FLAG_CMDSENT:  Command sent (no response required)
  *            @arg SDMMC_FLAG_DATAEND:  Data end (data counter, DATACOUNT, is zero)
  *            @arg SDMMC_FLAG_DBCKEND:  Data block sent/received (CRC check passed)
  *            @arg SDMMC_FLAG_SDIOIT:   SDIO interrupt received
  * @retval None
  *//**
  * @brief  Check whether the specified SD flag is set or not. 
  * @param  __HANDLE__: SD Handle   
  * @param  __FLAG__: specifies the flag to check. 
  *          This parameter can be one of the following values:
  *            @arg SDMMC_FLAG_CCRCFAIL: Command response received (CRC check failed)
  *            @arg SDMMC_FLAG_DCRCFAIL: Data block sent/received (CRC check failed)
  *            @arg SDMMC_FLAG_CTIMEOUT: Command response timeout
  *            @arg SDMMC_FLAG_DTIMEOUT: Data timeout
  *            @arg SDMMC_FLAG_TXUNDERR: Transmit FIFO underrun error
  *            @arg SDMMC_FLAG_RXOVERR:  Received FIFO overrun error
  *            @arg SDMMC_FLAG_CMDREND:  Command response received (CRC check passed)
  *            @arg SDMMC_FLAG_CMDSENT:  Command sent (no response required)
  *            @arg SDMMC_FLAG_DATAEND:  Data end (data counter, DATACOUNT, is zero)
  *            @arg SDMMC_FLAG_DBCKEND:  Data block sent/received (CRC check passed)
  *            @arg SDMMC_FLAG_CMDACT:   Command transfer in progress
  *            @arg SDMMC_FLAG_TXACT:    Data transmit in progress
  *            @arg SDMMC_FLAG_RXACT:    Data receive in progress
  *            @arg SDMMC_FLAG_TXFIFOHE: Transmit FIFO Half Empty
  *            @arg SDMMC_FLAG_RXFIFOHF: Receive FIFO Half Full
  *            @arg SDMMC_FLAG_TXFIFOF:  Transmit FIFO full
  *            @arg SDMMC_FLAG_RXFIFOF:  Receive FIFO full
  *            @arg SDMMC_FLAG_TXFIFOE:  Transmit FIFO empty
  *            @arg SDMMC_FLAG_RXFIFOE:  Receive FIFO empty
  *            @arg SDMMC_FLAG_TXDAVL:   Data available in transmit FIFO
  *            @arg SDMMC_FLAG_RXDAVL:   Data available in receive FIFO
  *            @arg SDMMC_FLAG_SDIOIT:   SDIO interrupt received
  * @retval The new state of SD FLAG (SET or RESET).
  *//**
  * @brief  Disable the SD device interrupt.
  * @param  __HANDLE__: SD Handle   
  * @param  __INTERRUPT__: specifies the SDMMC interrupt sources to be disabled.
  *          This parameter can be one or a combination of the following values:
  *            @arg SDMMC_IT_CCRCFAIL: Command response received (CRC check failed) interrupt
  *            @arg SDMMC_IT_DCRCFAIL: Data block sent/received (CRC check failed) interrupt
  *            @arg SDMMC_IT_CTIMEOUT: Command response timeout interrupt
  *            @arg SDMMC_IT_DTIMEOUT: Data timeout interrupt
  *            @arg SDMMC_IT_TXUNDERR: Transmit FIFO underrun error interrupt
  *            @arg SDMMC_IT_RXOVERR:  Received FIFO overrun error interrupt
  *            @arg SDMMC_IT_CMDREND:  Command response received (CRC check passed) interrupt
  *            @arg SDMMC_IT_CMDSENT:  Command sent (no response required) interrupt
  *            @arg SDMMC_IT_DATAEND:  Data end (data counter, DATACOUNT, is zero) interrupt
  *            @arg SDMMC_IT_DBCKEND:  Data block sent/received (CRC check passed) interrupt
  *            @arg SDMMC_IT_CMDACT:   Command transfer in progress interrupt
  *            @arg SDMMC_IT_TXACT:    Data transmit in progress interrupt
  *            @arg SDMMC_IT_RXACT:    Data receive in progress interrupt
  *            @arg SDMMC_IT_TXFIFOHE: Transmit FIFO Half Empty interrupt
  *            @arg SDMMC_IT_RXFIFOHF: Receive FIFO Half Full interrupt
  *            @arg SDMMC_IT_TXFIFOF:  Transmit FIFO full interrupt
  *            @arg SDMMC_IT_RXFIFOF:  Receive FIFO full interrupt
  *            @arg SDMMC_IT_TXFIFOE:  Transmit FIFO empty interrupt
  *            @arg SDMMC_IT_RXFIFOE:  Receive FIFO empty interrupt
  *            @arg SDMMC_IT_TXDAVL:   Data available in transmit FIFO interrupt
  *            @arg SDMMC_IT_RXDAVL:   Data available in receive FIFO interrupt
  *            @arg SDMMC_IT_SDIOIT:   SDIO interrupt received interrupt   
  * @retval None
  *//**
  * @brief  Enable the SD device interrupt.
  * @param  __HANDLE__: SD Handle  
  * @param  __INTERRUPT__: specifies the SDMMC interrupt sources to be enabled.
  *         This parameter can be one or a combination of the following values:
  *            @arg SDMMC_IT_CCRCFAIL: Command response received (CRC check failed) interrupt
  *            @arg SDMMC_IT_DCRCFAIL: Data block sent/received (CRC check failed) interrupt
  *            @arg SDMMC_IT_CTIMEOUT: Command response timeout interrupt
  *            @arg SDMMC_IT_DTIMEOUT: Data timeout interrupt
  *            @arg SDMMC_IT_TXUNDERR: Transmit FIFO underrun error interrupt
  *            @arg SDMMC_IT_RXOVERR:  Received FIFO overrun error interrupt
  *            @arg SDMMC_IT_CMDREND:  Command response received (CRC check passed) interrupt
  *            @arg SDMMC_IT_CMDSENT:  Command sent (no response required) interrupt
  *            @arg SDMMC_IT_DATAEND:  Data end (data counter, DATACOUNT, is zero) interrupt
  *            @arg SDMMC_IT_DBCKEND:  Data block sent/received (CRC check passed) interrupt
  *            @arg SDMMC_IT_CMDACT:   Command transfer in progress interrupt
  *            @arg SDMMC_IT_TXACT:    Data transmit in progress interrupt
  *            @arg SDMMC_IT_RXACT:    Data receive in progress interrupt
  *            @arg SDMMC_IT_TXFIFOHE: Transmit FIFO Half Empty interrupt
  *            @arg SDMMC_IT_RXFIFOHF: Receive FIFO Half Full interrupt
  *            @arg SDMMC_IT_TXFIFOF:  Transmit FIFO full interrupt
  *            @arg SDMMC_IT_RXFIFOF:  Receive FIFO full interrupt
  *            @arg SDMMC_IT_TXFIFOE:  Transmit FIFO empty interrupt
  *            @arg SDMMC_IT_RXFIFOE:  Receive FIFO empty interrupt
  *            @arg SDMMC_IT_TXDAVL:   Data available in transmit FIFO interrupt
  *            @arg SDMMC_IT_RXDAVL:   Data available in receive FIFO interrupt
  *            @arg SDMMC_IT_SDIOIT:   SDIO interrupt received interrupt
  * @retval None
  *//**
  * @brief  Disable the SDMMC DMA transfer.
  * @retval None
  *//**
  * @brief  Enable the SDMMC DMA transfer.
  * @retval None
  *//**
  * @brief  Disable the SD device.
  * @retval None
  *//**
  * @brief  Enable the SD device.
  * @retval None
  *//** @brief Reset SD handle state.
  * @param  __HANDLE__ : SD handle.
  * @retval None
  *//** @defgroup SD_Exported_macros SD Exported Macros
 *  @brief macros to handle interrupts and specific clock configurations
 * @{
 *//** @defgroup SD_Exported_Constansts_Group4 SD Supported Version
  * @{
  *//*!< SD High Capacity <32Go, SD Extended Capacity <2To  *//*!< SD Standard Capacity <2Go                          *//** @defgroup SD_Exported_Constansts_Group3 SD Supported Memory Cards
  * @{
  *//*!< Process in DMA mode              *//*!< Process in Interrupt mode        *//*!< Write multiple blocks operation  *//*!< Write single block operation     *//*!< Read multiple blocks operation   *//*!< Read single block operation      *//*!< None                             *//** @defgroup SD_Exported_Constansts_Group2 SD context enumeration
  * @{
  *//** 
  * @}
  *//*!< Invalid callback error                                        *//*!< Erase sequence was cleared before executing because an out 
                                                                                       of erase sequence command was received                        *//*!< Sequence or password error has been detected in unlock 
                                                                                       command or if there was an attempt to access a locked card    *//*!< Transferred block length is not allowed for the card or the 
                                                                                       number of transferred bytes does not match the block length   *//** @defgroup SD_Exported_Constansts_Group1 SD Error status enumeration Structure definition 
  * @{
  *//*!< Block size is 512 bytes *//** @defgroup SD_Exported_Constants Exported Constants
  * @{
  *//** @defgroup SD_Exported_Types_Group8 SD Callback pointer definition 
  * @{
  *//*!< SD MspDeInit Callback ID                       *//*!< SD MspInit Callback ID                         *//*!< SD Abort Callback ID                           *//*!< SD Error Callback ID                           *//*!< SD Rx Complete Callback ID                     *//*!< SD Tx Complete Callback ID                     *//** @defgroup SD_Exported_Types_Group7 SD Callback ID enumeration definition 
  * @{
  *//*!< Carries information about the erase offset                 *//*!< Determines the timeout for any number of AU erase          *//*!< Determines the number of AUs to be erased in one operation *//*!< Carries information about the card's allocation unit size  *//*!< Carries information about the card's performance move      *//*!< Carries information about the speed class of the card      *//*!< Carries information about the capacity of protected area   *//*!< Carries information about card type                        *//*!< Card is in secured mode of operation                       *//*!< Shows the currently defined data bus width                 *//** @defgroup SD_Exported_Types_Group6 SD Card Status returned by ACMD13 
  * @{
  *//*!< Always 1              *//*!< CID CRC               *//*!< Manufacturing Date    *//*!< Reserved1             *//*!< Product Serial Number *//*!< Product Revision      *//*!< Product Name part2    *//*!< Product Name part1    *//*!< OEM/Application ID    *//*!< Manufacturer ID       *//** @defgroup SD_Exported_Types_Group5 Card Identification Data: CID Register
  * @{
  *//*!< Always 1                              *//*!< CSD CRC                               *//*!< ECC code                              *//*!< File format                           *//*!< Temporary write protection            *//*!< Permanent write protection            *//*!< Copy flag (OTP)                       *//*!< File format group                     *//*!< Content protection application        *//*!< Reserved                              *//*!< Partial blocks for write allowed      *//*!< Max. write data block length          *//*!< Write speed factor                    *//*!< Manufacturer default ECC              *//*!< Write protect group enable            *//*!< Write protect group size              *//*!< Erase group size multiplier           *//*!< Erase group size                      *//*!< Device size multiplier                *//*!< Max. write current @ VDD max          *//*!< Max. write current @ VDD min          *//*!< Max. read current @ VDD max           *//*!< Max. read current @ VDD min           *//*!< Device Size                           *//*!< DSR implemented                       *//*!< Read block misalignment               *//*!< Write block misalignment              *//*!< Partial blocks for read allowed       *//*!< Max. read data block length           *//*!< Card command classes                  *//*!< Max. bus clock frequency              *//*!< Data read access time 2 in CLK cycles *//*!< Data read access time 1               *//*!< System specification version          *//*!< CSD structure                         *//** @defgroup SD_Exported_Types_Group4 Card Specific Data: CSD Register 
  * @{
  *//*!< SD card identification number table *//*!< SD card specific data table         *//*!< SD Card information                 *//*!< SD Rx DMA handle parameters         *//*!< SD Tx DMA handle parameters         *//*!< SD Card Error codes                 *//*!< SD card State                       *//*!< SD transfer context                 *//*!< SD Rx Transfer size                 *//*!< Pointer to SD Rx transfer Buffer    *//*!< SD Tx Transfer size                 *//*!< Pointer to SD Tx transfer Buffer    *//*!< SD locking object                   *//*!< SD required parameters              *//*!< SD registers base address           *//** 
  * @brief  SD handle Structure definition
  *//*!< Specifies logical block size in bytes           *//*!< Specifies the Card logical Capacity in blocks   *//*!< Specifies one block size in bytes               *//*!< Specifies the Card Capacity in blocks           *//*!< Specifies the Relative Card Address             *//*!< Specifies the class of the card class           *//*!< Specifies the card version                      *//*!< Specifies the card Type                         *//** 
  * @brief  SD Card Information Structure definition
  *//** @defgroup SD_Exported_Types_Group3 SD Handle Structure definition   
  * @{
  *//*!< Card response Error                     *//*!< Card is disconnected                    *//*!< Card is in programming state            *//*!< Card is receiving operation information *//*!< Card is sending an operation            *//*!< Card is in transfer state               *//*!< Card is in standby state                *//*!< Card is in identification state         *//*!< Card state is ready                     *//** @defgroup SD_Exported_Types_Group2 SD Card State enumeration structure
  * @{
  *//*!< SD is in error state                *//*!< SD Transfer State                  *//*!< SD Receiving State                  *//*!< SD Programming State                *//*!< SD process ongoing                  *//*!< SD Timeout state                    *//*!< SD initialized and ready for use    *//*!< SD not yet initialized or disabled  *//** @defgroup SD_Exported_Types_Group1 SD State enumeration structure
  * @{
  *//** @defgroup SD_Exported_Types SD Exported Types
  * @{
  *//** @defgroup SD SD
  * @brief SD HAL module driver
  * @{
  *//**
  ******************************************************************************
  * @file    stm32f7xx_hal_sd.h
  * @author  MCD Application Team
  * @brief   Header file of SD HAL module.
  ******************************************************************************
  * @attention
  *
  * Copyright (c) 2017 STMicroelectronics.
  * All rights reserved.
  *
  * This software is licensed under terms that can be found in the LICENSE file
  * in the root directory of this software component.
  * If no LICENSE file comes with this software, it is provided AS-IS.
  *
  ******************************************************************************
  */pCardInfopStatuspCSDpCIDpSDstatusWideModeBlockAddNumberOfBlocksBlockStartAddBlockEndAddTIMEx_DMACommutationHalfCpltHAL_TIMEx_GetChannelNStateconst TIM_HandleTypeDefconst TIM_HandleTypeDef *HAL_TIMEx_HallSensor_GetStateHAL_TIMEx_Break2CallbackTIM_HandleTypeDef *HAL_TIMEx_BreakCallbackHAL_TIMEx_CommutHalfCpltCallbackHAL_TIMEx_RemapConfigHAL_TIMEx_GroupChannel5HAL_TIMEx_ConfigBreakInputconst TIMEx_BreakInputConfigTypeDefconst TIMEx_BreakInputConfigTypeDef *HAL_TIMEx_ConfigBreakDeadTimeconst TIM_BreakDeadTimeConfigTypeDefconst TIM_BreakDeadTimeConfigTypeDef *HAL_TIMEx_MasterConfigSynchronizationconst TIM_MasterConfigTypeDefconst TIM_MasterConfigTypeDef *HAL_TIMEx_OnePulseN_Stop_ITHAL_TIMEx_OnePulseN_Start_ITHAL_TIMEx_OnePulseN_StopHAL_TIMEx_OnePulseN_StartHAL_TIMEx_PWMN_Stop_DMAHAL_TIMEx_PWMN_Start_DMAHAL_TIMEx_PWMN_Stop_ITHAL_TIMEx_PWMN_Start_ITHAL_TIMEx_PWMN_StopHAL_TIMEx_PWMN_StartHAL_TIMEx_OCN_Stop_DMAHAL_TIMEx_OCN_Start_DMAHAL_TIMEx_OCN_Stop_ITHAL_TIMEx_OCN_Start_ITHAL_TIMEx_OCN_StopHAL_TIMEx_OCN_StartHAL_TIMEx_HallSensor_Stop_DMAHAL_TIMEx_HallSensor_Start_DMAHAL_TIMEx_HallSensor_Stop_ITHAL_TIMEx_HallSensor_Start_ITHAL_TIMEx_HallSensor_StopHAL_TIMEx_HallSensor_StartHAL_TIMEx_HallSensor_MspDeInitHAL_TIMEx_HallSensor_MspInitHAL_TIMEx_HallSensor_DeInitHAL_TIMEx_HallSensor_Initconst TIM_HallSensor_InitTypeDefconst TIM_HallSensor_InitTypeDef *TIMEx_BreakInputConfigTypeDefTIM_HallSensor_InitTypeDefCommutation_DelayIC1FilterIC1PrescalerIC1PolarityIS_TIM_BREAKINPUTSOURCE_POLARITY(__POLARITY__)(((__POLARITY__) == TIM_BREAKINPUTSOURCE_POLARITY_LOW) || ((__POLARITY__) == TIM_BREAKINPUTSOURCE_POLARITY_HIGH))IS_TIM_BREAKINPUTSOURCE_STATE(__STATE__)(((__STATE__) == TIM_BREAKINPUTSOURCE_DISABLE) || ((__STATE__) == TIM_BREAKINPUTSOURCE_ENABLE))IS_TIM_BREAKINPUTSOURCE(__SOURCE__)(((__SOURCE__) == TIM_BREAKINPUTSOURCE_BKIN) || ((__SOURCE__) == TIM_BREAKINPUTSOURCE_DFSDM))IS_TIM_BREAKINPUT(__BREAKINPUT__)(((__BREAKINPUT__) == TIM_BREAKINPUT_BRK) || ((__BREAKINPUT__) == TIM_BREAKINPUT_BRK2))IS_TIM_REMAP(__TIM_REMAP__)(((__TIM_REMAP__) == TIM_TIM2_TIM8_TRGO)|| ((__TIM_REMAP__) == TIM_TIM2_ETH_PTP) || ((__TIM_REMAP__) == TIM_TIM2_USBFS_SOF)|| ((__TIM_REMAP__) == TIM_TIM2_USBHS_SOF)|| ((__TIM_REMAP__) == TIM_TIM5_GPIO) || ((__TIM_REMAP__) == TIM_TIM5_LSI) || ((__TIM_REMAP__) == TIM_TIM5_LSE) || ((__TIM_REMAP__) == TIM_TIM5_RTC) || ((__TIM_REMAP__) == TIM_TIM11_GPIO) || ((__TIM_REMAP__) == TIM_TIM11_SPDIFRX) || ((__TIM_REMAP__) == TIM_TIM11_HSE) || ((__TIM_REMAP__) == TIM_TIM11_MCO1))TIM_BREAKINPUTSOURCE_POLARITY_HIGHTIM_BREAKINPUTSOURCE_POLARITY_LOWTIM_BREAKINPUTSOURCE_ENABLETIM_BREAKINPUTSOURCE_DISABLETIM_BREAKINPUTSOURCE_BKINTIM_BREAKINPUT_BRK2TIM_BREAKINPUT_BRKTIM_TIM11_MCO1TIM_TIM11_HSETIM_TIM11_SPDIFRXTIM_TIM11_GPIOTIM_TIM5_RTC(0x000000C0U)TIM_TIM5_LSETIM_TIM5_LSITIM_TIM5_GPIOTIM_TIM2_USBHS_SOFTIM_TIM2_USBFS_SOFTIM_TIM2_ETH_PTP(0x00000400U)TIM_TIM2_TIM8_TRGOSTM32F7xx_HAL_TIM_EX_Hdefined(TIM_BREAK_INPUT_SUPPORT)/* STM32F7xx_HAL_TIM_EX_H *//* End of private functions --------------------------------------------------*//** @addtogroup TIMEx_Private_Functions TIM Extended Private Functions
  * @{
  *//* Private functions----------------------------------------------------------*//* End of exported functions -------------------------------------------------*//* Extended Peripheral State functions  ***************************************//** @addtogroup TIMEx_Exported_Functions_Group7 Extended Peripheral State functions
  * @brief    Extended Peripheral State functions
  * @{
  *//* Extended Callback **********************************************************//** @addtogroup TIMEx_Exported_Functions_Group6 Extended Callbacks functions
  * @brief    Extended Callbacks functions
  * @{
  *//* TIM_BREAK_INPUT_SUPPORT *//* Extended Control functions  ************************************************//** @addtogroup TIMEx_Exported_Functions_Group5 Extended Peripheral Control functions
  *  @brief    Peripheral Control functions
  * @{
  *//*  Timer Complementary One Pulse functions  **********************************//** @addtogroup TIMEx_Exported_Functions_Group4 Extended Timer Complementary One Pulse functions
  *  @brief    Timer Complementary One Pulse functions
  * @{
  *//*  Timer Complementary PWM functions  ****************************************//** @addtogroup TIMEx_Exported_Functions_Group3 Extended Timer Complementary PWM functions
  *  @brief    Timer Complementary PWM functions
  * @{
  *//*  Timer Complementary Output Compare functions  *****************************//** @addtogroup TIMEx_Exported_Functions_Group2 Extended Timer Complementary Output Compare functions
  *  @brief   Timer Complementary Output Compare functions
  * @{
  *//*  Timer Hall Sensor functions  **********************************************//** @addtogroup TIMEx_Exported_Functions_Group1 Extended Timer Hall Sensor functions
  *  @brief    Timer Hall Sensor functions
  * @{
  *//** @addtogroup TIMEx_Exported_Functions TIM Extended Exported Functions
  * @{
  *//* End of private macro ------------------------------------------------------*//** @defgroup TIMEx_Private_Macros TIM Extended Private Macros
  * @{
  *//* End of exported macro -----------------------------------------------------*//** @defgroup TIMEx_Exported_Macros TIM Extended Exported Macros
  * @{
  *//* End of exported constants -------------------------------------------------*//*!< Break input source is active_high *//*!< Break input source is active low *//** @defgroup TIMEx_Break_Input_Source_Polarity TIM Extended Break input polarity
  * @{
  *//*!< Break input source is enabled *//*!< Break input source is disabled *//** @defgroup TIMEx_Break_Input_Source_Enable TIM Extended Break input source enabling
  * @{
  *//*!< The analog watchdog output of the DFSDM1 peripheral is connected to the break input *//*!< An external source (GPIO) is connected to the BKIN pin  *//** @defgroup TIMEx_Break_Input_Source TIM Extended Break input source
  * @{
  *//*!< Timer break2 input *//*!< Timer break input  *//** @defgroup TIMEx_Break_Input TIM Extended Break input
  * @{
  *//** @defgroup TIMEx_Remap TIM Extended Remapping
  * @{
  *//** @defgroup TIMEx_Exported_Constants TIM Extended Exported Constants
  * @{
  *//* End of exported types -----------------------------------------------------*//*!< Specifies the break input source polarity.
                                This parameter can be a value of @ref TIMEx_Break_Input_Source_Polarity
                                Not relevant when analog watchdog output of the DFSDM1 used as break input source *//*!< Specifies whether or not the break input source is enabled.
                                This parameter can be a value of @ref TIMEx_Break_Input_Source_Enable *//*!< Specifies the source of the timer break input.
                                This parameter can be a value of @ref TIMEx_Break_Input_Source *//**
  * @brief  TIM Break/Break2 input configuration
  *//*!< Specifies the pulse value to be loaded into the Capture Compare Register.
                                     This parameter can be a number between Min_Data = 0x0000 and Max_Data = 0xFFFF *//*!< Specifies the input capture filter.
                                     This parameter can be a number between Min_Data = 0x0 and Max_Data = 0xF *//*!< Specifies the Input Capture Prescaler.
                                     This parameter can be a value of @ref TIM_Input_Capture_Prescaler *//*!< Specifies the active edge of the input signal.
                                     This parameter can be a value of @ref TIM_Input_Capture_Polarity *//**
  * @brief  TIM Hall sensor Configuration Structure definition
  *//** @defgroup TIMEx_Exported_Types TIM Extended Exported Types
  * @{
  *//** @addtogroup TIMEx
  * @{
  *//**
  ******************************************************************************
  * @file    stm32f7xx_hal_tim_ex.h
  * @author  MCD Application Team
  * @brief   Header file of TIM HAL Extended module.
  ******************************************************************************
  * @attention
  *
  * Copyright (c) 2017 STMicroelectronics.
  * All rights reserved.
  *
  * This software is licensed under terms that can be found in the LICENSE file
  * in the root directory of this software component.
  * If no LICENSE file comes with this software, it is provided AS-IS.
  *
  ******************************************************************************
  */htimChannelNRemapChannelsBreakInputsBreakInputConfigsBreakDeadTimeConfigsMasterConfigInputTriggerCommutationSourceOutputChannel"stm32f7xx_hal_tim_ex.h"TIM_CCxChannelCmdTIM_TypeDef *TIM_DMACaptureHalfCpltTIM_DMADelayPulseHalfCpltTIM_ETR_SetConfigTIM_OC2_SetConfigconst TIM_OC_InitTypeDefconst TIM_OC_InitTypeDef *TIM_TI1_SetConfigTIM_Base_SetConfigconst TIM_Base_InitTypeDefconst TIM_Base_InitTypeDef *HAL_TIM_DMABurstStateHAL_TIM_GetChannelStateHAL_TIM_GetActiveChannelHAL_TIM_Encoder_GetStateHAL_TIM_OnePulse_GetStateHAL_TIM_IC_GetStateHAL_TIM_PWM_GetStateHAL_TIM_OC_GetStateHAL_TIM_Base_GetStateHAL_TIM_ErrorCallbackHAL_TIM_TriggerHalfCpltCallbackHAL_TIM_TriggerCallbackHAL_TIM_PWM_PulseFinishedHalfCpltCallbackHAL_TIM_PWM_PulseFinishedCallbackHAL_TIM_IC_CaptureHalfCpltCallbackHAL_TIM_IC_CaptureCallbackHAL_TIM_OC_DelayElapsedCallbackHAL_TIM_PeriodElapsedHalfCpltCallbackHAL_TIM_PeriodElapsedCallbackHAL_TIM_ReadCapturedValueHAL_TIM_GenerateEventHAL_TIM_DMABurst_ReadStopHAL_TIM_DMABurst_MultiReadStartHAL_TIM_DMABurst_ReadStartHAL_TIM_DMABurst_WriteStopHAL_TIM_DMABurst_MultiWriteStartHAL_TIM_DMABurst_WriteStartconst TIM_SlaveConfigTypeDefconst TIM_SlaveConfigTypeDef *HAL_TIM_ConfigTI1InputHAL_TIM_ConfigClockSourceconst TIM_ClockConfigTypeDefconst TIM_ClockConfigTypeDef *HAL_TIM_ConfigOCrefClearconst TIM_ClearInputConfigTypeDefconst TIM_ClearInputConfigTypeDef *HAL_TIM_OnePulse_ConfigChannelTIM_OnePulse_InitTypeDef *HAL_TIM_IC_ConfigChannelconst TIM_IC_InitTypeDefconst TIM_IC_InitTypeDef *HAL_TIM_PWM_ConfigChannelHAL_TIM_OC_ConfigChannelHAL_TIM_IRQHandlerHAL_TIM_Encoder_Stop_DMAHAL_TIM_Encoder_Start_DMAHAL_TIM_Encoder_Stop_ITHAL_TIM_Encoder_Start_ITHAL_TIM_Encoder_StopHAL_TIM_Encoder_StartHAL_TIM_Encoder_MspDeInitHAL_TIM_Encoder_MspInitHAL_TIM_Encoder_DeInitHAL_TIM_Encoder_Initconst TIM_Encoder_InitTypeDefconst TIM_Encoder_InitTypeDef *HAL_TIM_OnePulse_Stop_ITHAL_TIM_OnePulse_Start_ITHAL_TIM_OnePulse_StopHAL_TIM_OnePulse_StartHAL_TIM_OnePulse_MspDeInitHAL_TIM_OnePulse_MspInitHAL_TIM_OnePulse_DeInitHAL_TIM_OnePulse_InitHAL_TIM_IC_Stop_DMAHAL_TIM_IC_Start_DMAHAL_TIM_IC_Stop_ITHAL_TIM_IC_Start_ITHAL_TIM_IC_StopHAL_TIM_IC_StartHAL_TIM_IC_MspDeInitHAL_TIM_IC_MspInitHAL_TIM_IC_DeInitHAL_TIM_IC_InitHAL_TIM_PWM_Stop_DMAHAL_TIM_PWM_Start_DMAHAL_TIM_PWM_Stop_ITHAL_TIM_PWM_Start_ITHAL_TIM_PWM_StopHAL_TIM_PWM_StartHAL_TIM_PWM_MspDeInitHAL_TIM_PWM_MspInitHAL_TIM_PWM_DeInitHAL_TIM_PWM_InitHAL_TIM_OC_Stop_DMAHAL_TIM_OC_Start_DMAHAL_TIM_OC_Stop_ITHAL_TIM_OC_Start_ITHAL_TIM_OC_StopHAL_TIM_OC_StartHAL_TIM_OC_MspDeInitHAL_TIM_OC_MspInitHAL_TIM_OC_DeInitHAL_TIM_OC_InitHAL_TIM_Base_Stop_DMAHAL_TIM_Base_Start_DMAHAL_TIM_Base_Stop_ITHAL_TIM_Base_Start_ITHAL_TIM_Base_StopHAL_TIM_Base_StartHAL_TIM_Base_MspDeInitHAL_TIM_Base_MspInitHAL_TIM_Base_DeInitHAL_TIM_Base_InitTIM_HandleTypeDefHAL_TIM_ActiveChannelHAL_TIM_ACTIVE_CHANNEL_1HAL_TIM_ACTIVE_CHANNEL_2HAL_TIM_ACTIVE_CHANNEL_3HAL_TIM_ACTIVE_CHANNEL_4HAL_TIM_ACTIVE_CHANNEL_5HAL_TIM_ACTIVE_CHANNEL_6HAL_TIM_ACTIVE_CHANNEL_CLEAREDHAL_TIM_DMABurstStateTypeDefHAL_DMA_BURST_STATE_RESETHAL_DMA_BURST_STATE_READYHAL_DMA_BURST_STATE_BUSYHAL_TIM_ChannelStateTypeDefHAL_TIM_CHANNEL_STATE_RESETHAL_TIM_CHANNEL_STATE_READYHAL_TIM_CHANNEL_STATE_BUSYHAL_TIM_StateTypeDefHAL_TIM_STATE_RESETHAL_TIM_STATE_READYHAL_TIM_STATE_BUSYHAL_TIM_STATE_TIMEOUTHAL_TIM_STATE_ERRORTIM_BreakDeadTimeConfigTypeDefTIM_SlaveConfigTypeDefTIM_MasterConfigTypeDefTIM_ClearInputConfigTypeDefTIM_ClockConfigTypeDefTIM_Encoder_InitTypeDefTIM_IC_InitTypeDefTIM_OnePulse_InitTypeDefTIM_OC_InitTypeDefTIM_Base_InitTypeDefvolatile HAL_TIM_DMABurstStateTypeDefDMABurstStatevolatile HAL_TIM_ChannelStateTypeDefvolatile HAL_TIM_ChannelStateTypeDef[4]enum <unnamed>[4]ChannelNStatevolatile HAL_TIM_ChannelStateTypeDef[6]enum <unnamed>[6]ChannelStatevolatile HAL_TIM_StateTypeDefDMA_HandleTypeDef *[7]__DMA_HandleTypeDef *[7]AutomaticOutputBreak2FilterBreak2PolarityBreak2StateBreakFilterBreakPolarityBreakStateLockLevelOffStateIDLEModeOffStateRunModeTriggerFilterTriggerPrescalerTriggerPolaritySlaveModeMasterSlaveModeMasterOutputTrigger2MasterOutputTriggerClearInputFilterClearInputPrescalerClearInputPolarityClearInputSourceClearInputStateClockFilterClockPolarityClockSourceIC2FilterIC2PrescalerIC2SelectionIC2PolarityIC1SelectionEncoderModeICFilterICPrescalerICSelectionICPolarityOCNIdleStateOCIdleStateOCNPolarityOCPolarityPulseOCModeOCFastModeAutoReloadPreloadRepetitionCounterClockDivisionPeriodCounterModePrescalerTIM_CHANNEL_N_STATE_SET_ALL(__HANDLE__,__CHANNEL_STATE__)do { (__HANDLE__)->ChannelNState[0] = (__CHANNEL_STATE__); (__HANDLE__)->ChannelNState[1] = (__CHANNEL_STATE__); (__HANDLE__)->ChannelNState[2] = (__CHANNEL_STATE__); (__HANDLE__)->ChannelNState[3] = (__CHANNEL_STATE__); } while(0)TIM_CHANNEL_N_STATE_SET(__HANDLE__,__CHANNEL__,__CHANNEL_STATE__)(((__CHANNEL__) == TIM_CHANNEL_1) ? ((__HANDLE__)->ChannelNState[0] = (__CHANNEL_STATE__)) : ((__CHANNEL__) == TIM_CHANNEL_2) ? ((__HANDLE__)->ChannelNState[1] = (__CHANNEL_STATE__)) : ((__CHANNEL__) == TIM_CHANNEL_3) ? ((__HANDLE__)->ChannelNState[2] = (__CHANNEL_STATE__)) : ((__HANDLE__)->ChannelNState[3] = (__CHANNEL_STATE__)))TIM_CHANNEL_N_STATE_GET(__HANDLE__,__CHANNEL__)(((__CHANNEL__) == TIM_CHANNEL_1) ? (__HANDLE__)->ChannelNState[0] : ((__CHANNEL__) == TIM_CHANNEL_2) ? (__HANDLE__)->ChannelNState[1] : ((__CHANNEL__) == TIM_CHANNEL_3) ? (__HANDLE__)->ChannelNState[2] : (__HANDLE__)->ChannelNState[3])TIM_CHANNEL_STATE_SET_ALL(__HANDLE__,__CHANNEL_STATE__)do { (__HANDLE__)->ChannelState[0] = (__CHANNEL_STATE__); (__HANDLE__)->ChannelState[1] = (__CHANNEL_STATE__); (__HANDLE__)->ChannelState[2] = (__CHANNEL_STATE__); (__HANDLE__)->ChannelState[3] = (__CHANNEL_STATE__); (__HANDLE__)->ChannelState[4] = (__CHANNEL_STATE__); (__HANDLE__)->ChannelState[5] = (__CHANNEL_STATE__); } while(0)TIM_CHANNEL_STATE_SET(__HANDLE__,__CHANNEL__,__CHANNEL_STATE__)(((__CHANNEL__) == TIM_CHANNEL_1) ? ((__HANDLE__)->ChannelState[0] = (__CHANNEL_STATE__)) : ((__CHANNEL__) == TIM_CHANNEL_2) ? ((__HANDLE__)->ChannelState[1] = (__CHANNEL_STATE__)) : ((__CHANNEL__) == TIM_CHANNEL_3) ? ((__HANDLE__)->ChannelState[2] = (__CHANNEL_STATE__)) : ((__CHANNEL__) == TIM_CHANNEL_4) ? ((__HANDLE__)->ChannelState[3] = (__CHANNEL_STATE__)) : ((__CHANNEL__) == TIM_CHANNEL_5) ? ((__HANDLE__)->ChannelState[4] = (__CHANNEL_STATE__)) : ((__HANDLE__)->ChannelState[5] = (__CHANNEL_STATE__)))TIM_CHANNEL_STATE_GET(__HANDLE__,__CHANNEL__)(((__CHANNEL__) == TIM_CHANNEL_1) ? (__HANDLE__)->ChannelState[0] : ((__CHANNEL__) == TIM_CHANNEL_2) ? (__HANDLE__)->ChannelState[1] : ((__CHANNEL__) == TIM_CHANNEL_3) ? (__HANDLE__)->ChannelState[2] : ((__CHANNEL__) == TIM_CHANNEL_4) ? (__HANDLE__)->ChannelState[3] : ((__CHANNEL__) == TIM_CHANNEL_5) ? (__HANDLE__)->ChannelState[4] : (__HANDLE__)->ChannelState[5])TIM_RESET_CAPTUREPOLARITY(__HANDLE__,__CHANNEL__)(((__CHANNEL__) == TIM_CHANNEL_1) ? ((__HANDLE__)->Instance->CCER &= ~(TIM_CCER_CC1P | TIM_CCER_CC1NP)) : ((__CHANNEL__) == TIM_CHANNEL_2) ? ((__HANDLE__)->Instance->CCER &= ~(TIM_CCER_CC2P | TIM_CCER_CC2NP)) : ((__CHANNEL__) == TIM_CHANNEL_3) ? ((__HANDLE__)->Instance->CCER &= ~(TIM_CCER_CC3P | TIM_CCER_CC3NP)) : ((__HANDLE__)->Instance->CCER &= ~(TIM_CCER_CC4P | TIM_CCER_CC4NP)))TIM_SET_CAPTUREPOLARITY(__HANDLE__,__CHANNEL__,__POLARITY__)(((__CHANNEL__) == TIM_CHANNEL_1) ? ((__HANDLE__)->Instance->CCER |= (__POLARITY__)) : ((__CHANNEL__) == TIM_CHANNEL_2) ? ((__HANDLE__)->Instance->CCER |= ((__POLARITY__) << 4U)) : ((__CHANNEL__) == TIM_CHANNEL_3) ? ((__HANDLE__)->Instance->CCER |= ((__POLARITY__) << 8U)) : ((__HANDLE__)->Instance->CCER |= (((__POLARITY__) << 12U))))TIM_RESET_ICPRESCALERVALUE(__HANDLE__,__CHANNEL__)(((__CHANNEL__) == TIM_CHANNEL_1) ? ((__HANDLE__)->Instance->CCMR1 &= ~TIM_CCMR1_IC1PSC) : ((__CHANNEL__) == TIM_CHANNEL_2) ? ((__HANDLE__)->Instance->CCMR1 &= ~TIM_CCMR1_IC2PSC) : ((__CHANNEL__) == TIM_CHANNEL_3) ? ((__HANDLE__)->Instance->CCMR2 &= ~TIM_CCMR2_IC3PSC) : ((__HANDLE__)->Instance->CCMR2 &= ~TIM_CCMR2_IC4PSC))TIM_SET_ICPRESCALERVALUE(__HANDLE__,__CHANNEL__,__ICPSC__)(((__CHANNEL__) == TIM_CHANNEL_1) ? ((__HANDLE__)->Instance->CCMR1 |= (__ICPSC__)) : ((__CHANNEL__) == TIM_CHANNEL_2) ? ((__HANDLE__)->Instance->CCMR1 |= ((__ICPSC__) << 8U)) : ((__CHANNEL__) == TIM_CHANNEL_3) ? ((__HANDLE__)->Instance->CCMR2 |= (__ICPSC__)) : ((__HANDLE__)->Instance->CCMR2 |= ((__ICPSC__) << 8U)))IS_TIM_SLAVEMODE_TRIGGER_ENABLED(__TRIGGER__)(((__TRIGGER__) == TIM_SLAVEMODE_TRIGGER) || ((__TRIGGER__) == TIM_SLAVEMODE_COMBINED_RESETTRIGGER))IS_TIM_BREAK_SYSTEM(__CONFIG__)(((__CONFIG__) == TIM_BREAK_SYSTEM_ECC) || ((__CONFIG__) == TIM_BREAK_SYSTEM_PVD) || ((__CONFIG__) == TIM_BREAK_SYSTEM_SRAM_PARITY_ERROR) || ((__CONFIG__) == TIM_BREAK_SYSTEM_LOCKUP))IS_TIM_DEADTIME(__DEADTIME__)((__DEADTIME__) <= 0xFFU)IS_TIM_IC_FILTER(__ICFILTER__)((__ICFILTER__) <= 0xFU)IS_TIM_DMA_DATA_LENGTH(LENGTH)(((LENGTH) >= 0x1U) && ((LENGTH) < 0x10000U))IS_TIM_DMA_LENGTH(__LENGTH__)(((__LENGTH__) == TIM_DMABURSTLENGTH_1TRANSFER) || ((__LENGTH__) == TIM_DMABURSTLENGTH_2TRANSFERS) || ((__LENGTH__) == TIM_DMABURSTLENGTH_3TRANSFERS) || ((__LENGTH__) == TIM_DMABURSTLENGTH_4TRANSFERS) || ((__LENGTH__) == TIM_DMABURSTLENGTH_5TRANSFERS) || ((__LENGTH__) == TIM_DMABURSTLENGTH_6TRANSFERS) || ((__LENGTH__) == TIM_DMABURSTLENGTH_7TRANSFERS) || ((__LENGTH__) == TIM_DMABURSTLENGTH_8TRANSFERS) || ((__LENGTH__) == TIM_DMABURSTLENGTH_9TRANSFERS) || ((__LENGTH__) == TIM_DMABURSTLENGTH_10TRANSFERS) || ((__LENGTH__) == TIM_DMABURSTLENGTH_11TRANSFERS) || ((__LENGTH__) == TIM_DMABURSTLENGTH_12TRANSFERS) || ((__LENGTH__) == TIM_DMABURSTLENGTH_13TRANSFERS) || ((__LENGTH__) == TIM_DMABURSTLENGTH_14TRANSFERS) || ((__LENGTH__) == TIM_DMABURSTLENGTH_15TRANSFERS) || ((__LENGTH__) == TIM_DMABURSTLENGTH_16TRANSFERS) || ((__LENGTH__) == TIM_DMABURSTLENGTH_17TRANSFERS) || ((__LENGTH__) == TIM_DMABURSTLENGTH_18TRANSFERS))IS_TIM_TI1SELECTION(__TI1SELECTION__)(((__TI1SELECTION__) == TIM_TI1SELECTION_CH1) || ((__TI1SELECTION__) == TIM_TI1SELECTION_XORCOMBINATION))IS_TIM_TRIGGERFILTER(__ICFILTER__)IS_TIM_TRIGGERPRESCALER(__PRESCALER__)(((__PRESCALER__) == TIM_TRIGGERPRESCALER_DIV1) || ((__PRESCALER__) == TIM_TRIGGERPRESCALER_DIV2) || ((__PRESCALER__) == TIM_TRIGGERPRESCALER_DIV4) || ((__PRESCALER__) == TIM_TRIGGERPRESCALER_DIV8))IS_TIM_TRIGGERPOLARITY(__POLARITY__)(((__POLARITY__) == TIM_TRIGGERPOLARITY_INVERTED ) || ((__POLARITY__) == TIM_TRIGGERPOLARITY_NONINVERTED) || ((__POLARITY__) == TIM_TRIGGERPOLARITY_RISING ) || ((__POLARITY__) == TIM_TRIGGERPOLARITY_FALLING ) || ((__POLARITY__) == TIM_TRIGGERPOLARITY_BOTHEDGE ))IS_TIM_INTERNAL_TRIGGEREVENT_SELECTION(__SELECTION__)(((__SELECTION__) == TIM_TS_ITR0) || ((__SELECTION__) == TIM_TS_ITR1) || ((__SELECTION__) == TIM_TS_ITR2) || ((__SELECTION__) == TIM_TS_ITR3) || ((__SELECTION__) == TIM_TS_NONE))IS_TIM_TRIGGER_SELECTION(__SELECTION__)(((__SELECTION__) == TIM_TS_ITR0) || ((__SELECTION__) == TIM_TS_ITR1) || ((__SELECTION__) == TIM_TS_ITR2) || ((__SELECTION__) == TIM_TS_ITR3) || ((__SELECTION__) == TIM_TS_TI1F_ED) || ((__SELECTION__) == TIM_TS_TI1FP1) || ((__SELECTION__) == TIM_TS_TI2FP2) || ((__SELECTION__) == TIM_TS_ETRF))IS_TIM_OC_MODE(__MODE__)(((__MODE__) == TIM_OCMODE_TIMING) || ((__MODE__) == TIM_OCMODE_ACTIVE) || ((__MODE__) == TIM_OCMODE_INACTIVE) || ((__MODE__) == TIM_OCMODE_TOGGLE) || ((__MODE__) == TIM_OCMODE_FORCED_ACTIVE) || ((__MODE__) == TIM_OCMODE_FORCED_INACTIVE) || ((__MODE__) == TIM_OCMODE_RETRIGERRABLE_OPM1) || ((__MODE__) == TIM_OCMODE_RETRIGERRABLE_OPM2))IS_TIM_PWM_MODE(__MODE__)(((__MODE__) == TIM_OCMODE_PWM1) || ((__MODE__) == TIM_OCMODE_PWM2) || ((__MODE__) == TIM_OCMODE_COMBINED_PWM1) || ((__MODE__) == TIM_OCMODE_COMBINED_PWM2) || ((__MODE__) == TIM_OCMODE_ASYMMETRIC_PWM1) || ((__MODE__) == TIM_OCMODE_ASYMMETRIC_PWM2))IS_TIM_SLAVE_MODE(__MODE__)(((__MODE__) == TIM_SLAVEMODE_DISABLE) || ((__MODE__) == TIM_SLAVEMODE_RESET) || ((__MODE__) == TIM_SLAVEMODE_GATED) || ((__MODE__) == TIM_SLAVEMODE_TRIGGER) || ((__MODE__) == TIM_SLAVEMODE_EXTERNAL1) || ((__MODE__) == TIM_SLAVEMODE_COMBINED_RESETTRIGGER))IS_TIM_MSM_STATE(__STATE__)(((__STATE__) == TIM_MASTERSLAVEMODE_ENABLE) || ((__STATE__) == TIM_MASTERSLAVEMODE_DISABLE))IS_TIM_TRGO2_SOURCE(__SOURCE__)(((__SOURCE__) == TIM_TRGO2_RESET) || ((__SOURCE__) == TIM_TRGO2_ENABLE) || ((__SOURCE__) == TIM_TRGO2_UPDATE) || ((__SOURCE__) == TIM_TRGO2_OC1) || ((__SOURCE__) == TIM_TRGO2_OC1REF) || ((__SOURCE__) == TIM_TRGO2_OC2REF) || ((__SOURCE__) == TIM_TRGO2_OC3REF) || ((__SOURCE__) == TIM_TRGO2_OC3REF) || ((__SOURCE__) == TIM_TRGO2_OC4REF) || ((__SOURCE__) == TIM_TRGO2_OC5REF) || ((__SOURCE__) == TIM_TRGO2_OC6REF) || ((__SOURCE__) == TIM_TRGO2_OC4REF_RISINGFALLING) || ((__SOURCE__) == TIM_TRGO2_OC6REF_RISINGFALLING) || ((__SOURCE__) == TIM_TRGO2_OC4REF_RISING_OC6REF_RISING) || ((__SOURCE__) == TIM_TRGO2_OC4REF_RISING_OC6REF_FALLING) || ((__SOURCE__) == TIM_TRGO2_OC5REF_RISING_OC6REF_RISING) || ((__SOURCE__) == TIM_TRGO2_OC5REF_RISING_OC6REF_FALLING))IS_TIM_TRGO_SOURCE(__SOURCE__)(((__SOURCE__) == TIM_TRGO_RESET) || ((__SOURCE__) == TIM_TRGO_ENABLE) || ((__SOURCE__) == TIM_TRGO_UPDATE) || ((__SOURCE__) == TIM_TRGO_OC1) || ((__SOURCE__) == TIM_TRGO_OC1REF) || ((__SOURCE__) == TIM_TRGO_OC2REF) || ((__SOURCE__) == TIM_TRGO_OC3REF) || ((__SOURCE__) == TIM_TRGO_OC4REF))IS_TIM_GROUPCH5(__OCREF__)((((__OCREF__) & 0x1FFFFFFFU) == 0x00000000U))IS_TIM_AUTOMATIC_OUTPUT_STATE(__STATE__)(((__STATE__) == TIM_AUTOMATICOUTPUT_ENABLE) || ((__STATE__) == TIM_AUTOMATICOUTPUT_DISABLE))IS_TIM_BREAK2_POLARITY(__POLARITY__)(((__POLARITY__) == TIM_BREAK2POLARITY_LOW) || ((__POLARITY__) == TIM_BREAK2POLARITY_HIGH))IS_TIM_BREAK2_STATE(__STATE__)(((__STATE__) == TIM_BREAK2_ENABLE) || ((__STATE__) == TIM_BREAK2_DISABLE))IS_TIM_BREAK_POLARITY(__POLARITY__)(((__POLARITY__) == TIM_BREAKPOLARITY_LOW) || ((__POLARITY__) == TIM_BREAKPOLARITY_HIGH))IS_TIM_BREAK_STATE(__STATE__)(((__STATE__) == TIM_BREAK_ENABLE) || ((__STATE__) == TIM_BREAK_DISABLE))IS_TIM_BREAK_FILTER(__BRKFILTER__)((__BRKFILTER__) <= 0xFUL)IS_TIM_LOCK_LEVEL(__LEVEL__)(((__LEVEL__) == TIM_LOCKLEVEL_OFF) || ((__LEVEL__) == TIM_LOCKLEVEL_1) || ((__LEVEL__) == TIM_LOCKLEVEL_2) || ((__LEVEL__) == TIM_LOCKLEVEL_3))IS_TIM_OSSI_STATE(__STATE__)(((__STATE__) == TIM_OSSI_ENABLE) || ((__STATE__) == TIM_OSSI_DISABLE))IS_TIM_OSSR_STATE(__STATE__)(((__STATE__) == TIM_OSSR_ENABLE) || ((__STATE__) == TIM_OSSR_DISABLE))IS_TIM_CLEARINPUT_FILTER(__ICFILTER__)IS_TIM_CLEARINPUT_PRESCALER(__PRESCALER__)(((__PRESCALER__) == TIM_CLEARINPUTPRESCALER_DIV1) || ((__PRESCALER__) == TIM_CLEARINPUTPRESCALER_DIV2) || ((__PRESCALER__) == TIM_CLEARINPUTPRESCALER_DIV4) || ((__PRESCALER__) == TIM_CLEARINPUTPRESCALER_DIV8))IS_TIM_CLEARINPUT_POLARITY(__POLARITY__)(((__POLARITY__) == TIM_CLEARINPUTPOLARITY_INVERTED) || ((__POLARITY__) == TIM_CLEARINPUTPOLARITY_NONINVERTED))IS_TIM_CLOCKFILTER(__ICFILTER__)IS_TIM_CLOCKPRESCALER(__PRESCALER__)(((__PRESCALER__) == TIM_CLOCKPRESCALER_DIV1) || ((__PRESCALER__) == TIM_CLOCKPRESCALER_DIV2) || ((__PRESCALER__) == TIM_CLOCKPRESCALER_DIV4) || ((__PRESCALER__) == TIM_CLOCKPRESCALER_DIV8))IS_TIM_CLOCKPOLARITY(__POLARITY__)(((__POLARITY__) == TIM_CLOCKPOLARITY_INVERTED) || ((__POLARITY__) == TIM_CLOCKPOLARITY_NONINVERTED) || ((__POLARITY__) == TIM_CLOCKPOLARITY_RISING) || ((__POLARITY__) == TIM_CLOCKPOLARITY_FALLING) || ((__POLARITY__) == TIM_CLOCKPOLARITY_BOTHEDGE))IS_TIM_CLOCKSOURCE(__CLOCK__)(((__CLOCK__) == TIM_CLOCKSOURCE_INTERNAL) || ((__CLOCK__) == TIM_CLOCKSOURCE_ETRMODE1) || ((__CLOCK__) == TIM_CLOCKSOURCE_ETRMODE2) || ((__CLOCK__) == TIM_CLOCKSOURCE_TI1ED) || ((__CLOCK__) == TIM_CLOCKSOURCE_TI1) || ((__CLOCK__) == TIM_CLOCKSOURCE_TI2) || ((__CLOCK__) == TIM_CLOCKSOURCE_ITR0) || ((__CLOCK__) == TIM_CLOCKSOURCE_ITR1) || ((__CLOCK__) == TIM_CLOCKSOURCE_ITR2) || ((__CLOCK__) == TIM_CLOCKSOURCE_ITR3))IS_TIM_COMPLEMENTARY_CHANNELS(__CHANNEL__)(((__CHANNEL__) == TIM_CHANNEL_1) || ((__CHANNEL__) == TIM_CHANNEL_2) || ((__CHANNEL__) == TIM_CHANNEL_3))IS_TIM_PERIOD(__HANDLE__,__PERIOD__)((IS_TIM_32B_COUNTER_INSTANCE(((__HANDLE__)->Instance)) == 0U) ? (((__PERIOD__) > 0U) && ((__PERIOD__) <= 0x0000FFFFU)) : ((__PERIOD__) > 0U))IS_TIM_OPM_CHANNELS(__CHANNEL__)(((__CHANNEL__) == TIM_CHANNEL_1) || ((__CHANNEL__) == TIM_CHANNEL_2))IS_TIM_CHANNELS(__CHANNEL__)(((__CHANNEL__) == TIM_CHANNEL_1) || ((__CHANNEL__) == TIM_CHANNEL_2) || ((__CHANNEL__) == TIM_CHANNEL_3) || ((__CHANNEL__) == TIM_CHANNEL_4) || ((__CHANNEL__) == TIM_CHANNEL_5) || ((__CHANNEL__) == TIM_CHANNEL_6) || ((__CHANNEL__) == TIM_CHANNEL_ALL))IS_TIM_DMA_SOURCE(__SOURCE__)((((__SOURCE__) & 0xFFFF80FFU) == 0x00000000U) && ((__SOURCE__) != 0x00000000U))IS_TIM_ENCODER_MODE(__MODE__)(((__MODE__) == TIM_ENCODERMODE_TI1) || ((__MODE__) == TIM_ENCODERMODE_TI2) || ((__MODE__) == TIM_ENCODERMODE_TI12))IS_TIM_OPM_MODE(__MODE__)(((__MODE__) == TIM_OPMODE_SINGLE) || ((__MODE__) == TIM_OPMODE_REPETITIVE))IS_TIM_CCX_CHANNEL(__INSTANCE__,__CHANNEL__)(IS_TIM_CCX_INSTANCE(__INSTANCE__, __CHANNEL__) && ((__CHANNEL__) != (TIM_CHANNEL_5)) && ((__CHANNEL__) != (TIM_CHANNEL_6)))IS_TIM_IC_PRESCALER(__PRESCALER__)(((__PRESCALER__) == TIM_ICPSC_DIV1) || ((__PRESCALER__) == TIM_ICPSC_DIV2) || ((__PRESCALER__) == TIM_ICPSC_DIV4) || ((__PRESCALER__) == TIM_ICPSC_DIV8))IS_TIM_IC_SELECTION(__SELECTION__)(((__SELECTION__) == TIM_ICSELECTION_DIRECTTI) || ((__SELECTION__) == TIM_ICSELECTION_INDIRECTTI) || ((__SELECTION__) == TIM_ICSELECTION_TRC))IS_TIM_IC_POLARITY(__POLARITY__)(((__POLARITY__) == TIM_ICPOLARITY_RISING) || ((__POLARITY__) == TIM_ICPOLARITY_FALLING) || ((__POLARITY__) == TIM_ICPOLARITY_BOTHEDGE))IS_TIM_ENCODERINPUT_POLARITY(__POLARITY__)(((__POLARITY__) == TIM_ENCODERINPUTPOLARITY_RISING) || ((__POLARITY__) == TIM_ENCODERINPUTPOLARITY_FALLING))IS_TIM_OCNIDLE_STATE(__STATE__)(((__STATE__) == TIM_OCNIDLESTATE_SET) || ((__STATE__) == TIM_OCNIDLESTATE_RESET))IS_TIM_OCIDLE_STATE(__STATE__)(((__STATE__) == TIM_OCIDLESTATE_SET) || ((__STATE__) == TIM_OCIDLESTATE_RESET))IS_TIM_OCN_POLARITY(__POLARITY__)(((__POLARITY__) == TIM_OCNPOLARITY_HIGH) || ((__POLARITY__) == TIM_OCNPOLARITY_LOW))IS_TIM_OC_POLARITY(__POLARITY__)(((__POLARITY__) == TIM_OCPOLARITY_HIGH) || ((__POLARITY__) == TIM_OCPOLARITY_LOW))IS_TIM_FAST_STATE(__STATE__)(((__STATE__) == TIM_OCFAST_DISABLE) || ((__STATE__) == TIM_OCFAST_ENABLE))IS_TIM_AUTORELOAD_PRELOAD(PRELOAD)(((PRELOAD) == TIM_AUTORELOAD_PRELOAD_DISABLE) || ((PRELOAD) == TIM_AUTORELOAD_PRELOAD_ENABLE))IS_TIM_CLOCKDIVISION_DIV(__DIV__)(((__DIV__) == TIM_CLOCKDIVISION_DIV1) || ((__DIV__) == TIM_CLOCKDIVISION_DIV2) || ((__DIV__) == TIM_CLOCKDIVISION_DIV4))IS_TIM_UIFREMAP_MODE(__MODE__)(((__MODE__) == TIM_UIFREMAP_DISABLE) || ((__MODE__) == TIM_UIFREMAP_ENABLE))IS_TIM_COUNTER_MODE(__MODE__)(((__MODE__) == TIM_COUNTERMODE_UP) || ((__MODE__) == TIM_COUNTERMODE_DOWN) || ((__MODE__) == TIM_COUNTERMODE_CENTERALIGNED1) || ((__MODE__) == TIM_COUNTERMODE_CENTERALIGNED2) || ((__MODE__) == TIM_COUNTERMODE_CENTERALIGNED3))IS_TIM_EVENT_SOURCE(__SOURCE__)((((__SOURCE__) & 0xFFFFFE00U) == 0x00000000U) && ((__SOURCE__) != 0x00000000U))IS_TIM_DMA_BASE(__BASE__)(((__BASE__) == TIM_DMABASE_CR1) || ((__BASE__) == TIM_DMABASE_CR2) || ((__BASE__) == TIM_DMABASE_SMCR) || ((__BASE__) == TIM_DMABASE_DIER) || ((__BASE__) == TIM_DMABASE_SR) || ((__BASE__) == TIM_DMABASE_EGR) || ((__BASE__) == TIM_DMABASE_CCMR1) || ((__BASE__) == TIM_DMABASE_CCMR2) || ((__BASE__) == TIM_DMABASE_CCER) || ((__BASE__) == TIM_DMABASE_CNT) || ((__BASE__) == TIM_DMABASE_PSC) || ((__BASE__) == TIM_DMABASE_ARR) || ((__BASE__) == TIM_DMABASE_RCR) || ((__BASE__) == TIM_DMABASE_CCR1) || ((__BASE__) == TIM_DMABASE_CCR2) || ((__BASE__) == TIM_DMABASE_CCR3) || ((__BASE__) == TIM_DMABASE_CCR4) || ((__BASE__) == TIM_DMABASE_BDTR) || ((__BASE__) == TIM_DMABASE_OR) || ((__BASE__) == TIM_DMABASE_CCMR3) || ((__BASE__) == TIM_DMABASE_CCR5) || ((__BASE__) == TIM_DMABASE_CCR6))IS_TIM_CLEARINPUT_SOURCE(__MODE__)(((__MODE__) == TIM_CLEARINPUTSOURCE_NONE) || ((__MODE__) == TIM_CLEARINPUTSOURCE_ETR))((uint32_t)(TIM_CCER_CC1NE | TIM_CCER_CC2NE | TIM_CCER_CC3NE))((uint32_t)(TIM_CCER_CC1E | TIM_CCER_CC2E | TIM_CCER_CC3E | TIM_CCER_CC4E))__HAL_TIM_SELECT_CCDMAREQUEST(__HANDLE__,__CCDMA__)MODIFY_REG((__HANDLE__)->Instance->CR2, TIM_CR2_CCDS, (__CCDMA__))__HAL_TIM_SET_CAPTUREPOLARITY(__HANDLE__,__CHANNEL__,__POLARITY__)do{ TIM_RESET_CAPTUREPOLARITY((__HANDLE__), (__CHANNEL__)); TIM_SET_CAPTUREPOLARITY((__HANDLE__), (__CHANNEL__), (__POLARITY__)); }while(0)__HAL_TIM_URS_DISABLE(__HANDLE__)((__HANDLE__)->Instance->CR1&=~TIM_CR1_URS)__HAL_TIM_URS_ENABLE(__HANDLE__)((__HANDLE__)->Instance->CR1|= TIM_CR1_URS)__HAL_TIM_DISABLE_OCxFAST(__HANDLE__,__CHANNEL__)(((__CHANNEL__) == TIM_CHANNEL_1) ? ((__HANDLE__)->Instance->CCMR1 &= ~TIM_CCMR1_OC1FE) : ((__CHANNEL__) == TIM_CHANNEL_2) ? ((__HANDLE__)->Instance->CCMR1 &= ~TIM_CCMR1_OC2FE) : ((__CHANNEL__) == TIM_CHANNEL_3) ? ((__HANDLE__)->Instance->CCMR2 &= ~TIM_CCMR2_OC3FE) : ((__CHANNEL__) == TIM_CHANNEL_4) ? ((__HANDLE__)->Instance->CCMR2 &= ~TIM_CCMR2_OC4FE) : ((__CHANNEL__) == TIM_CHANNEL_5) ? ((__HANDLE__)->Instance->CCMR3 &= ~TIM_CCMR3_OC5FE) : ((__HANDLE__)->Instance->CCMR3 &= ~TIM_CCMR3_OC6FE))__HAL_TIM_ENABLE_OCxFAST(__HANDLE__,__CHANNEL__)(((__CHANNEL__) == TIM_CHANNEL_1) ? ((__HANDLE__)->Instance->CCMR1 |= TIM_CCMR1_OC1FE) : ((__CHANNEL__) == TIM_CHANNEL_2) ? ((__HANDLE__)->Instance->CCMR1 |= TIM_CCMR1_OC2FE) : ((__CHANNEL__) == TIM_CHANNEL_3) ? ((__HANDLE__)->Instance->CCMR2 |= TIM_CCMR2_OC3FE) : ((__CHANNEL__) == TIM_CHANNEL_4) ? ((__HANDLE__)->Instance->CCMR2 |= TIM_CCMR2_OC4FE) : ((__CHANNEL__) == TIM_CHANNEL_5) ? ((__HANDLE__)->Instance->CCMR3 |= TIM_CCMR3_OC5FE) : ((__HANDLE__)->Instance->CCMR3 |= TIM_CCMR3_OC6FE))__HAL_TIM_DISABLE_OCxPRELOAD(__HANDLE__,__CHANNEL__)(((__CHANNEL__) == TIM_CHANNEL_1) ? ((__HANDLE__)->Instance->CCMR1 &= ~TIM_CCMR1_OC1PE) : ((__CHANNEL__) == TIM_CHANNEL_2) ? ((__HANDLE__)->Instance->CCMR1 &= ~TIM_CCMR1_OC2PE) : ((__CHANNEL__) == TIM_CHANNEL_3) ? ((__HANDLE__)->Instance->CCMR2 &= ~TIM_CCMR2_OC3PE) : ((__CHANNEL__) == TIM_CHANNEL_4) ? ((__HANDLE__)->Instance->CCMR2 &= ~TIM_CCMR2_OC4PE) : ((__CHANNEL__) == TIM_CHANNEL_5) ? ((__HANDLE__)->Instance->CCMR3 &= ~TIM_CCMR3_OC5PE) : ((__HANDLE__)->Instance->CCMR3 &= ~TIM_CCMR3_OC6PE))__HAL_TIM_ENABLE_OCxPRELOAD(__HANDLE__,__CHANNEL__)(((__CHANNEL__) == TIM_CHANNEL_1) ? ((__HANDLE__)->Instance->CCMR1 |= TIM_CCMR1_OC1PE) : ((__CHANNEL__) == TIM_CHANNEL_2) ? ((__HANDLE__)->Instance->CCMR1 |= TIM_CCMR1_OC2PE) : ((__CHANNEL__) == TIM_CHANNEL_3) ? ((__HANDLE__)->Instance->CCMR2 |= TIM_CCMR2_OC3PE) : ((__CHANNEL__) == TIM_CHANNEL_4) ? ((__HANDLE__)->Instance->CCMR2 |= TIM_CCMR2_OC4PE) : ((__CHANNEL__) == TIM_CHANNEL_5) ? ((__HANDLE__)->Instance->CCMR3 |= TIM_CCMR3_OC5PE) : ((__HANDLE__)->Instance->CCMR3 |= TIM_CCMR3_OC6PE))__HAL_TIM_GET_COMPARE(__HANDLE__,__CHANNEL__)(((__CHANNEL__) == TIM_CHANNEL_1) ? ((__HANDLE__)->Instance->CCR1) : ((__CHANNEL__) == TIM_CHANNEL_2) ? ((__HANDLE__)->Instance->CCR2) : ((__CHANNEL__) == TIM_CHANNEL_3) ? ((__HANDLE__)->Instance->CCR3) : ((__CHANNEL__) == TIM_CHANNEL_4) ? ((__HANDLE__)->Instance->CCR4) : ((__CHANNEL__) == TIM_CHANNEL_5) ? ((__HANDLE__)->Instance->CCR5) : ((__HANDLE__)->Instance->CCR6))__HAL_TIM_SET_COMPARE(__HANDLE__,__CHANNEL__,__COMPARE__)(((__CHANNEL__) == TIM_CHANNEL_1) ? ((__HANDLE__)->Instance->CCR1 = (__COMPARE__)) : ((__CHANNEL__) == TIM_CHANNEL_2) ? ((__HANDLE__)->Instance->CCR2 = (__COMPARE__)) : ((__CHANNEL__) == TIM_CHANNEL_3) ? ((__HANDLE__)->Instance->CCR3 = (__COMPARE__)) : ((__CHANNEL__) == TIM_CHANNEL_4) ? ((__HANDLE__)->Instance->CCR4 = (__COMPARE__)) : ((__CHANNEL__) == TIM_CHANNEL_5) ? ((__HANDLE__)->Instance->CCR5 = (__COMPARE__)) : ((__HANDLE__)->Instance->CCR6 = (__COMPARE__)))__HAL_TIM_GET_ICPRESCALER(__HANDLE__,__CHANNEL__)(((__CHANNEL__) == TIM_CHANNEL_1) ? ((__HANDLE__)->Instance->CCMR1 & TIM_CCMR1_IC1PSC) : ((__CHANNEL__) == TIM_CHANNEL_2) ? (((__HANDLE__)->Instance->CCMR1 & TIM_CCMR1_IC2PSC) >> 8U) : ((__CHANNEL__) == TIM_CHANNEL_3) ? ((__HANDLE__)->Instance->CCMR2 & TIM_CCMR2_IC3PSC) : (((__HANDLE__)->Instance->CCMR2 & TIM_CCMR2_IC4PSC)) >> 8U)__HAL_TIM_SET_ICPRESCALER(__HANDLE__,__CHANNEL__,__ICPSC__)do{ TIM_RESET_ICPRESCALERVALUE((__HANDLE__), (__CHANNEL__)); TIM_SET_ICPRESCALERVALUE((__HANDLE__), (__CHANNEL__), (__ICPSC__)); } while(0)__HAL_TIM_GET_CLOCKDIVISION(__HANDLE__)((__HANDLE__)->Instance->CR1 & TIM_CR1_CKD)__HAL_TIM_SET_CLOCKDIVISION(__HANDLE__,__CKD__)do{ (__HANDLE__)->Instance->CR1 &= (~TIM_CR1_CKD); (__HANDLE__)->Instance->CR1 |= (__CKD__); (__HANDLE__)->Init.ClockDivision = (__CKD__); } while(0)__HAL_TIM_GET_AUTORELOAD(__HANDLE__)((__HANDLE__)->Instance->ARR)__HAL_TIM_SET_AUTORELOAD(__HANDLE__,__AUTORELOAD__)do{ (__HANDLE__)->Instance->ARR = (__AUTORELOAD__); (__HANDLE__)->Init.Period = (__AUTORELOAD__); } while(0)__HAL_TIM_GET_COUNTER(__HANDLE__)((__HANDLE__)->Instance->CNT)__HAL_TIM_SET_COUNTER(__HANDLE__,__COUNTER__)((__HANDLE__)->Instance->CNT = (__COUNTER__))__HAL_TIM_SET_PRESCALER(__HANDLE__,__PRESC__)((__HANDLE__)->Instance->PSC = (__PRESC__))__HAL_TIM_IS_TIM_COUNTING_DOWN(__HANDLE__)(((__HANDLE__)->Instance->CR1 &(TIM_CR1_DIR)) == (TIM_CR1_DIR))__HAL_TIM_GET_UIFCPY(__COUNTER__)(((__COUNTER__) & (TIM_CNT_UIFCPY)) == (TIM_CNT_UIFCPY))__HAL_TIM_UIFREMAP_DISABLE(__HANDLE__)(((__HANDLE__)->Instance->CR1 &= ~TIM_CR1_UIFREMAP))__HAL_TIM_UIFREMAP_ENABLE(__HANDLE__)(((__HANDLE__)->Instance->CR1 |= TIM_CR1_UIFREMAP))__HAL_TIM_CLEAR_IT(__HANDLE__,__INTERRUPT__)((__HANDLE__)->Instance->SR = ~(__INTERRUPT__))__HAL_TIM_GET_IT_SOURCE(__HANDLE__,__INTERRUPT__)((((__HANDLE__)->Instance->DIER & (__INTERRUPT__)) == (__INTERRUPT__)) ? SET : RESET)__HAL_TIM_CLEAR_FLAG(__HANDLE__,__FLAG__)((__HANDLE__)->Instance->SR = ~(__FLAG__))__HAL_TIM_GET_FLAG(__HANDLE__,__FLAG__)(((__HANDLE__)->Instance->SR &(__FLAG__)) == (__FLAG__))__HAL_TIM_DISABLE_DMA(__HANDLE__,__DMA__)((__HANDLE__)->Instance->DIER &= ~(__DMA__))__HAL_TIM_ENABLE_DMA(__HANDLE__,__DMA__)((__HANDLE__)->Instance->DIER |= (__DMA__))__HAL_TIM_DISABLE_IT(__HANDLE__,__INTERRUPT__)((__HANDLE__)->Instance->DIER &= ~(__INTERRUPT__))__HAL_TIM_ENABLE_IT(__HANDLE__,__INTERRUPT__)((__HANDLE__)->Instance->DIER |= (__INTERRUPT__))__HAL_TIM_MOE_DISABLE_UNCONDITIONALLY(__HANDLE__)(__HANDLE__)->Instance->BDTR &= ~(TIM_BDTR_MOE)__HAL_TIM_MOE_DISABLE(__HANDLE__)do { if (((__HANDLE__)->Instance->CCER & TIM_CCER_CCxE_MASK) == 0UL) { if(((__HANDLE__)->Instance->CCER & TIM_CCER_CCxNE_MASK) == 0UL) { (__HANDLE__)->Instance->BDTR &= ~(TIM_BDTR_MOE); } } } while(0)__HAL_TIM_DISABLE(__HANDLE__)do { if (((__HANDLE__)->Instance->CCER & TIM_CCER_CCxE_MASK) == 0UL) { if(((__HANDLE__)->Instance->CCER & TIM_CCER_CCxNE_MASK) == 0UL) { (__HANDLE__)->Instance->CR1 &= ~(TIM_CR1_CEN); } } } while(0)__HAL_TIM_MOE_ENABLE(__HANDLE__)((__HANDLE__)->Instance->BDTR|=(TIM_BDTR_MOE))__HAL_TIM_ENABLE(__HANDLE__)((__HANDLE__)->Instance->CR1|=(TIM_CR1_CEN))__HAL_TIM_RESET_HANDLE_STATE(__HANDLE__)do { (__HANDLE__)->State = HAL_TIM_STATE_RESET; (__HANDLE__)->ChannelState[0] = HAL_TIM_CHANNEL_STATE_RESET; (__HANDLE__)->ChannelState[1] = HAL_TIM_CHANNEL_STATE_RESET; (__HANDLE__)->ChannelState[2] = HAL_TIM_CHANNEL_STATE_RESET; (__HANDLE__)->ChannelState[3] = HAL_TIM_CHANNEL_STATE_RESET; (__HANDLE__)->ChannelState[4] = HAL_TIM_CHANNEL_STATE_RESET; (__HANDLE__)->ChannelState[5] = HAL_TIM_CHANNEL_STATE_RESET; (__HANDLE__)->ChannelNState[0] = HAL_TIM_CHANNEL_STATE_RESET; (__HANDLE__)->ChannelNState[1] = HAL_TIM_CHANNEL_STATE_RESET; (__HANDLE__)->ChannelNState[2] = HAL_TIM_CHANNEL_STATE_RESET; (__HANDLE__)->ChannelNState[3] = HAL_TIM_CHANNEL_STATE_RESET; (__HANDLE__)->DMABurstState = HAL_DMA_BURST_STATE_RESET; } while(0)TIM_BREAK_SYSTEM_LOCKUPSYSCFG_CFGR2_CLLTIM_BREAK_SYSTEM_SRAM_PARITY_ERRORSYSCFG_CFGR2_SPLTIM_BREAK_SYSTEM_PVDSYSCFG_CFGR2_PVDLTIM_BREAK_SYSTEM_ECCSYSCFG_CFGR2_ECCLTIM_CCxN_DISABLETIM_CCxN_ENABLETIM_CCx_DISABLETIM_CCx_ENABLETIM_DMA_ID_TRIGGER((uint16_t) 0x0006)TIM_DMA_ID_COMMUTATION((uint16_t) 0x0005)TIM_DMA_ID_CC4((uint16_t) 0x0004)TIM_DMA_ID_CC3((uint16_t) 0x0003)TIM_DMA_ID_CC2((uint16_t) 0x0002)TIM_DMA_ID_CC1((uint16_t) 0x0001)TIM_DMA_ID_UPDATE((uint16_t) 0x0000)0x00001100U0x00000E00U0x00000D00U0x00000C00U0x00000B00U0x00000A00U0x00000900UTIM_TI1SELECTION_XORCOMBINATIONTIM_TI1SELECTION_CH1TIM_TRIGGERPRESCALER_DIV8TIM_ETRPRESCALER_DIV8TIM_TRIGGERPRESCALER_DIV4TIM_ETRPRESCALER_DIV4TIM_TRIGGERPRESCALER_DIV2TIM_ETRPRESCALER_DIV2TIM_TRIGGERPRESCALER_DIV1TIM_ETRPRESCALER_DIV1TIM_TRIGGERPOLARITY_BOTHEDGETIM_INPUTCHANNELPOLARITY_BOTHEDGETIM_TRIGGERPOLARITY_FALLINGTIM_INPUTCHANNELPOLARITY_FALLINGTIM_TRIGGERPOLARITY_RISINGTIM_INPUTCHANNELPOLARITY_RISINGTIM_TRIGGERPOLARITY_NONINVERTEDTIM_ETRPOLARITY_NONINVERTEDTIM_TRIGGERPOLARITY_INVERTEDTIM_ETRPOLARITY_INVERTEDTIM_TS_NONETIM_TS_ETRF(TIM_SMCR_TS_0 | TIM_SMCR_TS_1 | TIM_SMCR_TS_2)TIM_TS_TI2FP2(TIM_SMCR_TS_1 | TIM_SMCR_TS_2)TIM_TS_TI1FP1(TIM_SMCR_TS_0 | TIM_SMCR_TS_2)TIM_TS_TI1F_EDTIM_TS_ITR3(TIM_SMCR_TS_0 | TIM_SMCR_TS_1)TIM_TS_ITR2TIM_TS_ITR1TIM_TS_ITR0(TIM_CCMR1_OC1M_3 | TIM_CCMR1_OC1M_1 | TIM_CCMR1_OC1M_2)TIM_OCMODE_COMBINED_PWM2(TIM_CCMR1_OC1M_3 | TIM_CCMR1_OC1M_0 | TIM_CCMR1_OC1M_2)TIM_OCMODE_COMBINED_PWM1(TIM_CCMR1_OC1M_3 | TIM_CCMR1_OC1M_2)TIM_OCMODE_RETRIGERRABLE_OPM2(TIM_CCMR1_OC1M_3 | TIM_CCMR1_OC1M_0)TIM_OCMODE_RETRIGERRABLE_OPM1TIM_OCMODE_FORCED_INACTIVETIM_OCMODE_FORCED_ACTIVE(TIM_CCMR1_OC1M_2 | TIM_CCMR1_OC1M_0)TIM_OCMODE_PWM2(TIM_CCMR1_OC1M_2 | TIM_CCMR1_OC1M_1 | TIM_CCMR1_OC1M_0)TIM_OCMODE_PWM1(TIM_CCMR1_OC1M_2 | TIM_CCMR1_OC1M_1)TIM_OCMODE_TOGGLE(TIM_CCMR1_OC1M_1 | TIM_CCMR1_OC1M_0)TIM_OCMODE_INACTIVETIM_OCMODE_ACTIVETIM_OCMODE_TIMINGTIM_SLAVEMODE_COMBINED_RESETTRIGGERTIM_SLAVEMODE_EXTERNAL1(TIM_SMCR_SMS_2 | TIM_SMCR_SMS_1 | TIM_SMCR_SMS_0)TIM_SLAVEMODE_TRIGGER(TIM_SMCR_SMS_2 | TIM_SMCR_SMS_1)TIM_SLAVEMODE_GATED(TIM_SMCR_SMS_2 | TIM_SMCR_SMS_0)TIM_SLAVEMODE_RESETTIM_SLAVEMODE_DISABLETIM_MASTERSLAVEMODE_DISABLETIM_MASTERSLAVEMODE_ENABLETIM_TRGO2_OC5REF_RISING_OC6REF_FALLING(TIM_CR2_MMS2_3 | TIM_CR2_MMS2_2 | TIM_CR2_MMS2_1 | TIM_CR2_MMS2_0)TIM_TRGO2_OC5REF_RISING_OC6REF_RISING(TIM_CR2_MMS2_3 | TIM_CR2_MMS2_2 |TIM_CR2_MMS2_1)TIM_TRGO2_OC4REF_RISING_OC6REF_FALLING(TIM_CR2_MMS2_3 | TIM_CR2_MMS2_2 | TIM_CR2_MMS2_0)TIM_TRGO2_OC4REF_RISING_OC6REF_RISING(TIM_CR2_MMS2_3 | TIM_CR2_MMS2_2)TIM_TRGO2_OC6REF_RISINGFALLING(TIM_CR2_MMS2_3 | TIM_CR2_MMS2_1 | TIM_CR2_MMS2_0)TIM_TRGO2_OC4REF_RISINGFALLING(TIM_CR2_MMS2_3 | TIM_CR2_MMS2_1)TIM_TRGO2_OC6REF(TIM_CR2_MMS2_3 | TIM_CR2_MMS2_0)TIM_TRGO2_OC5REFTIM_TRGO2_OC4REF(TIM_CR2_MMS2_2 | TIM_CR2_MMS2_1 | TIM_CR2_MMS2_0)TIM_TRGO2_OC3REF(TIM_CR2_MMS2_2 | TIM_CR2_MMS2_1)TIM_TRGO2_OC2REF(TIM_CR2_MMS2_2 | TIM_CR2_MMS2_0)TIM_TRGO2_OC1REFTIM_TRGO2_OC1(TIM_CR2_MMS2_1 | TIM_CR2_MMS2_0)TIM_TRGO2_UPDATETIM_TRGO2_ENABLETIM_TRGO2_RESETTIM_TRGO_OC4REF(TIM_CR2_MMS_2 | TIM_CR2_MMS_1 | TIM_CR2_MMS_0)TIM_TRGO_OC3REF(TIM_CR2_MMS_2 | TIM_CR2_MMS_1)TIM_TRGO_OC2REF(TIM_CR2_MMS_2 | TIM_CR2_MMS_0)TIM_TRGO_OC1REFTIM_TRGO_OC1(TIM_CR2_MMS_1 | TIM_CR2_MMS_0)TIM_TRGO_UPDATETIM_TRGO_ENABLETIM_TRGO_RESETTIM_GROUPCH5_OC3REFCTIM_GROUPCH5_OC2REFCTIM_GROUPCH5_OC1REFCTIM_GROUPCH5_NONETIM_AUTOMATICOUTPUT_ENABLETIM_AUTOMATICOUTPUT_DISABLETIM_BREAK2POLARITY_HIGHTIM_BREAK2POLARITY_LOWTIM_BREAK2_ENABLETIM_BREAK2_DISABLETIM_BREAKPOLARITY_HIGHTIM_BREAKPOLARITY_LOWTIM_BREAK_DISABLETIM_BREAK_ENABLETIM_LOCKLEVEL_3TIM_LOCKLEVEL_2TIM_LOCKLEVEL_1TIM_LOCKLEVEL_OFFTIM_OSSI_DISABLETIM_OSSI_ENABLETIM_OSSR_DISABLETIM_OSSR_ENABLETIM_CLEARINPUTPRESCALER_DIV8TIM_CLEARINPUTPRESCALER_DIV4TIM_CLEARINPUTPRESCALER_DIV2TIM_CLEARINPUTPRESCALER_DIV1TIM_CLEARINPUTPOLARITY_NONINVERTEDTIM_CLEARINPUTPOLARITY_INVERTEDTIM_CLOCKPRESCALER_DIV8TIM_CLOCKPRESCALER_DIV4TIM_CLOCKPRESCALER_DIV2TIM_CLOCKPRESCALER_DIV1TIM_CLOCKPOLARITY_BOTHEDGETIM_CLOCKPOLARITY_FALLINGTIM_CLOCKPOLARITY_RISINGTIM_CLOCKPOLARITY_NONINVERTEDTIM_CLOCKPOLARITY_INVERTEDTIM_CLOCKSOURCE_ITR3TIM_CLOCKSOURCE_ITR2TIM_CLOCKSOURCE_ITR1TIM_CLOCKSOURCE_ITR0TIM_CLOCKSOURCE_TI2TIM_CLOCKSOURCE_TI1TIM_CLOCKSOURCE_TI1EDTIM_CLOCKSOURCE_ETRMODE2TIM_CLOCKSOURCE_ETRMODE1TIM_CLOCKSOURCE_INTERNALTIM_CHANNEL_ALL0x0000003CUTIM_CHANNEL_6TIM_CHANNEL_5TIM_CHANNEL_4TIM_CHANNEL_3TIM_CHANNEL_2TIM_CHANNEL_1TIM_FLAG_CC4OFTIM_FLAG_CC3OFTIM_FLAG_CC2OFTIM_FLAG_CC1OFTIM_FLAG_SYSTEM_BREAKTIM_FLAG_BREAK2TIM_FLAG_BREAKTIM_FLAG_TRIGGERTIM_FLAG_COMTIM_FLAG_CC6TIM_FLAG_CC5TIM_FLAG_CC4TIM_FLAG_CC3TIM_FLAG_CC2TIM_FLAG_CC1TIM_FLAG_UPDATETIM_CCDMAREQUEST_UPDATETIM_CCDMAREQUEST_CCTIM_DMA_TRIGGERTIM_DMA_COMTIM_DMA_CC4TIM_DMA_CC3TIM_DMA_CC2TIM_DMA_CC1TIM_DMA_UPDATETIM_COMMUTATION_SOFTWARETIM_COMMUTATION_TRGITIM_IT_BREAKTIM_IT_TRIGGERTIM_IT_COMTIM_IT_CC4TIM_IT_CC3TIM_IT_CC2TIM_IT_CC1TIM_IT_UPDATETIM_ENCODERMODE_TI12(TIM_SMCR_SMS_1 | TIM_SMCR_SMS_0)TIM_ENCODERMODE_TI2TIM_ENCODERMODE_TI1TIM_OPMODE_REPETITIVETIM_OPMODE_SINGLETIM_ICPSC_DIV8TIM_ICPSC_DIV4TIM_ICPSC_DIV2TIM_ICPSC_DIV1TIM_ICSELECTION_TRCTIM_ICSELECTION_INDIRECTTITIM_ICSELECTION_DIRECTTITIM_ENCODERINPUTPOLARITY_FALLINGTIM_ENCODERINPUTPOLARITY_RISINGTIM_ICPOLARITY_BOTHEDGETIM_ICPOLARITY_FALLINGTIM_ICPOLARITY_RISINGTIM_OCNIDLESTATE_RESETTIM_OCNIDLESTATE_SETTIM_OCIDLESTATE_RESETTIM_OCIDLESTATE_SETTIM_OCNPOLARITY_LOWTIM_OCNPOLARITY_HIGHTIM_OCPOLARITY_LOWTIM_OCPOLARITY_HIGHTIM_OUTPUTNSTATE_ENABLETIM_OUTPUTNSTATE_DISABLETIM_OCFAST_ENABLETIM_OCFAST_DISABLETIM_AUTORELOAD_PRELOAD_ENABLETIM_AUTORELOAD_PRELOAD_DISABLETIM_OUTPUTSTATE_ENABLETIM_OUTPUTSTATE_DISABLETIM_CLOCKDIVISION_DIV4TIM_CLOCKDIVISION_DIV2TIM_CLOCKDIVISION_DIV1TIM_UIFREMAP_ENABLETIM_UIFREMAP_DISABLETIM_COUNTERMODE_CENTERALIGNED3TIM_COUNTERMODE_CENTERALIGNED2TIM_COUNTERMODE_CENTERALIGNED1TIM_COUNTERMODE_DOWNTIM_COUNTERMODE_UP(TIM_CCER_CC1P | TIM_CCER_CC1NP)TIM_DMABASE_AF20x00000019UTIM_DMABASE_AF10x00000017U0x00000016U0x00000012U0x00000011UTIM_CLEARINPUTSOURCE_ETRTIM_CLEARINPUTSOURCE_NONESTM32F7xx_HAL_TIM_H(USE_HAL_TIM_REGISTER_CALLBACKS == 1)defined(TIM_AF1_BKINE)&&defined(TIM_AF2_BKINE)/* STM32F7xx_HAL_TIM_H *//* USE_HAL_TIM_REGISTER_CALLBACKS *//** @defgroup TIM_Private_Functions TIM Private Functions
  * @{
  *//* Peripheral Channel state functions  ************************************************//** @defgroup TIM_Exported_Functions_Group10 TIM Peripheral State functions
  *  @brief  Peripheral State functions
  * @{
  *//* Callback in non blocking modes (Interrupt and DMA) *************************//** @defgroup TIM_Exported_Functions_Group9 TIM Callbacks functions
  *  @brief   TIM Callbacks functions
  * @{
  *//* Control functions  *********************************************************//** @defgroup TIM_Exported_Functions_Group8 TIM Peripheral Control functions
  *  @brief   Peripheral Control functions
  * @{
  *//* Interrupt Handler functions  ***********************************************//** @addtogroup TIM_Exported_Functions_Group7 TIM IRQ handler management
  *  @brief   IRQ handler management
  * @{
  *//* Timer Encoder functions ****************************************************//** @addtogroup TIM_Exported_Functions_Group6 TIM Encoder functions
  *  @brief   TIM Encoder functions
  * @{
  *//* Timer One Pulse functions **************************************************//** @addtogroup TIM_Exported_Functions_Group5 TIM One Pulse functions
  *  @brief   TIM One Pulse functions
  * @{
  *//* Timer Input Capture functions **********************************************//** @addtogroup TIM_Exported_Functions_Group4 TIM Input Capture functions
  *  @brief   TIM Input Capture functions
  * @{
  *//* Timer PWM functions ********************************************************//** @addtogroup TIM_Exported_Functions_Group3 TIM PWM functions
  *  @brief   TIM PWM functions
  * @{
  *//* Timer Output Compare functions *********************************************//** @addtogroup TIM_Exported_Functions_Group2 TIM Output Compare functions
  *  @brief   TIM Output Compare functions
  * @{
  *//* Time Base functions ********************************************************//** @addtogroup TIM_Exported_Functions_Group1 TIM Time Base functions
  *  @brief   Time Base functions
  * @{
  *//** @addtogroup TIM_Exported_Functions TIM Exported Functions
  * @{
  *//* Include TIM HAL Extended module *//* End of private macros -----------------------------------------------------*//* TIM_AF1_BKINE && TIM_AF1_BKINE *//** @defgroup TIM_Private_Macros TIM Private Macros
  * @{
  *//* End of private constants --------------------------------------------------*//* The counter of a timer instance is disabled only if all the CCx and CCxN
   channels have been disabled *//** @defgroup TIM_Private_Constants TIM Private Constants
  * @{
  *//* End of exported macros ----------------------------------------------------*//** @brief  Select the Capture/compare DMA request source.
  * @param  __HANDLE__ specifies the TIM Handle.
  * @param  __CCDMA__ specifies Capture/compare DMA request source
  *          This parameter can be one of the following values:
  *            @arg TIM_CCDMAREQUEST_CC: CCx DMA request generated on Capture/Compare event
  *            @arg TIM_CCDMAREQUEST_UPDATE: CCx DMA request generated on Update event
  * @retval None
  *//**
  * @brief  Set the TIM Capture x input polarity on runtime.
  * @param  __HANDLE__ TIM handle.
  * @param  __CHANNEL__ TIM Channels to be configured.
  *          This parameter can be one of the following values:
  *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
  *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
  *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
  * @param  __POLARITY__ Polarity for TIx source
  *            @arg TIM_INPUTCHANNELPOLARITY_RISING: Rising Edge
  *            @arg TIM_INPUTCHANNELPOLARITY_FALLING: Falling Edge
  *            @arg TIM_INPUTCHANNELPOLARITY_BOTHEDGE: Rising and Falling Edge
  * @retval None
  *//**
  * @brief  Reset the Update Request Source (URS) bit of the TIMx_CR1 register.
  * @param  __HANDLE__ TIM handle.
  * @note  When the URS bit of the TIMx_CR1 register is reset, any of the
  *        following events generate an update interrupt or DMA request (if
  *        enabled):
  *           _ Counter overflow underflow
  *           _ Setting the UG bit
  *           _ Update generation through the slave mode controller
  * @retval None
  *//**
  * @brief  Set the Update Request Source (URS) bit of the TIMx_CR1 register.
  * @param  __HANDLE__ TIM handle.
  * @note  When the URS bit of the TIMx_CR1 register is set, only counter
  *        overflow/underflow generates an update interrupt or DMA request (if
  *        enabled)
  * @retval None
  *//**
  * @brief  Disable fast mode for a given channel.
  * @param  __HANDLE__ TIM handle.
  * @param  __CHANNEL__ TIM Channels to be configured.
  *          This parameter can be one of the following values:
  *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
  *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
  *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
  *            @arg TIM_CHANNEL_5: TIM Channel 5 selected
  *            @arg TIM_CHANNEL_6: TIM Channel 6 selected
  * @note  When fast mode is disabled CCx output behaves normally depending
  *        on counter and CCRx values even when the trigger is ON. The minimum
  *        delay to activate CCx output when an active edge occurs on the
  *        trigger input is 5 clock cycles.
  * @retval None
  *//**
  * @brief  Enable fast mode for a given channel.
  * @param  __HANDLE__ TIM handle.
  * @param  __CHANNEL__ TIM Channels to be configured.
  *          This parameter can be one of the following values:
  *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
  *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
  *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
  *            @arg TIM_CHANNEL_5: TIM Channel 5 selected
  *            @arg TIM_CHANNEL_6: TIM Channel 6 selected
  * @note  When fast mode is enabled an active edge on the trigger input acts
  *        like a compare match on CCx output. Delay to sample the trigger
  *        input and to activate CCx output is reduced to 3 clock cycles.
  * @note  Fast mode acts only if the channel is configured in PWM1 or PWM2 mode.
  * @retval None
  *//**
  * @brief  Reset the TIM Output compare preload.
  * @param  __HANDLE__ TIM handle.
  * @param  __CHANNEL__ TIM Channels to be configured.
  *          This parameter can be one of the following values:
  *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
  *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
  *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
  *            @arg TIM_CHANNEL_5: TIM Channel 5 selected
  *            @arg TIM_CHANNEL_6: TIM Channel 6 selected
  * @retval None
  *//**
  * @brief  Set the TIM Output compare preload.
  * @param  __HANDLE__ TIM handle.
  * @param  __CHANNEL__ TIM Channels to be configured.
  *          This parameter can be one of the following values:
  *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
  *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
  *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
  *            @arg TIM_CHANNEL_5: TIM Channel 5 selected
  *            @arg TIM_CHANNEL_6: TIM Channel 6 selected
  * @retval None
  *//**
  * @brief  Get the TIM Capture Compare Register value on runtime.
  * @param  __HANDLE__ TIM handle.
  * @param  __CHANNEL__ TIM Channel associated with the capture compare register
  *          This parameter can be one of the following values:
  *            @arg TIM_CHANNEL_1: get capture/compare 1 register value
  *            @arg TIM_CHANNEL_2: get capture/compare 2 register value
  *            @arg TIM_CHANNEL_3: get capture/compare 3 register value
  *            @arg TIM_CHANNEL_4: get capture/compare 4 register value
  *            @arg TIM_CHANNEL_5: get capture/compare 5 register value
  *            @arg TIM_CHANNEL_6: get capture/compare 6 register value
  * @retval 16-bit or 32-bit value of the capture/compare register (TIMx_CCRy)
  *//**
  * @brief  Set the TIM Capture Compare Register value on runtime without calling another time ConfigChannel function.
  * @param  __HANDLE__ TIM handle.
  * @param  __CHANNEL__ TIM Channels to be configured.
  *          This parameter can be one of the following values:
  *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
  *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
  *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
  *            @arg TIM_CHANNEL_5: TIM Channel 5 selected
  *            @arg TIM_CHANNEL_6: TIM Channel 6 selected
  * @param  __COMPARE__ specifies the Capture Compare register new value.
  * @retval None
  *//**
  * @brief  Get the TIM Input Capture prescaler on runtime.
  * @param  __HANDLE__ TIM handle.
  * @param  __CHANNEL__ TIM Channels to be configured.
  *          This parameter can be one of the following values:
  *            @arg TIM_CHANNEL_1: get input capture 1 prescaler value
  *            @arg TIM_CHANNEL_2: get input capture 2 prescaler value
  *            @arg TIM_CHANNEL_3: get input capture 3 prescaler value
  *            @arg TIM_CHANNEL_4: get input capture 4 prescaler value
  * @retval The input capture prescaler can be one of the following values:
  *            @arg TIM_ICPSC_DIV1: no prescaler
  *            @arg TIM_ICPSC_DIV2: capture is done once every 2 events
  *            @arg TIM_ICPSC_DIV4: capture is done once every 4 events
  *            @arg TIM_ICPSC_DIV8: capture is done once every 8 events
  *//**
  * @brief  Set the TIM Input Capture prescaler on runtime without calling another time HAL_TIM_IC_ConfigChannel()
  *         function.
  * @param  __HANDLE__ TIM handle.
  * @param  __CHANNEL__ TIM Channels to be configured.
  *          This parameter can be one of the following values:
  *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
  *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
  *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
  * @param  __ICPSC__ specifies the Input Capture4 prescaler new value.
  *          This parameter can be one of the following values:
  *            @arg TIM_ICPSC_DIV1: no prescaler
  *            @arg TIM_ICPSC_DIV2: capture is done once every 2 events
  *            @arg TIM_ICPSC_DIV4: capture is done once every 4 events
  *            @arg TIM_ICPSC_DIV8: capture is done once every 8 events
  * @retval None
  *//**
  * @brief  Get the TIM Clock Division value on runtime.
  * @param  __HANDLE__ TIM handle.
  * @retval The clock division can be one of the following values:
  *            @arg TIM_CLOCKDIVISION_DIV1: tDTS=tCK_INT
  *            @arg TIM_CLOCKDIVISION_DIV2: tDTS=2*tCK_INT
  *            @arg TIM_CLOCKDIVISION_DIV4: tDTS=4*tCK_INT
  *//**
  * @brief  Set the TIM Clock Division value on runtime without calling another time any Init function.
  * @param  __HANDLE__ TIM handle.
  * @param  __CKD__ specifies the clock division value.
  *          This parameter can be one of the following value:
  *            @arg TIM_CLOCKDIVISION_DIV1: tDTS=tCK_INT
  *            @arg TIM_CLOCKDIVISION_DIV2: tDTS=2*tCK_INT
  *            @arg TIM_CLOCKDIVISION_DIV4: tDTS=4*tCK_INT
  * @retval None
  *//**
  * @brief  Get the TIM Autoreload Register value on runtime.
  * @param  __HANDLE__ TIM handle.
  * @retval 16-bit or 32-bit value of the timer auto-reload register(TIMx_ARR)
  *//**
  * @brief  Set the TIM Autoreload Register value on runtime without calling another time any Init function.
  * @param  __HANDLE__ TIM handle.
  * @param  __AUTORELOAD__ specifies the Counter register new value.
  * @retval None
  *//**
  * @brief  Get the TIM Counter Register value on runtime.
  * @param  __HANDLE__ TIM handle.
  * @retval 16-bit or 32-bit value of the timer counter register (TIMx_CNT)
  *//**
  * @brief  Set the TIM Counter Register value on runtime.
  * Note Please check if the bit 31 of CNT register is used as UIF copy or not, this may affect the counter range in
  *      case of 32 bits counter TIM instance.
  *      Bit 31 of CNT can be enabled/disabled using __HAL_TIM_UIFREMAP_ENABLE()/__HAL_TIM_UIFREMAP_DISABLE() macros.
  * @param  __HANDLE__ TIM handle.
  * @param  __COUNTER__ specifies the Counter register new value.
  * @retval None
  *//**
  * @brief  Set the TIM Prescaler on runtime.
  * @param  __HANDLE__ TIM handle.
  * @param  __PRESC__ specifies the Prescaler new value.
  * @retval None
  *//**
  * @brief  Indicates whether or not the TIM Counter is used as downcounter.
  * @param  __HANDLE__ TIM handle.
  * @retval False (Counter used as upcounter) or True (Counter used as downcounter)
  * @note This macro is particularly useful to get the counting mode when the timer operates in Center-aligned mode
  *       or Encoder mode.
  *//**
  * @brief  Get update interrupt flag (UIF) copy status.
  * @param  __COUNTER__ Counter value.
  * @retval The state of UIFCPY (TRUE or FALSE).
mode.
  *//**
  * @brief  Disable update interrupt flag (UIF) remapping.
  * @param  __HANDLE__ TIM handle.
  * @retval None
mode.
  *//**
  * @brief  Force a continuous copy of the update interrupt flag (UIF) into the timer counter register (bit 31).
  * @note This allows both the counter value and a potential roll-over condition signalled by the UIFCPY flag to be read
  *       in an atomic way.
  * @param  __HANDLE__ TIM handle.
  * @retval None
mode.
  *//** @brief Clear the TIM interrupt pending bits.
  * @param  __HANDLE__ TIM handle
  * @param  __INTERRUPT__ specifies the interrupt pending bit to clear.
  *          This parameter can be one of the following values:
  *            @arg TIM_IT_UPDATE: Update interrupt
  *            @arg TIM_IT_CC1:   Capture/Compare 1 interrupt
  *            @arg TIM_IT_CC2:  Capture/Compare 2 interrupt
  *            @arg TIM_IT_CC3:  Capture/Compare 3 interrupt
  *            @arg TIM_IT_CC4:  Capture/Compare 4 interrupt
  *            @arg TIM_IT_COM:   Commutation interrupt
  *            @arg TIM_IT_TRIGGER: Trigger interrupt
  *            @arg TIM_IT_BREAK: Break interrupt
  * @retval None
  *//**
  * @brief  Check whether the specified TIM interrupt source is enabled or not.
  * @param  __HANDLE__ TIM handle
  * @param  __INTERRUPT__ specifies the TIM interrupt source to check.
  *          This parameter can be one of the following values:
  *            @arg TIM_IT_UPDATE: Update interrupt
  *            @arg TIM_IT_CC1:   Capture/Compare 1 interrupt
  *            @arg TIM_IT_CC2:  Capture/Compare 2 interrupt
  *            @arg TIM_IT_CC3:  Capture/Compare 3 interrupt
  *            @arg TIM_IT_CC4:  Capture/Compare 4 interrupt
  *            @arg TIM_IT_COM:   Commutation interrupt
  *            @arg TIM_IT_TRIGGER: Trigger interrupt
  *            @arg TIM_IT_BREAK: Break interrupt
  * @retval The state of TIM_IT (SET or RESET).
  *//** @brief  Clear the specified TIM interrupt flag.
  * @param  __HANDLE__ specifies the TIM Handle.
  * @param  __FLAG__ specifies the TIM interrupt flag to clear.
  *        This parameter can be one of the following values:
  *            @arg TIM_FLAG_UPDATE: Update interrupt flag
  *            @arg TIM_FLAG_CC1: Capture/Compare 1 interrupt flag
  *            @arg TIM_FLAG_CC2: Capture/Compare 2 interrupt flag
  *            @arg TIM_FLAG_CC3: Capture/Compare 3 interrupt flag
  *            @arg TIM_FLAG_CC4: Capture/Compare 4 interrupt flag
  *            @arg TIM_FLAG_CC5: Compare 5 interrupt flag
  *            @arg TIM_FLAG_CC6: Compare 6 interrupt flag
  *            @arg TIM_FLAG_COM:  Commutation interrupt flag
  *            @arg TIM_FLAG_TRIGGER: Trigger interrupt flag
  *            @arg TIM_FLAG_BREAK: Break interrupt flag
  *            @arg TIM_FLAG_BREAK2: Break 2 interrupt flag
  *            @arg TIM_FLAG_SYSTEM_BREAK: System Break interrupt flag
  *            @arg TIM_FLAG_CC1OF: Capture/Compare 1 overcapture flag
  *            @arg TIM_FLAG_CC2OF: Capture/Compare 2 overcapture flag
  *            @arg TIM_FLAG_CC3OF: Capture/Compare 3 overcapture flag
  *            @arg TIM_FLAG_CC4OF: Capture/Compare 4 overcapture flag
  * @retval The new state of __FLAG__ (TRUE or FALSE).
  *//** @brief  Check whether the specified TIM interrupt flag is set or not.
  * @param  __HANDLE__ specifies the TIM Handle.
  * @param  __FLAG__ specifies the TIM interrupt flag to check.
  *        This parameter can be one of the following values:
  *            @arg TIM_FLAG_UPDATE: Update interrupt flag
  *            @arg TIM_FLAG_CC1: Capture/Compare 1 interrupt flag
  *            @arg TIM_FLAG_CC2: Capture/Compare 2 interrupt flag
  *            @arg TIM_FLAG_CC3: Capture/Compare 3 interrupt flag
  *            @arg TIM_FLAG_CC4: Capture/Compare 4 interrupt flag
  *            @arg TIM_FLAG_CC5: Compare 5 interrupt flag
  *            @arg TIM_FLAG_CC6: Compare 6 interrupt flag
  *            @arg TIM_FLAG_COM:  Commutation interrupt flag
  *            @arg TIM_FLAG_TRIGGER: Trigger interrupt flag
  *            @arg TIM_FLAG_BREAK: Break interrupt flag
  *            @arg TIM_FLAG_BREAK2: Break 2 interrupt flag
  *            @arg TIM_FLAG_SYSTEM_BREAK: System Break interrupt flag
  *            @arg TIM_FLAG_CC1OF: Capture/Compare 1 overcapture flag
  *            @arg TIM_FLAG_CC2OF: Capture/Compare 2 overcapture flag
  *            @arg TIM_FLAG_CC3OF: Capture/Compare 3 overcapture flag
  *            @arg TIM_FLAG_CC4OF: Capture/Compare 4 overcapture flag
  * @retval The new state of __FLAG__ (TRUE or FALSE).
  *//** @brief  Disable the specified DMA request.
  * @param  __HANDLE__ specifies the TIM Handle.
  * @param  __DMA__ specifies the TIM DMA request to disable.
  *          This parameter can be one of the following values:
  *            @arg TIM_DMA_UPDATE: Update DMA request
  *            @arg TIM_DMA_CC1:   Capture/Compare 1 DMA request
  *            @arg TIM_DMA_CC2:  Capture/Compare 2 DMA request
  *            @arg TIM_DMA_CC3:  Capture/Compare 3 DMA request
  *            @arg TIM_DMA_CC4:  Capture/Compare 4 DMA request
  *            @arg TIM_DMA_COM:   Commutation DMA request
  *            @arg TIM_DMA_TRIGGER: Trigger DMA request
  * @retval None
  *//** @brief  Enable the specified DMA request.
  * @param  __HANDLE__ specifies the TIM Handle.
  * @param  __DMA__ specifies the TIM DMA request to enable.
  *          This parameter can be one of the following values:
  *            @arg TIM_DMA_UPDATE: Update DMA request
  *            @arg TIM_DMA_CC1:   Capture/Compare 1 DMA request
  *            @arg TIM_DMA_CC2:  Capture/Compare 2 DMA request
  *            @arg TIM_DMA_CC3:  Capture/Compare 3 DMA request
  *            @arg TIM_DMA_CC4:  Capture/Compare 4 DMA request
  *            @arg TIM_DMA_COM:   Commutation DMA request
  *            @arg TIM_DMA_TRIGGER: Trigger DMA request
  * @retval None
  *//** @brief  Disable the specified TIM interrupt.
  * @param  __HANDLE__ specifies the TIM Handle.
  * @param  __INTERRUPT__ specifies the TIM interrupt source to disable.
  *          This parameter can be one of the following values:
  *            @arg TIM_IT_UPDATE: Update interrupt
  *            @arg TIM_IT_CC1:   Capture/Compare 1 interrupt
  *            @arg TIM_IT_CC2:  Capture/Compare 2 interrupt
  *            @arg TIM_IT_CC3:  Capture/Compare 3 interrupt
  *            @arg TIM_IT_CC4:  Capture/Compare 4 interrupt
  *            @arg TIM_IT_COM:   Commutation interrupt
  *            @arg TIM_IT_TRIGGER: Trigger interrupt
  *            @arg TIM_IT_BREAK: Break interrupt
  * @retval None
  *//** @brief  Enable the specified TIM interrupt.
  * @param  __HANDLE__ specifies the TIM Handle.
  * @param  __INTERRUPT__ specifies the TIM interrupt source to enable.
  *          This parameter can be one of the following values:
  *            @arg TIM_IT_UPDATE: Update interrupt
  *            @arg TIM_IT_CC1:   Capture/Compare 1 interrupt
  *            @arg TIM_IT_CC2:  Capture/Compare 2 interrupt
  *            @arg TIM_IT_CC3:  Capture/Compare 3 interrupt
  *            @arg TIM_IT_CC4:  Capture/Compare 4 interrupt
  *            @arg TIM_IT_COM:   Commutation interrupt
  *            @arg TIM_IT_TRIGGER: Trigger interrupt
  *            @arg TIM_IT_BREAK: Break interrupt
  * @retval None
  *//**
  * @brief  Disable the TIM main Output.
  * @param  __HANDLE__ TIM handle
  * @retval None
  * @note The Main Output Enable of a timer instance is disabled unconditionally
  *//**
  * @brief  Disable the TIM main Output.
  * @param  __HANDLE__ TIM handle
  * @retval None
  * @note The Main Output Enable of a timer instance is disabled only if all the CCx and CCxN channels have been
  *       disabled
  *//**
  * @brief  Disable the TIM peripheral.
  * @param  __HANDLE__ TIM handle
  * @retval None
  *//**
  * @brief  Enable the TIM main Output.
  * @param  __HANDLE__ TIM handle
  * @retval None
  *//**
  * @brief  Enable the TIM peripheral.
  * @param  __HANDLE__ TIM handle
  * @retval None
  *//** @brief  Reset TIM handle state.
  * @param  __HANDLE__ TIM handle.
  * @retval None
  *//** @defgroup TIM_Exported_Macros TIM Exported Macros
  * @{
  *//*!< Enables and locks the LOCKUP output of CortexM4 with Break Input of TIM1/8/15/16/17 *//*!< Enables and locks the SRAM_PARITY error signal with Break Input of TIM1/8/15/16/17 *//*!< Enables and locks the PVD connection with TIM1/8/15/16/17 Break Input and also the PVDE and PLS bits of the Power Control Interface *//*!< Enables and locks the ECC error signal with Break Input of TIM1/8/15/16/17 *//** @defgroup TIM_Break_System TIM Break System
  * @{
  *//*!< Complementary output channel is enabled *//*!< Input or output channel is disabled *//*!< Input or output channel is enabled *//** @defgroup Channel_CC_State TIM Capture/Compare Channel State
  * @{
  *//*!< Index of the DMA handle used for Trigger DMA requests *//*!< Index of the DMA handle used for Commutation DMA requests *//*!< Index of the DMA handle used for Capture/Compare 4 DMA requests *//*!< Index of the DMA handle used for Capture/Compare 3 DMA requests *//*!< Index of the DMA handle used for Capture/Compare 2 DMA requests *//*!< Index of the DMA handle used for Capture/Compare 1 DMA requests *//*!< Index of the DMA handle used for Update DMA requests *//** @defgroup DMA_Handle_index TIM DMA Handle Index
  * @{
  *//*!< The transfer is done to 18 registers starting from TIMx_CR1 + TIMx_DCR.DBA *//*!< The transfer is done to 17 registers starting from TIMx_CR1 + TIMx_DCR.DBA *//*!< The transfer is done to 16 registers starting from TIMx_CR1 + TIMx_DCR.DBA *//*!< The transfer is done to 15 registers starting from TIMx_CR1 + TIMx_DCR.DBA *//*!< The transfer is done to 14 registers starting from TIMx_CR1 + TIMx_DCR.DBA *//*!< The transfer is done to 13 registers starting from TIMx_CR1 + TIMx_DCR.DBA *//*!< The transfer is done to 12 registers starting from TIMx_CR1 + TIMx_DCR.DBA *//*!< The transfer is done to 11 registers starting from TIMx_CR1 + TIMx_DCR.DBA *//*!< The transfer is done to 10 registers starting from TIMx_CR1 + TIMx_DCR.DBA *//*!< The transfer is done to 9 registers starting from TIMx_CR1 + TIMx_DCR.DBA  *//*!< The transfer is done to 8 registers starting from TIMx_CR1 + TIMx_DCR.DBA  *//*!< The transfer is done to 7 registers starting from TIMx_CR1 + TIMx_DCR.DBA  *//*!< The transfer is done to 6 registers starting from TIMx_CR1 + TIMx_DCR.DBA  *//*!< The transfer is done to 5 registers starting from TIMx_CR1 + TIMx_DCR.DBA  *//*!< The transfer is done to 4 registers starting from TIMx_CR1 + TIMx_DCR.DBA  *//*!< The transfer is done to 3 registers starting from TIMx_CR1 + TIMx_DCR.DBA  *//*!< The transfer is done to 2 registers starting from TIMx_CR1 + TIMx_DCR.DBA  *//*!< The transfer is done to 1 register starting from TIMx_CR1 + TIMx_DCR.DBA   *//** @defgroup TIM_DMA_Burst_Length TIM DMA Burst Length
  * @{
  *//*!< The TIMx_CH1, CH2 and CH3 pins are connected to the TI1 input (XOR combination) *//*!< The TIMx_CH1 pin is connected to TI1 input *//** @defgroup TIM_TI1_Selection TIM TI1 Input Selection
  * @{
  *//*!< Prescaler for External ETR Trigger: Capture performed once every 8 events. *//*!< Prescaler for External ETR Trigger: Capture performed once every 4 events. *//*!< Prescaler for External ETR Trigger: Capture performed once every 2 events. *//*!< No prescaler is used                                                       *//** @defgroup TIM_Trigger_Prescaler TIM Trigger Prescaler
  * @{
  *//*!< Polarity for TIxFPx or TI1_ED trigger sources *//*!< Polarity for ETRx trigger sources             *//** @defgroup TIM_Trigger_Polarity TIM Trigger Polarity
  * @{
  *//*!< No trigger selected                    *//*!< Filtered External Trigger input (ETRF) *//*!< Filtered Timer Input 2 (TI2FP2)        *//*!< Filtered Timer Input 1 (TI1FP1)        *//*!< TI1 Edge Detector (TI1F_ED)            *//*!< Internal Trigger 3 (ITR3)              *//*!< Internal Trigger 2 (ITR2)              *//*!< Internal Trigger 1 (ITR1)              *//*!< Internal Trigger 0 (ITR0)              *//** @defgroup TIM_Trigger_Selection TIM Trigger Selection
  * @{
  *//*!< Asymmetric PWM mode 2                  *//*!< Asymmetric PWM mode 1                  *//*!< Combined PWM mode 2                    *//*!< Combined PWM mode 1                    *//*!< Retrigerrable OPM mode 2               *//*!< Retrigerrable OPM mode 1               *//*!< Force inactive level                   *//*!< Force active level                     *//*!< PWM mode 2                             *//*!< PWM mode 1                             *//*!< Toggle                                 *//*!< Set channel to inactive level on match *//*!< Set channel to active level on match   *//*!< Frozen                                 *//** @defgroup TIM_Output_Compare_and_PWM_modes TIM Output Compare and PWM Modes
  * @{
  *//*!< Combined reset + trigger mode *//*!< External Clock Mode 1         *//*!< Trigger Mode                  *//*!< Gated Mode                    *//*!< Reset Mode                    *//*!< Slave mode disabled           *//** @defgroup TIM_Slave_Mode TIM Slave mode
  * @{
  *//*!< Master/slave mode is selected *//*!< No action *//** @defgroup TIM_Master_Slave_Mode TIM Master/Slave Mode
  * @{
  *//*!< OC5REF or OC6REF rising edges generate pulses on TRGO2         *//*!< OC4REF rising or OC6REF falling edges generate pulses on TRGO2 *//*!< OC4REF or OC6REF rising edges generate pulses on TRGO2         *//*!< OC6REF rising or falling edges generate pulses on TRGO2        *//*!< OC4REF rising or falling edges generate pulses on TRGO2        *//*!< OC6REF signal is used as trigger output (TRGO2)                *//*!< OC5REF signal is used as trigger output (TRGO2)                *//*!< OC4REF signal is used as trigger output (TRGO2)                *//*!< OC3REF signal is used as trigger output (TRGO2)                *//*!< OC2REF signal is used as trigger output (TRGO2)                *//*!< OC1REF signal is used as trigger output (TRGO2)                *//*!< Capture or a compare match 1 is used as trigger output (TRGO2) *//*!< Update event is used as trigger output (TRGO2)                 *//*!< TIMx_CR1.CEN bit is used as trigger output (TRGO2)             *//*!< TIMx_EGR.UG bit is used as trigger output (TRGO2)              *//** @defgroup TIM_Master_Mode_Selection_2 TIM Master Mode Selection 2 (TRGO2)
  * @{
  *//*!< OC4REF signal is used as trigger output(TRGO)                 *//*!< OC3REF signal is used as trigger output(TRGO)                 *//*!< OC2REF signal is used as trigger output(TRGO)                 *//*!< OC1REF signal is used as trigger output (TRGO)                *//*!< Capture or a compare match 1 is used as trigger output (TRGO) *//*!< Update event is used as trigger output (TRGO)                 *//*!< TIMx_CR1.CEN bit is used as trigger output (TRGO)             *//*!< TIMx_EGR.UG bit is used as trigger output (TRGO)              *//** @defgroup TIM_Master_Mode_Selection TIM Master Mode Selection
  * @{
  *//*!< OC3REFC is the logical AND of OC3REFC and OC5REF    *//*!< OC2REFC is the logical AND of OC2REFC and OC5REF    *//*!< OC1REFC is the logical AND of OC1REFC and OC5REF    *//*!< No effect of OC5REF on OC1REFC, OC2REFC and OC3REFC *//** @defgroup TIM_Group_Channel5 TIM Group Channel 5 and Channel 1, 2 or 3
  * @{
  *//*!< MOE can be set by software or automatically at the next update event (if none of the break inputs BRK and BRK2 is active) *//*!< MOE can be set only by software *//** @defgroup TIM_AOE_Bit_Set_Reset TIM Automatic Output Enable
  * @{
  *//*!< Break input BRK2 is active high  *//*!< Break input BRK2 is active low   *//** @defgroup TIM_Break2_Polarity TIM Break Input 2 Polarity
  * @{
  *//*!< Break input BRK2 is enabled  *//*!< Break input BRK2 is disabled  *//** @defgroup TIM_Break2_Input_enable_disable TIM Break input 2 Enable
  * @{
  *//*!< Break input BRK is active high *//*!< Break input BRK is active low  *//** @defgroup TIM_Break_Polarity TIM Break Input Polarity
  * @{
  *//*!< Break input BRK is disabled *//*!< Break input BRK is enabled  *//** @defgroup TIM_Break_Input_enable_disable TIM Break Input Enable
  * @{
  *//*!< LOCK Level 3 *//*!< LOCK Level 2 *//*!< LOCK Level 1 *//*!< LOCK OFF     *//** @defgroup TIM_Lock_level  TIM Lock level
  * @{
  *//*!< When inactive, OC/OCN outputs are disabled (not controlled any longer by the timer) *//*!< When inactive, OC/OCN outputs are enabled (still controlled by the timer)           *//** @defgroup TIM_OSSI_Off_State_Selection_for_Idle_mode_state TIM OSSI OffState Selection for Idle mode state
  * @{
  *//** @defgroup TIM_OSSR_Off_State_Selection_for_Run_mode_state TIM OSSR OffState Selection for Run mode state
  * @{
  *//*!< Prescaler for External ETR pin: Capture performed once every 8 events. *//*!< Prescaler for External ETR pin: Capture performed once every 4 events. *//*!< Prescaler for External ETR pin: Capture performed once every 2 events. *//*!< No prescaler is used                                                   *//** @defgroup TIM_ClearInput_Prescaler TIM Clear Input Prescaler
  * @{
  *//*!< Polarity for ETRx pin *//** @defgroup TIM_ClearInput_Polarity TIM Clear Input Polarity
  * @{
  *//*!< Prescaler for External ETR Clock: Capture performed once every 8 events. *//*!< Prescaler for External ETR Clock: Capture performed once every 4 events. *//*!< Prescaler for External ETR Clock: Capture performed once every 2 events. *//*!< No prescaler is used                                                     *//** @defgroup TIM_Clock_Prescaler TIM Clock Prescaler
  * @{
  *//*!< Polarity for TIx clock sources *//*!< Polarity for ETRx clock sources *//** @defgroup TIM_Clock_Polarity TIM Clock Polarity
  * @{
  *//*!< External clock source mode 1 (ITR3)                   *//*!< External clock source mode 1 (ITR2)                   *//*!< External clock source mode 1 (ITR1)                   *//*!< External clock source mode 1 (ITR0)                   *//*!< External clock source mode 1 (TTI2FP2)                *//*!< External clock source mode 1 (TTI1FP1)                *//*!< External clock source mode 1 (TTI1FP1 + edge detect.) *//*!< External clock source mode 2                          *//*!< External clock source mode 1 (ETRF)                   *//*!< Internal clock source                                 *//** @defgroup TIM_Clock_Source TIM Clock Source
  * @{
  *//*!< Global Capture/compare channel identifier  *//*!< Compare channel 6 identifier              *//*!< Compare channel 5 identifier              *//*!< Capture/compare channel 4 identifier      *//*!< Capture/compare channel 3 identifier      *//*!< Capture/compare channel 2 identifier      *//*!< Capture/compare channel 1 identifier      *//** @defgroup TIM_Channel TIM Channel
  * @{
  *//*!< Capture 4 overcapture flag    *//*!< Capture 3 overcapture flag    *//*!< Capture 2 overcapture flag    *//*!< Capture 1 overcapture flag    *//*!< System Break interrupt flag   *//*!< Break 2 interrupt flag        *//*!< Break interrupt flag          *//*!< Trigger interrupt flag        *//*!< Commutation interrupt flag    *//*!< Capture/Compare 6 interrupt flag *//*!< Capture/Compare 5 interrupt flag *//*!< Capture/Compare 4 interrupt flag *//*!< Capture/Compare 3 interrupt flag *//*!< Capture/Compare 2 interrupt flag *//*!< Capture/Compare 1 interrupt flag *//*!< Update interrupt flag         *//** @defgroup TIM_Flag_definition TIM Flag Definition
  * @{
  *//*!< CCx DMA requests sent when update event occurs *//*!< CCx DMA request sent when capture or compare match event occurs *//** @defgroup TIM_CC_DMA_Request CCx DMA request selection
  * @{
  *//*!< DMA request is triggered by the trigger event *//*!< DMA request is triggered by the commutation event *//*!< DMA request is triggered by the capture/compare macth 4 event event *//*!< DMA request is triggered by the capture/compare macth 3 event event *//*!< DMA request is triggered by the capture/compare macth 2 event event *//*!< DMA request is triggered by the capture/compare macth 1 event *//*!< DMA request is triggered by the update event *//** @defgroup TIM_DMA_sources TIM DMA Sources
  * @{
  *//*!< When Capture/compare control bits are preloaded, they are updated by setting the COMG bit *//*!< When Capture/compare control bits are preloaded, they are updated by setting the COMG bit or when an rising edge occurs on trigger input *//** @defgroup TIM_Commutation_Source  TIM Commutation Source
  * @{
  *//*!< Break interrupt             *//*!< Trigger interrupt           *//*!< Commutation interrupt       *//*!< Capture/Compare 4 interrupt *//*!< Capture/Compare 3 interrupt *//*!< Capture/Compare 2 interrupt *//*!< Capture/Compare 1 interrupt *//*!< Update interrupt            *//** @defgroup TIM_Interrupt_definition TIM interrupt Definition
  * @{
  *//*!< Quadrature encoder mode 3, x4 mode, counts up/down on both TI1FP1 and TI2FP2 edges depending on the level of the other input. *//*!< Quadrature encoder mode 2, x2 mode, counts up/down on TI2FP2 edge depending on TI1FP1 level. *//*!< Quadrature encoder mode 1, x2 mode, counts up/down on TI1FP1 edge depending on TI2FP2 level  *//** @defgroup TIM_Encoder_Mode TIM Encoder Mode
  * @{
  *//*!< Counter is not stopped at update event          *//*!< Counter stops counting at the next update event *//** @defgroup TIM_One_Pulse_Mode TIM One Pulse Mode
  * @{
  *//*!< Capture performed once every 8 events                                *//*!< Capture performed once every 4 events                                *//*!< Capture performed once every 2 events                                *//*!< Capture performed each time an edge is detected on the capture input *//** @defgroup TIM_Input_Capture_Prescaler TIM Input Capture Prescaler
  * @{
  *//*!< TIM Input 1, 2, 3 or 4 is selected to be connected to TRC *//*!< TIM Input 1, 2, 3 or 4 is selected to be connected to IC2, IC1, IC4 or IC3, respectively *//*!< TIM Input 1, 2, 3 or 4 is selected to be connected to IC1, IC2, IC3 or IC4, respectively *//** @defgroup TIM_Input_Capture_Selection TIM Input Capture Selection
  * @{
  *//*!< Encoder input with falling edge polarity *//*!< Encoder input with rising edge polarity  *//** @defgroup TIM_Encoder_Input_Polarity TIM Encoder Input Polarity
  * @{
  *//*!< Capture triggered by both rising and falling edges on timer input*//*!< Capture triggered by falling edge on timer input                 *//*!< Capture triggered by rising edge on timer input                  *//** @defgroup TIM_Input_Capture_Polarity TIM Input Capture Polarity
  * @{
  *//*!< Complementary output Idle state: OCxN=0 when MOE=0 *//*!< Complementary output Idle state: OCxN=1 when MOE=0 *//** @defgroup TIM_Output_Compare_N_Idle_State TIM Complementary Output Compare Idle State
  * @{
  *//*!< Output Idle state: OCx=0 when MOE=0 *//*!< Output Idle state: OCx=1 when MOE=0 *//** @defgroup TIM_Output_Compare_Idle_State TIM Output Compare Idle State
  * @{
  *//*!< Capture/Compare complementary output polarity *//** @defgroup TIM_Output_Compare_N_Polarity TIM Complementary Output Compare Polarity
  * @{
  *//*!< Capture/Compare output polarity  *//** @defgroup TIM_Output_Compare_Polarity TIM Output Compare Polarity
  * @{
  *//*!< OCxN is enabled   *//*!< OCxN is disabled  *//** @defgroup TIM_Output_Compare_N_State TIM Complementary Output Compare State
  * @{
  *//*!< Output Compare fast enable  *//*!< Output Compare fast disable *//** @defgroup TIM_Output_Fast_State TIM Output Fast State
  * @{
  *//*!< TIMx_ARR register is buffered *//*!< TIMx_ARR register is not buffered *//** @defgroup TIM_AutoReloadPreload TIM Auto-Reload Preload
  * @{
  *//*!< Capture/Compare 1 output enabled *//*!< Capture/Compare 1 output disabled *//** @defgroup TIM_Output_Compare_State TIM Output Compare State
  * @{
  *//*!< Clock division: tDTS=4*tCK_INT *//*!< Clock division: tDTS=2*tCK_INT *//*!< Clock division: tDTS=tCK_INT   *//** @defgroup TIM_ClockDivision TIM Clock Division
  * @{
  *//*!< Update interrupt flag remap enabled *//*!< Update interrupt flag remap disabled *//** @defgroup TIM_Update_Interrupt_Flag_Remap TIM Update Interrupt Flag Remap
  * @{
  *//*!< Center-aligned mode 3        *//*!< Center-aligned mode 2        *//*!< Center-aligned mode 1        *//*!< Counter used as down-counter *//*!< Counter used as up-counter   *//** @defgroup TIM_Counter_Mode TIM Counter Mode
  * @{
  *//*!< ETR input source is divided by 8 *//*!< ETR input source is divided by 4 *//*!< ETR input source is divided by 2 *//*!< No prescaler is used *//** @defgroup TIM_ETR_Prescaler TIM ETR Prescaler
  * @{
  *//*!< Polarity for ETR source *//** @defgroup TIM_ETR_Polarity TIM ETR Polarity
  * @{
  *//*!< Polarity for TIx source *//** @defgroup TIM_Input_Channel_Polarity TIM Input Channel polarity
  * @{
  *//*!< A break 2 event is generated *//*!< A break event is generated *//*!< A trigger event is generated *//*!< A commutation event is generated *//*!< A capture/compare event is generated on channel 4 *//*!< A capture/compare event is generated on channel 3 *//*!< A capture/compare event is generated on channel 2 *//*!< A capture/compare event is generated on channel 1 *//*!< Reinitialize the counter and generates an update of the registers *//** @defgroup TIM_Event_Source TIM Event Source
  * @{
  *//** @defgroup TIM_DMA_Base_address TIM DMA Base Address
  * @{
  *//*!< OCREF_CLR is connected to ETRF input *//*!< OCREF_CLR is disabled *//** @defgroup TIM_ClearInput_Source TIM Clear Input Source
  * @{
  *//** @defgroup TIM_Exported_Constants TIM Exported Constants
  * @{
  *//*!< pointer to the TIM callback function *//**
  * @brief  HAL TIM Callback pointer definition
  *//*!< TIM Break2 Callback ID                                     *//*!< TIM Break Callback ID                                      *//*!< TIM Commutation half complete Callback ID                  *//*!< TIM Commutation Callback ID                                *//*!< TIM Error Callback ID                                      *//*!< TIM PWM Pulse Finished half complete Callback ID           *//*!< TIM PWM Pulse Finished Callback ID                         *//*!< TIM Output Compare Delay Elapsed Callback ID               *//*!< TIM Input Capture half complete Callback ID                *//*!< TIM Input Capture Callback ID                              *//*!< TIM Trigger half complete Callback ID                      *//*!< TIM Trigger Callback ID                                    *//*!< TIM Period Elapsed half complete Callback ID               *//*!< TIM Period Elapsed Callback ID                             *//*!< TIM Hall Sensor MspDeInit Callback ID                      *//*!< TIM Encoder MspDeInit Callback ID                          *//*!< TIM Encoder MspInit Callback ID                            *//*!< TIM One Pulse MspDeInit Callback ID                        *//*!< TIM One Pulse MspInit Callback ID                          *//*!< TIM PWM MspDeInit Callback ID                              *//*!< TIM PWM MspInit Callback ID                                *//*!< TIM OC MspDeInit Callback ID                               *//*!< TIM OC MspInit Callback ID                                 *//*!< TIM IC MspDeInit Callback ID                               *//*!< TIM IC MspInit Callback ID                                 *//*!< TIM Base MspDeInit Callback ID                             *//*!< TIM Base MspInit Callback ID                               *//**
  * @brief  HAL TIM Callback ID enumeration definition
  *//*!< TIM Break2 Callback                                     *//*!< TIM Break Callback                                      *//*!< TIM Commutation half complete Callback                  *//*!< TIM Commutation Callback                                *//*!< TIM Error Callback                                      *//*!< TIM PWM Pulse Finished half complete Callback           *//*!< TIM PWM Pulse Finished Callback                         *//*!< TIM Output Compare Delay Elapsed Callback               *//*!< TIM Input Capture half complete Callback                *//*!< TIM Input Capture Callback                              *//*!< TIM Trigger half complete Callback                      *//*!< TIM Trigger Callback                                    *//*!< TIM Period Elapsed half complete Callback               *//*!< TIM Period Elapsed Callback                             *//*!< TIM Hall Sensor Msp DeInit Callback                     *//*!< TIM Hall Sensor Msp Init Callback                       *//*!< TIM Encoder Msp DeInit Callback                         *//*!< TIM Encoder Msp Init Callback                           *//*!< TIM One Pulse Msp DeInit Callback                       *//*!< TIM One Pulse Msp Init Callback                         *//*!< TIM PWM Msp DeInit Callback                             *//*!< TIM PWM Msp Init Callback                               *//*!< TIM OC Msp DeInit Callback                              *//*!< TIM OC Msp Init Callback                                *//*!< TIM IC Msp DeInit Callback                              *//*!< TIM IC Msp Init Callback                                *//*!< TIM Base Msp DeInit Callback                            *//*!< TIM Base Msp Init Callback                              *//*!< DMA burst operation state                         *//*!< TIM complementary channel operation state         *//*!< TIM channel operation state                       *//*!< TIM operation state                               *//*!< Locking object                                    *//*!< DMA Handlers array
                                                             This array is accessed by a @ref DMA_Handle_index *//*!< Active channel                                    *//*!< TIM Time Base required parameters                 *//*!< Register base address                             *//**
  * @brief  TIM Time Base Handle Structure definition
  *//*!< All active channels cleared *//*!< The active channel is 6     *//*!< The active channel is 5     *//*!< The active channel is 4     *//*!< The active channel is 3     *//*!< The active channel is 2     *//*!< The active channel is 1     *//**
  * @brief  HAL Active channel structures definition
  *//*!< Ongoing DMA Burst       *//*!< DMA Burst ready for use *//*!< DMA Burst initial state *//**
  * @brief  DMA Burst States definition
  *//*!< An internal process is ongoing on the TIM channel *//*!< TIM Channel ready for use                         *//*!< TIM Channel initial state                         *//**
  * @brief  TIM Channel States definition
  *//*!< Reception process is ongoing                *//*!< Peripheral not yet initialized or disabled  *//*!< TIM Automatic Output Enable state, This parameter can be a value of @ref TIM_AOE_Bit_Set_Reset *//*!< TIM break2 input filter.This parameter can be a number between Min_Data = 0x0 and Max_Data = 0xF *//*!< TIM Break2 input polarity, This parameter can be a value of @ref TIM_Break2_Polarity *//*!< TIM Break2 State, This parameter can be a value of @ref TIM_Break2_Input_enable_disable *//*!< Specifies the break input filter.This parameter can be a number between Min_Data = 0x0 and Max_Data = 0xF *//*!< TIM Break input polarity, This parameter can be a value of @ref TIM_Break_Polarity *//*!< TIM Break State, This parameter can be a value of @ref TIM_Break_Input_enable_disable *//*!< TIM dead Time, This parameter can be a number between Min_Data = 0x00 and Max_Data = 0xFF *//*!< TIM Lock level, This parameter can be a value of @ref TIM_Lock_level *//*!< TIM off state in IDLE mode, This parameter can be a value of @ref TIM_OSSI_Off_State_Selection_for_Idle_mode_state *//*!< TIM off state in run mode, This parameter can be a value of @ref TIM_OSSR_Off_State_Selection_for_Run_mode_state *//**
  * @brief  TIM Break input(s) and Dead time configuration Structure definition
  * @note   2 break inputs can be configured (BKIN and BKIN2) with configurable
  *        filter and polarity.
  *//*!< Input trigger filter
                                    This parameter can be a number between Min_Data = 0x0 and Max_Data = 0xF  *//*!< Input trigger prescaler
                                    This parameter can be a value of @ref TIM_Trigger_Prescaler *//*!< Input Trigger polarity
                                    This parameter can be a value of @ref TIM_Trigger_Polarity *//*!< Input Trigger source
                                    This parameter can be a value of @ref TIM_Trigger_Selection *//*!< Slave mode selection
                                    This parameter can be a value of @ref TIM_Slave_Mode *//**
  * @brief  TIM Slave configuration Structure definition
  *//*!< Master/slave mode selection
                                        This parameter can be a value of @ref TIM_Master_Slave_Mode
                                        @note When the Master/slave mode is enabled, the effect of
                                        an event on the trigger input (TRGI) is delayed to allow a
                                        perfect synchronization between the current timer and its
                                        slaves (through TRGO). It is not mandatory in case of timer
                                        synchronization mode. *//*!< Trigger output2 (TRGO2) selection
                                        This parameter can be a value of @ref TIM_Master_Mode_Selection_2 *//*!< Trigger output (TRGO) selection
                                        This parameter can be a value of @ref TIM_Master_Mode_Selection *//**
  * @brief  TIM Master configuration Structure definition
  * @note   Advanced timers provide TRGO2 internal line which is redirected
  *         to the ADC
  *//*!< TIM Clear Input filter
                                      This parameter can be a number between Min_Data = 0x0 and Max_Data = 0xF *//*!< TIM Clear Input prescaler
                                      This parameter must be 0: When OCRef clear feature is used with ETR source,
                                      ETR prescaler must be off *//*!< TIM Clear Input polarity
                                      This parameter can be a value of @ref TIM_ClearInput_Polarity *//*!< TIM clear Input sources
                                      This parameter can be a value of @ref TIM_ClearInput_Source *//*!< TIM clear Input state
                                      This parameter can be ENABLE or DISABLE *//**
  * @brief  TIM Clear Input Configuration Handle Structure definition
  *//*!< TIM clock filter
                                 This parameter can be a number between Min_Data = 0x0 and Max_Data = 0xF *//*!< TIM clock prescaler
                                 This parameter can be a value of @ref TIM_Clock_Prescaler *//*!< TIM clock polarity
                                 This parameter can be a value of @ref TIM_Clock_Polarity *//*!< TIM clock sources
                                 This parameter can be a value of @ref TIM_Clock_Source *//**
  * @brief  Clock Configuration Handle Structure definition
  *//*!< Specifies the input capture filter.
                               This parameter can be a number between Min_Data = 0x0 and Max_Data = 0xF *//*!< Specifies the Input Capture Prescaler.
                               This parameter can be a value of @ref TIM_Input_Capture_Prescaler *//*!< Specifies the input.
                              This parameter can be a value of @ref TIM_Input_Capture_Selection *//*!< Specifies the active edge of the input signal.
                               This parameter can be a value of @ref TIM_Encoder_Input_Polarity *//*!< Specifies the input.
                               This parameter can be a value of @ref TIM_Input_Capture_Selection *//*!< Specifies the active edge of the input signal.
                               This parameter can be a value of @ref TIM_Encoder_Mode *//**
  * @brief  TIM Encoder Configuration Structure definition
  *//*!< Specifies the input capture filter.
                              This parameter can be a number between Min_Data = 0x0 and Max_Data = 0xF *//*!< Specifies the Input Capture Prescaler.
                              This parameter can be a value of @ref TIM_Input_Capture_Prescaler *//*!< Specifies the active edge of the input signal.
                              This parameter can be a value of @ref TIM_Input_Capture_Polarity *//**
  * @brief  TIM Input Capture Configuration Structure definition
  *//*!< Specifies the active edge of the input signal.
                               This parameter can be a value of @ref TIM_Input_Capture_Polarity *//*!< Specifies the TIM Output Compare pin state during Idle state.
                               This parameter can be a value of @ref TIM_Output_Compare_N_Idle_State
                               @note This parameter is valid only for timer instances supporting break feature. *//*!< Specifies the TIM Output Compare pin state during Idle state.
                               This parameter can be a value of @ref TIM_Output_Compare_Idle_State
                               @note This parameter is valid only for timer instances supporting break feature. *//*!< Specifies the complementary output polarity.
                               This parameter can be a value of @ref TIM_Output_Compare_N_Polarity
                               @note This parameter is valid only for timer instances supporting break feature. *//*!< Specifies the output polarity.
                               This parameter can be a value of @ref TIM_Output_Compare_Polarity *//*!< Specifies the pulse value to be loaded into the Capture Compare Register.
                               This parameter can be a number between Min_Data = 0x0000 and Max_Data = 0xFFFF *//*!< Specifies the TIM mode.
                               This parameter can be a value of @ref TIM_Output_Compare_and_PWM_modes *//**
  * @brief  TIM One Pulse Mode Configuration Structure definition
  *//*!< Specifies the Fast mode state.
                               This parameter can be a value of @ref TIM_Output_Fast_State
                               @note This parameter is valid only in PWM1 and PWM2 mode. *//**
  * @brief  TIM Output Compare Configuration Structure definition
  *//*!< Specifies the auto-reload preload.
                                   This parameter can be a value of @ref TIM_AutoReloadPreload *//*!< Specifies the repetition counter value. Each time the RCR downcounter
                                    reaches zero, an update event is generated and counting restarts
                                    from the RCR value (N).
                                    This means in PWM mode that (N+1) corresponds to:
                                        - the number of PWM periods in edge-aligned mode
                                        - the number of half PWM period in center-aligned mode
                                     GP timers: this parameter must be a number between Min_Data = 0x00 and
                                     Max_Data = 0xFF.
                                     Advanced timers: this parameter must be a number between Min_Data = 0x0000 and
                                     Max_Data = 0xFFFF. *//*!< Specifies the clock division.
                                   This parameter can be a value of @ref TIM_ClockDivision *//*!< Specifies the period value to be loaded into the active
                                   Auto-Reload Register at the next update event.
                                   This parameter can be a number between Min_Data = 0x0000 and Max_Data = 0xFFFF.  *//*!< Specifies the counter mode.
                                   This parameter can be a value of @ref TIM_Counter_Mode *//*!< Specifies the prescaler value used to divide the TIM clock.
                                   This parameter can be a number between Min_Data = 0x0000 and Max_Data = 0xFFFF *//**
  * @brief  TIM Time base Configuration Structure definition
  *//** @defgroup TIM_Exported_Types TIM Exported Types
  * @{
  *//** @addtogroup TIM
  * @{
  *//**
  ******************************************************************************
  * @file    stm32f7xx_hal_tim.h
  * @author  MCD Application Team
  * @brief   Header file of TIM HAL module.
  ******************************************************************************
  * @attention
  *
  * Copyright (c) 2017 STMicroelectronics.
  * All rights reserved.
  *
  * This software is licensed under terms that can be found in the LICENSE file
  * in the root directory of this software component.
  * If no LICENSE file comes with this software, it is provided AS-IS.
  *
  ******************************************************************************
  */TIMxTIM_ExtTRGPrescalerTIM_ExtTRGPolarityExtTRGFilterOC_ConfigTIM_ICPolarityTIM_ICSelectionTIM_ICFilterStructureEventSourceBurstRequestSrcBurstBaseAddressBurstBufferBurstLengthsSlaveConfigTI1_SelectionsClockSourceConfigsClearInputConfigInputChannelpData1pData2OnePulseModeHAL_UARTEx_GetRxEventTypeconst UART_HandleTypeDefconst UART_HandleTypeDef *HAL_UARTEx_ReceiveToIdle_DMAHAL_UARTEx_ReceiveToIdle_ITHAL_UARTEx_ReceiveToIdleHAL_MultiProcessorEx_AddressLength_SetHAL_UARTEx_DisableClockStopModeHAL_UARTEx_EnableClockStopModeHAL_UARTEx_DisableStopModeHAL_UARTEx_EnableStopModeHAL_UARTEx_StopModeWakeUpSourceConfigHAL_RS485Ex_InitUART_WakeUpTypeDefAddressLengthWakeUpEventIS_UART_ADDRESSLENGTH_DETECT(__ADDRESS__)(((__ADDRESS__) == UART_ADDRESS_DETECT_4B) || ((__ADDRESS__) == UART_ADDRESS_DETECT_7B))IS_UART_WORD_LENGTH(__LENGTH__)(((__LENGTH__) == UART_WORDLENGTH_7B) || ((__LENGTH__) == UART_WORDLENGTH_8B) || ((__LENGTH__) == UART_WORDLENGTH_9B))UART_MASK_COMPUTATION(__HANDLE__)do { if ((__HANDLE__)->Init.WordLength == UART_WORDLENGTH_9B) { if ((__HANDLE__)->Init.Parity == UART_PARITY_NONE) { (__HANDLE__)->Mask = 0x01FFU ; } else { (__HANDLE__)->Mask = 0x00FFU ; } } else if ((__HANDLE__)->Init.WordLength == UART_WORDLENGTH_8B) { if ((__HANDLE__)->Init.Parity == UART_PARITY_NONE) { (__HANDLE__)->Mask = 0x00FFU ; } else { (__HANDLE__)->Mask = 0x007FU ; } } else if ((__HANDLE__)->Init.WordLength == UART_WORDLENGTH_7B) { if ((__HANDLE__)->Init.Parity == UART_PARITY_NONE) { (__HANDLE__)->Mask = 0x007FU ; } else { (__HANDLE__)->Mask = 0x003FU ; } } else { (__HANDLE__)->Mask = 0x0000U; } } while(0U)UART_GETCLOCKSOURCE(__HANDLE__,__CLOCKSOURCE__)do { if((__HANDLE__)->Instance == USART1) { switch(__HAL_RCC_GET_USART1_SOURCE()) { case RCC_USART1CLKSOURCE_PCLK2: (__CLOCKSOURCE__) = UART_CLOCKSOURCE_PCLK2; break; case RCC_USART1CLKSOURCE_HSI: (__CLOCKSOURCE__) = UART_CLOCKSOURCE_HSI; break; case RCC_USART1CLKSOURCE_SYSCLK: (__CLOCKSOURCE__) = UART_CLOCKSOURCE_SYSCLK; break; case RCC_USART1CLKSOURCE_LSE: (__CLOCKSOURCE__) = UART_CLOCKSOURCE_LSE; break; default: (__CLOCKSOURCE__) = UART_CLOCKSOURCE_UNDEFINED; break; } } else if((__HANDLE__)->Instance == USART2) { switch(__HAL_RCC_GET_USART2_SOURCE()) { case RCC_USART2CLKSOURCE_PCLK1: (__CLOCKSOURCE__) = UART_CLOCKSOURCE_PCLK1; break; case RCC_USART2CLKSOURCE_HSI: (__CLOCKSOURCE__) = UART_CLOCKSOURCE_HSI; break; case RCC_USART2CLKSOURCE_SYSCLK: (__CLOCKSOURCE__) = UART_CLOCKSOURCE_SYSCLK; break; case RCC_USART2CLKSOURCE_LSE: (__CLOCKSOURCE__) = UART_CLOCKSOURCE_LSE; break; default: (__CLOCKSOURCE__) = UART_CLOCKSOURCE_UNDEFINED; break; } } else if((__HANDLE__)->Instance == USART3) { switch(__HAL_RCC_GET_USART3_SOURCE()) { case RCC_USART3CLKSOURCE_PCLK1: (__CLOCKSOURCE__) = UART_CLOCKSOURCE_PCLK1; break; case RCC_USART3CLKSOURCE_HSI: (__CLOCKSOURCE__) = UART_CLOCKSOURCE_HSI; break; case RCC_USART3CLKSOURCE_SYSCLK: (__CLOCKSOURCE__) = UART_CLOCKSOURCE_SYSCLK; break; case RCC_USART3CLKSOURCE_LSE: (__CLOCKSOURCE__) = UART_CLOCKSOURCE_LSE; break; default: (__CLOCKSOURCE__) = UART_CLOCKSOURCE_UNDEFINED; break; } } else if((__HANDLE__)->Instance == UART4) { switch(__HAL_RCC_GET_UART4_SOURCE()) { case RCC_UART4CLKSOURCE_PCLK1: (__CLOCKSOURCE__) = UART_CLOCKSOURCE_PCLK1; break; case RCC_UART4CLKSOURCE_HSI: (__CLOCKSOURCE__) = UART_CLOCKSOURCE_HSI; break; case RCC_UART4CLKSOURCE_SYSCLK: (__CLOCKSOURCE__) = UART_CLOCKSOURCE_SYSCLK; break; case RCC_UART4CLKSOURCE_LSE: (__CLOCKSOURCE__) = UART_CLOCKSOURCE_LSE; break; default: (__CLOCKSOURCE__) = UART_CLOCKSOURCE_UNDEFINED; break; } } else if ((__HANDLE__)->Instance == UART5) { switch(__HAL_RCC_GET_UART5_SOURCE()) { case RCC_UART5CLKSOURCE_PCLK1: (__CLOCKSOURCE__) = UART_CLOCKSOURCE_PCLK1; break; case RCC_UART5CLKSOURCE_HSI: (__CLOCKSOURCE__) = UART_CLOCKSOURCE_HSI; break; case RCC_UART5CLKSOURCE_SYSCLK: (__CLOCKSOURCE__) = UART_CLOCKSOURCE_SYSCLK; break; case RCC_UART5CLKSOURCE_LSE: (__CLOCKSOURCE__) = UART_CLOCKSOURCE_LSE; break; default: (__CLOCKSOURCE__) = UART_CLOCKSOURCE_UNDEFINED; break; } } else if((__HANDLE__)->Instance == USART6) { switch(__HAL_RCC_GET_USART6_SOURCE()) { case RCC_USART6CLKSOURCE_PCLK2: (__CLOCKSOURCE__) = UART_CLOCKSOURCE_PCLK2; break; case RCC_USART6CLKSOURCE_HSI: (__CLOCKSOURCE__) = UART_CLOCKSOURCE_HSI; break; case RCC_USART6CLKSOURCE_SYSCLK: (__CLOCKSOURCE__) = UART_CLOCKSOURCE_SYSCLK; break; case RCC_USART6CLKSOURCE_LSE: (__CLOCKSOURCE__) = UART_CLOCKSOURCE_LSE; break; default: (__CLOCKSOURCE__) = UART_CLOCKSOURCE_UNDEFINED; break; } } else if ((__HANDLE__)->Instance == UART7) { switch(__HAL_RCC_GET_UART7_SOURCE()) { case RCC_UART7CLKSOURCE_PCLK1: (__CLOCKSOURCE__) = UART_CLOCKSOURCE_PCLK1; break; case RCC_UART7CLKSOURCE_HSI: (__CLOCKSOURCE__) = UART_CLOCKSOURCE_HSI; break; case RCC_UART7CLKSOURCE_SYSCLK: (__CLOCKSOURCE__) = UART_CLOCKSOURCE_SYSCLK; break; case RCC_UART7CLKSOURCE_LSE: (__CLOCKSOURCE__) = UART_CLOCKSOURCE_LSE; break; default: (__CLOCKSOURCE__) = UART_CLOCKSOURCE_UNDEFINED; break; } } else if ((__HANDLE__)->Instance == UART8) { switch(__HAL_RCC_GET_UART8_SOURCE()) { case RCC_UART8CLKSOURCE_PCLK1: (__CLOCKSOURCE__) = UART_CLOCKSOURCE_PCLK1; break; case RCC_UART8CLKSOURCE_HSI: (__CLOCKSOURCE__) = UART_CLOCKSOURCE_HSI; break; case RCC_UART8CLKSOURCE_SYSCLK: (__CLOCKSOURCE__) = UART_CLOCKSOURCE_SYSCLK; break; case RCC_UART8CLKSOURCE_LSE: (__CLOCKSOURCE__) = UART_CLOCKSOURCE_LSE; break; default: (__CLOCKSOURCE__) = UART_CLOCKSOURCE_UNDEFINED; break; } } else { (__CLOCKSOURCE__) = UART_CLOCKSOURCE_UNDEFINED; } } while(0U)UART_ADDRESS_DETECT_7BUART_ADDRESS_DETECT_4BUART_WORDLENGTH_9BUART_WORDLENGTH_8BUART_WORDLENGTH_7BSTM32F7xx_HAL_UART_EX_Hdefined(USART_CR1_UESM)defined(USART_CR3_UCESM)/* STM32F7xx_HAL_UART_EX_H *//**
  * @brief Ensure that UART wake-up address length is valid.
  * @param __ADDRESS__ UART wake-up address length.
  * @retval SET (__ADDRESS__ is valid) or RESET (__ADDRESS__ is invalid)
  *//**
  * @brief Ensure that UART frame length is valid.
  * @param __LENGTH__ UART frame length.
  * @retval SET (__LENGTH__ is valid) or RESET (__LENGTH__ is invalid)
  *//** @brief  Report the UART mask to apply to retrieve the received data
  *         according to the word length and to the parity bits activation.
  * @note   If PCE = 1, the parity bit is not included in the data extracted
  *         by the reception API().
  *         This masking operation is not carried out in the case of
  *         DMA transfers.
  * @param  __HANDLE__ specifies the UART Handle.
  * @retval None, the mask to apply to UART RDR register is stored in (__HANDLE__)->Mask field.
  *//** @brief  Report the UART clock source.
  * @param  __HANDLE__ specifies the UART Handle.
  * @param  __CLOCKSOURCE__ output variable.
  * @retval UART clocking source, written in __CLOCKSOURCE__.
  *//** @defgroup UARTEx_Private_Macros UARTEx Private Macros
  * @{
  *//* USART_CR3_UCESM *//* USART_CR1_UESM *//** @addtogroup UARTEx_Exported_Functions_Group3
  * @{
  *//** @addtogroup UARTEx_Exported_Functions_Group2
  * @{
  *//* Initialization and de-initialization functions  ****************************//** @addtogroup UARTEx_Exported_Functions_Group1
  * @{
  *//** @addtogroup UARTEx_Exported_Functions
  * @{
  *//*!< 7-bit long wake-up address *//*!< 4-bit long wake-up address *//** @defgroup UARTEx_WakeUp_Address_Length UARTEx WakeUp Address Length
  * @{
  *//*!< 9-bit long UART frame *//*!< 8-bit long UART frame *//*!< 7-bit long UART frame *//** @defgroup UARTEx_Word_Length UARTEx Word Length
  * @{
  *//** @defgroup UARTEx_Exported_Constants UARTEx Exported Constants
  * @{
  *//*!< UART/USART node address (7-bit long max). *//*!< Specifies whether the address is 4 or 7-bit long.
                                    This parameter can be a value of @ref UARTEx_WakeUp_Address_Length.  *//*!< Specifies which event will activate the Wakeup from Stop mode flag (WUF).
                                    This parameter can be a value of @ref UART_WakeUp_from_Stop_Selection.
                                    If set to UART_WAKEUP_ON_ADDRESS, the two other fields below must
                                    be filled up. *//**
  * @brief  UART wake up from stop mode parameters
  *//** @defgroup UARTEx_Exported_Types UARTEx Exported Types
  * @{
  *//** @addtogroup UARTEx
  * @{
  *//**
  ******************************************************************************
  * @file    stm32f7xx_hal_uart_ex.h
  * @author  MCD Application Team
  * @brief   Header file of UART HAL Extended module.
  ******************************************************************************
  * @attention
  *
  * Copyright (c) 2017 STMicroelectronics.
  * All rights reserved.
  *
  * This software is licensed under terms that can be found in the LICENSE file
  * in the root directory of this software component.
  * If no LICENSE file comes with this software, it is provided AS-IS.
  *
  ******************************************************************************
  */RxLenWakeUpSelectionAssertionTimeDeassertionTime"stm32f7xx_hal_uart_ex.h"UART_Start_Receive_DMAUART_Start_Receive_ITUART_AdvFeatureConfigUART_WaitOnFlagUntilTimeoutUART_CheckIdleStateUART_SetConfigHAL_UART_GetErrorHAL_UART_GetStateHAL_HalfDuplex_EnableReceiverHAL_HalfDuplex_EnableTransmitterHAL_MultiProcessor_EnterMuteModeHAL_MultiProcessor_DisableMuteModeHAL_MultiProcessor_EnableMuteModeHAL_LIN_SendBreakHAL_UART_DisableReceiverTimeoutHAL_UART_EnableReceiverTimeoutHAL_UART_ReceiverTimeout_ConfigHAL_UARTEx_RxEventCallbackHAL_UART_AbortReceiveCpltCallbackHAL_UART_AbortTransmitCpltCallbackHAL_UART_AbortCpltCallbackHAL_UART_ErrorCallbackHAL_UART_RxCpltCallbackHAL_UART_RxHalfCpltCallbackHAL_UART_TxCpltCallbackHAL_UART_TxHalfCpltCallbackHAL_UART_IRQHandlerHAL_UART_AbortReceive_ITHAL_UART_AbortTransmit_ITHAL_UART_Abort_ITHAL_UART_AbortReceiveHAL_UART_AbortTransmitHAL_UART_AbortHAL_UART_DMAStopHAL_UART_DMAResumeHAL_UART_DMAPauseHAL_UART_Receive_DMAHAL_UART_Transmit_DMAHAL_UART_Receive_ITHAL_UART_Transmit_ITHAL_UART_ReceiveHAL_UART_TransmitHAL_UART_MspDeInitHAL_UART_MspInitHAL_UART_DeInitHAL_MultiProcessor_InitHAL_LIN_InitHAL_HalfDuplex_InitHAL_UART_InitUART_HandleTypeDef__UART_HandleTypeDefHAL_UART_RxEventTypeTypeDefHAL_UART_RxTypeTypeDefUART_ClockSourceTypeDefUART_CLOCKSOURCE_PCLK1UART_CLOCKSOURCE_PCLK2UART_CLOCKSOURCE_HSIUART_CLOCKSOURCE_SYSCLKUART_CLOCKSOURCE_LSEUART_CLOCKSOURCE_UNDEFINEDHAL_UART_StateTypeDefUART_AdvFeatureInitTypeDefUART_InitTypeDefvolatile HAL_UART_StateTypeDefRxStateTxISRRxISRvolatile HAL_UART_RxEventTypeTypeDefRxEventTypevolatile HAL_UART_RxTypeTypeDefReceptionTypeMaskRxXferCountTxXferCountAdvancedInitMSBFirstAutoBaudRateModeAutoBaudRateEnableDMADisableonRxErrorOverrunDisableSwapDataInvertRxPinLevelInvertTxPinLevelInvertAdvFeatureInitOneBitSamplingOverSamplingHwFlowCtlParityStopBitsWordLengthBaudRateIS_UART_DE_POLARITY(__POLARITY__)(((__POLARITY__) == UART_DE_POLARITY_HIGH) || ((__POLARITY__) == UART_DE_POLARITY_LOW))IS_UART_WAKEUP_SELECTION(__WAKE__)(((__WAKE__) == UART_WAKEUP_ON_ADDRESS) || ((__WAKE__) == UART_WAKEUP_ON_STARTBIT) || ((__WAKE__) == UART_WAKEUP_ON_READDATA_NONEMPTY))IS_UART_MUTE_MODE(__MUTE__)(((__MUTE__) == UART_ADVFEATURE_MUTEMODE_DISABLE) || ((__MUTE__) == UART_ADVFEATURE_MUTEMODE_ENABLE))IS_UART_ADVFEATURE_STOPMODE(__STOPMODE__)(((__STOPMODE__) == UART_ADVFEATURE_STOPMODE_DISABLE) || ((__STOPMODE__) == UART_ADVFEATURE_STOPMODE_ENABLE))IS_UART_ADVFEATURE_MSBFIRST(__MSBFIRST__)(((__MSBFIRST__) == UART_ADVFEATURE_MSBFIRST_DISABLE) || ((__MSBFIRST__) == UART_ADVFEATURE_MSBFIRST_ENABLE))IS_UART_ADVFEATURE_DMAONRXERROR(__DMA__)(((__DMA__) == UART_ADVFEATURE_DMA_ENABLEONRXERROR) || ((__DMA__) == UART_ADVFEATURE_DMA_DISABLEONRXERROR))IS_UART_ADVFEATURE_AUTOBAUDRATE(__AUTOBAUDRATE__)(((__AUTOBAUDRATE__) == UART_ADVFEATURE_AUTOBAUDRATE_DISABLE) || ((__AUTOBAUDRATE__) == UART_ADVFEATURE_AUTOBAUDRATE_ENABLE))IS_UART_OVERRUN(__OVERRUN__)(((__OVERRUN__) == UART_ADVFEATURE_OVERRUN_ENABLE) || ((__OVERRUN__) == UART_ADVFEATURE_OVERRUN_DISABLE))IS_UART_ADVFEATURE_SWAP(__SWAP__)(((__SWAP__) == UART_ADVFEATURE_SWAP_DISABLE) || ((__SWAP__) == UART_ADVFEATURE_SWAP_ENABLE))IS_UART_ADVFEATURE_DATAINV(__DATAINV__)(((__DATAINV__) == UART_ADVFEATURE_DATAINV_DISABLE) || ((__DATAINV__) == UART_ADVFEATURE_DATAINV_ENABLE))IS_UART_ADVFEATURE_RXINV(__RXINV__)(((__RXINV__) == UART_ADVFEATURE_RXINV_DISABLE) || ((__RXINV__) == UART_ADVFEATURE_RXINV_ENABLE))IS_UART_ADVFEATURE_TXINV(__TXINV__)(((__TXINV__) == UART_ADVFEATURE_TXINV_DISABLE) || ((__TXINV__) == UART_ADVFEATURE_TXINV_ENABLE))IS_UART_ADVFEATURE_INIT(__INIT__)((__INIT__) <= (UART_ADVFEATURE_NO_INIT | UART_ADVFEATURE_TXINVERT_INIT | UART_ADVFEATURE_RXINVERT_INIT | UART_ADVFEATURE_DATAINVERT_INIT | UART_ADVFEATURE_SWAP_INIT | UART_ADVFEATURE_RXOVERRUNDISABLE_INIT | UART_ADVFEATURE_DMADISABLEONERROR_INIT | UART_ADVFEATURE_AUTOBAUDRATE_INIT | UART_ADVFEATURE_MSBFIRST_INIT))IS_UART_REQUEST_PARAMETER(__PARAM__)(((__PARAM__) == UART_AUTOBAUD_REQUEST) || ((__PARAM__) == UART_SENDBREAK_REQUEST) || ((__PARAM__) == UART_MUTE_MODE_REQUEST) || ((__PARAM__) == UART_RXDATA_FLUSH_REQUEST) || ((__PARAM__) == UART_TXDATA_FLUSH_REQUEST))IS_UART_WAKEUPMETHOD(__WAKEUP__)(((__WAKEUP__) == UART_WAKEUPMETHOD_IDLELINE) || ((__WAKEUP__) == UART_WAKEUPMETHOD_ADDRESSMARK))IS_UART_HALF_DUPLEX(__HDSEL__)(((__HDSEL__) == UART_HALF_DUPLEX_DISABLE) || ((__HDSEL__) == UART_HALF_DUPLEX_ENABLE))IS_UART_DMA_RX(__DMARX__)(((__DMARX__) == UART_DMA_RX_DISABLE) || ((__DMARX__) == UART_DMA_RX_ENABLE))IS_UART_DMA_TX(__DMATX__)(((__DMATX__) == UART_DMA_TX_DISABLE) || ((__DMATX__) == UART_DMA_TX_ENABLE))IS_UART_LIN_BREAK_DETECT_LENGTH(__LENGTH__)(((__LENGTH__) == UART_LINBREAKDETECTLENGTH_10B) || ((__LENGTH__) == UART_LINBREAKDETECTLENGTH_11B))IS_UART_LIN(__LIN__)(((__LIN__) == UART_LIN_DISABLE) || ((__LIN__) == UART_LIN_ENABLE))IS_UART_RECEIVER_TIMEOUT_VALUE(__TIMEOUTVALUE__)((__TIMEOUTVALUE__) <= 0xFFFFFFU)IS_UART_RECEIVER_TIMEOUT(__TIMEOUT__)(((__TIMEOUT__) == UART_RECEIVER_TIMEOUT_DISABLE) || ((__TIMEOUT__) == UART_RECEIVER_TIMEOUT_ENABLE))IS_UART_ADVFEATURE_AUTOBAUDRATEMODE(__MODE__)(((__MODE__) == UART_ADVFEATURE_AUTOBAUDRATE_ONSTARTBIT) || ((__MODE__) == UART_ADVFEATURE_AUTOBAUDRATE_ONFALLINGEDGE) || ((__MODE__) == UART_ADVFEATURE_AUTOBAUDRATE_ON0X7FFRAME) || ((__MODE__) == UART_ADVFEATURE_AUTOBAUDRATE_ON0X55FRAME))IS_UART_ONE_BIT_SAMPLE(__ONEBIT__)(((__ONEBIT__) == UART_ONE_BIT_SAMPLE_DISABLE) || ((__ONEBIT__) == UART_ONE_BIT_SAMPLE_ENABLE))IS_UART_OVERSAMPLING(__SAMPLING__)(((__SAMPLING__) == UART_OVERSAMPLING_16) || ((__SAMPLING__) == UART_OVERSAMPLING_8))IS_UART_STATE(__STATE__)(((__STATE__) == UART_STATE_DISABLE) || ((__STATE__) == UART_STATE_ENABLE))IS_UART_MODE(__MODE__)((((__MODE__) & (~((uint32_t)(UART_MODE_TX_RX)))) == 0x00U) && ((__MODE__) != 0x00U))IS_UART_HARDWARE_FLOW_CONTROL(__CONTROL__)(((__CONTROL__) == UART_HWCONTROL_NONE) || ((__CONTROL__) == UART_HWCONTROL_RTS) || ((__CONTROL__) == UART_HWCONTROL_CTS) || ((__CONTROL__) == UART_HWCONTROL_RTS_CTS))IS_UART_PARITY(__PARITY__)(((__PARITY__) == UART_PARITY_NONE) || ((__PARITY__) == UART_PARITY_EVEN) || ((__PARITY__) == UART_PARITY_ODD))IS_UART_STOPBITS(__STOPBITS__)(((__STOPBITS__) == UART_STOPBITS_0_5) || ((__STOPBITS__) == UART_STOPBITS_1) || ((__STOPBITS__) == UART_STOPBITS_1_5) || ((__STOPBITS__) == UART_STOPBITS_2))IS_UART_DEASSERTIONTIME(__TIME__)((__TIME__) <= 0x1FU)IS_UART_ASSERTIONTIME(__TIME__)IS_UART_BAUDRATE(__BAUDRATE__)((__BAUDRATE__) < 27000001U)UART_DIV_SAMPLING16(__PCLK__,__BAUD__)(((__PCLK__) + ((__BAUD__)/2U)) / (__BAUD__))UART_DIV_SAMPLING8(__PCLK__,__BAUD__)((((__PCLK__)*2U) + ((__BAUD__)/2U)) / (__BAUD__))__HAL_UART_HWCONTROL_RTS_DISABLE(__HANDLE__)do{ ATOMIC_CLEAR_BIT((__HANDLE__)->Instance->CR3, USART_CR3_RTSE); (__HANDLE__)->Init.HwFlowCtl &= ~(USART_CR3_RTSE); } while(0U)__HAL_UART_HWCONTROL_RTS_ENABLE(__HANDLE__)do{ ATOMIC_SET_BIT((__HANDLE__)->Instance->CR3, USART_CR3_RTSE); (__HANDLE__)->Init.HwFlowCtl |= USART_CR3_RTSE; } while(0U)__HAL_UART_HWCONTROL_CTS_DISABLE(__HANDLE__)do{ ATOMIC_CLEAR_BIT((__HANDLE__)->Instance->CR3, USART_CR3_CTSE); (__HANDLE__)->Init.HwFlowCtl &= ~(USART_CR3_CTSE); } while(0U)__HAL_UART_HWCONTROL_CTS_ENABLE(__HANDLE__)do{ ATOMIC_SET_BIT((__HANDLE__)->Instance->CR3, USART_CR3_CTSE); (__HANDLE__)->Init.HwFlowCtl |= USART_CR3_CTSE; } while(0U)__HAL_UART_DISABLE(__HANDLE__)((__HANDLE__)->Instance->CR1 &= ~USART_CR1_UE)__HAL_UART_ENABLE(__HANDLE__)((__HANDLE__)->Instance->CR1 |= USART_CR1_UE)__HAL_UART_ONE_BIT_SAMPLE_DISABLE(__HANDLE__)((__HANDLE__)->Instance->CR3 &= ~USART_CR3_ONEBIT)__HAL_UART_ONE_BIT_SAMPLE_ENABLE(__HANDLE__)((__HANDLE__)->Instance->CR3|= USART_CR3_ONEBIT)__HAL_UART_SEND_REQ(__HANDLE__,__REQ__)((__HANDLE__)->Instance->RQR |= (uint16_t)(__REQ__))__HAL_UART_CLEAR_IT(__HANDLE__,__IT_CLEAR__)((__HANDLE__)->Instance->ICR = (uint32_t)(__IT_CLEAR__))__HAL_UART_GET_IT_SOURCE(__HANDLE__,__INTERRUPT__)((((((((uint8_t)(__INTERRUPT__)) >> 5U) == 1U) ? (__HANDLE__)->Instance->CR1 : (((((uint8_t)(__INTERRUPT__)) >> 5U) == 2U) ? (__HANDLE__)->Instance->CR2 : (__HANDLE__)->Instance->CR3)) & (1U << (((uint16_t)(__INTERRUPT__)) & UART_IT_MASK))) != RESET) ? SET : RESET)__HAL_UART_GET_IT(__HANDLE__,__INTERRUPT__)((((__HANDLE__)->Instance->ISR & (1U << ((__INTERRUPT__)>> 8U))) != RESET) ? SET : RESET)__HAL_UART_DISABLE_IT(__HANDLE__,__INTERRUPT__)( ((((uint8_t)(__INTERRUPT__)) >> 5U) == 1U)? ((__HANDLE__)->Instance->CR1 &= ~ (1U << ((__INTERRUPT__) & UART_IT_MASK))): ((((uint8_t)(__INTERRUPT__)) >> 5U) == 2U)? ((__HANDLE__)->Instance->CR2 &= ~ (1U << ((__INTERRUPT__) & UART_IT_MASK))): ((__HANDLE__)->Instance->CR3 &= ~ (1U << ((__INTERRUPT__) & UART_IT_MASK))))__HAL_UART_ENABLE_IT(__HANDLE__,__INTERRUPT__)( ((((uint8_t)(__INTERRUPT__)) >> 5U) == 1U)? ((__HANDLE__)->Instance->CR1 |= (1U << ((__INTERRUPT__) & UART_IT_MASK))): ((((uint8_t)(__INTERRUPT__)) >> 5U) == 2U)? ((__HANDLE__)->Instance->CR2 |= (1U << ((__INTERRUPT__) & UART_IT_MASK))): ((__HANDLE__)->Instance->CR3 |= (1U << ((__INTERRUPT__) & UART_IT_MASK))))__HAL_UART_GET_FLAG(__HANDLE__,__FLAG__)(((__HANDLE__)->Instance->ISR & (__FLAG__)) == (__FLAG__))__HAL_UART_CLEAR_IDLEFLAG(__HANDLE__)__HAL_UART_CLEAR_FLAG((__HANDLE__), UART_CLEAR_IDLEF)__HAL_UART_CLEAR_OREFLAG(__HANDLE__)__HAL_UART_CLEAR_FLAG((__HANDLE__), UART_CLEAR_OREF)__HAL_UART_CLEAR_NEFLAG(__HANDLE__)__HAL_UART_CLEAR_FLAG((__HANDLE__), UART_CLEAR_NEF)__HAL_UART_CLEAR_FEFLAG(__HANDLE__)__HAL_UART_CLEAR_FLAG((__HANDLE__), UART_CLEAR_FEF)__HAL_UART_CLEAR_PEFLAG(__HANDLE__)__HAL_UART_CLEAR_FLAG((__HANDLE__), UART_CLEAR_PEF)__HAL_UART_CLEAR_FLAG(__HANDLE__,__FLAG__)__HAL_UART_FLUSH_DRREGISTER(__HANDLE__)do{ SET_BIT((__HANDLE__)->Instance->RQR, UART_RXDATA_FLUSH_REQUEST); SET_BIT((__HANDLE__)->Instance->RQR, UART_TXDATA_FLUSH_REQUEST); } while(0U)__HAL_UART_RESET_HANDLE_STATE(__HANDLE__)do{ (__HANDLE__)->gState = HAL_UART_STATE_RESET; (__HANDLE__)->RxState = HAL_UART_STATE_RESET; } while(0U)HAL_UART_RXEVENT_IDLEHAL_UART_RXEVENT_HTHAL_UART_RXEVENT_TCHAL_UART_RECEPTION_TOCHARMATCHHAL_UART_RECEPTION_TORTOHAL_UART_RECEPTION_TOIDLEHAL_UART_RECEPTION_STANDARDUART_CLEAR_RTOFUART_CLEAR_WUFUART_CLEAR_CMFUART_CLEAR_CTSFUART_CLEAR_LBDFUART_CLEAR_TCFUART_CLEAR_IDLEFUART_CLEAR_OREFUART_CLEAR_NEFUART_CLEAR_FEFUART_CLEAR_PEFUART_IT_FEUART_IT_NEUART_IT_OREUART_IT_ERRUART_IT_RTO0x0B3AUUART_IT_WUF0x1476UUART_IT_CM0x112EUUART_IT_CTS0x096AUUART_IT_LBD0x0846UUART_IT_IDLE0x0424UUART_IT_RXNE0x0525UUART_IT_TC0x0626UUART_IT_TXE0x0727UUART_IT_PE0x0028UUART_FLAG_PEUART_FLAG_FEUART_FLAG_NEUART_FLAG_OREUART_FLAG_IDLEUART_FLAG_RXNEUART_FLAG_TCUART_FLAG_TXEUART_FLAG_LBDFUART_FLAG_CTSIFUART_FLAG_CTSUART_FLAG_RTOFUART_FLAG_ABREUART_FLAG_ABRFUART_FLAG_BUSYUART_FLAG_CMFUART_FLAG_SBKFUART_FLAG_RWUUART_FLAG_WUFUART_FLAG_TEACKUART_FLAG_REACKHAL_UART_TIMEOUT_VALUE0x1FFFFFFUUART_IT_MASK0x001FUUART_CR1_DEDT_ADDRESS_LSB_POSUART_CR1_DEAT_ADDRESS_LSB_POSUART_DE_POLARITY_LOWUART_DE_POLARITY_HIGHUART_WAKEUP_ON_READDATA_NONEMPTYUART_WAKEUP_ON_STARTBITUART_WAKEUP_ON_ADDRESSUART_CR2_ADDRESS_LSB_POSUART_ADVFEATURE_MUTEMODE_ENABLEUART_ADVFEATURE_MUTEMODE_DISABLEUART_ADVFEATURE_STOPMODE_ENABLEUART_ADVFEATURE_STOPMODE_DISABLEUART_ADVFEATURE_MSBFIRST_ENABLEUART_ADVFEATURE_MSBFIRST_DISABLEUART_ADVFEATURE_DMA_DISABLEONRXERRORUART_ADVFEATURE_DMA_ENABLEONRXERRORUART_ADVFEATURE_AUTOBAUDRATE_ENABLEUART_ADVFEATURE_AUTOBAUDRATE_DISABLEUART_ADVFEATURE_OVERRUN_DISABLEUART_ADVFEATURE_OVERRUN_ENABLEUART_ADVFEATURE_SWAP_ENABLEUART_ADVFEATURE_SWAP_DISABLEUART_ADVFEATURE_DATAINV_ENABLEUART_ADVFEATURE_DATAINV_DISABLEUART_ADVFEATURE_RXINV_ENABLEUART_ADVFEATURE_RXINV_DISABLEUART_ADVFEATURE_TXINV_ENABLEUART_ADVFEATURE_TXINV_DISABLEUART_ADVFEATURE_MSBFIRST_INITUART_ADVFEATURE_AUTOBAUDRATE_INITUART_ADVFEATURE_DMADISABLEONERROR_INITUART_ADVFEATURE_RXOVERRUNDISABLE_INITUART_ADVFEATURE_SWAP_INITUART_ADVFEATURE_DATAINVERT_INITUART_ADVFEATURE_RXINVERT_INITUART_ADVFEATURE_TXINVERT_INITUART_ADVFEATURE_NO_INITUART_TXDATA_FLUSH_REQUESTUART_RXDATA_FLUSH_REQUESTUART_MUTE_MODE_REQUESTUART_SENDBREAK_REQUESTUART_AUTOBAUD_REQUESTUART_HALF_DUPLEX_ENABLEUART_HALF_DUPLEX_DISABLEUART_DMA_RX_ENABLEUART_DMA_RX_DISABLEUART_DMA_TX_ENABLEUART_DMA_TX_DISABLEUART_LINBREAKDETECTLENGTH_11BUART_LINBREAKDETECTLENGTH_10BUART_LIN_ENABLEUART_LIN_DISABLEUART_RECEIVER_TIMEOUT_ENABLEUART_RECEIVER_TIMEOUT_DISABLEUART_ADVFEATURE_AUTOBAUDRATE_ON0X55FRAMEUART_ADVFEATURE_AUTOBAUDRATE_ON0X7FFRAMEUART_ADVFEATURE_AUTOBAUDRATE_ONFALLINGEDGEUART_ADVFEATURE_AUTOBAUDRATE_ONSTARTBITUART_OVERSAMPLING_8UART_OVERSAMPLING_16UART_STATE_ENABLEUART_STATE_DISABLEUART_MODE_TX_RX(USART_CR1_TE |USART_CR1_RE)UART_MODE_TXUART_MODE_RXUART_HWCONTROL_RTS_CTS(USART_CR3_RTSE | USART_CR3_CTSE)UART_HWCONTROL_CTSUART_HWCONTROL_RTSUART_HWCONTROL_NONEUART_PARITY_ODD(USART_CR1_PCE | USART_CR1_PS)UART_PARITY_EVENUART_PARITY_NONEUART_STOPBITS_2UART_STOPBITS_1_5(USART_CR2_STOP_0 | USART_CR2_STOP_1)UART_STOPBITS_1UART_STOPBITS_0_5HAL_UART_ERROR_RTOHAL_UART_ERROR_DMAHAL_UART_ERROR_OREHAL_UART_ERROR_FEHAL_UART_ERROR_NEHAL_UART_ERROR_PEHAL_UART_ERROR_NONEHAL_UART_STATE_ERRORHAL_UART_STATE_TIMEOUTHAL_UART_STATE_BUSY_TX_RXHAL_UART_STATE_BUSY_RX0x00000022UHAL_UART_STATE_BUSY_TX0x00000021UHAL_UART_STATE_BUSYHAL_UART_STATE_READYHAL_UART_STATE_RESETSTM32F7xx_HAL_UART_H(USE_HAL_UART_REGISTER_CALLBACKS == 1)defined(USART_CR3_WUFIE)defined(USART_CR3_WUS)defined(USART_ISR_REACK)/* STM32F7xx_HAL_UART_H *//* Private variables -----------------------------------------------------------*//** @addtogroup UART_Private_Functions UART Private Functions
  * @{
  *//* Private functions -----------------------------------------------------------*//* Peripheral State and Errors functions  **************************************************//** @addtogroup UART_Exported_Functions_Group4 Peripheral State and Error functions
  * @{
  *//** @addtogroup UART_Exported_Functions_Group3 Peripheral Control functions
  * @{
  *//* Transfer Abort functions *//** @addtogroup UART_Exported_Functions_Group2 IO operation functions
  * @{
  *//** @addtogroup UART_Exported_Functions_Group1 Initialization and de-initialization functions
  * @{
  *//** @addtogroup UART_Exported_Functions UART Exported Functions
  * @{
  *//* Include UART HAL Extended module *//**
  * @brief Ensure that UART driver enable polarity is valid.
  * @param __POLARITY__ UART driver enable polarity.
  * @retval SET (__POLARITY__ is valid) or RESET (__POLARITY__ is invalid)
  *//* USART_CR3_WUFIE *//**
  * @brief Ensure that UART wake-up selection is valid.
  * @param __WAKE__ UART wake-up selection.
  * @retval SET (__WAKE__ is valid) or RESET (__WAKE__ is invalid)
  *//**
  * @brief Ensure that UART mute mode state is valid.
  * @param __MUTE__ UART mute mode state.
  * @retval SET (__MUTE__ is valid) or RESET (__MUTE__ is invalid)
  *//**
  * @brief Ensure that UART stop mode state is valid.
  * @param __STOPMODE__ UART stop mode state.
  * @retval SET (__STOPMODE__ is valid) or RESET (__STOPMODE__ is invalid)
  *//**
  * @brief Ensure that UART frame MSB first setting is valid.
  * @param __MSBFIRST__ UART frame MSB first setting.
  * @retval SET (__MSBFIRST__ is valid) or RESET (__MSBFIRST__ is invalid)
  *//**
  * @brief Ensure that UART DMA enabling or disabling on error setting is valid.
  * @param __DMA__ UART DMA enabling or disabling on error setting.
  * @retval SET (__DMA__ is valid) or RESET (__DMA__ is invalid)
  *//**
  * @brief Ensure that UART auto Baud rate state is valid.
  * @param __AUTOBAUDRATE__ UART auto Baud rate state.
  * @retval SET (__AUTOBAUDRATE__ is valid) or RESET (__AUTOBAUDRATE__ is invalid)
  *//**
  * @brief Ensure that UART frame overrun setting is valid.
  * @param __OVERRUN__ UART frame overrun setting.
  * @retval SET (__OVERRUN__ is valid) or RESET (__OVERRUN__ is invalid)
  *//**
  * @brief Ensure that UART frame RX/TX pins swap setting is valid.
  * @param __SWAP__ UART frame RX/TX pins swap setting.
  * @retval SET (__SWAP__ is valid) or RESET (__SWAP__ is invalid)
  *//**
  * @brief Ensure that UART frame data inversion setting is valid.
  * @param __DATAINV__ UART frame data inversion setting.
  * @retval SET (__DATAINV__ is valid) or RESET (__DATAINV__ is invalid)
  *//**
  * @brief Ensure that UART frame RX inversion setting is valid.
  * @param __RXINV__ UART frame RX inversion setting.
  * @retval SET (__RXINV__ is valid) or RESET (__RXINV__ is invalid)
  *//**
  * @brief Ensure that UART frame TX inversion setting is valid.
  * @param __TXINV__ UART frame TX inversion setting.
  * @retval SET (__TXINV__ is valid) or RESET (__TXINV__ is invalid)
  *//**
  * @brief Ensure that UART advanced features initialization is valid.
  * @param __INIT__ UART advanced features initialization.
  * @retval SET (__INIT__ is valid) or RESET (__INIT__ is invalid)
  *//**
  * @brief Ensure that UART request parameter is valid.
  * @param __PARAM__ UART request parameter.
  * @retval SET (__PARAM__ is valid) or RESET (__PARAM__ is invalid)
  *//**
  * @brief Ensure that UART wake-up method is valid.
  * @param __WAKEUP__ UART wake-up method .
  * @retval SET (__WAKEUP__ is valid) or RESET (__WAKEUP__ is invalid)
  *//**
  * @brief Ensure that UART half-duplex state is valid.
  * @param __HDSEL__ UART half-duplex state.
  * @retval SET (__HDSEL__ is valid) or RESET (__HDSEL__ is invalid)
  *//**
  * @brief Ensure that UART DMA RX state is valid.
  * @param __DMARX__ UART DMA RX state.
  * @retval SET (__DMARX__ is valid) or RESET (__DMARX__ is invalid)
  *//**
  * @brief Ensure that UART DMA TX state is valid.
  * @param __DMATX__ UART DMA TX state.
  * @retval SET (__DMATX__ is valid) or RESET (__DMATX__ is invalid)
  *//**
  * @brief Ensure that UART LIN break detection length is valid.
  * @param __LENGTH__ UART LIN break detection length.
  * @retval SET (__LENGTH__ is valid) or RESET (__LENGTH__ is invalid)
  *//**
  * @brief Ensure that UART LIN state is valid.
  * @param __LIN__ UART LIN state.
  * @retval SET (__LIN__ is valid) or RESET (__LIN__ is invalid)
  *//** @brief  Check the receiver timeout value.
  * @note   The maximum UART receiver timeout value is 0xFFFFFF.
  * @param  __TIMEOUTVALUE__ receiver timeout value.
  * @retval Test result (TRUE or FALSE)
  *//**
  * @brief Ensure that UART receiver timeout setting is valid.
  * @param __TIMEOUT__ UART receiver timeout setting.
  * @retval SET (__TIMEOUT__ is valid) or RESET (__TIMEOUT__ is invalid)
  *//**
  * @brief Ensure that UART auto Baud rate detection mode is valid.
  * @param __MODE__ UART auto Baud rate detection mode.
  * @retval SET (__MODE__ is valid) or RESET (__MODE__ is invalid)
  *//**
  * @brief Ensure that UART frame sampling is valid.
  * @param __ONEBIT__ UART frame sampling.
  * @retval SET (__ONEBIT__ is valid) or RESET (__ONEBIT__ is invalid)
  *//**
  * @brief Ensure that UART oversampling is valid.
  * @param __SAMPLING__ UART oversampling.
  * @retval SET (__SAMPLING__ is valid) or RESET (__SAMPLING__ is invalid)
  *//**
  * @brief Ensure that UART state is valid.
  * @param __STATE__ UART state.
  * @retval SET (__STATE__ is valid) or RESET (__STATE__ is invalid)
  *//**
  * @brief Ensure that UART communication mode is valid.
  * @param __MODE__ UART communication mode.
  * @retval SET (__MODE__ is valid) or RESET (__MODE__ is invalid)
  *//**
  * @brief Ensure that UART hardware flow control is valid.
  * @param __CONTROL__ UART hardware flow control.
  * @retval SET (__CONTROL__ is valid) or RESET (__CONTROL__ is invalid)
  *//**
  * @brief Ensure that UART frame parity is valid.
  * @param __PARITY__ UART frame parity.
  * @retval SET (__PARITY__ is valid) or RESET (__PARITY__ is invalid)
  *//**
  * @brief Ensure that UART frame number of stop bits is valid.
  * @param __STOPBITS__ UART frame number of stop bits.
  * @retval SET (__STOPBITS__ is valid) or RESET (__STOPBITS__ is invalid)
  *//** @brief  Check UART deassertion time.
  * @param  __TIME__ 5-bit value deassertion time.
  * @retval Test result (TRUE or FALSE).
  *//** @brief  Check UART assertion time.
  * @param  __TIME__ 5-bit value assertion time.
  * @retval Test result (TRUE or FALSE).
  *//** @brief  Check UART Baud rate.
  * @param  __BAUDRATE__ Baudrate specified by the user.
  *         The maximum Baud Rate is derived from the maximum clock on F7 (i.e. 216 MHz)
  *         divided by the smallest oversampling used on the USART (i.e. 8)
  * @retval SET (__BAUDRATE__ is valid) or RESET (__BAUDRATE__ is invalid)
  *//** @brief  BRR division operation to set BRR register in 16-bit oversampling mode.
  * @param  __PCLK__ UART clock.
  * @param  __BAUD__ Baud rate set by the user.
  * @retval Division result
  *//** @brief  BRR division operation to set BRR register in 8-bit oversampling mode.
  * @param  __PCLK__ UART clock.
  * @param  __BAUD__ Baud rate set by the user.
  * @retval Division result
  *//** @defgroup UART_Private_Macros   UART Private Macros
  * @{
  *//* Private macros --------------------------------------------------------*//** @brief  Disable RTS flow control.
  * @note   This macro allows to disable RTS hardware flow control for a given UART instance,
  *         without need to call HAL_UART_Init() function.
  *         As involving direct access to UART registers, usage of this macro should be fully endorsed by user.
  * @note   As macro is expected to be used for modifying RTS Hw flow control feature activation, without need
  *         for USART instance Deinit/Init, following conditions for macro call should be fulfilled :
  *           - UART instance should have already been initialised (through call of HAL_UART_Init() )
  *           - macro could only be called when corresponding UART instance is disabled
  *             (i.e. __HAL_UART_DISABLE(__HANDLE__)) and should be followed by an Enable
  *              macro (i.e. __HAL_UART_ENABLE(__HANDLE__)).
  * @param  __HANDLE__ specifies the UART Handle.
  * @retval None
  *//** @brief  Enable RTS flow control.
  * @note   This macro allows to enable RTS hardware flow control for a given UART instance,
  *         without need to call HAL_UART_Init() function.
  *         As involving direct access to UART registers, usage of this macro should be fully endorsed by user.
  * @note   As macro is expected to be used for modifying RTS Hw flow control feature activation, without need
  *         for USART instance Deinit/Init, following conditions for macro call should be fulfilled :
  *           - UART instance should have already been initialised (through call of HAL_UART_Init() )
  *           - macro could only be called when corresponding UART instance is disabled
  *             (i.e. __HAL_UART_DISABLE(__HANDLE__)) and should be followed by an Enable
  *              macro (i.e. __HAL_UART_ENABLE(__HANDLE__)).
  * @param  __HANDLE__ specifies the UART Handle.
  * @retval None
  *//** @brief  Disable CTS flow control.
  * @note   This macro allows to disable CTS hardware flow control for a given UART instance,
  *         without need to call HAL_UART_Init() function.
  *         As involving direct access to UART registers, usage of this macro should be fully endorsed by user.
  * @note   As macro is expected to be used for modifying CTS Hw flow control feature activation, without need
  *         for USART instance Deinit/Init, following conditions for macro call should be fulfilled :
  *           - UART instance should have already been initialised (through call of HAL_UART_Init() )
  *           - macro could only be called when corresponding UART instance is disabled
  *             (i.e. __HAL_UART_DISABLE(__HANDLE__)) and should be followed by an Enable
  *              macro (i.e. __HAL_UART_ENABLE(__HANDLE__)).
  * @param  __HANDLE__ specifies the UART Handle.
  * @retval None
  *//** @brief  Enable CTS flow control.
  * @note   This macro allows to enable CTS hardware flow control for a given UART instance,
  *         without need to call HAL_UART_Init() function.
  *         As involving direct access to UART registers, usage of this macro should be fully endorsed by user.
  * @note   As macro is expected to be used for modifying CTS Hw flow control feature activation, without need
  *         for USART instance Deinit/Init, following conditions for macro call should be fulfilled :
  *           - UART instance should have already been initialised (through call of HAL_UART_Init() )
  *           - macro could only be called when corresponding UART instance is disabled
  *             (i.e. __HAL_UART_DISABLE(__HANDLE__)) and should be followed by an Enable
  *              macro (i.e. __HAL_UART_ENABLE(__HANDLE__)).
  * @param  __HANDLE__ specifies the UART Handle.
  * @retval None
  *//** @brief  Disable UART.
  * @param  __HANDLE__ specifies the UART Handle.
  * @retval None
  *//** @brief  Enable UART.
  * @param  __HANDLE__ specifies the UART Handle.
  * @retval None
  *//** @brief  Disable the UART one bit sample method.
  * @param  __HANDLE__ specifies the UART Handle.
  * @retval None
  *//** @brief  Enable the UART one bit sample method.
  * @param  __HANDLE__ specifies the UART Handle.
  * @retval None
  *//** @brief  Set a specific UART request flag.
  * @param  __HANDLE__ specifies the UART Handle.
  * @param  __REQ__ specifies the request flag to set
  *          This parameter can be one of the following values:
  *            @arg @ref UART_AUTOBAUD_REQUEST Auto-Baud Rate Request
  *            @arg @ref UART_SENDBREAK_REQUEST Send Break Request
  *            @arg @ref UART_MUTE_MODE_REQUEST Mute Mode Request
  *            @arg @ref UART_RXDATA_FLUSH_REQUEST Receive Data flush Request
  *            @arg @ref UART_TXDATA_FLUSH_REQUEST Transmit data flush Request
  * @retval None
  *//** @brief  Clear the specified UART ISR flag, in setting the proper ICR register flag.
  * @param  __HANDLE__ specifies the UART Handle.
  * @param  __IT_CLEAR__ specifies the interrupt clear register flag that needs to be set
  *                       to clear the corresponding interrupt
  *          This parameter can be one of the following values:
  *            @arg @ref UART_CLEAR_PEF    Parity Error Clear Flag
  *            @arg @ref UART_CLEAR_FEF    Framing Error Clear Flag
  *            @arg @ref UART_CLEAR_NEF    Noise detected Clear Flag
  *            @arg @ref UART_CLEAR_OREF   Overrun Error Clear Flag
  *            @arg @ref UART_CLEAR_IDLEF  IDLE line detected Clear Flag
  *            @arg @ref UART_CLEAR_RTOF   Receiver timeout clear flag
  *            @arg @ref UART_CLEAR_TCF    Transmission Complete Clear Flag
  *            @arg @ref UART_CLEAR_LBDF   LIN Break Detection Clear Flag
  *            @arg @ref UART_CLEAR_CTSF   CTS Interrupt Clear Flag
  *            @arg @ref UART_CLEAR_CMF    Character Match Clear Flag
#if defined(USART_CR1_UESM)
#if defined(USART_CR3_WUFIE)
  *            @arg @ref UART_CLEAR_WUF    Wake Up from stop mode Clear Flag
#endif
#endif
  * @retval None
  *//** @brief  Check whether the specified UART interrupt source is enabled or not.
  * @param  __HANDLE__ specifies the UART Handle.
  * @param  __INTERRUPT__ specifies the UART interrupt source to check.
  *          This parameter can be one of the following values:
#if defined(USART_CR1_UESM)
#if defined(USART_CR3_WUFIE)
  *            @arg @ref UART_IT_WUF   Wakeup from stop mode interrupt
#endif
#endif
  *            @arg @ref UART_IT_CM    Character match interrupt
  *            @arg @ref UART_IT_CTS   CTS change interrupt
  *            @arg @ref UART_IT_LBD   LIN Break detection interrupt
  *            @arg @ref UART_IT_TXE   Transmit Data Register empty interrupt
  *            @arg @ref UART_IT_TC    Transmission complete interrupt
  *            @arg @ref UART_IT_RXNE  Receive Data register not empty interrupt
  *            @arg @ref UART_IT_RTO   Receive Timeout interrupt
  *            @arg @ref UART_IT_IDLE  Idle line detection interrupt
  *            @arg @ref UART_IT_PE    Parity Error interrupt
  *            @arg @ref UART_IT_ERR   Error interrupt (Frame error, noise error, overrun error)
  * @retval The new state of __INTERRUPT__ (SET or RESET).
  *//** @brief  Check whether the specified UART interrupt has occurred or not.
  * @param  __HANDLE__ specifies the UART Handle.
  * @param  __INTERRUPT__ specifies the UART interrupt to check.
  *          This parameter can be one of the following values:
#if defined(USART_CR1_UESM)
#if defined(USART_CR3_WUFIE)
  *            @arg @ref UART_IT_WUF   Wakeup from stop mode interrupt
#endif
#endif
  *            @arg @ref UART_IT_CM    Character match interrupt
  *            @arg @ref UART_IT_CTS   CTS change interrupt
  *            @arg @ref UART_IT_LBD   LIN Break detection interrupt
  *            @arg @ref UART_IT_TXE   Transmit Data Register empty interrupt
  *            @arg @ref UART_IT_TC    Transmission complete interrupt
  *            @arg @ref UART_IT_RXNE  Receive Data register not empty interrupt
  *            @arg @ref UART_IT_RTO   Receive Timeout interrupt
  *            @arg @ref UART_IT_IDLE  Idle line detection interrupt
  *            @arg @ref UART_IT_PE    Parity Error interrupt
  *            @arg @ref UART_IT_ERR   Error interrupt (Frame error, noise error, overrun error)
  * @retval The new state of __INTERRUPT__ (SET or RESET).
  *//** @brief  Disable the specified UART interrupt.
  * @param  __HANDLE__ specifies the UART Handle.
  * @param  __INTERRUPT__ specifies the UART interrupt source to disable.
  *          This parameter can be one of the following values:
#if defined(USART_CR1_UESM)
#if defined(USART_CR3_WUFIE)
  *            @arg @ref UART_IT_WUF   Wakeup from stop mode interrupt
#endif
#endif
  *            @arg @ref UART_IT_CM    Character match interrupt
  *            @arg @ref UART_IT_CTS   CTS change interrupt
  *            @arg @ref UART_IT_LBD   LIN Break detection interrupt
  *            @arg @ref UART_IT_TXE   Transmit Data Register empty interrupt
  *            @arg @ref UART_IT_TC    Transmission complete interrupt
  *            @arg @ref UART_IT_RXNE  Receive Data register not empty interrupt
  *            @arg @ref UART_IT_RTO   Receive Timeout interrupt
  *            @arg @ref UART_IT_IDLE  Idle line detection interrupt
  *            @arg @ref UART_IT_PE    Parity Error interrupt
  *            @arg @ref UART_IT_ERR   Error interrupt (Frame error, noise error, overrun error)
  * @retval None
  *//** @brief  Enable the specified UART interrupt.
  * @param  __HANDLE__ specifies the UART Handle.
  * @param  __INTERRUPT__ specifies the UART interrupt source to enable.
  *          This parameter can be one of the following values:
#if defined(USART_CR1_UESM)
#if defined(USART_CR3_WUFIE)
  *            @arg @ref UART_IT_WUF   Wakeup from stop mode interrupt
#endif
#endif
  *            @arg @ref UART_IT_CM    Character match interrupt
  *            @arg @ref UART_IT_CTS   CTS change interrupt
  *            @arg @ref UART_IT_LBD   LIN Break detection interrupt
  *            @arg @ref UART_IT_TXE   Transmit Data Register empty interrupt
  *            @arg @ref UART_IT_TC    Transmission complete interrupt
  *            @arg @ref UART_IT_RXNE  Receive Data register not empty interrupt
  *            @arg @ref UART_IT_RTO   Receive Timeout interrupt
  *            @arg @ref UART_IT_IDLE  Idle line detection interrupt
  *            @arg @ref UART_IT_PE    Parity Error interrupt
  *            @arg @ref UART_IT_ERR   Error interrupt (frame error, noise error, overrun error)
  * @retval None
  *//** @brief  Check whether the specified UART flag is set or not.
  * @param  __HANDLE__ specifies the UART Handle.
  * @param  __FLAG__ specifies the flag to check.
  *        This parameter can be one of the following values:
#if defined(USART_ISR_REACK)
  *            @arg @ref UART_FLAG_REACK Receive enable acknowledge flag
#endif
  *            @arg @ref UART_FLAG_TEACK Transmit enable acknowledge flag
#if defined(USART_CR1_UESM)
#if defined(USART_CR3_WUFIE)
  *            @arg @ref UART_FLAG_WUF   Wake up from stop mode flag
#endif
#endif
  *            @arg @ref UART_FLAG_RWU   Receiver wake up flag (if the UART in mute mode)
  *            @arg @ref UART_FLAG_SBKF  Send Break flag
  *            @arg @ref UART_FLAG_CMF   Character match flag
  *            @arg @ref UART_FLAG_BUSY  Busy flag
  *            @arg @ref UART_FLAG_ABRF  Auto Baud rate detection flag
  *            @arg @ref UART_FLAG_ABRE  Auto Baud rate detection error flag
  *            @arg @ref UART_FLAG_CTS   CTS Change flag
  *            @arg @ref UART_FLAG_LBDF  LIN Break detection flag
  *            @arg @ref UART_FLAG_TXE   Transmit data register empty flag
  *            @arg @ref UART_FLAG_TC    Transmission Complete flag
  *            @arg @ref UART_FLAG_RXNE  Receive data register not empty flag
  *            @arg @ref UART_FLAG_RTOF  Receiver Timeout flag
  *            @arg @ref UART_FLAG_IDLE  Idle Line detection flag
  *            @arg @ref UART_FLAG_ORE   Overrun Error flag
  *            @arg @ref UART_FLAG_NE    Noise Error flag
  *            @arg @ref UART_FLAG_FE    Framing Error flag
  *            @arg @ref UART_FLAG_PE    Parity Error flag
  * @retval The new state of __FLAG__ (TRUE or FALSE).
  *//** @brief  Clear the UART IDLE pending flag.
  * @param  __HANDLE__ specifies the UART Handle.
  * @retval None
  *//** @brief  Clear the UART ORE pending flag.
  * @param  __HANDLE__ specifies the UART Handle.
  * @retval None
  *//** @brief  Clear the UART NE pending flag.
  * @param  __HANDLE__ specifies the UART Handle.
  * @retval None
  *//** @brief  Clear the UART FE pending flag.
  * @param  __HANDLE__ specifies the UART Handle.
  * @retval None
  *//** @brief  Clear the UART PE pending flag.
  * @param  __HANDLE__ specifies the UART Handle.
  * @retval None
  *//** @brief  Clear the specified UART pending flag.
  * @param  __HANDLE__ specifies the UART Handle.
  * @param  __FLAG__ specifies the flag to check.
  *          This parameter can be any combination of the following values:
  *            @arg @ref UART_CLEAR_PEF      Parity Error Clear Flag
  *            @arg @ref UART_CLEAR_FEF      Framing Error Clear Flag
  *            @arg @ref UART_CLEAR_NEF      Noise detected Clear Flag
  *            @arg @ref UART_CLEAR_OREF     Overrun Error Clear Flag
  *            @arg @ref UART_CLEAR_IDLEF    IDLE line detected Clear Flag
  *            @arg @ref UART_CLEAR_TCF      Transmission Complete Clear Flag
  *            @arg @ref UART_CLEAR_RTOF     Receiver Timeout clear flag
  *            @arg @ref UART_CLEAR_LBDF     LIN Break Detection Clear Flag
  *            @arg @ref UART_CLEAR_CTSF     CTS Interrupt Clear Flag
  *            @arg @ref UART_CLEAR_CMF      Character Match Clear Flag
#if defined(USART_CR1_UESM)
#if defined(USART_CR3_WUFIE)
  *            @arg @ref UART_CLEAR_WUF      Wake Up from stop mode Clear Flag
#endif
#endif
  * @retval None
  *//** @brief  Flush the UART Data registers.
  * @param  __HANDLE__ specifies the UART Handle.
  * @retval None
  *//*USE_HAL_UART_REGISTER_CALLBACKS *//** @brief  Reset UART handle states.
  * @param  __HANDLE__ UART handle.
  * @retval None
  *//** @defgroup UART_Exported_Macros UART Exported Macros
  * @{
  *//*!< RxEvent linked to IDLE event              *//*!< RxEvent linked to Half Transfer event     *//*!< RxEvent linked to Transfer Complete event *//** @defgroup UART_RxEvent_Type_Values  UART RxEvent type values
  * @{
  *//*!< Reception till completion or CM event    *//*!< Reception till completion or RTO event   *//*!< Reception till completion or IDLE event  *//*!< Standard reception                       *//** @defgroup UART_Reception_Type_Values  UART Reception type values
  * @{
  *//*!< UART receiver timeout clear flag  *//*!< Character Match Clear Flag        *//*!< CTS Interrupt Clear Flag          *//*!< LIN Break Detection Clear Flag    *//*!< Transmission Complete Clear Flag  *//*!< IDLE line detected Clear Flag     *//*!< Overrun Error Clear Flag          *//*!< Noise Error detected Clear Flag   *//*!< Framing Error Clear Flag          *//*!< Parity Error Clear Flag           *//** @defgroup UART_IT_CLEAR_Flags  UART Interruption Clear Flags
  * @{
  *//*!< UART frame error interruption                  *//*!< UART noise error interruption                  *//*!< UART overrun error interruption                *//*!< UART error interruption                        *//*!< UART receiver timeout interruption             *//*!< UART wake-up from stop mode interruption       *//*!< UART character match interruption              *//*!< UART CTS interruption                          *//*!< UART LIN break detection interruption          *//*!< UART idle interruption                         *//*!< UART read data register not empty interruption *//*!< UART transmission complete interruption        *//*!< UART transmit data register empty interruption *//*!< UART parity error interruption                 *//** @defgroup UART_Interrupt_definition   UART Interrupts Definition
  *        Elements values convention: 000ZZZZZ0XXYYYYYb
  *           - YYYYY  : Interrupt source position in the XX register (5bits)
  *           - XX  : Interrupt source register (2bits)
  *                 - 01: CR1 register
  *                 - 10: CR2 register
  *                 - 11: CR3 register
  *           - ZZZZZ  : Flag position in the ISR register(5bits)
  *        Elements values convention: 000000000XXYYYYYb
  *           - YYYYY  : Interrupt source position in the XX register (5bits)
  *           - XX  : Interrupt source register (2bits)
  *                 - 01: CR1 register
  *                 - 10: CR2 register
  *                 - 11: CR3 register
  *        Elements values convention: 0000ZZZZ00000000b
  *           - ZZZZ  : Flag position in the ISR register(4bits)
  * @{
  *//*!< UART parity error                         *//*!< UART frame error                          *//*!< UART noise error                          *//*!< UART overrun error                        *//*!< UART idle flag                            *//*!< UART read data register not empty         *//*!< UART transmission complete                *//*!< UART transmit data register empty         *//*!< UART LIN break detection flag             *//*!< UART clear to send interrupt flag         *//*!< UART clear to send flag                   *//*!< UART receiver timeout flag                *//*!< UART auto Baud rate error                 *//*!< UART auto Baud rate flag                  *//*!< UART busy flag                            *//*!< UART character match flag                 *//*!< UART send break flag                      *//*!< UART receiver wake-up from mute mode flag *//*!< UART wake-up from stop mode flag          *//*!< UART transmit enable acknowledge flag     *//* USART_ISR_REACK *//*!< UART receive enable acknowledge flag      *//** @defgroup UART_Flags     UART Status Flags
  *        Elements values convention: 0xXXXX
  *           - 0xXXXX  : Flag mask in the ISR register
  * @{
  *//*!< UART polling-based communications time-out value *//** @defgroup UART_TimeOut_Value    UART polling-based communications time-out value
  * @{
  *//*!< UART interruptions flags mask *//** @defgroup UART_Interruption_Mask    UART Interruptions Flag Mask
  * @{
  *//*!< UART Driver Enable de-assertion time LSB
                                                          position in CR1 register *//** @defgroup UART_CR1_DEDT_ADDRESS_LSB_POS    UART Driver Enable DeAssertion Time LSB Position In CR1 Register
  * @{
  *//*!< UART Driver Enable assertion time LSB
                                                          position in CR1 register *//** @defgroup UART_CR1_DEAT_ADDRESS_LSB_POS    UART Driver Enable Assertion Time LSB Position In CR1 Register
  * @{
  *//*!< Driver enable signal is active low  *//*!< Driver enable signal is active high *//** @defgroup UART_DriverEnable_Polarity      UART DriverEnable Polarity
  * @{
  *//* USART_CR3_WUS *//*!< UART wake-up on receive data register
                                                                         not empty or RXFIFO is not empty            *//*!< UART wake-up on address                     *//*!< UART wake-up on start bit                   *//** @defgroup UART_WakeUp_from_Stop_Selection   UART WakeUp From Stop Selection
  * @{
  *//*!< UART address-matching LSB position in CR2 register *//** @defgroup UART_CR2_ADDRESS_LSB_POS    UART Address-matching LSB Position In CR2 Register
  * @{
  *//*!< UART mute mode enable  *//*!< UART mute mode disable *//** @defgroup UART_Mute_Mode   UART Advanced Feature Mute Mode Enable
  * @{
  *//*!< UART stop mode enable  *//*!< UART stop mode disable *//** @defgroup UART_Stop_Mode_Enable   UART Advanced Feature Stop Mode Enable
  * @{
  *//*!< Most significant bit sent/received
                                                                         first enable                       *//*!< Most significant bit sent/received
                                                                         first disable                      *//** @defgroup UART_MSB_First   UART Advanced Feature MSB First
  * @{
  *//*!< DMA disable on Reception Error *//*!< DMA enable on Reception Error  *//** @defgroup UART_DMA_Disable_on_Rx_Error   UART Advanced Feature DMA Disable On Rx Error
  * @{
  *//*!< RX Auto Baud rate detection disable *//*!< RX Auto Baud rate detection enable  *//** @defgroup UART_AutoBaudRate_Enable  UART Advanced Feature Auto BaudRate Enable
  * @{
  *//*!< RX overrun disable *//*!< RX overrun enable  *//** @defgroup UART_Overrun_Disable  UART Advanced Feature Overrun Disable
  * @{
  *//*!< TX/RX pins swap enable  *//*!< TX/RX pins swap disable *//** @defgroup UART_Rx_Tx_Swap UART Advanced Feature RX TX Pins Swap
  * @{
  *//*!< Binary data inversion enable  *//*!< Binary data inversion disable *//** @defgroup UART_Data_Inv  UART Advanced Feature Binary Data Inversion
  * @{
  *//*!< RX pin active level inversion enable  *//*!< RX pin active level inversion disable *//** @defgroup UART_Rx_Inv UART Advanced Feature RX Pin Active Level Inversion
  * @{
  *//*!< TX pin active level inversion enable  *//*!< TX pin active level inversion disable *//** @defgroup UART_Tx_Inv UART Advanced Feature TX Pin Active Level Inversion
  * @{
  *//*!< Most significant bit sent/received first *//*!< Auto Baud rate detection initialization  *//*!< DMA disable on Reception Error           *//*!< RX overrun disable                       *//*!< TX/RX pins swap                          *//*!< Binary data inversion                    *//*!< RX pin active level inversion            *//*!< TX pin active level inversion            *//*!< No advanced feature initialization       *//** @defgroup UART_Advanced_Features_Initialization_Type  UART Advanced Feature Initialization Type
  * @{
  *//** @defgroup UART_Request_Parameters UART Request Parameters
  * @{
  *//*!< UART wake-up on address mark *//*!< UART wake-up on idle line    *//** @defgroup UART_WakeUp_Methods   UART WakeUp Methods
  * @{
  *//*!< UART half-duplex enabled  *//*!< UART half-duplex disabled *//** @defgroup UART_Half_Duplex_Selection  UART Half Duplex Selection
  * @{
  *//*!< UART DMA RX enabled  *//*!< UART DMA RX disabled *//** @defgroup UART_DMA_Rx   UART DMA Rx
  * @{
  *//*!< UART DMA TX enabled  *//*!< UART DMA TX disabled *//** @defgroup UART_DMA_Tx    UART DMA Tx
  * @{
  *//*!< LIN 11-bit break detection length  *//*!< LIN 10-bit break detection length *//** @defgroup UART_LIN_Break_Detection  UART LIN Break Detection
  * @{
  *//*!< Local Interconnect Network enable  *//*!< Local Interconnect Network disable *//** @defgroup UART_LIN    UART Local Interconnection Network mode
  * @{
  *//*!< UART Receiver Timeout enable  *//*!< UART Receiver Timeout disable *//** @defgroup UART_Receiver_Timeout UART Receiver Timeout
  * @{
  *//*!< Auto Baud rate detection
                                                                              on 0x55 frame detection   *//*!< Auto Baud rate detection
                                                                              on 0x7F frame detection   *//*!< Auto Baud rate detection
                                                                              on falling edge           *//*!< Auto Baud rate detection
                                                                              on start bit              *//** @defgroup UART_AutoBaud_Rate_Mode    UART Advanced Feature AutoBaud Rate Mode
  * @{
  *//*!< One-bit sampling enable  *//*!< One-bit sampling disable *//** @defgroup UART_OneBit_Sampling UART One Bit Sampling Method
  * @{
  *//*!< Oversampling by 8  *//*!< Oversampling by 16 *//** @defgroup UART_Over_Sampling UART Over Sampling
  * @{
  *//*!< UART enabled   *//*!< UART disabled  *//** @defgroup UART_State  UART State
  * @{
  *//*!< RX and TX mode *//*!< TX mode        *//*!< RX mode        *//** @defgroup UART_Mode UART Transfer Mode
  * @{
  *//*!< Request and Clear To Send *//*!< Clear To Send             *//*!< Request To Send           *//*!< No hardware control       *//** @defgroup UART_Hardware_Flow_Control UART Hardware Flow Control
  * @{
  *//*!< Odd parity  *//*!< Even parity *//*!< No parity   *//** @defgroup UART_Parity  UART Parity
  * @{
  *//*!< UART frame with 2 stop bits   *//*!< UART frame with 1.5 stop bits *//*!< UART frame with 1 stop bit    *//*!< UART frame with 0.5 stop bit  *//** @defgroup UART_Stop_Bits   UART Number of Stop Bits
  * @{
  *//*!< Receiver Timeout error  *//*!< DMA transfer error      *//*!< Overrun error           *//*!< Frame error             *//*!< Noise error             *//*!< Parity error            *//*!< No error                *//** @defgroup UART_Error_Definition   UART Error Definition
  * @{
  *//*!< Error
                                                          Value is allowed for gState only *//*!< Timeout state
                                                          Value is allowed for gState only *//*!< Data Transmission and Reception process is ongoing
                                                          Not to be used for neither gState nor RxState.Value is result
                                                          of combination (Or) between gState and RxState values *//*!< Data Reception process is ongoing
                                                          Value is allowed for RxState only *//*!< Data Transmission process is ongoing
                                                          Value is allowed for gState only *//*!< an internal process is ongoing
                                                          Value is allowed for gState only *//*!< Peripheral Initialized and ready for use
                                                          Value is allowed for gState and RxState *//*!< Peripheral is not initialized
                                                          Value is allowed for gState and RxState *//** @defgroup UART_State_Definition UART State Code Definition
  * @{
  *//** @defgroup UART_Exported_Constants UART Exported Constants
  * @{
  *//*!< pointer to a UART Rx Event specific callback function *//*!< pointer to an UART callback function *//**
  * @brief  HAL UART Callback pointer definition
  *//*!< UART MspDeInit callback ID               *//*!< UART MspInit callback ID                 *//*!< UART Wakeup Callback ID                  *//*!< UART Abort Receive Complete Callback ID  *//*!< UART Abort Transmit Complete Callback ID *//*!< UART Abort Complete Callback ID          *//*!< UART Error Callback ID                   *//*!< UART Rx Complete Callback ID             *//*!< UART Rx Half Complete Callback ID        *//*!< UART Tx Complete Callback ID             *//*!< UART Tx Half Complete Callback ID        *//**
  * @brief  HAL UART Callback ID enumeration definition
  *//*!< UART Msp DeInit callback              *//*!< UART Msp Init callback                *//*!< UART Reception Event Callback     *//*!< UART Wakeup Callback                  *//*!< UART Abort Receive Complete Callback  *//*!< UART Abort Transmit Complete Callback *//*!< UART Abort Complete Callback          *//*!< UART Error Callback                   *//*!< UART Rx Complete Callback             *//*!< UART Rx Half Complete Callback        *//*!< UART Tx Complete Callback             *//*!< UART Tx Half Complete Callback        *//*!< UART Error code                    *//*!< UART state information related to Rx operations. This
                                                          parameter can be a value of @ref HAL_UART_StateTypeDef *//*!< UART state information related to global Handle management
                                                          and also related to Tx operations. This parameter
                                                          can be a value of @ref HAL_UART_StateTypeDef *//*!< Locking object                     *//*!< UART Rx DMA Handle parameters      *//*!< UART Tx DMA Handle parameters      *//*!< Function pointer on Tx IRQ handler *//*!< Function pointer on Rx IRQ handler *//*!< Type of Rx Event                   *//*!< Type of ongoing reception          *//*!< UART Rx RDR register mask          *//*!< UART Rx Transfer Counter           *//*!< UART Rx Transfer size              *//*!< Pointer to UART Rx transfer Buffer *//*!< UART Tx Transfer Counter           *//*!< UART Tx Transfer size              *//*!< Pointer to UART Tx transfer Buffer *//*!< UART Advanced Features initialization parameters *//*!< UART communication parameters      *//*!< UART registers base address        *//**
  * @brief  UART handle Structure definition
  *//**
  * @brief HAL UART Rx Event type definition
  * @note  HAL UART Rx Event type value aims to identify which type of Event has occurred
  *        leading to call of the RxEvent callback.
  *        This parameter can be a value of @ref UART_RxEvent_Type_Values :
  *           HAL_UART_RXEVENT_TC                 = 0x00U,
  *           HAL_UART_RXEVENT_HT                 = 0x01U,
  *           HAL_UART_RXEVENT_IDLE               = 0x02U,
  *//**
  * @brief HAL UART Reception type definition
  * @note  HAL UART Reception type value aims to identify which type of Reception is ongoing.
  *        This parameter can be a value of @ref UART_Reception_Type_Values :
  *           HAL_UART_RECEPTION_STANDARD         = 0x00U,
  *           HAL_UART_RECEPTION_TOIDLE           = 0x01U,
  *           HAL_UART_RECEPTION_TORTO            = 0x02U,
  *           HAL_UART_RECEPTION_TOCHARMATCH      = 0x03U,
  *//*!< Undefined clock source *//*!< LSE clock source       *//*!< SYSCLK clock source *//*!< HSI clock source    *//*!< PCLK2 clock source  *//*!< PCLK1 clock source  *//**
  * @brief UART clock sources definition
  *//**
  * @brief HAL UART State definition
  * @note  HAL UART State value is a combination of 2 different substates:
  *        gState and RxState (see @ref UART_State_Definition).
  *        - gState contains UART state information related to global Handle management
  *          and also information related to Tx operations.
  *          gState value coding follow below described bitmap :
  *          b7-b6  Error information
  *             00 : No Error
  *             01 : (Not Used)
  *             10 : Timeout
  *             11 : Error
  *          b5     Peripheral initialization status
  *             0  : Reset (Peripheral not initialized)
  *             1  : Init done (Peripheral initialized. HAL UART Init function already called)
  *          b4-b3  (not used)
  *             xx : Should be set to 00
  *          b2     Intrinsic process state
  *             0  : Ready
  *             1  : Busy (Peripheral busy with some configuration or internal operations)
  *          b1     (not used)
  *             x  : Should be set to 0
  *          b0     Tx state
  *             0  : Ready (no Tx operation ongoing)
  *             1  : Busy (Tx operation ongoing)
  *        - RxState contains information related to Rx operations.
  *          RxState value coding follow below described bitmap :
  *          b7-b6  (not used)
  *             xx : Should be set to 00
  *          b5     Peripheral initialization status
  *             0  : Reset (Peripheral not initialized)
  *             1  : Init done (Peripheral initialized)
  *          b4-b2  (not used)
  *            xxx : Should be set to 000
  *          b1     Rx state
  *             0  : Ready (no Rx operation ongoing)
  *             1  : Busy (Rx operation ongoing)
  *          b0     (not used)
  *             x  : Should be set to 0.
  *//*!< Specifies whether MSB is sent first on UART line.
                                       This parameter can be a value of @ref UART_MSB_First. *//*!< If auto Baud rate detection is enabled, specifies how the rate
                                       detection is carried out.
                                       This parameter can be a value of @ref UART_AutoBaud_Rate_Mode. *//*!< Specifies whether auto Baud rate detection is enabled.
                                       This parameter can be a value of @ref UART_AutoBaudRate_Enable. *//*!< Specifies whether the DMA is disabled in case of reception error.
                                       This parameter can be a value of @ref UART_DMA_Disable_on_Rx_Error. *//*!< Specifies whether the reception overrun detection is disabled.
                                       This parameter can be a value of @ref UART_Overrun_Disable. *//*!< Specifies whether TX and RX pins are swapped.
                                       This parameter can be a value of @ref UART_Rx_Tx_Swap. *//*!< Specifies whether data are inverted (positive/direct logic
                                       vs negative/inverted logic).
                                       This parameter can be a value of @ref UART_Data_Inv. *//*!< Specifies whether the RX pin active level is inverted.
                                       This parameter can be a value of @ref UART_Rx_Inv. *//*!< Specifies whether the TX pin active level is inverted.
                                       This parameter can be a value of @ref UART_Tx_Inv. *//*!< Specifies which advanced UART features is initialized. Several
                                       Advanced Features may be initialized at the same time .
                                       This parameter can be a value of
                                       @ref UART_Advanced_Features_Initialization_Type. *//**
  * @brief  UART Advanced Features initialization structure definition
  *//*!< Specifies whether a single sample or three samples' majority vote is selected.
                                         Selecting the single sample method increases the receiver tolerance to clock
                                         deviations. This parameter can be a value of @ref UART_OneBit_Sampling. *//*!< Specifies whether the Over sampling 8 is enabled or disabled,
                                         to achieve higher speed (up to f_PCLK/8).
                                         This parameter can be a value of @ref UART_Over_Sampling. *//*!< Specifies whether the hardware flow control mode is enabled
                                         or disabled.
                                         This parameter can be a value of @ref UART_Hardware_Flow_Control. *//*!< Specifies whether the Receive or Transmit mode is enabled or disabled.
                                         This parameter can be a value of @ref UART_Mode. *//*!< Specifies the parity mode.
                                         This parameter can be a value of @ref UART_Parity
                                         @note When parity is enabled, the computed parity is inserted
                                               at the MSB position of the transmitted data (9th bit when
                                               the word length is set to 9 data bits; 8th bit when the
                                               word length is set to 8 data bits). *//*!< Specifies the number of stop bits transmitted.
                                         This parameter can be a value of @ref UART_Stop_Bits. *//*!< Specifies the number of data bits transmitted or received in a frame.
                                         This parameter can be a value of @ref UARTEx_Word_Length. *//*!< This member configures the UART communication baud rate.
                                         The baud rate register is computed using the following formula:
                                         - If oversampling is 16 or in LIN mode,
                                            Baud Rate Register = ((uart_ker_ck) / ((huart->Init.BaudRate)))
                                         - If oversampling is 8,
                                            Baud Rate Register[15:4] = ((2 * uart_ker_ck) /
                                                                        ((huart->Init.BaudRate)))[15:4]
                                            Baud Rate Register[3] =  0
                                            Baud Rate Register[2:0] =  (((2 * uart_ker_ck) /
                                                                        ((huart->Init.BaudRate)))[3:0]) >> 1
                                         where uart_ker_ck is the UART input clock *//**
  * @brief UART Init Structure definition
  *//** @defgroup UART_Exported_Types UART Exported Types
  * @{
  *//** @addtogroup UART
  * @{
  *//**
  ******************************************************************************
  * @file    stm32f7xx_hal_uart.h
  * @author  MCD Application Team
  * @brief   Header file of UART HAL module.
  ******************************************************************************
  * @attention
  *
  * Copyright (c) 2017 STMicroelectronics.
  * All rights reserved.
  *
  * This software is licensed under terms that can be found in the LICENSE file
  * in the root directory of this software component.
  * If no LICENSE file comes with this software, it is provided AS-IS.
  *
  ******************************************************************************
  */FlagStatusTickstartTimeoutValueWakeUpMethodBreakDetectLengthHAL_MDIOS_GetStateMDIOS_HandleTypeDef *HAL_MDIOS_GetErrorHAL_MDIOS_WakeUpCallbackHAL_MDIOS_ErrorCallbackHAL_MDIOS_ReadCpltCallbackHAL_MDIOS_WriteCpltCallbackHAL_MDIOS_IRQHandlerHAL_MDIOS_EnableEventsHAL_MDIOS_ClearReadRegAddressHAL_MDIOS_ClearWriteRegAddressHAL_MDIOS_GetReadRegAddressHAL_MDIOS_GetWrittenRegAddressHAL_MDIOS_ReadRegHAL_MDIOS_WriteRegHAL_MDIOS_MspDeInitHAL_MDIOS_MspInitHAL_MDIOS_DeInitHAL_MDIOS_InitMDIOS_HandleTypeDefMDIOS_InitTypeDefHAL_MDIOS_StateTypeDefHAL_MDIOS_STATE_RESETHAL_MDIOS_STATE_READYHAL_MDIOS_STATE_BUSYHAL_MDIOS_STATE_ERRORvolatile HAL_MDIOS_StateTypeDefMDIOS_TypeDef *PreambleCheckPortAddressIS_MDIOS_PREAMBLECHECK(__PREAMBLECHECK__)(((__PREAMBLECHECK__) == MDIOS_PREAMBLE_CHECK_ENABLE) || ((__PREAMBLECHECK__) == MDIOS_PREAMBLE_CHECK_DISABLE))IS_MDIOS_REGISTER(__REGISTER__)((__REGISTER__) < 32)IS_MDIOS_PORTADDRESS(__ADDR__)((__ADDR__) < 32)__HAL_MDIOS_WAKEUP_EXTI_GENERATE_SWIT()(EXTI->SWIER |= (MDIOS_WAKEUP_EXTI_LINE))__HAL_MDIOS_WAKEUP_EXTI_DISABLE_FALLINGRISING_TRIGGER()EXTI->RTSR &= ~(MDIOS_WAKEUP_EXTI_LINE); EXTI->FTSR &= ~(MDIOS_WAKEUP_EXTI_LINE)__HAL_MDIOS_WAKEUP_EXTI_ENABLE_FALLINGRISING_TRIGGER()EXTI->RTSR |= MDIOS_WAKEUP_EXTI_LINE; EXTI->FTSR |= MDIOS_WAKEUP_EXTI_LINE__HAL_MDIOS_WAKEUP_EXTI_DISABLE_FALLING_EDGE_TRIGGER()EXTI->FTSR &= ~(MDIOS_WAKEUP_EXTI_LINE)__HAL_MDIOS_WAKEUP_EXTI_ENABLE_FALLING_EDGE_TRIGGER()EXTI->FTSR |= (MDIOS_WAKEUP_EXTI_LINE)__HAL_MDIOS_WAKEUP_EXTI_DISABLE_RISING_EDGE_TRIGGER()EXTI->RTSR &= ~(MDIOS_WAKEUP_EXTI_LINE)__HAL_MDIOS_WAKEUP_EXTI_ENABLE_RISING_EDGE_TRIGGER()EXTI->RTSR |= MDIOS_WAKEUP_EXTI_LINE__HAL_MDIOS_WAKEUP_EXTI_CLEAR_FLAG()(EXTI->PR = (MDIOS_WAKEUP_EXTI_LINE))__HAL_MDIOS_WAKEUP_EXTI_GET_FLAG()(EXTI->PR & (MDIOS_WAKEUP_EXTI_LINE))__HAL_MDIOS_WAKEUP_EXTI_DISABLE_EVENT()(EXTI->EMR &= ~(MDIOS_WAKEUP_EXTI_LINE))__HAL_MDIOS_WAKEUP_EXTI_ENABLE_EVENT()(EXTI->EMR |= (MDIOS_WAKEUP_EXTI_LINE))__HAL_MDIOS_WAKEUP_EXTI_DISABLE_IT()(EXTI->IMR &= ~(MDIOS_WAKEUP_EXTI_LINE))__HAL_MDIOS_WAKEUP_EXTI_ENABLE_IT()(EXTI->IMR |= (MDIOS_WAKEUP_EXTI_LINE))__HAL_MDIOS_GET_IT_SOURCE(__HANDLE__,__INTERRUPT__)__HAL_MDIOS_CLEAR_ERROR_FLAG(__HANDLE__,__FLAG__)((__HANDLE__)->Instance->CLRFR) |= (__FLAG__)__HAL_MDIOS_GET_ERROR_FLAG(__HANDLE__,__FLAG__)((__HANDLE__)->Instance->SR & (__FLAG__))__HAL_MDIOS_GET_READ_FLAG(__HANDLE__,__FLAG__)((__HANDLE__)->Instance->RDFR & (__FLAG__))__HAL_MDIOS_GET_WRITE_FLAG(__HANDLE__,__FLAG__)((__HANDLE__)->Instance->WRFR & (__FLAG__))__HAL_MDIOS_DISABLE_IT(__HANDLE__,__INTERRUPT__)__HAL_MDIOS_ENABLE_IT(__HANDLE__,__INTERRUPT__)__HAL_MDIOS_DISABLE(__HANDLE__)((__HANDLE__)->Instance->CR &= ~MDIOS_CR_EN)__HAL_MDIOS_ENABLE(__HANDLE__)((__HANDLE__)->Instance->CR |= MDIOS_CR_EN)__HAL_MDIOS_RESET_HANDLE_STATE(__HANDLE__)((__HANDLE__)->State = HAL_MDIOS_STATE_RESET)MDIOS_WAKEUP_EXTI_LINE((uint32_t)0x01000000)MDIOS_PREAMBLE_ERROR_FLAGMDIOS_START_ERROR_FLAGMDIOS_TURNAROUND_ERROR_FLAGMDIOS_IT_ERRORMDIOS_IT_READMDIOS_IT_WRITEMDIOS_ALLREG_FLAG((uint32_t)0xFFFFFFFFU)MDIOS_REG31_FLAGMDIOS_REG30_FLAGMDIOS_REG29_FLAGMDIOS_REG28_FLAGMDIOS_REG27_FLAGMDIOS_REG26_FLAGMDIOS_REG25_FLAGMDIOS_REG24_FLAGMDIOS_REG23_FLAGMDIOS_REG22_FLAGMDIOS_REG21_FLAGMDIOS_REG20_FLAGMDIOS_REG19_FLAGMDIOS_REG18_FLAGMDIOS_REG17_FLAGMDIOS_REG16_FLAGMDIOS_REG15_FLAGMDIOS_REG14_FLAGMDIOS_REG13_FLAGMDIOS_REG12_FLAGMDIOS_REG11_FLAGMDIOS_REG10_FLAGMDIOS_REG9_FLAGMDIOS_REG8_FLAGMDIOS_REG7_FLAGMDIOS_REG6_FLAGMDIOS_REG5_FLAGMDIOS_REG4_FLAGMDIOS_REG3_FLAGMDIOS_REG2_FLAGMDIOS_REG1_FLAGMDIOS_REG0_FLAGMDIOS_REG31((uint32_t)0x0000001FU)MDIOS_REG30((uint32_t)0x0000001EU)MDIOS_REG29((uint32_t)0x0000001DU)MDIOS_REG28((uint32_t)0x0000001CU)MDIOS_REG27((uint32_t)0x0000001BU)MDIOS_REG26((uint32_t)0x0000001AU)MDIOS_REG25((uint32_t)0x00000019U)MDIOS_REG24((uint32_t)0x00000018U)MDIOS_REG23((uint32_t)0x00000017U)MDIOS_REG22((uint32_t)0x00000016U)MDIOS_REG21((uint32_t)0x00000015U)MDIOS_REG20((uint32_t)0x00000014U)MDIOS_REG19((uint32_t)0x00000013U)MDIOS_REG18((uint32_t)0x00000012U)MDIOS_REG17((uint32_t)0x00000011U)MDIOS_REG16MDIOS_REG15((uint32_t)0x0000000FU)MDIOS_REG14((uint32_t)0x0000000EU)MDIOS_REG13((uint32_t)0x0000000DU)MDIOS_REG12((uint32_t)0x0000000CU)MDIOS_REG11((uint32_t)0x0000000BU)MDIOS_REG10((uint32_t)0x0000000AU)MDIOS_REG9((uint32_t)0x00000009U)MDIOS_REG8MDIOS_REG7MDIOS_REG6MDIOS_REG5MDIOS_REG4MDIOS_REG3MDIOS_REG2MDIOS_REG1MDIOS_REG0MDIOS_PREAMBLE_CHECK_DISABLEMDIOS_PREAMBLE_CHECK_ENABLE__STM32F7xx_HAL_MDIOS_Hdefined (MDIOS)( USE_HAL_MDIOS_REGISTER_CALLBACKS == 1 )(USE_HAL_MDIOS_REGISTER_CALLBACKS == 1)( USE_HAL_MDIOS_REGISTER_CALLBACKS == 1)/* __STM32F7xx_HAL_MDIOS_H *//* MDIOS *//** @defgroup MDIOS_Private_Functions MDIOS Private Functions
  * @{
  *//** @defgroup MDIOS_Private_Macros MDIOS Private Macros
  * @{
  *//** @defgroup MDIOS_Private_Constants MDIOS Private Constants
  * @{
  *//** @defgroup MDIOS_Private_Variables MDIOS Private Variables
  * @{
  *//** @defgroup MDIOS_Private_Types MDIOS Private Types
  * @{
  *//** @addtogroup MDIOS_Exported_Functions_Group3
  * @{
  *//** @addtogroup MDIOS_Exported_Functions_Group2
  * @{
  *//* USE_HAL_MDIOS_REGISTER_CALLBACKS *//** @addtogroup MDIOS_Exported_Functions_Group1
  * @{
  *//** @defgroup MDIOS_Exported_Functions MDIOS Exported Functions
  * @{
  *//**
  * @brief  Generates a Software interrupt on selected EXTI line.
  * @retval None
  *//**
  * @brief  Disables rising/falling edge trigger to the MDIOS External interrupt line.
  * @retval None
  *//**
  * @brief  Enables rising/falling edge trigger to the MDIOS External interrupt line.
  * @retval None
  *//**
  * @brief  Disables falling edge trigger to the MDIOS External interrupt line.
  * @retval None
  *//**
  * @brief  Enables falling edge trigger to the MDIOS External interrupt line.
  * @retval None
  *//**
  * @brief  Disables the rising edge trigger to the MDIOS External interrupt line.
  * @retval None
  *//**
  * @brief  Enables rising edge trigger to the MDIOS External interrupt line.
  * @retval None
  *//**
  * @brief Clear the MDIOS WAKEUP Exti flag. 
  * @retval None.
  *//**
  * @brief checks whether the specified MDIOS WAKEUP Exti interrupt flag is set or not. 
  * @retval EXTI MDIOS WAKEUP Line Status.
  *//**
  * @brief Disable event on MDIOS WAKEUP Exti Line.    
  * @retval None.
  *//**
  * @brief Enable event on MDIOS WAKEUP Exti Line.    
  * @retval None.
  *//**
  * @brief Disable the MDIOS WAKEUP Exti Line.    
  * @retval None.
  *//**
  * @brief Enable the MDIOS WAKEUP Exti Line.    
  * @retval None.
  *//**
  * @brief  Checks whether the specified MDIOS interrupt is set or not.
  * @param  __HANDLE__ specifies the MDIOS handle.
  * @param  __INTERRUPT__  specifies the MDIOS interrupt sources
  *            This parameter can be one or a combination of the following values:
  *            @arg MDIOS_IT_WRITE: Register write interrupt
  *            @arg MDIOS_IT_READ: Register read interrupt
  *            @arg MDIOS_IT_ERROR: Error interrupt 
  * @retval The state of the interrupt source
  *//** @brief  MDIOS slave clear interrupt
  * @param  __HANDLE__ specifies the MDIOS handle.
  * @param  __FLAG__  specifies the Error flag.
  *         This parameter can be one or a combination of the following values:
  *            @arg MDIOS_TURNARROUND_ERROR_FLAG: Register write interrupt
  *            @arg MDIOS_START_ERROR_FLAG: Register read interrupt
  *            @arg MDIOS_PREAMBLE_ERROR_FLAG: Error interrupt 
  * @retval none
  *//** @brief MDIOS slave get interrupt
  * @param  __HANDLE__ specifies the MDIOS handle.
  * @param  __FLAG__  specifies the Error flag.
  *         This parameter can be one or a combination of the following values:
  *            @arg MDIOS_TURNARROUND_ERROR_FLAG: Register write interrupt
  *            @arg MDIOS_START_ERROR_FLAG: Register read interrupt
  *            @arg MDIOS_PREAMBLE_ERROR_FLAG: Error interrupt 
  * @retval The state of the error flag
  *//** @brief MDIOS slave get read register flag
  * @param  __HANDLE__ specifies the MDIOS handle.
  * @param  __FLAG__ specifies the read register flag
  * @retval The state of read flag
  *//** @brief Set MDIOS slave get write register flag
  * @param  __HANDLE__ specifies the MDIOS handle.
  * @param  __FLAG__ specifies the write register flag
  * @retval The state of write flag
  *//**
  * @brief  Disable the MDIOS device interrupt.
  * @param  __HANDLE__ specifies the MDIOS handle.
  * @param  __INTERRUPT__  specifies the MDIOS interrupt sources to be disabled.
  *         This parameter can be one or a combination of the following values:
  *            @arg MDIOS_IT_WRITE: Register write interrupt
  *            @arg MDIOS_IT_READ: Register read interrupt
  *            @arg MDIOS_IT_ERROR: Error interrupt 
  * @retval None
  *//**
  * @brief  Enable the MDIOS device interrupt.
  * @param  __HANDLE__ specifies the MDIOS handle.
  * @param  __INTERRUPT__  specifies the MDIOS interrupt sources to be enabled.
  *         This parameter can be one or a combination of the following values:
  *            @arg MDIOS_IT_WRITE: Register write interrupt
  *            @arg MDIOS_IT_READ: Register read interrupt
  *            @arg MDIOS_IT_ERROR: Error interrupt 
  * @retval None
  *//**
  * @brief  Enable/Disable the MDIOS peripheral.
  * @param  __HANDLE__ specifies the MDIOS handle.
  * @retval None
  *//** @brief Reset MDIOS handle state
  * @param  __HANDLE__ MDIOS handle.
  * @retval None
  *//** @defgroup MDIOS_Exported_Macros MDIOS Exported Macros
  * @{
  *//* !<  EXTI Line 24 *//** @defgroup MDIOS_Wakeup_Line  MDIOS Wakeup Line
  * @{
  *//** @defgroup MDIOS_Interrupt_Flags  MDIOS Interrupt Flags
  * @{
  *//** @defgroup MDIOS_Interrupt_sources Interrupt Sources
  * @{
  *//** @defgroup MDIOS_Registers_Flags  MDIOS Registers Flags
  * @{
  *//** @defgroup MDIOS_Input_Output_Registers_Definitions MDIOS Input Output Registers Definitions
  * @{
  *//** @defgroup MDIOS_Preamble_Check  MDIOS Preamble Check
  * @{
  *//** @defgroup MDIOS_Exported_Constants MDIOS Exported Constants
  * @{
  *//*!< pointer to an MDIOS callback function *//**
  * @brief  HAL MDIOS Callback pointer definition
  *//*!< MDIOS Wake UP Callback ID           *//*!< MDIOS Error Callback ID             *//*!< MDIOS Read Complete Callback ID     *//*!< MDIOS Write Complete Callback ID    *//*!< MDIOS MspDeInit callback ID         *//*!< MDIOS MspInit callback ID           *//**
  * @brief  HAL MDIOS Callback ID enumeration definition
  *//*!< MDIOS Msp DeInit callback     *//*!< MDIOS Msp Init callback       *//*!< MDIOS Wake UP Callback        *//*!< MDIOS Error Callback          *//*!< MDIOS Read  Complete Callback *//*!< MDIOS Write Complete Callback *//*!< MDIOS Lock                  *//*!< MDIOS communication state   *//*!< MDIOS Init Structure        *//** @defgroup MDIOS_Exported_Types_Group4 MDIOS handle Structure definition
  * @{
  *//*!< Specifies whether the preamble check is enabled or disabled.   
                                       This parameter can be a value of @ref MDIOS_Preamble_Check *//*!< Specifies the MDIOS port address.   
                                       This parameter can be a value from 0 to 31 *//** @defgroup MDIOS_Exported_Types_Group2 MDIOS Init Structure definition
  * @{
  *//*!< Reception process is ongoing                       *//*!< an internal process is ongoing                     *//*!< Peripheral Initialized and ready for use           *//*!< Peripheral not yet Initialized or disabled         *//** @defgroup MDIOS_Exported_Types_Group1 MDIOS State structures definition
  * @{
  *//** @defgroup MDIOS_Exported_Types MDIOS Exported Types
  * @{
  *//** @addtogroup MDIOS
  * @{
  *//**
  ******************************************************************************
  * @file    stm32f7xx_hal_mdios.h
  * @author  MCD Application Team
  * @brief   Header file of MDIOS HAL module.
  ******************************************************************************
  * @attention
  *
  * Copyright (c) 2017 STMicroelectronics.
  * All rights reserved.
  *
  * This software is licensed under terms that can be found in the LICENSE file
  * in the root directory of this software component.
  * If no LICENSE file comes with this software, it is provided AS-IS.
  *
  ******************************************************************************
  */hmdiosRegNum"stm32f7xx_hal_mdios.h""stm32f7xx_hal_uart.h""stm32f7xx_hal_tim.h""stm32f7xx_hal_sd.h""stm32f7xx_hal_sai.h""stm32f7xx_hal_pwr.h""stm32f7xx_hal_ltdc.h""stm32f7xx_hal_i2c.h""stm32f7xx_hal_sdram.h""stm32f7xx_hal_nor.h""stm32f7xx_hal_sram.h""stm32f7xx_hal_flash.h""stm32f7xx_hal_eth.h""stm32f7xx_hal_dcmi.h""stm32f7xx_hal_dma2d.h""stm32f7xx_hal_adc.h""stm32f7xx_hal_cortex.h""stm32f7xx_hal_dma.h""stm32f7xx_hal_gpio.h""stm32f7xx_hal_rcc.h"assert_param(expr)((void)0U)USE_SPI_CRCPHY_LINK_INTERRUPTPHY_MISR_LINK_INT_ENPHY_MICR_INT_OEPHY_MICR_INT_ENPHY_DUPLEX_STATUSPHY_SPEED_STATUSPHY_LINK_STATUSPHY_MISRPHY_MICRPHY_SRPHY_JABBER_DETECTIONPHY_LINKED_STATUSPHY_AUTONEGO_COMPLETEPHY_ISOLATEPHY_POWERDOWNPHY_RESTART_AUTONEGOTIATIONPHY_AUTONEGOTIATIONPHY_HALFDUPLEX_10MPHY_FULLDUPLEX_10MPHY_HALFDUPLEX_100MPHY_FULLDUPLEX_100M((uint16_t)0x2100U)PHY_LOOPBACKPHY_RESETPHY_BSRPHY_BCRPHY_WRITE_TOPHY_READ_TOPHY_CONFIG_DELAY0x00000FFFUPHY_RESET_DELAY(0x000000FFU)DP83848_PHY_ADDRESSETH_TXBUFNBETH_RXBUFNBETH_TX_BUF_SIZEETH_RX_BUF_SIZEETH_MAC_ADDR5ETH_MAC_ADDR4ETH_MAC_ADDR3ETH_MAC_ADDR2ETH_MAC_ADDR1ETH_MAC_ADDR0USE_HAL_WWDG_REGISTER_CALLBACKSUSE_HAL_USART_REGISTER_CALLBACKSUSE_HAL_UART_REGISTER_CALLBACKSUSE_HAL_TIM_REGISTER_CALLBACKSUSE_HAL_SPI_REGISTER_CALLBACKSUSE_HAL_SMBUS_REGISTER_CALLBACKSUSE_HAL_SPDIFRX_REGISTER_CALLBACKSUSE_HAL_SRAM_REGISTER_CALLBACKSUSE_HAL_SDRAM_REGISTER_CALLBACKSUSE_HAL_SMARTCARD_REGISTER_CALLBACKSUSE_HAL_SD_REGISTER_CALLBACKSUSE_HAL_SAI_REGISTER_CALLBACKSUSE_HAL_RTC_REGISTER_CALLBACKSUSE_HAL_RNG_REGISTER_CALLBACKSUSE_HAL_QSPI_REGISTER_CALLBACKSUSE_HAL_PCD_REGISTER_CALLBACKSUSE_HAL_NOR_REGISTER_CALLBACKSUSE_HAL_NAND_REGISTER_CALLBACKSUSE_HAL_MMC_REGISTER_CALLBACKSUSE_HAL_MDIOS_REGISTER_CALLBACKSUSE_HAL_LTDC_REGISTER_CALLBACKSUSE_HAL_LPTIM_REGISTER_CALLBACKSUSE_HAL_JPEG_REGISTER_CALLBACKSUSE_HAL_IRDA_REGISTER_CALLBACKSUSE_HAL_I2S_REGISTER_CALLBACKSUSE_HAL_I2C_REGISTER_CALLBACKSUSE_HAL_HCD_REGISTER_CALLBACKSUSE_HAL_HASH_REGISTER_CALLBACKSUSE_HAL_ETH_REGISTER_CALLBACKSUSE_HAL_DSI_REGISTER_CALLBACKSUSE_HAL_DMA2D_REGISTER_CALLBACKSUSE_HAL_DFSDM_REGISTER_CALLBACKSUSE_HAL_DCMI_REGISTER_CALLBACKSUSE_HAL_DAC_REGISTER_CALLBACKSUSE_HAL_CRYP_REGISTER_CALLBACKSUSE_HAL_CEC_REGISTER_CALLBACKSUSE_HAL_CAN_REGISTER_CALLBACKSUSE_HAL_ADC_REGISTER_CALLBACKSPREFETCH_ENABLEUSE_RTOSTICK_INT_PRIORITYVDD_VALUE3300UEXTERNAL_CLOCK_VALUE12288000ULSE_VALUE32768ULSI_VALUE32000UHSI_VALUE16000000UHSE_VALUE25000000UHAL_MDIOS_MODULE_ENABLEDHAL_DSI_MODULE_ENABLEDHAL_CORTEX_MODULE_ENABLEDHAL_UART_MODULE_ENABLEDHAL_TIM_MODULE_ENABLEDHAL_SD_MODULE_ENABLEDHAL_SAI_MODULE_ENABLEDHAL_RCC_MODULE_ENABLEDHAL_PWR_MODULE_ENABLEDHAL_LTDC_MODULE_ENABLEDHAL_I2C_MODULE_ENABLEDHAL_GPIO_MODULE_ENABLEDHAL_SDRAM_MODULE_ENABLEDHAL_SRAM_MODULE_ENABLEDHAL_NOR_MODULE_ENABLEDHAL_FLASH_MODULE_ENABLEDHAL_ETH_MODULE_ENABLEDHAL_DMA2D_MODULE_ENABLEDHAL_DMA_MODULE_ENABLEDHAL_DCMI_MODULE_ENABLEDHAL_ADC_MODULE_ENABLEDHAL_MODULE_ENABLED__STM32F7xx_HAL_CONF_H!defined (HSE_VALUE)!defined (HSE_STARTUP_TIMEOUT)!defined (HSI_VALUE)!defined (LSI_VALUE)!defined (LSE_VALUE)!defined (LSE_STARTUP_TIMEOUT)!defined (EXTERNAL_CLOCK_VALUE)HAL_CAN_MODULE_ENABLEDHAL_CAN_LEGACY_MODULE_ENABLEDHAL_CEC_MODULE_ENABLEDHAL_CRC_MODULE_ENABLEDHAL_CRYP_MODULE_ENABLEDHAL_DAC_MODULE_ENABLEDHAL_ETH_LEGACY_MODULE_ENABLEDHAL_NAND_MODULE_ENABLEDHAL_HASH_MODULE_ENABLEDHAL_I2S_MODULE_ENABLEDHAL_IWDG_MODULE_ENABLEDHAL_LPTIM_MODULE_ENABLEDHAL_QSPI_MODULE_ENABLEDHAL_RNG_MODULE_ENABLEDHAL_RTC_MODULE_ENABLEDHAL_SPDIFRX_MODULE_ENABLEDHAL_SPI_MODULE_ENABLEDHAL_USART_MODULE_ENABLEDHAL_IRDA_MODULE_ENABLEDHAL_SMARTCARD_MODULE_ENABLEDHAL_WWDG_MODULE_ENABLEDHAL_PCD_MODULE_ENABLEDHAL_HCD_MODULE_ENABLEDHAL_DFSDM_MODULE_ENABLEDHAL_JPEG_MODULE_ENABLEDUSE_FULL_ASSERT/* __STM32F7xx_HAL_CONF_H *//* USE_FULL_ASSERT *//* Exported functions ------------------------------------------------------- *//**
  * @brief  The assert_param macro is used for function's parameters check.
  * @param  expr: If expr is false, it calls assert_failed function
  *         which reports the name of the source file and the source
  *         line number of the call that failed. 
  *         If expr is true, it returns no value.
  * @retval None
  *//* HAL_MDIOS_MODULE_ENABLED *//* HAL_JPEG_MODULE_ENABLED *//* HAL_DSI_MODULE_ENABLED *//* HAL_DFSDM_MODULE_ENABLED *//* HAL_HCD_MODULE_ENABLED *//* HAL_PCD_MODULE_ENABLED *//* HAL_WWDG_MODULE_ENABLED *//* HAL_SMARTCARD_MODULE_ENABLED *//* HAL_IRDA_MODULE_ENABLED *//* HAL_USART_MODULE_ENABLED *//* HAL_UART_MODULE_ENABLED *//* HAL_TIM_MODULE_ENABLED *//* HAL_SPI_MODULE_ENABLED *//* HAL_SPDIFRX_MODULE_ENABLED *//* HAL_SD_MODULE_ENABLED *//* HAL_SAI_MODULE_ENABLED *//* HAL_RTC_MODULE_ENABLED *//* HAL_RNG_MODULE_ENABLED *//* HAL_QSPI_MODULE_ENABLED *//* HAL_PWR_MODULE_ENABLED *//* HAL_LTDC_MODULE_ENABLED *//* HAL_LPTIM_MODULE_ENABLED *//* HAL_IWDG_MODULE_ENABLED *//* HAL_I2S_MODULE_ENABLED *//* HAL_I2C_MODULE_ENABLED *//* HAL_HASH_MODULE_ENABLED *//* HAL_SDRAM_MODULE_ENABLED *//* HAL_NAND_MODULE_ENABLED *//* HAL_NOR_MODULE_ENABLED *//* HAL_SRAM_MODULE_ENABLED *//* HAL_FLASH_MODULE_ENABLED *//* HAL_ETH_LEGACY_MODULE_ENABLED *//* HAL_ETH_MODULE_ENABLED *//* HAL_DCMI_MODULE_ENABLED *//* HAL_DAC_MODULE_ENABLED *//* HAL_DMA2D_MODULE_ENABLED *//* HAL_CRYP_MODULE_ENABLED *//* HAL_CRC_MODULE_ENABLED *//* HAL_CEC_MODULE_ENABLED *//* HAL_CAN_LEGACY_MODULE_ENABLED *//* HAL_CAN_MODULE_ENABLED *//* HAL_ADC_MODULE_ENABLED *//* HAL_CORTEX_MODULE_ENABLED *//* HAL_DMA_MODULE_ENABLED *//* HAL_GPIO_MODULE_ENABLED *//* HAL_RCC_MODULE_ENABLED *//**
  * @brief Include module's header file 
  *//* CRC FEATURE: Use to activate CRC feature inside HAL SPI Driver
* Activated: CRC code is present inside driver
* Deactivated: CRC code cleaned from driver
*//* ################## SPI peripheral configuration ########################## *//*!< PHY link status interrupt mask                  *//*!< Enable Interrupt on change of link status       *//*!< PHY Enable output interrupt events              *//*!< PHY Enable interrupts                           *//*!< PHY Duplex mask                                 *//*!< PHY Speed mask                                  *//*!< PHY Link mask                                   *//*!< MII Interrupt Status and Misc. Control Register *//*!< MII Interrupt Control Register                  *//*!< PHY status register Offset                      *//* Section 4: Extended PHY Registers *//*!< Jabber condition detected            *//*!< Valid link established               *//*!< Auto-Negotiation process completed   *//*!< Isolate PHY from MII                 *//*!< Select the power down mode           *//*!< Restart auto-negotiation function    *//*!< Enable auto-negotiation function     *//*!< Set the half-duplex mode at 10 Mb/s  *//*!< Set the full-duplex mode at 10 Mb/s  *//*!< Set the half-duplex mode at 100 Mb/s *//*!< Set the full-duplex mode at 100 Mb/s *//*!< Select loop-back mode *//*!< PHY Reset *//*!< Transceiver Basic Status Register    *//*!< Transceiver Basic Control Register   *//* Section 3: Common PHY Registers *//* PHY Configuration delay *//* PHY Reset delay these values are based on a 1 ms Systick interrupt*//* DP83848 PHY Address*//* Section 2: PHY configuration section *//* 4 Tx buffers of size ETH_TX_BUF_SIZE  *//* 4 Rx buffers of size ETH_RX_BUF_SIZE  *//* ETH Max buffer size for transmit              *//* ETH Max buffer size for receive               *//* Definition of the Ethernet driver buffers size and count *//* MAC ADDRESS: MAC_ADDR0:MAC_ADDR1:MAC_ADDR2:MAC_ADDR3:MAC_ADDR4:MAC_ADDR5 *//* Section 1 : Ethernet peripheral configuration *//* ################## Ethernet peripheral configuration ##################### *//* #define USE_FULL_ASSERT    1U *//**
  * @brief Uncomment the line below to expanse the "assert_param" macro in the 
  *        HAL drivers code
  *//* ########################## Assert Selection ############################## *//* WWDG register callback disabled      *//* USART register callback disabled     *//* UART register callback disabled      *//* TIM register callback disabled       *//* SPI register callback disabled       *//* SMBUS register callback disabled     *//* SPDIFRX register callback disabled   *//* SRAM register callback disabled      *//* SDRAM register callback disabled     *//* SMARTCARD register callback disabled *//* SD register callback disabled        *//* SAI register callback disabled       *//* RTC register callback disabled       *//* RNG register callback disabled       *//* QSPI register callback disabled      *//* PCD register callback disabled       *//* NOR register callback disabled       *//* NAND register callback disabled      *//* MMC register callback disabled       *//* MDIOS register callback disabled     *//* LTDC register callback disabled      *//* LPTIM register callback disabled     *//* JPEG register callback disabled      *//* IRDA register callback disabled      *//* I2S register callback disabled       *//* I2C register callback disabled       *//* HCD register callback disabled       *//* HASH register callback disabled      *//* ETH register callback disabled       *//* DSI register callback disabled       *//* DMA2D register callback disabled     *//* DFSDM register callback disabled     *//* DCMI register callback disabled      *//* DAC register callback disabled       *//* CRYP register callback disabled      *//* CEC register callback disabled       *//* CAN register callback disabled       *//* ADC register callback disabled       *//* To enable instruction cache and prefetch *//*!< tick interrupt priority *//*!< Value of VDD in mv *//**
  * @brief This is the HAL system configuration section
  *//* ########################### System Configuration ######################### *//* Tip: To avoid modifying this file each time you need to use different HSE,
   ===  you can define the HSE value in your toolchain compiler preprocessor. *//* EXTERNAL_CLOCK_VALUE *//*!< Value of the Internal oscillator in Hz*//**
  * @brief External clock source for I2S peripheral
  *        This value is used by the I2S HAL module to compute the I2S clock source 
  *        frequency, this source is inserted directly through I2S_CKIN pad. 
  *//* LSE_STARTUP_TIMEOUT *//*!< Time out for LSE start up, in ms *//* LSE_VALUE *//*!< Value of the External Low Speed oscillator in Hz *//**
  * @brief External Low Speed oscillator (LSE) value.
  *//*!< Value of the Internal Low Speed oscillator in Hz
                                             The real value may vary depending on the variations
                                             in voltage and temperature.  *//* LSI_VALUE *//*!< LSI Typical Value in Hz*//**
  * @brief Internal Low Speed oscillator (LSI) value.
  *//* HSI_VALUE *//**
  * @brief Internal High Speed oscillator (HSI) value.
  *        This value is used by the RCC HAL module to compute the system frequency
  *        (when HSI is used as system clock source, directly or through the PLL). 
  *//* HSE_STARTUP_TIMEOUT *//*!< Time out for HSE start up, in ms *//* HSE_VALUE *//*!< Value of the External oscillator in Hz *//**
  * @brief Adjust the value of External High Speed oscillator (HSE) used in your application.
  *        This value is used by the RCC HAL module to compute the system frequency
  *        (when HSE is used as system clock source, directly or through the PLL).  
  *//* ########################## HSE/HSI Values adaptation ##################### *//* #define HAL_JPEG_MODULE_ENABLED *//* #define HAL_DFSDM_MODULE_ENABLED *//* #define HAL_HCD_MODULE_ENABLED *//* #define HAL_PCD_MODULE_ENABLED *//* #define HAL_WWDG_MODULE_ENABLED *//* #define HAL_SMARTCARD_MODULE_ENABLED *//* #define HAL_IRDA_MODULE_ENABLED  *//* #define HAL_USART_MODULE_ENABLED *//* #define HAL_SPI_MODULE_ENABLED *//* #define HAL_SPDIFRX_MODULE_ENABLED *//* #define HAL_RTC_MODULE_ENABLED *//* #define HAL_RNG_MODULE_ENABLED *//* #define HAL_QSPI_MODULE_ENABLED    *//* #define HAL_LPTIM_MODULE_ENABLED *//* #define HAL_IWDG_MODULE_ENABLED *//* #define HAL_I2S_MODULE_ENABLED *//* #define HAL_HASH_MODULE_ENABLED *//* #define HAL_NAND_MODULE_ENABLED *//* #define HAL_ETH_LEGACY_MODULE_ENABLED *//* #define HAL_DAC_MODULE_ENABLED *//* #define HAL_CRYP_MODULE_ENABLED *//* #define HAL_CRC_MODULE_ENABLED *//* #define HAL_CEC_MODULE_ENABLED   *//* #define HAL_CAN_LEGACY_MODULE_ENABLED *//* #define HAL_CAN_MODULE_ENABLED *//**
  * @brief This is the list of modules to be used in the HAL driver 
  *//* ########################## Module Selection ############################## *//**
  ******************************************************************************
  * @file    LwIP/LwIP_StreamingServer/Inc/stm32f7xx_hal_conf.h
  * @author  MCD Application Team
  * @brief   HAL configuration file. 
  ******************************************************************************
  * @attention
  *
  * Copyright (c) 2016 STMicroelectronics.
  * All rights reserved.
  *
  * This software is licensed under terms that can be found in the LICENSE file
  * in the root directory of this software component.
  * If no LICENSE file comes with this software, it is provided AS-IS.
  *
  ******************************************************************************
  *//Users/jie/Documents/posixGen_Demos-main/LwIP_StreamingServer/Inc"stm32f7xx_hal_conf.h"HAL_TickFreqTypeDefHAL_TICK_FREQ_10HZHAL_TICK_FREQ_100HZHAL_TICK_FREQ_1KHZHAL_TICK_FREQ_DEFAULTIS_TICKFREQ(FREQ)(((FREQ) == HAL_TICK_FREQ_10HZ) || ((FREQ) == HAL_TICK_FREQ_100HZ) || ((FREQ) == HAL_TICK_FREQ_1KHZ))__HAL_SYSCFG_BREAK_PVD_LOCK()SET_BIT(SYSCFG->CBR, SYSCFG_CBR_PVDL)__HAL_SYSCFG_BREAK_LOCKUP_LOCK()SET_BIT(SYSCFG->CBR, SYSCFG_CBR_CLL)__HAL_SYSCFG_GET_BOOT_MODE()READ_BIT(SYSCFG->MEMRMP, SYSCFG_MEMRMP_MEM_BOOT)__HAL_SYSCFG_REMAPMEMORY_FMC_SDRAM()do {SYSCFG->MEMRMP &= ~(SYSCFG_MEMRMP_SWP_FMC); SYSCFG->MEMRMP |= (SYSCFG_MEMRMP_SWP_FMC_0); }while(0);__HAL_SYSCFG_REMAPMEMORY_FMC()(SYSCFG->MEMRMP &= ~(SYSCFG_MEMRMP_SWP_FMC))__HAL_DBGMCU_UNFREEZE_TIM11()(DBGMCU->APB2FZ &= ~(DBGMCU_APB2_FZ_DBG_TIM11_STOP))__HAL_DBGMCU_UNFREEZE_TIM10()(DBGMCU->APB2FZ &= ~(DBGMCU_APB2_FZ_DBG_TIM10_STOP))__HAL_DBGMCU_UNFREEZE_TIM9()(DBGMCU->APB2FZ &= ~(DBGMCU_APB2_FZ_DBG_TIM9_STOP))__HAL_DBGMCU_UNFREEZE_TIM8()(DBGMCU->APB2FZ &= ~(DBGMCU_APB2_FZ_DBG_TIM8_STOP))__HAL_DBGMCU_UNFREEZE_TIM1()(DBGMCU->APB2FZ &= ~(DBGMCU_APB2_FZ_DBG_TIM1_STOP))__HAL_DBGMCU_UNFREEZE_CAN2()(DBGMCU->APB1FZ &= ~(DBGMCU_APB1_FZ_DBG_CAN2_STOP))__HAL_DBGMCU_UNFREEZE_CAN1()(DBGMCU->APB1FZ &= ~(DBGMCU_APB1_FZ_DBG_CAN1_STOP))__HAL_DBGMCU_UNFREEZE_I2C4_TIMEOUT()(DBGMCU->APB1FZ &= ~(DBGMCU_APB1_FZ_DBG_I2C4_SMBUS_TIMEOUT))__HAL_DBGMCU_UNFREEZE_I2C3_TIMEOUT()(DBGMCU->APB1FZ &= ~(DBGMCU_APB1_FZ_DBG_I2C3_SMBUS_TIMEOUT))__HAL_DBGMCU_UNFREEZE_I2C2_TIMEOUT()(DBGMCU->APB1FZ &= ~(DBGMCU_APB1_FZ_DBG_I2C2_SMBUS_TIMEOUT))__HAL_DBGMCU_UNFREEZE_I2C1_TIMEOUT()(DBGMCU->APB1FZ &= ~(DBGMCU_APB1_FZ_DBG_I2C1_SMBUS_TIMEOUT))__HAL_DBGMCU_UNFREEZE_IWDG()(DBGMCU->APB1FZ &= ~(DBGMCU_APB1_FZ_DBG_IWDG_STOP))__HAL_DBGMCU_UNFREEZE_WWDG()(DBGMCU->APB1FZ &= ~(DBGMCU_APB1_FZ_DBG_WWDG_STOP))__HAL_DBGMCU_UNFREEZE_RTC()(DBGMCU->APB1FZ &= ~(DBGMCU_APB1_FZ_DBG_RTC_STOP))__HAL_DBGMCU_UNFREEZE_LPTIM1()(DBGMCU->APB1FZ &= ~(DBGMCU_APB1_FZ_DBG_LPTIM1_STOP))__HAL_DBGMCU_UNFREEZE_TIM14()(DBGMCU->APB1FZ &= ~(DBGMCU_APB1_FZ_DBG_TIM14_STOP))__HAL_DBGMCU_UNFREEZE_TIM13()(DBGMCU->APB1FZ &= ~(DBGMCU_APB1_FZ_DBG_TIM13_STOP))__HAL_DBGMCU_UNFREEZE_TIM12()(DBGMCU->APB1FZ &= ~(DBGMCU_APB1_FZ_DBG_TIM12_STOP))__HAL_DBGMCU_UNFREEZE_TIM7()(DBGMCU->APB1FZ &= ~(DBGMCU_APB1_FZ_DBG_TIM7_STOP))__HAL_DBGMCU_UNFREEZE_TIM6()(DBGMCU->APB1FZ &= ~(DBGMCU_APB1_FZ_DBG_TIM6_STOP))__HAL_DBGMCU_UNFREEZE_TIM5()(DBGMCU->APB1FZ &= ~(DBGMCU_APB1_FZ_DBG_TIM5_STOP))__HAL_DBGMCU_UNFREEZE_TIM4()(DBGMCU->APB1FZ &= ~(DBGMCU_APB1_FZ_DBG_TIM4_STOP))__HAL_DBGMCU_UNFREEZE_TIM3()(DBGMCU->APB1FZ &= ~(DBGMCU_APB1_FZ_DBG_TIM3_STOP))__HAL_DBGMCU_UNFREEZE_TIM2()(DBGMCU->APB1FZ &= ~(DBGMCU_APB1_FZ_DBG_TIM2_STOP))__HAL_DBGMCU_FREEZE_TIM11()(DBGMCU->APB2FZ |= (DBGMCU_APB2_FZ_DBG_TIM11_STOP))__HAL_DBGMCU_FREEZE_TIM10()(DBGMCU->APB2FZ |= (DBGMCU_APB2_FZ_DBG_TIM10_STOP))__HAL_DBGMCU_FREEZE_TIM9()(DBGMCU->APB2FZ |= (DBGMCU_APB2_FZ_DBG_TIM9_STOP))__HAL_DBGMCU_FREEZE_TIM8()(DBGMCU->APB2FZ |= (DBGMCU_APB2_FZ_DBG_TIM8_STOP))__HAL_DBGMCU_FREEZE_TIM1()(DBGMCU->APB2FZ |= (DBGMCU_APB2_FZ_DBG_TIM1_STOP))__HAL_DBGMCU_FREEZE_CAN2()(DBGMCU->APB1FZ |= (DBGMCU_APB1_FZ_DBG_CAN2_STOP))__HAL_DBGMCU_FREEZE_CAN1()(DBGMCU->APB1FZ |= (DBGMCU_APB1_FZ_DBG_CAN1_STOP))__HAL_DBGMCU_FREEZE_I2C4_TIMEOUT()(DBGMCU->APB1FZ |= (DBGMCU_APB1_FZ_DBG_I2C4_SMBUS_TIMEOUT))__HAL_DBGMCU_FREEZE_I2C3_TIMEOUT()(DBGMCU->APB1FZ |= (DBGMCU_APB1_FZ_DBG_I2C3_SMBUS_TIMEOUT))__HAL_DBGMCU_FREEZE_I2C2_TIMEOUT()(DBGMCU->APB1FZ |= (DBGMCU_APB1_FZ_DBG_I2C2_SMBUS_TIMEOUT))__HAL_DBGMCU_FREEZE_I2C1_TIMEOUT()(DBGMCU->APB1FZ |= (DBGMCU_APB1_FZ_DBG_I2C1_SMBUS_TIMEOUT))__HAL_DBGMCU_FREEZE_IWDG()(DBGMCU->APB1FZ |= (DBGMCU_APB1_FZ_DBG_IWDG_STOP))__HAL_DBGMCU_FREEZE_WWDG()(DBGMCU->APB1FZ |= (DBGMCU_APB1_FZ_DBG_WWDG_STOP))__HAL_DBGMCU_FREEZE_RTC()(DBGMCU->APB1FZ |= (DBGMCU_APB1_FZ_DBG_RTC_STOP))__HAL_DBGMCU_FREEZE_LPTIM1()(DBGMCU->APB1FZ |= (DBGMCU_APB1_FZ_DBG_LPTIM1_STOP))__HAL_DBGMCU_FREEZE_TIM14()(DBGMCU->APB1FZ |= (DBGMCU_APB1_FZ_DBG_TIM14_STOP))__HAL_DBGMCU_FREEZE_TIM13()(DBGMCU->APB1FZ |= (DBGMCU_APB1_FZ_DBG_TIM13_STOP))__HAL_DBGMCU_FREEZE_TIM12()(DBGMCU->APB1FZ |= (DBGMCU_APB1_FZ_DBG_TIM12_STOP))__HAL_DBGMCU_FREEZE_TIM7()(DBGMCU->APB1FZ |= (DBGMCU_APB1_FZ_DBG_TIM7_STOP))__HAL_DBGMCU_FREEZE_TIM6()(DBGMCU->APB1FZ |= (DBGMCU_APB1_FZ_DBG_TIM6_STOP))__HAL_DBGMCU_FREEZE_TIM5()(DBGMCU->APB1FZ |= (DBGMCU_APB1_FZ_DBG_TIM5_STOP))__HAL_DBGMCU_FREEZE_TIM4()(DBGMCU->APB1FZ |= (DBGMCU_APB1_FZ_DBG_TIM4_STOP))__HAL_DBGMCU_FREEZE_TIM3()(DBGMCU->APB1FZ |= (DBGMCU_APB1_FZ_DBG_TIM3_STOP))__HAL_DBGMCU_FREEZE_TIM2()(DBGMCU->APB1FZ |= (DBGMCU_APB1_FZ_DBG_TIM2_STOP))SYSCFG_MEM_BOOT_ADD1SYSCFG_MEM_BOOT_ADD0HAL_DisableMemorySwappingBankHAL_EnableMemorySwappingBankHAL_DisableFMCMemorySwappingHAL_EnableFMCMemorySwappingHAL_DisableCompensationCellHAL_EnableCompensationCellHAL_GetUIDw2HAL_GetUIDw1HAL_GetUIDw0HAL_GetDEVIDHAL_GetREVIDHAL_GetHalVersionHAL_ResumeTickHAL_SuspendTickHAL_GetTickFreqHAL_SetTickFreqHAL_GetTickPrioHAL_GetTickHAL_DelayHAL_IncTickuwTickFrequwTickPriouwTickHAL_InitTickHAL_MspDeInitHAL_MspInitHAL_DeInitHAL_InitFreqTickPriority/Users/jie/Documents/posixGen_Demos-main/LwIP_StreamingServer/Drivers/STM32F7xx_HAL_Driver/Src/stm32f7xx_hal.cSYSCFG->MEMRMP((SYSCFG_TypeDef *) ((0x40000000UL + 0x00010000UL) + 0x3800UL))->MEMRMP1073821696SYSCFG_TypeDef *4294967039(uint32_t)SYSCFG_MEMRMP_SWP_FMC((uint32_t)SYSCFG_MEMRMP_SWP_FMC)4294964223(uint32_t)~((uint32_t)SYSCFG_MEMRMP_SWP_FMC)(uint32_t)SYSCFG_CMPCR_CMP_PD((uint32_t)SYSCFG_CMPCR_CMP_PD)(uint32_t)~((uint32_t)SYSCFG_CMPCR_CMP_PD)DBGMCU->CR((DBGMCU_TypeDef *) 0xE0042000UL)->CR3758366720DBGMCU_TypeDef *42949672914294967293*((uint32_t *)(UID_BASE + 8U))*((uint32_t *)(0x1FF0F420UL + 8U))535884832535884840*((uint32_t *)(UID_BASE + 4U))*((uint32_t *)(0x1FF0F420UL + 4U))535884836*((uint32_t *)UID_BASE)*((uint32_t *)0x1FF0F420UL)IDCODE_DEVID_MASK167772161697382416974080__STM32F7xx_HAL_VERSION~SysTick_CTRL_TICKINT_MsktickstartwaitprevTickFreqIS_TICKFREQ(Freq)1000U/Users/jie/Documents/posixGen_Demos-main/LwIP_StreamingServer/Drivers/STM32F7xx_HAL_Driver/SrcFLASH->ACR((FLASH_TypeDef *) ((0x40000000UL + 0x00020000UL) + 0x3C00UL))->ACR153601073888256FLASH_TypeDef *((uint32_t)0x00000FFF)((__STM32F7xx_HAL_VERSION_MAIN << 24) |(__STM32F7xx_HAL_VERSION_SUB1 << 16) |(__STM32F7xx_HAL_VERSION_SUB2 << 8 ) |(__STM32F7xx_HAL_VERSION_RC))__STM32F7xx_HAL_VERSION_RC__STM32F7xx_HAL_VERSION_SUB2__STM32F7xx_HAL_VERSION_SUB1(0x03)__STM32F7xx_HAL_VERSION_MAIN(ART_ACCELERATOR_ENABLE != 0)(PREFETCH_ENABLE != 0U)/**
* @brief  Disable the Internal FLASH Bank Swapping.
*   
* @note   This function can be used only for STM32F77xx/STM32F76xx devices. 
*
* @note   The default state : Flash Bank1 mapped at 0x08000000 (AXI) (aliased at 0x00200000 (TCM)) 
*         and Flash Bank2 mapped at 0x08100000 (AXI)( aliased at 0x00300000 (TCM)) 
*           
* @retval None
*//**
* @brief  Enable the Internal FLASH Bank Swapping.
*   
* @note   This function can be used only for STM32F77xx/STM32F76xx devices. 
*
* @note   Flash Bank2 mapped at 0x08000000 (AXI) (aliased at 0x00200000 (TCM)) 
*         and Flash Bank1 mapped at 0x08100000 (AXI) (aliased at 0x00300000 (TCM))   
*
* @retval None
*//**
  * @brief  Disables the FMC Memory Mapping Swapping
  *   
  * @note   SDRAM is accessible at 0xC0000000 (default mapping)  
  *         and NOR/RAM is accessible at 0x60000000 (default mapping)    
  *           
  * @retval None
  *//**
  * @brief  Enables the FMC Memory Mapping Swapping.
  *   
  * @note   SDRAM is accessible at 0x60000000 
  *         and NOR/RAM is accessible at 0xC0000000   
  *
  * @retval None
  *//**
  * @brief  Power-down the I/O Compensation Cell.
  * @note   The I/O compensation cell can be used only when the device supply
  *         voltage ranges from 2.4 to 3.6 V.  
  * @retval None
  *//**
  * @brief  Enables the I/O Compensation Cell.
  * @note   The I/O compensation cell can be used only when the device supply
  *         voltage ranges from 2.4 to 3.6 V.  
  * @retval None
  *//**
  * @brief  Disable the Debug Module during STANDBY mode
  * @retval None
  *//**
  * @brief  Enable the Debug Module during STANDBY mode
  * @retval None
  *//**
  * @brief  Disable the Debug Module during STOP mode
  * @retval None
  *//**
  * @brief  Enable the Debug Module during STOP mode
  * @retval None
  *//**
  * @brief  Disable the Debug Module during SLEEP mode
  * @retval None
  *//**
  * @brief  Enable the Debug Module during SLEEP mode
  * @retval None
  *//**
  * @brief  Returns third word of the unique device identifier (UID based on 96 bits)
  * @retval Device identifier
  *//**
  * @brief  Returns second word of the unique device identifier (UID based on 96 bits)
  * @retval Device identifier
  *//**
  * @brief  Returns first word of the unique device identifier (UID based on 96 bits)
  * @retval Device identifier
  *//**
  * @brief  Returns the device identifier.
  * @retval Device identifier
  *//**
  * @brief  Returns the device revision identifier.
  * @retval Device revision identifier
  *//**
  * @brief  Returns the HAL revision
  * @retval version : 0xXYZR (8bits for each decimal, R for RC)
  *//* Enable SysTick Interrupt *//**
  * @brief Resume Tick increment.
  * @note In the default implementation , SysTick timer is the source of time base. It is
  *       used to generate interrupts at regular time intervals. Once HAL_ResumeTick()
  *       is called, the SysTick interrupt will be enabled and so Tick increment 
  *       is resumed.
  * @note This function is declared as __weak to be overwritten in case of other
  *       implementations in user file.
  * @retval None
  *//* Disable SysTick Interrupt *//**
  * @brief Suspend Tick increment.
  * @note In the default implementation , SysTick timer is the source of time base. It is
  *       used to generate interrupts at regular time intervals. Once HAL_SuspendTick()
  *       is called, the SysTick interrupt will be disabled and so Tick increment 
  *       is suspended.
  * @note This function is declared as __weak to be overwritten in case of other
  *       implementations in user file.
  * @retval None
  *//* Add a freq to guarantee minimum wait *//**
  * @brief This function provides minimum delay (in milliseconds) based
  *        on variable incremented.
  * @note In the default implementation , SysTick timer is the source of time base.
  *       It is used to generate interrupts at regular time intervals where uwTick
  *       is incremented.
  * @note This function is declared as __weak to be overwritten in case of other
  *       implementations in user file.
  * @param Delay  specifies the delay time length, in milliseconds.
  * @retval None
  *//**
  * @brief Return tick frequency.
  * @retval Tick frequency.
  *         Value of @ref HAL_TickFreqTypeDef.
  *//* Restore previous tick frequency *//* Apply the new tick Freq  *//* Update uwTickFreq global variable used by HAL_InitTick() *//* Back up uwTickFreq frequency *//**
  * @brief Set new tick Freq.
  * @retval Status
  *//**
  * @brief This function returns a tick priority.
  * @retval tick priority
  *//**
  * @brief Provides a tick value in millisecond.
  * @note This function is declared as __weak to be overwritten in case of other 
  *       implementations in user file.
  * @retval tick value
  *//**
  * @brief This function is called to increment  a global variable "uwTick"
  *        used as application time base.
  * @note In the default implementation, this variable is incremented each 1ms
  *       in SysTick ISR.
 * @note This function is declared as __weak to be overwritten in case of other 
  *      implementations in user file.
  * @retval None
  *//** @defgroup HAL_Exported_Functions_Group2 HAL Control functions 
 *  @brief    HAL Control functions
 *
@verbatim
 ===============================================================================
                      ##### HAL Control functions #####
 ===============================================================================
    [..]  This section provides functions allowing to:
      (+) Provide a tick value in millisecond
      (+) Provide a blocking delay in millisecond
      (+) Suspend the time base source interrupt
      (+) Resume the time base source interrupt
      (+) Get the HAL API driver version
      (+) Get the device identifier
      (+) Get the device revision identifier
      (+) Enable/Disable Debug module during SLEEP mode
      (+) Enable/Disable Debug module during STOP mode
      (+) Enable/Disable Debug module during STANDBY mode

@endverbatim
  * @{
  *//* Return function status *//* Configure the SysTick IRQ priority *//* Configure the SysTick to have interrupt in 1ms time basis*//**
  * @brief This function configures the source of the time base.
  *        The time source is configured  to have 1ms time base with a dedicated 
  *        Tick interrupt priority.
  * @note This function is called  automatically at the beginning of program after
  *       reset by HAL_Init() or at any time when clock is reconfigured  by HAL_RCC_ClockConfig().
  * @note In the default implementation, SysTick timer is the source of time base. 
  *       It is used to generate interrupts at regular time intervals. 
  *       Care must be taken if HAL_Delay() is called from a peripheral ISR process, 
  *       The SysTick interrupt must have higher priority (numerically lower)
  *       than the peripheral interrupt. Otherwise the caller ISR process will be blocked.
  *       The function is declared as __weak  to be overwritten  in case of other
  *       implementation  in user file.
  * @param TickPriority Tick interrupt priority.
  * @retval HAL status
  *//* NOTE : This function should not be modified, when the callback is needed,
            the HAL_MspDeInit could be implemented in the user file
   *//**
  * @brief  DeInitializes the MSP.
  * @retval None
  *//* NOTE : This function should not be modified, when the callback is needed,
            the HAL_MspInit could be implemented in the user file
   *//**
  * @brief  Initialize the MSP.
  * @retval None
  *//* De-Init the low level hardware *//* Reset of all peripherals *//**
  * @brief  This function de-Initializes common part of the HAL and stops the systick.
  *         This function is optional.   
  * @retval HAL status
  *//* Init the low level hardware *//* Use systick as time base source and configure 1ms tick (default clock after Reset is HSI) *//* Set Interrupt Group Priority *//* PREFETCH_ENABLE *//* Configure Flash prefetch *//* ART_ACCELERATOR_ENABLE *//* Configure Instruction cache through ART accelerator *//**
  * @brief  This function is used to initialize the HAL Library; it must be the first 
  *         instruction to be executed in the main program (before to call any other
  *         HAL function), it performs the following:
  *           Configure the Flash prefetch, and instruction cache through ART accelerator.
  *           Configures the SysTick to generate an interrupt each 1 millisecond,
  *           which is clocked by the HSI (at this stage, the clock is not yet
  *           configured and thus the system is running from the internal HSI at 16 MHz).
  *           Set NVIC Group Priority to 4.
  *           Calls the HAL_MspInit() callback function defined in user file 
  *           "stm32f7xx_hal_msp.c" to do the global low level hardware initialization 
  *            
  * @note   SysTick is used as time base for the HAL_Delay() function, the application
  *         need to ensure that the SysTick time base is always set to 1 millisecond
  *         to have correct HAL operation.
  * @retval HAL status
  *//** @defgroup HAL_Exported_Functions_Group1 Initialization and de-initialization Functions 
 *  @brief    Initialization and de-initialization functions
 *
@verbatim    
 ===============================================================================
              ##### Initialization and Configuration functions #####
 ===============================================================================
    [..]  This section provides functions allowing to:
      (+) Initializes the Flash interface the NVIC allocation and initial clock 
          configuration. It initializes the systick also when timeout is needed 
          and the backup domain when enabled.
      (+) De-Initializes common part of the HAL.
      (+) Configure the time base source to have 1ms time base with a dedicated 
          Tick interrupt priority. 
        (++) SysTick timer is used by default as source of time base, but user
             can eventually implement his proper time base source (a general purpose 
             timer for example or other time source), keeping in mind that Time base 
             duration should be kept 1ms since PPP_TIMEOUT_VALUEs are defined and 
             handled in milliseconds basis.
        (++) Time base configuration function (HAL_InitTick ()) is called automatically 
             at the beginning of the program after reset by HAL_Init() or at any time 
             when clock is configured, by HAL_RCC_ClockConfig(). 
        (++) Source of time base is configured  to generate interrupts at regular 
             time intervals. Care must be taken if HAL_Delay() is called from a 
             peripheral ISR process, the Tick interrupt line must have higher priority 
            (numerically lower) than the peripheral interrupt. Otherwise the caller 
            ISR process will be blocked. 
       (++) functions affecting time base configurations are declared as __weak  
             to make  override possible  in case of other  implementations in user file.
@endverbatim
  * @{
  *//** @defgroup HAL_Exported_Functions HAL Exported Functions
  * @{
  *//* 1KHz *//* Invalid PRIO *//**
 * @brief STM32F7xx HAL Driver version number V1.3.1
   *//** @addtogroup HAL_Private_Constants
  * @{
  *//** @defgroup HAL HAL
  * @brief HAL module driver.
  * @{
  *//**
  ******************************************************************************
  * @file    stm32f7xx_hal.c
  * @author  MCD Application Team
  * @brief   HAL module driver.
  *          This is the common part of the HAL initialization
  *
  ******************************************************************************
  * @attention
  *
  * Copyright (c) 2017 STMicroelectronics.
  * All rights reserved.
  *
  * This software is licensed under terms that can be found in the LICENSE file
  * in the root directory of this software component.
  * If no LICENSE file comes with this software, it is provided AS-IS.
  *
  ******************************************************************************
  @verbatim
  ==============================================================================
                     ##### How to use this driver #####
  ==============================================================================
    [..]
    The common HAL driver contains a set of generic and common APIs that can be
    used by the PPP peripheral drivers and the user to start using the HAL. 
    [..]
    The HAL contains two APIs' categories: 
         (+) Common HAL APIs
         (+) Services HAL APIs

  @endverbatim
  ******************************************************************************
  *//Users/jie/Documents/posixGen_Demos-main/LwIP_StreamingServer/Drivers/STM32F7xx_HAL_Driver/Src/stm32f7xx_hal_adc.cADC_DMAErrorADC_DMAHalfConvCpltADC_DMAConvCplthadc->StateHAL_ADC_STATE_ERROR_INTERNAL | HAL_ADC_STATE_ERROR_DMA((uint32_t)0x00000010U) | ((uint32_t)0x00000040U)hadc->Instance->SQR1(0xFUL << (20U))hadc->Instance->CR2((uint32_t)(0x1UL << (5U)))805306368157286404294967263ADC_Init89601073816320ADC_Common_TypeDef *(ADC_CCR_ADCPRE)4294770687~(ADC_CCR_ADCPRE)(ADC_CR1_SCAN)~(ADC_CR1_SCAN)hadc->Init.ScanConvMode50331648(ADC_CR1_RES)4244635647~(ADC_CR1_RES)(ADC_CR2_ALIGN)~(ADC_CR2_ALIGN)251658240251658241(ADC_CR2_EXTSEL)4043309055~(ADC_CR2_EXTSEL)(ADC_CR2_EXTEN)3489660927~(ADC_CR2_EXTEN)(ADC_CR2_CONT)~(ADC_CR2_CONT)(uint32_t)hadc->Init.ContinuousConvModeIS_ADC_REGULAR_DISC_NUMBER(hadc->Init.NbrOfDiscConversion)hadc->Init.NbrOfDiscConversion(uint32_t)ADC_CR1_DISCEN57344(ADC_CR1_DISCNUM)4294909951~(ADC_CR1_DISCNUM)(ADC_CR1_DISCEN)~(ADC_CR1_DISCEN)(ADC_SQR1_L)4279238655~(ADC_SQR1_L)hadc->Init.NbrOfConversion(ADC_CR2_DDS)4294966783~(ADC_CR2_DDS)(uint32_t)hadc->Init.DMAContinuousRequests(ADC_CR2_EOCS)4294966271~(ADC_CR2_EOCS)hadc->Init.EOCSelectionIS_ADC_ANALOG_WATCHDOG(AnalogWDGConfig->WatchdogMode)IS_ADC_CHANNEL(AnalogWDGConfig->Channel)IS_FUNCTIONAL_STATE(AnalogWDGConfig->ITMode)((uint32_t)(0x1UL << (6U)))4294967231419481612583424(ADC_CR1_AWDSGL | ADC_CR1_JAWDEN | ADC_CR1_AWDEN)4282383871~(ADC_CR1_AWDSGL | ADC_CR1_JAWDEN | ADC_CR1_AWDEN)4294967264~ADC_CR1_AWDCHIS_ADC_CHANNEL(sConfig->Channel)IS_ADC_REGULAR_RANK(sConfig->Rank)IS_ADC_SAMPLE_TIME(sConfig->SamplingTime)(0x7UL << (0U))sConfig->ChannelsConfig->SamplingTime((uint32_t)((0x10UL << (0U)) | (0x02UL << (0U))))2147483648268435456268435474(0x1FUL << (0U))sConfig->Rank107381555212582912(ADC_CCR_VBATE | ADC_CCR_TSVREFE)4282384383~(ADC_CCR_VBATE | ADC_CCR_TSVREFE)~ADC_CCR_TSVREFE4290772991~ADC_CCR_VBATE1000000tmp_hal_statusIS_ADC_ALL_INSTANCE(hadc->Instance)((uint32_t)(0x1UL << (26U)))HAL_ADC_STATE_REG_BUSY | HAL_ADC_STATE_INJ_BUSY((uint32_t)0x00000100U) | ((uint32_t)0x00001000U)(hadc->State)(((READ_REG(hadc->State)) & (~(((uint32_t)0x00000100U) | ((uint32_t)0x00001000U)))) | (((uint32_t)0x00000001U)))(((((hadc->State))) & (~(((uint32_t)0x00000100U) | ((uint32_t)0x00001000U)))) | (((uint32_t)0x00000001U)))~ADC_CR2_DMA43524294962943IS_FUNCTIONAL_STATE(hadc->Init.ContinuousConvMode)IS_ADC_EXT_TRIG_EDGE(hadc->Init.ExternalTrigConvEdge)HAL_ADC_STATE_READY | HAL_ADC_STATE_REG_EOC | HAL_ADC_STATE_REG_OVR((uint32_t)0x00000001U) | ((uint32_t)0x00000200U) | ((uint32_t)0x00000400U)(((READ_REG(hadc->State)) & (~(((uint32_t)0x00000001U) | ((uint32_t)0x00000200U) | ((uint32_t)0x00000400U)))) | (((uint32_t)0x00000100U)))(((((hadc->State))) & (~(((uint32_t)0x00000001U) | ((uint32_t)0x00000200U) | ((uint32_t)0x00000400U)))) | (((uint32_t)0x00000100U)))hadc->Instance->CR1(((READ_REG(hadc->State)) & (~(((uint32_t)0x00002000U)))) | (((uint32_t)0x00001000U)))(((((hadc->State))) & (~(((uint32_t)0x00002000U)))) | (((uint32_t)0x00001000U)))hadc->ErrorCode(HAL_ADC_ERROR_OVR | HAL_ADC_ERROR_DMA)(((uint32_t)0x02U) | ((uint32_t)0x04U))ADC_FLAG_EOC | ADC_FLAG_OVR((uint32_t)(0x1UL << (1U))) | ((uint32_t)(0x1UL << (5U)))ADC->CCR((ADC_Common_TypeDef *) ((0x40000000UL + 0x00010000UL) + 0x2300UL))->CCR(0x10UL << (0U))51315374294965758429495910342949672894294967261(uint32_t)ADC_CR2_SWSTARTtmp_srtmp_cr1IS_ADC_REGULAR_LENGTH(hadc->Init.NbrOfConversion)IS_ADC_EOCSelection(hadc->Init.EOCSelection)ADC_FLAG_STRT | ADC_FLAG_EOC((uint32_t)(0x1UL << (4U))) | ((uint32_t)(0x1UL << (1U)))4294967277hadc->Instance->JSQR(0x3UL << (20U))((uint32_t)(0x1UL << (7U)))(ADC_FLAG_JSTRT | ADC_FLAG_JEOC)(((uint32_t)(0x1UL << (3U))) | ((uint32_t)(0x1UL << (2U))))314572842949631994294967283((uint32_t)(0x1UL << (0U)))(ADC_IT_EOC | ADC_IT_OVR)(((uint32_t)(0x1UL << (5U))) | ((uint32_t)(0x1UL << (26U))))671088964227858399IS_ADC_EVENT_TYPE(EventType)((uint32_t)(0x1UL << (1U)))IS_ADC_CLOCKPRESCALER(hadc->Init.ClockPrescaler)IS_ADC_RESOLUTION(hadc->Init.Resolution)IS_ADC_SCAN_MODE(hadc->Init.ScanConvMode)IS_ADC_EXT_TRIG(hadc->Init.ExternalTrigConv)IS_ADC_DATA_ALIGN(hadc->Init.DataAlign)IS_FUNCTIONAL_STATE(hadc->Init.DMAContinuousRequests)IS_FUNCTIONAL_STATE(hadc->Init.DiscontinuousConvMode)(((READ_REG(hadc->State)) & (~(((uint32_t)0x00000100U) | ((uint32_t)0x00001000U)))) | (((uint32_t)0x00000002U)))(((((hadc->State))) & (~(((uint32_t)0x00000100U) | ((uint32_t)0x00001000U)))) | (((uint32_t)0x00000002U)))(((READ_REG(hadc->State)) & (~(((uint32_t)0x00000002U)))) | (((uint32_t)0x00000001U)))(((((hadc->State))) & (~(((uint32_t)0x00000002U)))) | (((uint32_t)0x00000001U)))/* Error callback *//* Set ADC error code to DMA error *//**
  * @brief  DMA error callback 
  * @param  hdma pointer to a DMA_HandleTypeDef structure that contains
  *                the configuration information for the specified DMA module.
  * @retval None
  *//* Half conversion callback *//**
  * @brief  DMA half transfer complete callback. 
  * @param  hdma pointer to a DMA_HandleTypeDef structure that contains
  *                the configuration information for the specified DMA module.
  * @retval None
  *//* Call DMA error callback *//* Call HAL ADC Error Callback function *//* DMA and-or internal error occurred *//* Conversion complete callback *//* Set ADC state *//* by overrun IRQ process below.                                      *//* HAL_ADC_Start_IT(), but is not disabled here because can be used   *//* Note: Overrun interrupt was enabled with EOC interrupt in          *//* Disable ADC end of single conversion interrupt on group regular *//*       of end of sequence.                                            *//*       sequence disabled or with end of conversion flag set to        *//*       The test of scan sequence on going is done either with scan    *//* Note: On STM32F7, there is no independent flag of end of sequence.   *//* by external trigger, continuous mode or scan sequence on going.      *//* Determine whether any further conversion upcoming on group regular   *//* Update ADC state machine *//* Update state machine on conversion status if not in error state *//* Retrieve ADC handle corresponding to current DMA handle *//**
  * @brief  DMA transfer complete callback. 
  * @param  hdma pointer to a DMA_HandleTypeDef structure that contains
  *                the configuration information for the specified DMA module.
  * @retval None
  *//* Enable or disable ADC end of conversion selection *//* Enable or disable ADC DMA continuous request *//* Set ADC number of conversion *//* Disable the selected ADC regular discontinuous mode *//* Set the number of channels to be converted in discontinuous mode *//* Enable the selected ADC regular discontinuous mode *//* Enable or disable ADC continuous conversion mode *//* Reset the external trigger *//* Select external trigger polarity *//* Select external trigger to start conversion *//*       software start.                                                  *//*       ExternalTrigConvEdge "trigger edge none" equivalent to           *//* Note: This configuration keeps the hardware feature of parameter       *//* start.                                                                 *//* Enable external trigger if trigger selection is different of software  *//* Set ADC data alignment *//* Set ADC resolution *//* Set ADC scan mode *//* Set the ADC clock prescaler *//* Set ADC parameters *//**
  * @brief  Initializes the ADCx peripheral according to the specified parameters 
  *         in the ADC_InitStruct without initializing the ADC MSP.       
  * @param  hadc pointer to a ADC_HandleTypeDef structure that contains
  *         the configuration information for the specified ADC.  
  * @retval None
  *//**
  * @brief  Return the ADC error code
  * @param  hadc pointer to a ADC_HandleTypeDef structure that contains
  *         the configuration information for the specified ADC.
  * @retval ADC Error Code
  *//* Return ADC state *//**
  * @brief  return the ADC state
  * @param  hadc pointer to a ADC_HandleTypeDef structure that contains
  *         the configuration information for the specified ADC.
  * @retval HAL state
  *//** @defgroup ADC_Exported_Functions_Group4 ADC Peripheral State functions
 *  @brief   ADC Peripheral State functions 
 *
@verbatim   
 ===============================================================================
            ##### Peripheral State and errors functions #####
 ===============================================================================  
    [..]
    This subsection provides functions allowing to
      (+) Check the ADC state
      (+) Check the ADC Error
         
@endverbatim
  * @{
  *//* Process unlocked *//* Set the Analog watchdog channel *//* Clear the Analog watchdog channel select bits *//* Set the low threshold *//* Set the high threshold *//* Set the analog watchdog enable mode *//* Clear AWDEN, JAWDEN and AWDSGL bits *//* Disable the ADC Analog watchdog interrupt *//* Enable the ADC Analog watchdog interrupt *//* Process locked *//* USE_FULL_ASSERT  *//* Check the parameters *//**
  * @brief  Configures the analog watchdog.
  * @note   Analog watchdog thresholds can be modified while ADC conversion
  *         is on going.
  *         In this case, some constraints must be taken into account:
  *         the programmed threshold values are effective from the next
  *         ADC EOC (end of unitary conversion).
  *         Considering that registers write delay may happen due to
  *         bus activity, this might cause an uncertainty on the
  *         effective timing of the new programmed threshold values.
  * @param  hadc pointer to a ADC_HandleTypeDef structure that contains
  *         the configuration information for the specified ADC.
  * @param  AnalogWDGConfig  pointer to an ADC_AnalogWDGConfTypeDef structure 
  *         that contains the configuration information of ADC analog watchdog.
  * @retval HAL status	  
  *//* Compute number of CPU cycles to wait for *//* Delay for temperature sensor stabilization time *//* Enable the TSVREFE channel*//* Disable the VBAT channel as it is multiplixed with TEMPSENSOR channel *//* if ADC1 Channel_18 or Channel_17 is selected enable TSVREFE Channel(Temperature sensor and VREFINT) *//* Enable the VBAT channel*//* Disable the TEMPSENSOR channel as it is multiplixed with the VBAT channel *//* if ADC1 Channel_18 is selected enable VBAT Channel *//* Disable the VBAT & TSVREFE channel*//* if no internal channel selected *//* Set the SQx bits for the selected rank *//* Clear the old SQx bits for the selected rank *//* For Rank 13 to 16 *//* For Rank 7 to 12 *//* For Rank 1 to 6 *//* Set the new sample time *//* Clear the old sample time *//* ADC_Channel include in ADC_Channel_[0..9] *//* if ADC_Channel_10 ... ADC_Channel_18 is selected *//**
  * @brief  Configures for the selected ADC regular channel its corresponding
  *         rank in the sequencer and its sample time.
  * @param  hadc pointer to a ADC_HandleTypeDef structure that contains
  *         the configuration information for the specified ADC.
  * @param  sConfig ADC configuration structure. 
  * @retval HAL status
  *//** @defgroup ADC_Exported_Functions_Group3 Peripheral Control functions
 *  @brief   	Peripheral Control functions 
 *
@verbatim   
 ===============================================================================
             ##### Peripheral Control functions #####
 ===============================================================================  
    [..]  This section provides functions allowing to:
      (+) Configure regular channels. 
      (+) Configure injected channels.
      (+) Configure multimode.
      (+) Configure the analog watch dog.
      
@endverbatim
  * @{
  *//* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_ADC_ErrorCallback could be implemented in the user file
   *//* Prevent unused argument(s) compilation warning *//**
  * @brief  Error ADC callback.
  * @note   In case of error due to overrun when using ADC with DMA transfer 
  *         (HAL ADC handle parameter "ErrorCode" to state "HAL_ADC_ERROR_OVR"):
  *         - Reinitialize the DMA using function "HAL_ADC_Stop_DMA()".
  *         - If needed, restart a new ADC conversion using function
  *           "HAL_ADC_Start_DMA()"
  *           (this function is also clearing overrun flag)
  * @param  hadc pointer to a ADC_HandleTypeDef structure that contains
  *         the configuration information for the specified ADC.
  * @retval None
  *//* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_ADC_LevelOoutOfWindowCallback could be implemented in the user file
   *//**
  * @brief  Analog watchdog callback in non blocking mode 
  * @param  hadc pointer to a ADC_HandleTypeDef structure that contains
  *         the configuration information for the specified ADC.
  * @retval None
  *//* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_ADC_ConvHalfCpltCallback could be implemented in the user file
   *//**
  * @brief  Regular conversion half DMA transfer callback in non blocking mode 
  * @param  hadc pointer to a ADC_HandleTypeDef structure that contains
  *         the configuration information for the specified ADC.
  * @retval None
  *//* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_ADC_ConvCpltCallback could be implemented in the user file
   *//**
  * @brief  Regular conversion complete callback in non blocking mode 
  * @param  hadc pointer to a ADC_HandleTypeDef structure that contains
  *         the configuration information for the specified ADC.
  * @retval None
  *//* Return the selected ADC converted value *//**
  * @brief  Gets the converted value from data register of regular channel.
  * @param  hadc pointer to a ADC_HandleTypeDef structure that contains
  *         the configuration information for the specified ADC.
  * @retval Converted value
  *//* Disable ADC overrun interrupt *//* Update ADC state machine to error *//* Check if DMA channel effectively disabled *//* DMA transfer is on going)                                              *//* Disable the DMA channel (in case of DMA in circular mode or stop while *//* Disable the selected ADC DMA mode *//* Check if ADC is effectively disabled *//* Disable ADC peripheral *//* Stop potential conversion on going, on regular and injected groups *//**
  * @brief  Disables ADC DMA (Single-ADC mode) and disables ADC peripheral    
  * @param  hadc pointer to a ADC_HandleTypeDef structure that contains
  *         the configuration information for the specified ADC.
  * @retval HAL status
  *//* Set ADC error code to ADC IP internal error *//* Enable the selected ADC software conversion for regular group *//* if instance of handle correspond to ADC3 and  no external trigger present enable software conversion of regular channels *//* check if the mode selected is not triple *//* if dual mode is selected, ADC3 works independently. *//* if instance of handle correspond to ADC1 and  no external trigger present enable software conversion of regular channels *//* if no external trigger present enable software conversion of regular channels *//* Check if Multimode enabled *//* Start the DMA channel *//* Enable ADC DMA mode *//* Enable ADC overrun interrupt *//* (To ensure of no unknown state from potential previous ADC operations) *//* Clear regular group conversion flag and overrun flag *//* start (in case of SW start):                                           *//* Manage ADC and DMA start: ADC overrun interruption, DMA start, ADC     *//* Set the DMA error callback *//* Set the DMA half transfer complete callback *//* Set the DMA transfer complete callback *//* interruption, to let the process to ADC IRQ Handler.                   *//* Unlock before starting ADC conversions: in case of potential           *//* Reset ADC all error code fields *//* Reset ADC error code fields related to conversions on group regular *//* State machine update: Check if an injected conversion is ongoing *//* update ADC state.                                                      *//* If conversions on group regular are also triggering group injected,    *//* - Set state bitfield related to regular group operation                *//* - Clear state bitfield related to regular group conversion results     *//* Set ADC state                                                          *//* Start conversion if ADC is effectively enabled *//* Delay for ADC stabilization time *//* Enable the Peripheral *//* Check if ADC peripheral is disabled in order to enable it and wait during 
     Tstab time the ADC's stabilization *//* Enable the ADC peripheral *//**
  * @brief  Enables ADC DMA request after last transfer (Single-ADC mode) and enables ADC peripheral  
  * @param  hadc pointer to a ADC_HandleTypeDef structure that contains
  *         the configuration information for the specified ADC.
  * @param  pData The destination Buffer address.
  * @param  Length The length of data to be transferred from ADC peripheral to memory.
  * @retval HAL status
  *//* Clear the Overrun flag *//* Clear ADC overrun flag *//* Set ADC error code to overrun *//*       details.                                                       *//*       refer to description of parameter "EOCSelection" for more      *//* Note: On STM32F7, ADC overrun can be set through other parameters    *//* Check Overrun flag *//* Clear the ADC analog watchdog flag *//* Level out of window callback *//* Check Analog watchdog flag *//* Clear injected group conversion flag *//* Disable ADC end of single conversion interrupt on group injected *//* interruption disabling above).                                       *//* conversion from group regular (same conditions as group regular      *//* by external trigger, scan sequence on going or by automatic injected *//* Determine whether any further conversion upcoming on group injected  *//* Check End of conversion flag for injected channels *//* Clear regular group conversion flag *//* Check End of conversion flag for regular channels *//**
  * @brief  Handles ADC interrupt request  
  * @param  hadc pointer to a ADC_HandleTypeDef structure that contains
  *         the configuration information for the specified ADC.
  * @retval None
  *//* Disable ADC end of conversion interrupt for regular group *//**
  * @brief  Disables the interrupt and stop ADC conversion of regular channels.
  * 
  * @note   Caution: This function will stop also injected channels.  
  *
  * @param  hadc pointer to a ADC_HandleTypeDef structure that contains
  *         the configuration information for the specified ADC.
  * @retval HAL status.
  *//* Enable end of conversion interrupt for regular group *//**
  * @brief  Enables the interrupt and starts ADC conversion of regular channels.
  * @param  hadc pointer to a ADC_HandleTypeDef structure that contains
  *         the configuration information for the specified ADC.
  * @retval HAL status.
  *//* Overrun event *//* Clear ADC analog watchdog flag *//* Analog watchdog (level out of window) event *//* Update ADC state machine to timeout *//* New check to avoid false timeout detection in case of preemption *//* Check for the Timeout *//* Check selected event flag *//* Get tick *//**
  * @brief  Poll for conversion event
  * @param  hadc pointer to a ADC_HandleTypeDef structure that contains
  *         the configuration information for the specified ADC.
  * @param  EventType the ADC event type.
  *          This parameter can be one of the following values:
  *            @arg ADC_AWD_EVENT: ADC Analog watch Dog event.
  *            @arg ADC_OVR_EVENT: ADC Overrun event.
  * @param  Timeout Timeout value in millisecond.   
  * @retval HAL status
  *//*       of end of sequence.                                                *//*       sequence disabled or with end of conversion flag set to            *//*       The test of scan sequence on going is done either with scan        *//* Note: On STM32F7, there is no independent flag of end of sequence.       *//* by external trigger, continuous mode or scan sequence on going.          *//* Determine whether any further conversion upcoming on group regular       *//* Check if timeout is disabled (set to infinite wait) *//* Check End of conversion flag *//* ADC configured in DMA mode and polling for end of each conversion.     *//* For code simplicity sake, this particular case is generalized to       *//* several ranks and polling for end of each conversion.                  *//* Particular case is ADC configured in DMA mode and ADC sequencer with   *//* each conversion:                                                       *//* Verification that ADC configuration is compliant with polling for      *//**
  * @brief  Poll for regular conversion complete
  * @note   ADC conversion flags EOS (end of sequence) and EOC (end of
  *         conversion) are cleared by this function.
  * @note   This function cannot be used in a particular setup: ADC configured 
  *         in DMA mode and polling for end of each conversion (ADC init
  *         parameter "EOCSelection" set to ADC_EOC_SINGLE_CONV).
  *         In this case, DMA resets the flag EOC and polling cannot be
  *         performed on each conversion. Nevertheless, polling can still 
  *         be performed on the complete sequence.
  * @param  hadc pointer to a ADC_HandleTypeDef structure that contains
  *         the configuration information for the specified ADC.
  * @param  Timeout Timeout value in millisecond.  
  * @retval HAL status
  *//**
  * @brief  Disables ADC and stop conversion of regular channels.
  * 
  * @note   Caution: This function will stop also injected channels.  
  *
  * @param  hadc pointer to a ADC_HandleTypeDef structure that contains
  *         the configuration information for the specified ADC.
  *
  * @retval HAL status.
  *//* if instance of handle correspond to ADC3 and no external trigger present enable software conversion of regular channels *//* Check if ADC peripheral is disabled in order to enable it and wait during 
  Tstab time the ADC's stabilization *//**
  * @brief  Enables ADC and starts conversion of the regular channels.
  * @param  hadc pointer to a ADC_HandleTypeDef structure that contains
  *         the configuration information for the specified ADC.
  * @retval HAL status
  *//** @defgroup ADC_Exported_Functions_Group2 IO operation functions
 *  @brief    IO operation functions 
 *
@verbatim   
 ===============================================================================
             ##### IO operation functions #####
 ===============================================================================  
    [..]  This section provides functions allowing to:
      (+) Start conversion of regular channel.
      (+) Stop conversion of regular channel.
      (+) Start conversion of regular channel and enable interrupt.
      (+) Stop conversion of regular channel and disable interrupt.
      (+) Start conversion of regular channel and enable DMA transfer.
      (+) Stop conversion of regular channel and disable DMA transfer.
      (+) Handle ADC interrupt request. 
               
@endverbatim
  * @{
  *//* Return error status *//* Update the error code *//* Legacy weak MspDeInit            *//* Legacy weak MspInit              *//**
  * @brief  Unregister a ADC Callback
  *         ADC callback is redirected to the weak predefined callback
  * @param  hadc Pointer to a ADC_HandleTypeDef structure that contains
  *                the configuration information for the specified ADC.
  * @param  CallbackID ID of the callback to be unregistered
  *         This parameter can be one of the following values:
  *          @arg @ref HAL_ADC_CONVERSION_COMPLETE_CB_ID      ADC conversion complete callback ID
  *          @arg @ref HAL_ADC_CONVERSION_HALF_CB_ID          ADC conversion DMA half-transfer callback ID
  *          @arg @ref HAL_ADC_LEVEL_OUT_OF_WINDOW_1_CB_ID    ADC analog watchdog 1 callback ID
  *          @arg @ref HAL_ADC_ERROR_CB_ID                    ADC error callback ID
  *          @arg @ref HAL_ADC_INJ_CONVERSION_COMPLETE_CB_ID  ADC group injected conversion complete callback ID
  *          @arg @ref HAL_ADC_INJ_QUEUE_OVEFLOW_CB_ID        ADC group injected context queue overflow callback ID
  *          @arg @ref HAL_ADC_MSPINIT_CB_ID                  ADC Msp Init callback ID
  *          @arg @ref HAL_ADC_MSPDEINIT_CB_ID                ADC Msp DeInit callback ID
  * @retval HAL status
  *//**
  * @brief  Register a User ADC Callback
  *         To be used instead of the weak predefined callback
  * @param  hadc Pointer to a ADC_HandleTypeDef structure that contains
  *                the configuration information for the specified ADC.
  * @param  CallbackID ID of the callback to be registered
  *         This parameter can be one of the following values:
  *          @arg @ref HAL_ADC_CONVERSION_COMPLETE_CB_ID      ADC conversion complete callback ID
  *          @arg @ref HAL_ADC_CONVERSION_HALF_CB_ID          ADC conversion DMA half-transfer callback ID
  *          @arg @ref HAL_ADC_LEVEL_OUT_OF_WINDOW_1_CB_ID    ADC analog watchdog 1 callback ID
  *          @arg @ref HAL_ADC_ERROR_CB_ID                    ADC error callback ID
  *          @arg @ref HAL_ADC_INJ_CONVERSION_COMPLETE_CB_ID  ADC group injected conversion complete callback ID
  *          @arg @ref HAL_ADC_INJ_QUEUE_OVEFLOW_CB_ID        ADC group injected context queue overflow callback ID
  *          @arg @ref HAL_ADC_MSPINIT_CB_ID                  ADC Msp Init callback ID
  *          @arg @ref HAL_ADC_MSPDEINIT_CB_ID                ADC Msp DeInit callback ID
  * @param  pCallback pointer to the Callback function
  * @retval HAL status
  *//* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_ADC_MspDeInit could be implemented in the user file
   *//**
  * @brief  DeInitializes the ADC MSP.
  * @param  hadc pointer to a ADC_HandleTypeDef structure that contains
  *         the configuration information for the specified ADC.  
  * @retval None
  *//* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_ADC_MspInit could be implemented in the user file
   *//**
  * @brief  Initializes the ADC MSP.
  * @param  hadc pointer to a ADC_HandleTypeDef structure that contains
  *         the configuration information for the specified ADC.  
  * @retval None
  *//* Set ADC error code to none *//* DeInit the low level hardware: RCC clock, NVIC *//* Legacy weak MspDeInit  *//* correctly completed.                                                     *//* Configuration of ADC parameters if previous preliminary actions are      *//* Check ADC handle *//**
  * @brief  Deinitializes the ADCx peripheral registers to their default reset values. 
  * @param  hadc pointer to a ADC_HandleTypeDef structure that contains
  *         the configuration information for the specified ADC.  
  * @retval HAL status
  *//* Release Lock *//* Set the ADC state *//* Allocate lock resource and initialize it *//* Initialize ADC error code *//* Legacy weak MspInit  *//* Legacy weak callback *//* Init the ADC Callback settings *//**
  * @brief  Initializes the ADCx peripheral according to the specified parameters 
  *         in the ADC_InitStruct and initializes the ADC MSP.
  *           
  * @note   This function is used to configure the global features of the ADC ( 
  *         ClockPrescaler, Resolution, Data Alignment and number of conversion), however,
  *         the rest of the configuration parameters are specific to the regular
  *         channels group (scan mode activation, continuous mode activation,
  *         External trigger source and edge, DMA continuous request after the  
  *         last transfer and End of conversion selection).
  *             
  * @param  hadc pointer to a ADC_HandleTypeDef structure that contains
  *         the configuration information for the specified ADC.  
  * @retval HAL status
  *//** @defgroup ADC_Exported_Functions_Group1 Initialization and de-initialization functions 
 *  @brief    Initialization and Configuration functions 
 *
@verbatim    
 ===============================================================================
              ##### Initialization and de-initialization functions #####
 ===============================================================================
    [..]  This section provides functions allowing to:
      (+) Initialize and configure the ADC. 
      (+) De-initialize the ADC. 
         
@endverbatim
  * @{
  *//** @defgroup ADC_Exported_Functions ADC Exported Functions
  * @{
  *//** @addtogroup ADC_Private_Functions
  * @{
  *//** @defgroup ADC ADC
  * @brief ADC driver modules
  * @{
  *//**
  ******************************************************************************
  * @file    stm32f7xx_hal_adc.c
  * @author  MCD Application Team
  * @brief   This file provides firmware functions to manage the following 
  *          functionalities of the Analog to Digital Converter (ADC) peripheral:
  *           + Initialization and de-initialization functions
  *           + Peripheral Control functions
  *           + Peripheral State functions
  *
  ******************************************************************************
  * @attention
  *
  * Copyright (c) 2017 STMicroelectronics.
  * All rights reserved.
  *
  * This software is licensed under terms that can be found in the LICENSE file
  * in the root directory of this software component.
  * If no LICENSE file comes with this software, it is provided AS-IS.
  *
  ******************************************************************************
  @verbatim
  ==============================================================================
                    ##### ADC Peripheral features #####
  ==============================================================================
  [..] 
  (#) 12-bit, 10-bit, 8-bit or 6-bit configurable resolution.
  (#) Interrupt generation at the end of conversion, end of injected conversion,  
      and in case of analog watchdog or overrun events
  (#) Single and continuous conversion modes.
  (#) Scan mode for automatic conversion of channel 0 to channel x.
  (#) Data alignment with in-built data coherency.
  (#) Channel-wise programmable sampling time.
  (#) External trigger option with configurable polarity for both regular and 
      injected conversion.
  (#) Dual/Triple mode (on devices with 2 ADCs or more).
  (#) Configurable DMA data storage in Dual/Triple ADC mode. 
  (#) Configurable delay between conversions in Dual/Triple interleaved mode.
  (#) ADC conversion type (refer to the datasheets).
  (#) ADC supply requirements: 2.4 V to 3.6 V at full speed and down to 1.8 V at 
      slower speed.
  (#) ADC input range: VREF(minus) = VIN = VREF(plus).
  (#) DMA request generation during regular channel conversion.


                     ##### How to use this driver #####
  ==============================================================================
  [..]
  (#)Initialize the ADC low level resources by implementing the HAL_ADC_MspInit():
       (##) Enable the ADC interface clock using __HAL_RCC_ADC_CLK_ENABLE()
       (##) ADC pins configuration
             (+++) Enable the clock for the ADC GPIOs using the following function:
                   __HAL_RCC_GPIOx_CLK_ENABLE()  
             (+++) Configure these ADC pins in analog mode using HAL_GPIO_Init() 
       (##) In case of using interrupts (e.g. HAL_ADC_Start_IT())
             (+++) Configure the ADC interrupt priority using HAL_NVIC_SetPriority()
             (+++) Enable the ADC IRQ handler using HAL_NVIC_EnableIRQ()
             (+++) In ADC IRQ handler, call HAL_ADC_IRQHandler()
       (##) In case of using DMA to control data transfer (e.g. HAL_ADC_Start_DMA())
             (+++) Enable the DMAx interface clock using __HAL_RCC_DMAx_CLK_ENABLE()
             (+++) Configure and enable two DMA streams stream for managing data
                 transfer from peripheral to memory (output stream)
             (+++) Associate the initialized DMA handle to the CRYP DMA handle
                 using  __HAL_LINKDMA()
             (+++) Configure the priority and enable the NVIC for the transfer complete
                 interrupt on the two DMA Streams. The output stream should have higher
                 priority than the input stream.
                       
    *** Configuration of ADC, groups regular/injected, channels parameters ***
  ==============================================================================
  [..]
  (#) Configure the ADC parameters (resolution, data alignment, ...)
      and regular group parameters (conversion trigger, sequencer, ...)
      using function HAL_ADC_Init().

  (#) Configure the channels for regular group parameters (channel number, 
      channel rank into sequencer, ..., into regular group)
      using function HAL_ADC_ConfigChannel().

  (#) Optionally, configure the injected group parameters (conversion trigger, 
      sequencer, ..., of injected group)
      and the channels for injected group parameters (channel number, 
      channel rank into sequencer, ..., into injected group)
      using function HAL_ADCEx_InjectedConfigChannel().

  (#) Optionally, configure the analog watchdog parameters (channels
      monitored, thresholds, ...) using function HAL_ADC_AnalogWDGConfig().

  (#) Optionally, for devices with several ADC instances: configure the 
      multimode parameters using function HAL_ADCEx_MultiModeConfigChannel().

                       *** Execution of ADC conversions ***
  ==============================================================================
  [..]  
  (#) ADC driver can be used among three modes: polling, interruption,
      transfer by DMA.    

     *** Polling mode IO operation ***
     =================================
     [..]    
       (+) Start the ADC peripheral using HAL_ADC_Start() 
       (+) Wait for end of conversion using HAL_ADC_PollForConversion(), at this stage
           user can specify the value of timeout according to his end application      
       (+) To read the ADC converted values, use the HAL_ADC_GetValue() function.
       (+) Stop the ADC peripheral using HAL_ADC_Stop()
       
     *** Interrupt mode IO operation ***    
     ===================================
     [..]    
       (+) Start the ADC peripheral using HAL_ADC_Start_IT() 
       (+) Use HAL_ADC_IRQHandler() called under ADC_IRQHandler() Interrupt subroutine
       (+) At ADC end of conversion HAL_ADC_ConvCpltCallback() function is executed and user can 
           add his own code by customization of function pointer HAL_ADC_ConvCpltCallback 
       (+) In case of ADC Error, HAL_ADC_ErrorCallback() function is executed and user can 
           add his own code by customization of function pointer HAL_ADC_ErrorCallback
       (+) Stop the ADC peripheral using HAL_ADC_Stop_IT()     

     *** DMA mode IO operation ***    
     ==============================
     [..]    
       (+) Start the ADC peripheral using HAL_ADC_Start_DMA(), at this stage the user specify the length 
           of data to be transferred at each end of conversion 
       (+) At The end of data transfer by HAL_ADC_ConvCpltCallback() function is executed and user can 
           add his own code by customization of function pointer HAL_ADC_ConvCpltCallback 
       (+) In case of transfer Error, HAL_ADC_ErrorCallback() function is executed and user can 
           add his own code by customization of function pointer HAL_ADC_ErrorCallback
       (+) Stop the ADC peripheral using HAL_ADC_Stop_DMA()
                    
     *** ADC HAL driver macros list ***
     ============================================= 
     [..]
       Below the list of most used macros in ADC HAL driver.
       
      (+) __HAL_ADC_ENABLE : Enable the ADC peripheral
      (+) __HAL_ADC_DISABLE : Disable the ADC peripheral
      (+) __HAL_ADC_ENABLE_IT: Enable the ADC end of conversion interrupt
      (+) __HAL_ADC_DISABLE_IT: Disable the ADC end of conversion interrupt
      (+) __HAL_ADC_GET_IT_SOURCE: Check if the specified ADC interrupt source is enabled or disabled
      (+) __HAL_ADC_CLEAR_FLAG: Clear the ADC's pending flags
      (+) __HAL_ADC_GET_FLAG: Get the selected ADC's flag status
      (+) ADC_GET_RESOLUTION: Return resolution bits in CR1 register 
      
     *** Callback functions ***
     ==============================
     [..]
      (@) Callback functions must be implemented in user program:
      (+@) HAL_ADC_ErrorCallback()
      (+@) HAL_ADC_LevelOutOfWindowCallback() (callback of analog watchdog)
      (+@) HAL_ADC_ConvCpltCallback()
      (+@) HAL_ADC_ConvHalfCpltCallback

       (@) You can refer to the ADC HAL driver header file for more useful macros 

                      *** Deinitialization of ADC ***
  ==============================================================================
  [..]
  (#) Disable the ADC interface
     (++) ADC clock can be hard reset and disabled at RCC top level.
     (++) Hard reset of ADC peripherals
          using macro __HAL_RCC_ADC_FORCE_RESET(), __HAL_RCC_ADC_RELEASE_RESET().
     (++) ADC clock disable using the equivalent macro/functions as configuration step.
               (+++) Example:
                   Into HAL_ADC_MspDeInit() (recommended code location) or with
                   other device clock parameters configuration:
               (+++) HAL_RCC_GetOscConfig(&RCC_OscInitStructure);
               (+++) RCC_OscInitStructure.OscillatorType = RCC_OSCILLATORTYPE_HSI;
               (+++) RCC_OscInitStructure.HSIState = RCC_HSI_OFF; (if not used for system clock)
               (+++) HAL_RCC_OscConfig(&RCC_OscInitStructure);

  (#) ADC pins configuration
     (++) Disable the clock for the ADC GPIOs using macro __HAL_RCC_GPIOx_CLK_DISABLE()

  (#) Optionally, in case of usage of ADC with interruptions:
     (++) Disable the NVIC for ADC using function HAL_NVIC_DisableIRQ(ADCx_IRQn)

  (#) Optionally, in case of usage of DMA:
        (++) Deinitialize the DMA using function HAL_DMA_DeInit().
        (++) Disable the NVIC for DMA using function HAL_NVIC_DisableIRQ(DMAx_Channelx_IRQn)   

                      *** Callback registration ***
  ==============================================================================
    [..]

     The compilation flag USE_HAL_ADC_REGISTER_CALLBACKS, when set to 1,
     allows the user to configure dynamically the driver callbacks.
     Use Functions HAL_ADC_RegisterCallback()
     to register an interrupt callback.
    [..]

     Function HAL_ADC_RegisterCallback() allows to register following callbacks:
       (+) ConvCpltCallback               : ADC conversion complete callback
       (+) ConvHalfCpltCallback           : ADC conversion DMA half-transfer callback
       (+) LevelOutOfWindowCallback       : ADC analog watchdog 1 callback
       (+) ErrorCallback                  : ADC error callback
       (+) InjectedConvCpltCallback       : ADC group injected conversion complete callback
       (+) InjectedQueueOverflowCallback  : ADC group injected context queue overflow callback
       (+) LevelOutOfWindow2Callback      : ADC analog watchdog 2 callback
       (+) LevelOutOfWindow3Callback      : ADC analog watchdog 3 callback
       (+) EndOfSamplingCallback          : ADC end of sampling callback
       (+) MspInitCallback                : ADC Msp Init callback
       (+) MspDeInitCallback              : ADC Msp DeInit callback
     This function takes as parameters the HAL peripheral handle, the Callback ID
     and a pointer to the user callback function.
    [..]

     Use function HAL_ADC_UnRegisterCallback to reset a callback to the default
     weak function.
    [..]

     HAL_ADC_UnRegisterCallback takes as parameters the HAL peripheral handle,
     and the Callback ID.
     This function allows to reset following callbacks:
       (+) ConvCpltCallback               : ADC conversion complete callback
       (+) ConvHalfCpltCallback           : ADC conversion DMA half-transfer callback
       (+) LevelOutOfWindowCallback       : ADC analog watchdog 1 callback
       (+) ErrorCallback                  : ADC error callback
       (+) InjectedConvCpltCallback       : ADC group injected conversion complete callback
       (+) InjectedQueueOverflowCallback  : ADC group injected context queue overflow callback
       (+) LevelOutOfWindow2Callback      : ADC analog watchdog 2 callback
       (+) LevelOutOfWindow3Callback      : ADC analog watchdog 3 callback
       (+) EndOfSamplingCallback          : ADC end of sampling callback
       (+) MspInitCallback                : ADC Msp Init callback
       (+) MspDeInitCallback              : ADC Msp DeInit callback
     [..]

     By default, after the HAL_ADC_Init() and when the state is HAL_ADC_STATE_RESET
     all callbacks are set to the corresponding weak functions:
     examples HAL_ADC_ConvCpltCallback(), HAL_ADC_ErrorCallback().
     Exception done for MspInit and MspDeInit functions that are
     reset to the legacy weak functions in the HAL_ADC_Init()/ HAL_ADC_DeInit() only when
     these callbacks are null (not registered beforehand).
    [..]

     If MspInit or MspDeInit are not null, the HAL_ADC_Init()/ HAL_ADC_DeInit()
     keep and use the user MspInit/MspDeInit callbacks (registered beforehand) whatever the state.
     [..]

     Callbacks can be registered/unregistered in HAL_ADC_STATE_READY state only.
     Exception done MspInit/MspDeInit functions that can be registered/unregistered
     in HAL_ADC_STATE_READY or HAL_ADC_STATE_RESET state,
     thus registered (user) MspInit/DeInit callbacks can be used during the Init/DeInit.
    [..]

     Then, the user first registers the MspInit/MspDeInit user callbacks
     using HAL_ADC_RegisterCallback() before calling HAL_ADC_DeInit()
     or HAL_ADC_Init() function.
     [..]

     When the compilation flag USE_HAL_ADC_REGISTER_CALLBACKS is set to 0 or
     not defined, the callback registration feature is not available and all callbacks
     are set to the corresponding weak functions.

    @endverbatim
  ******************************************************************************
  *//Users/jie/Documents/posixGen_Demos-main/LwIP_StreamingServer/Drivers/STM32F7xx_HAL_Driver/Src/stm32f7xx_hal_adc_ex.cADC_MultiModeDMAErrorADC_MultiModeDMAHalfConvCpltADC_MultiModeDMAConvCpltIS_ADC_MODE(multimode->Mode)IS_ADC_DMA_ACCESS_MODE(multimode->DMAAccessMode)IS_ADC_SAMPLING_DELAY(multimode->TwoSamplingDelay)(ADC_CCR_MULTI)~(ADC_CCR_MULTI)49152(ADC_CCR_DMA)4294918143~(ADC_CCR_DMA)(ADC_CCR_DELAY)4294963455~(ADC_CCR_DELAY)IS_ADC_CHANNEL(sConfigInjected->InjectedChannel)IS_ADC_INJECTED_RANK(sConfigInjected->InjectedRank)IS_ADC_SAMPLE_TIME(sConfigInjected->InjectedSamplingTime)IS_ADC_EXT_INJEC_TRIG(sConfigInjected->ExternalTrigInjecConv)IS_ADC_INJECTED_LENGTH(sConfigInjected->InjectedNbrOfConversion)IS_FUNCTIONAL_STATE(sConfigInjected->AutoInjectedConv)IS_FUNCTIONAL_STATE(sConfigInjected->InjectedDiscontinuousConvMode)IS_ADC_EXT_INJEC_TRIG_EDGE(sConfigInjected->ExternalTrigInjecConvEdge)983040983041sConfigInjected->InjectedChannelsConfigInjected->InjectedSamplingTime(ADC_JSQR_JL)4291821567~(ADC_JSQR_JL)sConfigInjected->InjectedNbrOfConversionsConfigInjected->InjectedRank(ADC_CR2_JEXTSEL)4293984255~(ADC_CR2_JEXTSEL)(ADC_CR2_JEXTEN)~(ADC_CR2_JEXTEN)(ADC_CR1_JAUTO)~(ADC_CR1_JAUTO)(ADC_CR1_JDISCEN)~(ADC_CR1_JDISCEN)(ADC_JOFR1_JOFFSET1)4294963200~(ADC_JOFR1_JOFFSET1)(ADC_JOFR2_JOFFSET2)~(ADC_JOFR2_JOFFSET2)(ADC_JOFR3_JOFFSET3)~(ADC_JOFR3_JOFFSET3)(ADC_JOFR4_JOFFSET4)~(ADC_JOFR4_JOFFSET4)~ADC_CCR_DDS1073816328&ADC->CDR(uint32_t)&ADC->CDRIS_ADC_INJECTED_RANK(InjectedRank)((uint32_t)(0x1UL << (2U)))ADC_FLAG_JSTRT | ADC_FLAG_JEOC((uint32_t)(0x1UL << (3U))) | ((uint32_t)(0x1UL << (2U)))HAL_ADC_STATE_READY | HAL_ADC_STATE_INJ_EOC((uint32_t)0x00000001U) | ((uint32_t)0x00002000U)(((READ_REG(hadc->State)) & (~(((uint32_t)0x00000001U) | ((uint32_t)0x00002000U)))) | (((uint32_t)0x00001000U)))(((((hadc->State))) & (~(((uint32_t)0x00000001U) | ((uint32_t)0x00002000U)))) | (((uint32_t)0x00001000U)))81934294959102/* Set delay between two sampling phases *//* Set the ADC DMA access mode *//* Set ADC mode *//**
  * @brief  Configures the ADC multi-mode 
  * @param  hadc       pointer to a ADC_HandleTypeDef structure that contains
  *                     the configuration information for the specified ADC.  
  * @param  multimode  pointer to an ADC_MultiModeTypeDef structure that contains 
  *                     the configuration information for  multimode.
  * @retval HAL status
  *//* if ADC1 Channel_16 or Channel_17 is selected enable TSVREFE Channel(Temperature sensor and VREFINT) *//* Set injected channel 4 offset *//* Set injected channel 3 offset *//* Set injected channel 2 offset *//* Set injected channel 1 offset *//* Disable the selected ADC injected discontinuous mode *//* Enable the selected ADC injected discontinuous mode *//* Disable the selected ADC automatic injected group conversion *//* Enable the selected ADC automatic injected group conversion *//* Rank configuration *//*---------------------------- ADCx JSQR Configuration -----------------*//**
  * @brief  Configures for the selected ADC injected channel its corresponding
  *         rank in the sequencer and its sample time.
  * @param  hadc pointer to a ADC_HandleTypeDef structure that contains
  *         the configuration information for the specified ADC.
  * @param  sConfigInjected ADC configuration structure for injected channel. 
  * @retval None
  *//* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_ADC_InjectedConvCpltCallback could be implemented in the user file
   *//**
  * @brief  Injected conversion complete callback in non blocking mode 
  * @param  hadc pointer to a ADC_HandleTypeDef structure that contains
  *         the configuration information for the specified ADC.
  * @retval None
  *//* Return the multi mode conversion value *//**
  * @brief  Returns the last ADC1, ADC2 and ADC3 regular conversions results 
  *         data in the selected multi mode.
  * @param  hadc pointer to a ADC_HandleTypeDef structure that contains
  *         the configuration information for the specified ADC.
  * @retval The converted data value.
  *//* Disable the selected ADC DMA mode for multimode *//**
  * @brief  Disables ADC DMA (multi-ADC mode) and disables ADC peripheral    
  * @param  hadc pointer to a ADC_HandleTypeDef structure that contains
  *         the configuration information for the specified ADC.
  * @retval HAL status
  *//* Enable the DMA Stream *//* Disable the selected ADC EOC rising on each regular channel conversion *//* Enable the selected ADC DMA request after last transfer *//**
  * @brief  Enables ADC DMA request after last transfer (Multi-ADC mode) and enables ADC peripheral
  * 
  * @note   Caution: This function must be used only with the ADC master.  
  *
  * @param  hadc pointer to a ADC_HandleTypeDef structure that contains
  *         the configuration information for the specified ADC.
  * @param  pData   Pointer to buffer in which transferred from ADC peripheral to memory will be stored. 
  * @param  Length  The length of data to be transferred from ADC peripheral to memory.  
  * @retval HAL status
  *//* regular group: reading data register also clears end of conversion flag. *//* Clear injected group conversion flag to have similar behaviour as        *//**
  * @brief  Gets the converted value from data register of injected channel.
  * @param  hadc pointer to a ADC_HandleTypeDef structure that contains
  *         the configuration information for the specified ADC.
  * @param  InjectedRank the ADC injected rank.
  *          This parameter can be one of the following values:
  *            @arg ADC_INJECTED_RANK_1: Injected Channel1 selected
  *            @arg ADC_INJECTED_RANK_2: Injected Channel2 selected
  *            @arg ADC_INJECTED_RANK_3: Injected Channel3 selected
  *            @arg ADC_INJECTED_RANK_4: Injected Channel4 selected
  * @retval None
  *//* Disable ADC end of conversion interrupt for injected channels *//* - In case of auto-injection mode, HAL_ADC_Stop must be used.             *//*   are common)                                                            *//*   continue (injected and regular groups stop conversion and ADC disable  *//* - No conversion on the other group (regular group) is intended to        *//* Conditioned to:                                                          *//* Stop potential conversion and disable ADC peripheral                     *//**
  * @brief  Stop conversion of injected channels, disable interruption of 
  *         end-of-conversion. Disable ADC peripheral if no regular conversion
  *         is on going.
  * @note   If ADC must be disabled and if conversion is on going on 
  *         regular group, function HAL_ADC_Stop must be used to stop both
  *         injected and regular groups, and disable the ADC.
  * @note   If injected group mode auto-injection is enabled,
  *         function HAL_ADC_Stop must be used.
  * @param  hadc ADC handle
  * @retval None
  *//* Determine whether any further conversion upcoming on group injected      *//**
  * @brief  Poll for injected conversion complete
  * @param  hadc pointer to a ADC_HandleTypeDef structure that contains
  *         the configuration information for the specified ADC.
  * @param  Timeout Timeout value in millisecond.  
  * @retval HAL status
  *//**
  * @brief  Stop conversion of injected channels. Disable ADC peripheral if
  *         no regular conversion is on going.
  * @note   If ADC must be disabled and if conversion is on going on 
  *         regular group, function HAL_ADC_Stop must be used to stop both
  *         injected and regular groups, and disable the ADC.
  * @note   If injected group mode auto-injection is enabled,
  *         function HAL_ADC_Stop must be used.
  * @note   In case of auto-injection mode, HAL_ADC_Stop must be used.
  * @param  hadc ADC handle
  * @retval None
  *//* Enable the selected ADC software conversion for injected group *//* Enable end of conversion interrupt for injected channels *//*       going on group regular, no error code is reset.                  *//*       conversions on group injected only. In case of conversion on     *//* Note: On this device, there is no ADC error code fields related to     *//* Check if a regular conversion is ongoing *//* - Set state bitfield related to injected operation                     *//* - Clear state bitfield related to injected group conversion results    *//**
  * @brief  Enables the interrupt and starts ADC conversion of injected channels.
  * @param  hadc pointer to a ADC_HandleTypeDef structure that contains
  *         the configuration information for the specified ADC.
  *
  * @retval HAL status.
  *//**
  * @brief  Enables the selected ADC software start conversion of the injected channels.
  * @param  hadc pointer to a ADC_HandleTypeDef structure that contains
  *         the configuration information for the specified ADC.
  * @retval HAL status
  *//** @defgroup ADCEx_Exported_Functions_Group1  Extended features functions 
  *  @brief    Extended features functions  
  *
@verbatim   
 ===============================================================================
                 ##### Extended features functions #####
 ===============================================================================  
    [..]  This section provides functions allowing to:
      (+) Start conversion of injected channel.
      (+) Stop conversion of injected channel.
      (+) Start multimode and enable DMA transfer.
      (+) Stop multimode and disable DMA transfer.
      (+) Get result of injected channel conversion.
      (+) Get result of multimode conversion.
      (+) Configure injected channels.
      (+) Configure multimode.
               
@endverbatim
  * @{
  *//** @defgroup ADCEx_Exported_Functions ADC Exported Functions
  * @{
  *//** @addtogroup ADCEx_Private_Functions
  * @{
  *//** @defgroup ADCEx ADCEx
  * @brief ADC Extended driver modules
  * @{
  *//**
  ******************************************************************************
  * @file    stm32f7xx_hal_adc_ex.c
  * @author  MCD Application Team
  * @brief   This file provides firmware functions to manage the following 
  *          functionalities of the ADC extension peripheral:
  *           + Extended features functions
  *
  ******************************************************************************
  * @attention
  *
  * Copyright (c) 2017 STMicroelectronics.
  * All rights reserved.
  *
  * This software is licensed under terms that can be found in the LICENSE file
  * in the root directory of this software component.
  * If no LICENSE file comes with this software, it is provided AS-IS.
  *
  ******************************************************************************
  @verbatim
  ==============================================================================
                    ##### How to use this driver #####
  ==============================================================================
    [..]
    (#)Initialize the ADC low level resources by implementing the HAL_ADC_MspInit():
       (##) Enable the ADC interface clock using __HAL_RCC_ADC_CLK_ENABLE()
       (##) ADC pins configuration
             (+++) Enable the clock for the ADC GPIOs using the following function:
                   __HAL_RCC_GPIOx_CLK_ENABLE()
             (+++) Configure these ADC pins in analog mode using HAL_GPIO_Init()
       (##) In case of using interrupts (e.g. HAL_ADC_Start_IT())
             (+++) Configure the ADC interrupt priority using HAL_NVIC_SetPriority()
             (+++) Enable the ADC IRQ handler using HAL_NVIC_EnableIRQ()
             (+++) In ADC IRQ handler, call HAL_ADC_IRQHandler()
      (##) In case of using DMA to control data transfer (e.g. HAL_ADC_Start_DMA())
             (+++) Enable the DMAx interface clock using __HAL_RCC_DMAx_CLK_ENABLE()
             (+++) Configure and enable two DMA streams stream for managing data
                 transfer from peripheral to memory (output stream)
             (+++) Associate the initialized DMA handle to the ADC DMA handle
                 using  __HAL_LINKDMA()
             (+++) Configure the priority and enable the NVIC for the transfer complete
                 interrupt on the two DMA Streams. The output stream should have higher
                 priority than the input stream.
     (#) Configure the ADC Prescaler, conversion resolution and data alignment
         using the HAL_ADC_Init() function.

     (#) Configure the ADC Injected channels group features, use HAL_ADC_Init()
         and HAL_ADC_ConfigChannel() functions.

     (#) Three operation modes are available within this driver :

     *** Polling mode IO operation ***
     =================================
     [..]
       (+) Start the ADC peripheral using HAL_ADCEx_InjectedStart()
       (+) Wait for end of conversion using HAL_ADCEx_InjectedPollForConversion(), at this stage
           user can specify the value of timeout according to his end application
       (+) To read the ADC converted values, use the HAL_ADCEx_InjectedGetValue() function.
       (+) Stop the ADC peripheral using HAL_ADCEx_InjectedStop()

     *** Interrupt mode IO operation ***
     ===================================
     [..]
       (+) Start the ADC peripheral using HAL_ADCEx_InjectedStart_IT()
       (+) Use HAL_ADC_IRQHandler() called under ADC_IRQHandler() Interrupt subroutine
       (+) At ADC end of conversion HAL_ADCEx_InjectedConvCpltCallback() function is executed and user can
            add his own code by customization of function pointer HAL_ADCEx_InjectedConvCpltCallback 
       (+) In case of ADC Error, HAL_ADCEx_InjectedErrorCallback() function is executed and user can 
            add his own code by customization of function pointer HAL_ADCEx_InjectedErrorCallback
       (+) Stop the ADC peripheral using HAL_ADCEx_InjectedStop_IT()

     *** Multi mode ADCs Regular channels configuration ***
     ======================================================
     [..]
       (+) Select the Multi mode ADC regular channels features (dual or triple mode)
          and configure the DMA mode using HAL_ADCEx_MultiModeConfigChannel() functions.
       (+) Start the ADC peripheral using HAL_ADCEx_MultiModeStart_DMA(), at this stage the user specify the length
           of data to be transferred at each end of conversion
       (+) Read the ADCs converted values using the HAL_ADCEx_MultiModeGetValue() function.


    @endverbatim
  ******************************************************************************
  *//Users/jie/Documents/posixGen_Demos-main/LwIP_StreamingServer/Drivers/STM32F7xx_HAL_Driver/Src/stm32f7xx_hal_cortex.cIS_SYSTICK_CLK_SOURCE(CLKSource)~SYSTICK_CLKSOURCE_HCLKIS_NVIC_DEVICE_IRQ(IRQn)IS_NVIC_PRIORITY_GROUP(PriorityGroup)IS_MPU_REGION_NUMBER(MPU_Init->Number)IS_MPU_REGION_ENABLE(MPU_Init->Enable)IS_MPU_INSTRUCTION_ACCESS(MPU_Init->DisableExec)IS_MPU_REGION_PERMISSION_ATTRIBUTE(MPU_Init->AccessPermission)IS_MPU_TEX_LEVEL(MPU_Init->TypeExtField)IS_MPU_ACCESS_SHAREABLE(MPU_Init->IsShareable)IS_MPU_ACCESS_CACHEABLE(MPU_Init->IsCacheable)IS_MPU_ACCESS_BUFFERABLE(MPU_Init->IsBufferable)IS_MPU_SUB_REGION_DISABLE(MPU_Init->SubRegionDisable)IS_MPU_REGION_SIZE(MPU_Init->Size)MPU->RASR((MPU_Type *) ((0xE000E000UL) + 0x0D90UL) )->RASRIS_MPU_REGION_NUMBER(RegionNumber)prioritygroupIS_NVIC_SUB_PRIORITY(SubPriority)IS_NVIC_PREEMPTION_PRIORITY(PreemptPriority)/* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_SYSTICK_Callback could be implemented in the user file
   *//**
  * @brief  SYSTICK callback.
  * @retval None
  *//**
  * @brief  This function handles SYSTICK interrupt request.
  * @retval None
  *//**
  * @brief  Configures the SysTick clock source.
  * @param  CLKSource specifies the SysTick clock source.
  *          This parameter can be one of the following values:
  *             @arg SYSTICK_CLKSOURCE_HCLK_DIV8: AHB clock divided by 8 selected as SysTick clock source.
  *             @arg SYSTICK_CLKSOURCE_HCLK: AHB clock selected as SysTick clock source.
  * @retval None
  *//* Return 1 if active else 0 *//**
  * @brief Gets active interrupt ( reads the active register in NVIC and returns the active bit).
  * @param IRQn External interrupt number
  *         This parameter can be an enumerator of IRQn_Type enumeration
  *         (For the complete STM32 Devices IRQ Channels list, please refer to the appropriate CMSIS device file (stm32f7xxxx.h))
  * @retval status: - 0  Interrupt status is not pending.
  *                 - 1  Interrupt status is pending.
  *//* Clear pending interrupt *//**
  * @brief  Clears the pending bit of an external interrupt.
  * @param  IRQn External interrupt number.
  *         This parameter can be an enumerator of IRQn_Type enumeration
  *         (For the complete STM32 Devices IRQ Channels list, please refer to the appropriate CMSIS device file (stm32f7xxxx.h))
  * @retval None
  *//* Return 1 if pending else 0 *//**
  * @brief  Gets Pending Interrupt (reads the pending register in the NVIC 
  *         and returns the pending bit for the specified interrupt).
  * @param  IRQn External interrupt number.
  *          This parameter can be an enumerator of IRQn_Type enumeration
  *         (For the complete STM32 Devices IRQ Channels list, please refer to the appropriate CMSIS device file (stm32f7xxxx.h))
  * @retval status: - 0  Interrupt status is not pending.
  *                 - 1  Interrupt status is pending.
  *//* Set interrupt pending *//**
  * @brief  Sets Pending bit of an external interrupt.
  * @param  IRQn External interrupt number
  *         This parameter can be an enumerator of IRQn_Type enumeration
  *         (For the complete STM32 Devices IRQ Channels list, please refer to the appropriate CMSIS device file (stm32f7xxxx.h))
  * @retval None
  *//* Get priority for Cortex-M system or device specific interrupts *//**
  * @brief  Gets the priority of an interrupt.
  * @param  IRQn External interrupt number.
  *         This parameter can be an enumerator of IRQn_Type enumeration
  *         (For the complete STM32 Devices IRQ Channels list, please refer to the appropriate CMSIS device file (stm32f7xxxx.h))
  * @param   PriorityGroup the priority grouping bits length.
  *         This parameter can be one of the following values:
  *           @arg NVIC_PRIORITYGROUP_0: 0 bits for preemption priority
  *                                      4 bits for subpriority
  *           @arg NVIC_PRIORITYGROUP_1: 1 bits for preemption priority
  *                                      3 bits for subpriority
  *           @arg NVIC_PRIORITYGROUP_2: 2 bits for preemption priority
  *                                      2 bits for subpriority
  *           @arg NVIC_PRIORITYGROUP_3: 3 bits for preemption priority
  *                                      1 bits for subpriority
  *           @arg NVIC_PRIORITYGROUP_4: 4 bits for preemption priority
  *                                      0 bits for subpriority
  * @param  pPreemptPriority Pointer on the Preemptive priority value (starting from 0).
  * @param  pSubPriority Pointer on the Subpriority value (starting from 0).
  * @retval None
  *//* Get the PRIGROUP[10:8] field value *//**
  * @brief  Gets the priority grouping field from the NVIC Interrupt Controller.
  * @retval Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field)
  *//* Disable the Region *//* Set the Region number *//**
  * @brief  Initializes and configures the Region and the memory to be protected.
  * @param MPU_Init Pointer to a MPU_Region_InitTypeDef structure that contains
  *                the initialization and configuration information.
  * @retval None
  *//**
  * @brief  Disables the MPU Region.
  * @retval None
  *//* Enable the Region *//**
  * @brief  Enables the MPU Region.
  * @retval None
  *//* Ensure MPU setting take effects *//* Enable fault exceptions *//* Enable the MPU *//**
  * @brief  Enables the MPU
  * @param  MPU_Control Specifies the control mode of the MPU during hard fault, 
  *          NMI, FAULTMASK and privileged access to the default memory 
  *          This parameter can be one of the following values:
  *            @arg MPU_HFNMI_PRIVDEF_NONE
  *            @arg MPU_HARDFAULT_NMI
  *            @arg MPU_PRIVILEGED_DEFAULT
  *            @arg MPU_HFNMI_PRIVDEF
  * @retval None
  *//* Disable the MPU and clear the control register*//* Disable fault exceptions *//* Make sure outstanding transfers are done *//**
  * @brief  Disables the MPU
  * @retval None
  *//** @defgroup CORTEX_Exported_Functions_Group2 Peripheral Control functions
 *  @brief   Cortex control functions 
 *
@verbatim   
  ==============================================================================
                      ##### Peripheral Control functions #####
  ==============================================================================  
    [..]
      This subsection provides a set of functions allowing to control the CORTEX
      (NVIC, SYSTICK, MPU) functionalities. 
 
      
@endverbatim
  * @{
  *//**
  * @brief  Initializes the System Timer and its interrupt, and starts the System Tick Timer.
  *         Counter is in free running mode to generate periodic interrupts.
  * @param  TicksNumb Specifies the ticks Number of ticks between two interrupts.
  * @retval status:  - 0  Function succeeded.
  *                  - 1  Function failed.
  *//* System Reset *//**
  * @brief  Initiates a system reset request to reset the MCU.
  * @retval None
  *//* Disable interrupt *//**
  * @brief  Disables a device specific interrupt in the NVIC interrupt controller.
  * @param  IRQn External interrupt number.
  *         This parameter can be an enumerator of IRQn_Type enumeration
  *         (For the complete STM32 Devices IRQ Channels list, please refer to the appropriate CMSIS device file (stm32f7xxxx.h))
  * @retval None
  *//* Enable interrupt *//**
  * @brief  Enables a device specific interrupt in the NVIC interrupt controller.
  * @note   To configure interrupts priority correctly, the NVIC_PriorityGroupConfig()
  *         function should be called before. 
  * @param  IRQn External interrupt number.
  *         This parameter can be an enumerator of IRQn_Type enumeration
  *         (For the complete STM32 Devices IRQ Channels list, please refer to the appropriate CMSIS device file (stm32f7xxxx.h))
  * @retval None
  *//**
  * @brief  Sets the priority of an interrupt.
  * @param  IRQn External interrupt number.
  *         This parameter can be an enumerator of IRQn_Type enumeration
  *         (For the complete STM32 Devices IRQ Channels list, please refer to the appropriate CMSIS device file (stm32f7xxxx.h))
  * @param  PreemptPriority The preemption priority for the IRQn channel.
  *         This parameter can be a value between 0 and 15
  *         A lower priority value indicates a higher priority 
  * @param  SubPriority the subpriority level for the IRQ channel.
  *         This parameter can be a value between 0 and 15
  *         A lower priority value indicates a higher priority.          
  * @retval None
  *//* Set the PRIGROUP[10:8] bits according to the PriorityGroup parameter value *//**
  * @brief  Sets the priority grouping field (preemption priority and subpriority)
  *         using the required unlock sequence.
  * @param  PriorityGroup The priority grouping bits length. 
  *         This parameter can be one of the following values:
  *         @arg NVIC_PRIORITYGROUP_0: 0 bits for preemption priority
  *                                    4 bits for subpriority
  *         @arg NVIC_PRIORITYGROUP_1: 1 bits for preemption priority
  *                                    3 bits for subpriority
  *         @arg NVIC_PRIORITYGROUP_2: 2 bits for preemption priority
  *                                    2 bits for subpriority
  *         @arg NVIC_PRIORITYGROUP_3: 3 bits for preemption priority
  *                                    1 bits for subpriority
  *         @arg NVIC_PRIORITYGROUP_4: 4 bits for preemption priority
  *                                    0 bits for subpriority
  * @note   When the NVIC_PriorityGroup_0 is selected, IRQ preemption is no more possible. 
  *         The pending IRQ priority will be managed only by the subpriority. 
  * @retval None
  *//** @defgroup CORTEX_Exported_Functions_Group1 Initialization and de-initialization functions
 *  @brief    Initialization and Configuration functions 
 *
@verbatim    
  ==============================================================================
              ##### Initialization and de-initialization functions #####
  ==============================================================================
    [..]
      This section provides the CORTEX HAL driver functions allowing to configure Interrupts
      Systick functionalities 

@endverbatim
  * @{
  *//** @defgroup CORTEX_Exported_Functions CORTEX Exported Functions
  * @{
  *//** @defgroup CORTEX CORTEX
  * @brief CORTEX HAL module driver
  * @{
  *//**
  ******************************************************************************
  * @file    stm32f7xx_hal_cortex.c
  * @author  MCD Application Team
  * @brief   CORTEX HAL module driver.
  *          This file provides firmware functions to manage the following 
  *          functionalities of the CORTEX:
  *           + Initialization and de-initialization functions
  *           + Peripheral Control functions 
  *
  @verbatim  
  ==============================================================================
                        ##### How to use this driver #####
  ==============================================================================

    [..]  
    *** How to configure Interrupts using CORTEX HAL driver ***
    ===========================================================
    [..]     
    This section provides functions allowing to configure the NVIC interrupts (IRQ).
    The Cortex-M4 exceptions are managed by CMSIS functions.
   
    (#) Configure the NVIC Priority Grouping using HAL_NVIC_SetPriorityGrouping()
        function according to the following table.
    (#) Configure the priority of the selected IRQ Channels using HAL_NVIC_SetPriority(). 
    (#) Enable the selected IRQ Channels using HAL_NVIC_EnableIRQ().
    (#) please refer to programming manual for details in how to configure priority. 
      
     -@- When the NVIC_PRIORITYGROUP_0 is selected, IRQ preemption is no more possible. 
         The pending IRQ priority will be managed only by the sub priority.
   
     -@- IRQ priority order (sorted by highest to lowest priority):
        (+@) Lowest preemption priority
        (+@) Lowest sub priority
        (+@) Lowest hardware priority (IRQ number)
 
    [..]  
    *** How to configure Systick using CORTEX HAL driver ***
    ========================================================
    [..]
    Setup SysTick Timer for time base.
           
   (+) The HAL_SYSTICK_Config() function calls the SysTick_Config() function which
       is a CMSIS function that:
        (++) Configures the SysTick Reload register with value passed as function parameter.
        (++) Configures the SysTick IRQ priority to the lowest value (0x0F).
        (++) Resets the SysTick Counter register.
        (++) Configures the SysTick Counter clock source to be Core Clock Source (HCLK).
        (++) Enables the SysTick Interrupt.
        (++) Starts the SysTick Counter.
    
   (+) You can change the SysTick Clock source to be HCLK_Div8 by calling the macro
       __HAL_CORTEX_SYSTICKCLK_CONFIG(SYSTICK_CLKSOURCE_HCLK_DIV8) just after the
       HAL_SYSTICK_Config() function call. The __HAL_CORTEX_SYSTICKCLK_CONFIG() macro is defined
       inside the stm32f7xx_hal_cortex.h file.

   (+) You can change the SysTick IRQ priority by calling the
       HAL_NVIC_SetPriority(SysTick_IRQn,...) function just after the HAL_SYSTICK_Config() function 
       call. The HAL_NVIC_SetPriority() call the NVIC_SetPriority() function which is a CMSIS function.

   (+) To adjust the SysTick time base, use the following formula:
                            
       Reload Value = SysTick Counter Clock (Hz) x  Desired Time base (s)
       (++) Reload Value is the parameter to be passed for HAL_SYSTICK_Config() function
       (++) Reload Value should not exceed 0xFFFFFF
   
  @endverbatim
  ******************************************************************************
  * @attention
  *
  * Copyright (c) 2017 STMicroelectronics.
  * All rights reserved.
  *
  * This software is licensed under terms that can be found in the LICENSE file in
  * the root directory of this software component.
  * If no LICENSE file comes with this software, it is provided AS-IS.
  *
  ******************************************************************************
  *//Users/jie/Documents/posixGen_Demos-main/LwIP_StreamingServer/Drivers/STM32F7xx_HAL_Driver/Src/stm32f7xx_hal_dcmi.cDCMI_DMAErrorDCMI_DMAXferCplt524288(uint32_t)DCMI_CR_CROP~(uint32_t)DCMI_CR_CROPIS_DCMI_WINDOW_COORDINATE(X0)IS_DCMI_WINDOW_HEIGHT(Y0)IS_DCMI_WINDOW_COORDINATE(XSize)IS_DCMI_WINDOW_COORDINATE(YSize)hdcmi->Instance->MISRisr_value((uint32_t)(0x1UL << (4U)))((uint32_t)(0x1UL << (3U)))DCMI_IT_LINE | DCMI_IT_VSYNC | DCMI_IT_ERR | DCMI_IT_OVR((uint32_t)(0x1UL << (4U))) | ((uint32_t)(0x1UL << (3U))) | ((uint32_t)(0x1UL << (2U))) | ((uint32_t)(0x1UL << (1U)))4294967265countHAL_TIMEOUT_DCMI_STOP(DCMI_CR_CAPTURE)~(DCMI_CR_CAPTURE)tmp_lengthIS_DCMI_CAPTURE_MODE(DCMI_Mode)(DCMI_CR_CM)~(DCMI_CR_CM)0xFFFFUIS_DCMI_ALL_INSTANCE(hdcmi->Instance)IS_DCMI_PCKPOLARITY(hdcmi->Init.PCKPolarity)IS_DCMI_VSPOLARITY(hdcmi->Init.VSPolarity)IS_DCMI_HSPOLARITY(hdcmi->Init.HSPolarity)IS_DCMI_SYNCHRO(hdcmi->Init.SynchroMode)IS_DCMI_CAPTURE_RATE(hdcmi->Init.CaptureRate)IS_DCMI_EXTENDED_DATA(hdcmi->Init.ExtendedDataMode)IS_DCMI_MODE_JPEG(hdcmi->Init.JPEGMode)IS_DCMI_BYTE_SELECT_MODE(hdcmi->Init.ByteSelectMode)IS_DCMI_BYTE_SELECT_START(hdcmi->Init.ByteSelectStart)IS_DCMI_LINE_SELECT_MODE(hdcmi->Init.LineSelectMode)IS_DCMI_LINE_SELECT_START(hdcmi->Init.LineSelectStart)124832963552406440724088696242006962621444628409871282035704(DCMI_CR_PCKPOL | DCMI_CR_HSPOL  | DCMI_CR_VSPOL  | DCMI_CR_EDM_0 | \
                           DCMI_CR_EDM_1  | DCMI_CR_FCRC_0 | DCMI_CR_FCRC_1 | DCMI_CR_JPEG  | \
                           DCMI_CR_ESS | DCMI_CR_BSM_0 | DCMI_CR_BSM_1 | DCMI_CR_OEBS | \
                           DCMI_CR_LSM | DCMI_CR_OELS)4292931591~(DCMI_CR_PCKPOL | DCMI_CR_HSPOL  | DCMI_CR_VSPOL  | DCMI_CR_EDM_0 | \
                           DCMI_CR_EDM_1  | DCMI_CR_FCRC_0 | DCMI_CR_FCRC_1 | DCMI_CR_JPEG  | \
                           DCMI_CR_ESS | DCMI_CR_BSM_0 | DCMI_CR_BSM_1 | DCMI_CR_OEBS | \
                           DCMI_CR_LSM | DCMI_CR_OELS)((uint32_t)1000)/*Call registered DCMI error callback*//* DCMI error Callback *//* Set DCMI Error Code *//* Initialize the DCMI state*//**
  * @brief  DMA error callback
  * @param  hdma pointer to a DMA_HandleTypeDef structure that contains
  *                the configuration information for the specified DMA module.
  * @retval None
  *//* When snapshot mode, set dcmi state to ready *//* Enable the Frame interrupt *//* Check if the frame is transferred *//* Nothing to do *//* Update memory 1 address location *//* Update memory 0 address location *//**
  * @brief  DMA conversion complete callback.
  * @param  hdma pointer to a DMA_HandleTypeDef structure that contains
  *                the configuration information for the specified DMA module.
  * @retval None
  *//** @defgroup DCMI_Private_Functions DCMI Private Functions
  * @{
  *//* update return status *//* update the error code *//* Legacy weak ErrorCallback         *//* Legacy weak LineEventCallback    *//* Legacy weak VsyncEventCallback   *//* Legacy weak  FrameEventCallback  *//**
  * @brief  Unregister a DCMI Callback
  *         DCMI callback is redirected to the weak predefined callback
  * @param  hdcmi DCMI handle
  * @param  CallbackID ID of the callback to be registered
  *         This parameter can be one of the following values:
  *          @arg @ref HAL_DCMI_LINE_EVENT_CB_ID Line Event callback ID
  *          @arg @ref HAL_DCMI_FRAME_EVENT_CB_ID Frame Event callback ID
  *          @arg @ref HAL_DCMI_VSYNC_EVENT_CB_ID Vsync Event callback ID
  *          @arg @ref HAL_DCMI_ERROR_CB_ID Error callback ID
  *          @arg @ref HAL_DCMI_MSPINIT_CB_ID MspInit callback ID
  *          @arg @ref HAL_DCMI_MSPDEINIT_CB_ID MspDeInit callback ID
  * @retval HAL status
  *//**
  * @brief  Register a User DCMI Callback
  *         To be used instead of the weak predefined callback
  * @param  hdcmi DCMI handle
  * @param  CallbackID ID of the callback to be registered
  *         This parameter can be one of the following values:
  *          @arg @ref HAL_DCMI_LINE_EVENT_CB_ID Line Event callback ID
  *          @arg @ref HAL_DCMI_FRAME_EVENT_CB_ID Frame Event callback ID
  *          @arg @ref HAL_DCMI_VSYNC_EVENT_CB_ID Vsync Event callback ID
  *          @arg @ref HAL_DCMI_ERROR_CB_ID Error callback ID
  *          @arg @ref HAL_DCMI_MSPINIT_CB_ID MspInit callback ID
  *          @arg @ref HAL_DCMI_MSPDEINIT_CB_ID MspDeInit callback ID
  * @param  pCallback pointer to the Callback function
  * @retval HAL status
  *//**
  * @brief  Return the DCMI error code
  * @param  hdcmi  pointer to a DCMI_HandleTypeDef structure that contains
  *               the configuration information for DCMI.
  * @retval DCMI Error Code
  *//**
  * @brief  Return the DCMI state
  * @param  hdcmi pointer to a DCMI_HandleTypeDef structure that contains
  *                the configuration information for DCMI.
  * @retval HAL state
  *//** @defgroup DCMI_Exported_Functions_Group4 Peripheral State functions
  *  @brief    Peripheral State functions
  *
@verbatim
 ===============================================================================
               ##### Peripheral State and Errors functions #####
 ===============================================================================
    [..]
    This subsection provides functions allowing to
      (+) Check the DCMI state.
      (+) Get the specific DCMI error flag.

@endverbatim
  * @{
  *//* Process Unlocked *//* Change the DCMI state*//* Write DCMI embedded synchronization unmask register *//* Lock the DCMI peripheral state *//* Process Locked *//**
  * @brief  Set embedded synchronization delimiters unmasks.
  * @param  hdcmi pointer to a DCMI_HandleTypeDef structure that contains
  *               the configuration information for DCMI.
  * @param  SyncUnmask pointer to a DCMI_SyncUnmaskTypeDef structure that contains
  *                    the embedded synchronization delimiters unmasks.
  * @retval HAL status
  *//* Enable DCMI Crop feature *//**
  * @brief  Enable the Crop feature.
  * @param  hdcmi pointer to a DCMI_HandleTypeDef structure that contains
  *                the configuration information for DCMI.
  * @retval HAL status
  *//* Disable DCMI Crop feature *//**
  * @brief  Disable the Crop feature.
  * @param  hdcmi pointer to a DCMI_HandleTypeDef structure that contains
  *                the configuration information for DCMI.
  * @retval HAL status
  *//* Configure CROP *//**
  * @brief  Configure the DCMI CROP coordinate.
  * @param  hdcmi pointer to a DCMI_HandleTypeDef structure that contains
  *                the configuration information for DCMI.
  * @param  YSize DCMI Line number
  * @param  XSize DCMI Pixel per line
  * @param  X0    DCMI window X offset
  * @param  Y0    DCMI window Y offset
  * @retval HAL status
  *//** @defgroup DCMI_Exported_Functions_Group3 Peripheral Control functions
  *  @brief    Peripheral Control functions
  *
@verbatim
 ===============================================================================
                    ##### Peripheral Control functions #####
 ===============================================================================
[..]  This section provides functions allowing to:
      (+) Configure the CROP feature.
      (+) Enable/Disable the CROP feature.
      (+) Set embedded synchronization delimiters unmasks.

@endverbatim
  * @{
  *//* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_DCMI_FrameEventCallback could be implemented in the user file
   *//**
  * @brief  Frame Event callback.
  * @param  hdcmi pointer to a DCMI_HandleTypeDef structure that contains
  *                the configuration information for DCMI.
  * @retval None
  *//* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_DCMI_VsyncEventCallback could be implemented in the user file
   *//**
  * @brief  VSYNC Event callback.
  * @param  hdcmi pointer to a DCMI_HandleTypeDef structure that contains
  *                the configuration information for DCMI.
  * @retval None
  *//* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_DCMI_LineEventCallback could be implemented in the user file
   *//**
  * @brief  Line Event callback.
  * @param  hdcmi pointer to a DCMI_HandleTypeDef structure that contains
  *                the configuration information for DCMI.
  * @retval None
  *//* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_DCMI_ErrorCallback could be implemented in the user file
   *//**
  * @brief  Error DCMI callback.
  * @param  hdcmi pointer to a DCMI_HandleTypeDef structure that contains
  *                the configuration information for DCMI.
  * @retval None
  *//*Call registered DCMI frame event callback*//* Frame Callback *//* Clear the End of Frame flag *//* Disable the Frame interrupt *//* Disable the Line, Vsync, Error and Overrun interrupts *//* When snapshot mode, disable Vsync, Error and Overrun interrupts *//* FRAME interrupt management ***********************************************//*Call registered DCMI vsync event callback*//* VSYNC Callback *//* Clear the VSYNC flag *//* VSYNC interrupt management ***********************************************//*Call registered DCMI line event callback*//* Line interrupt Callback *//* Clear the Line interrupt flag *//* Line Interrupt management ************************************************//* Abort the DMA Transfer *//* Set the overflow callback *//* Change DCMI state *//* Update error code *//* Clear the Overflow flag *//* Overflow interrupt management ********************************************//* Set the synchronization error callback *//* Clear the Synchronization error flag *//* Synchronization error interrupt management *******************************//**
  * @brief  Handles DCMI interrupt request.
  * @param  hdcmi pointer to a DCMI_HandleTypeDef structure that contains
  *                the configuration information for the DCMI.
  * @retval None
  *//* Enable Capture *//**
  * @brief  Resume DCMI capture
  * @param  hdcmi pointer to a DCMI_HandleTypeDef structure that contains
  *                the configuration information for DCMI.
  * @retval HAL status
  *//* Check if the DCMI capture effectively disabled *//* Disable Capture *//**
  * @brief  Suspend DCMI capture
  * @param  hdcmi pointer to a DCMI_HandleTypeDef structure that contains
  *                the configuration information for DCMI.
  * @retval HAL status
  *//* Disable the DMA *//* Disable the DCMI *//**
  * @brief  Disable DCMI DMA request and Disable DCMI capture
  * @param  hdcmi pointer to a DCMI_HandleTypeDef structure that contains
  *                the configuration information for DCMI.
  * @retval HAL status
  *//* Set Error Code *//* Start DMA multi buffer transfer *//* Update second memory address *//* Update DCMI counter  and transfer number*//* Get the number of buffer *//* Initialize transfer parameters *//* Set the DMA memory1 conversion complete callback *//* DCMI_DOUBLE_BUFFER Mode *//* Reset transfer counters value *//* Set the dma abort callback *//* Set the DMA memory0 conversion complete callback *//* Configure the DCMI Mode *//* Enable DCMI by setting DCMIEN bit *//* Check function parameters *//* Initialize the second memory address *//**
  * @brief  Enables DCMI DMA request and enables DCMI capture
  * @param  hdcmi     pointer to a DCMI_HandleTypeDef structure that contains
  *                    the configuration information for DCMI.
  * @param  DCMI_Mode DCMI capture mode snapshot or continuous grab.
  * @param  pData     The destination memory Buffer address (LCD Frame buffer).
  * @param  Length    The length of capture to be transferred.
  * @retval HAL status
  *//** @defgroup DCMI_Exported_Functions_Group2 IO operation functions
  *  @brief   IO operation functions
  *
@verbatim
 ===============================================================================
                      #####  IO operation functions  #####
 ===============================================================================
    [..]  This section provides functions allowing to:
      (+) Configure destination address and data length and
          Enables DCMI DMA request and enables DCMI capture
      (+) Stop the DCMI capture.
      (+) Handles DCMI interrupt request.

@endverbatim
  * @{
  *//* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_DCMI_MspDeInit could be implemented in the user file
   *//**
  * @brief  DeInitializes the DCMI MSP.
  * @param  hdcmi pointer to a DCMI_HandleTypeDef structure that contains
  *                the configuration information for DCMI.
  * @retval None
  *//* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_DCMI_MspInit could be implemented in the user file
   *//**
  * @brief  Initializes the DCMI MSP.
  * @param  hdcmi pointer to a DCMI_HandleTypeDef structure that contains
  *                the configuration information for DCMI.
  * @retval None
  *//* (USE_HAL_DCMI_REGISTER_CALLBACKS) *//* DeInit the low level hardware: GPIO, CLOCK, NVIC and DMA *//* De-Initialize the low level hardware (MSP) *//**
  * @brief  Deinitializes the DCMI peripheral registers to their default reset
  *         values.
  * @param  hdcmi pointer to a DCMI_HandleTypeDef structure that contains
  *                the configuration information for DCMI.
  * @retval HAL status
  *//* Enable the Line, Vsync, Error and Overrun interrupts *//* Configures the HS, VS, DE and PC polarity *//* Byte select mode must be programmed to the reset value if the extended mode
    is not set to 8-bit data capture on every pixel clock *//* Change the DCMI state *//* Init the low level hardware : GPIO, CLOCK, NVIC and DMA *//* Initialize the low level hardware (MSP) *//* Legacy weak MspInit Callback        *//* Legacy weak ErrorCallback       *//* Legacy weak LineEventCallback   *//* Legacy weak VsyncEventCallback  *//* Legacy weak FrameEventCallback  *//* Reset callback pointers to the weak predefined callbacks *//* Init the DCMI Callback settings *//* Check the DCMI peripheral state *//**
  * @brief  Initializes the DCMI according to the specified
  *         parameters in the DCMI_InitTypeDef and create the associated handle.
  * @param  hdcmi pointer to a DCMI_HandleTypeDef structure that contains
  *                the configuration information for DCMI.
  * @retval HAL status
  *//** @defgroup DCMI_Exported_Functions_Group1 Initialization and Configuration functions
  *  @brief   Initialization and Configuration functions
  *
@verbatim
 ===============================================================================
                ##### Initialization and Configuration functions #####
 ===============================================================================
    [..]  This section provides functions allowing to:
      (+) Initialize and configure the DCMI
      (+) De-initialize the DCMI

@endverbatim
  * @{
  *//** @defgroup DCMI_Exported_Functions DCMI Exported Functions
  * @{
  *//* Set timeout to 1s  *//** @defgroup DCMI_Stop_TimeOut DCMI Stop Time Out
  * @{
  *//** @defgroup DCMI DCMI
  * @brief DCMI HAL module driver
  * @{
  *//**
  ******************************************************************************
  * @file    stm32f7xx_hal_dcmi.c
  * @author  MCD Application Team
  * @brief   DCMI HAL module driver
  *          This file provides firmware functions to manage the following
  *          functionalities of the Digital Camera Interface (DCMI) peripheral:
  *           + Initialization and de-initialization functions
  *           + IO operation functions
  *           + Peripheral Control functions
  *           + Peripheral State and Error functions
  *
  ******************************************************************************
  * @attention
  *
  * Copyright (c) 2017 STMicroelectronics.
  * All rights reserved.
  *
  * This software is licensed under terms that can be found in the LICENSE file
  * in the root directory of this software component.
  * If no LICENSE file comes with this software, it is provided AS-IS.
  *
  ******************************************************************************
  @verbatim
  ==============================================================================
                        ##### How to use this driver #####
  ==============================================================================
  [..]
      The sequence below describes how to use this driver to capture image
      from a camera module connected to the DCMI Interface.
      This sequence does not take into account the configuration of the
      camera module, which should be made before to configure and enable
      the DCMI to capture images.

    (#) Program the required configuration through following parameters:
        horizontal and vertical polarity, pixel clock polarity, Capture Rate,
        Synchronization Mode, code of the frame delimiter and data width
        using HAL_DCMI_Init() function.

    (#) Configure the selected DMA stream to transfer Data from DCMI DR
        register to the destination memory buffer.

    (#) Program the required configuration through following parameters:
        DCMI mode, destination memory Buffer address and the data length
        and enable capture using HAL_DCMI_Start_DMA() function.

    (#) Optionally, configure and Enable the CROP feature to select a rectangular
        window from the received image using HAL_DCMI_ConfigCrop()
        and HAL_DCMI_EnableCrop() functions

    (#) The capture can be stopped using HAL_DCMI_Stop() function.

    (#) To control DCMI state you can use the function HAL_DCMI_GetState().

     *** DCMI HAL driver macros list ***
     =============================================
     [..]
       Below the list of most used macros in DCMI HAL driver.

      (+) __HAL_DCMI_ENABLE: Enable the DCMI peripheral.
      (+) __HAL_DCMI_DISABLE: Disable the DCMI peripheral.
      (+) __HAL_DCMI_GET_FLAG: Get the DCMI pending flags.
      (+) __HAL_DCMI_CLEAR_FLAG: Clear the DCMI pending flags.
      (+) __HAL_DCMI_ENABLE_IT: Enable the specified DCMI interrupts.
      (+) __HAL_DCMI_DISABLE_IT: Disable the specified DCMI interrupts.
      (+) __HAL_DCMI_GET_IT_SOURCE: Check whether the specified DCMI interrupt has occurred or not.

     [..]
       (@) You can refer to the DCMI HAL driver header file for more useful macros

    *** Callback registration ***
    =============================

    The compilation define USE_HAL_DCMI_REGISTER_CALLBACKS when set to 1
    allows the user to configure dynamically the driver callbacks.
    Use functions HAL_DCMI_RegisterCallback() to register a user callback.

    Function HAL_DCMI_RegisterCallback() allows to register following callbacks:
      (+) FrameEventCallback : callback for DCMI Frame Event.
      (+) VsyncEventCallback : callback for DCMI Vsync Event.
      (+) LineEventCallback  : callback for DCMI Line Event.
      (+) ErrorCallback      : callback for DCMI error detection.
      (+) MspInitCallback    : callback for DCMI MspInit.
      (+) MspDeInitCallback  : callback for DCMI MspDeInit.
    This function takes as parameters the HAL peripheral handle, the Callback ID
    and a pointer to the user callback function.

    Use function HAL_DCMI_UnRegisterCallback() to reset a callback to the default
    weak (surcharged) function.
    HAL_DCMI_UnRegisterCallback() takes as parameters the HAL peripheral handle,
    and the callback ID.
    This function allows to reset following callbacks:
      (+) FrameEventCallback : callback for DCMI Frame Event.
      (+) VsyncEventCallback : callback for DCMI Vsync Event.
      (+) LineEventCallback  : callback for DCMI Line Event.
      (+) ErrorCallback      : callback for DCMI error.
      (+) MspInitCallback    : callback for DCMI MspInit.
      (+) MspDeInitCallback  : callback for DCMI MspDeInit.

    By default, after the HAL_DCMI_Init and if the state is HAL_DCMI_STATE_RESET
    all callbacks are reset to the corresponding legacy weak (surcharged) functions:
    examples FrameEventCallback(), HAL_DCMI_ErrorCallback().
    Exception done for MspInit and MspDeInit callbacks that are respectively
    reset to the legacy weak (surcharged) functions in the HAL_DCMI_Init
    and HAL_DCMI_DeInit only when these callbacks are null (not registered beforehand).
    If not, MspInit or MspDeInit are not null, the HAL_DCMI_Init and HAL_DCMI_DeInit
    keep and use the user MspInit/MspDeInit callbacks (registered beforehand).

    Callbacks can be registered/unregistered in READY state only.
    Exception done for MspInit/MspDeInit callbacks that can be registered/unregistered
    in READY or RESET state, thus registered (user) MspInit/DeInit callbacks can be used
    during the Init/DeInit.
    In that case first register the MspInit/MspDeInit user callbacks
    using HAL_DCMI_RegisterCallback before calling HAL_DCMI_DeInit
    or HAL_DCMI_Init function.

    When the compilation define USE_HAL_DCMI_REGISTER_CALLBACKS is set to 0 or
    not defined, the callback registering feature is not available
    and weak (surcharged) callbacks are used.

  @endverbatim
  ******************************************************************************
  *//Users/jie/Documents/posixGen_Demos-main/LwIP_StreamingServer/Drivers/STM32F7xx_HAL_Driver/Src/stm32f7xx_hal_dcmi_ex.c/**
  ******************************************************************************
  * @file    stm32f7xx_hal_dcmi_ex.c
  * @author  MCD Application Team
  * @brief   Empty file; This file is no longer used to handle the Black&White
  *          feature. Its content is now moved to common files
  *          (stm32f7xx_hal_dcmi.c/.h) as there's no device's dependency within
  *          this family. It's just kept for compatibility reasons.
  *
  ******************************************************************************
  * @attention
  *
  * Copyright (c) 2017 STMicroelectronics.
  * All rights reserved.
  *
  * This software is licensed under terms that can be found in the LICENSE file
  * in the root directory of this software component.
  * If no LICENSE file comes with this software, it is provided AS-IS.
  *
  ******************************************************************************
  *//Users/jie/Documents/posixGen_Demos-main/LwIP_StreamingServer/Drivers/STM32F7xx_HAL_Driver/Src/stm32f7xx_hal_dma.cDMA_CheckFifoParamDMA_CalcBaseAndBitshiftstream_number0xFFUflagBitshiftOffset0x3FFU4294966272~0x3FFU(~0x3FFU)(uint32_t)(~0x3FFU)DMA_SetConfig4294705151~DMA_SxCR_DBM(uint32_t)(~DMA_SxCR_DBM)tmpisrtimeout9600DMA_Base_Registers *regs(DMA_IT_TE)~(DMA_IT_TE)(uint32_t)(DMA_SxCR_DBM)(DMA_IT_HT)4294967287~(DMA_IT_HT)(DMA_IT_TC | DMA_IT_TE | DMA_IT_DME)4294967273~(DMA_IT_TC | DMA_IT_TE | DMA_IT_DME)(DMA_IT_FE)~(DMA_IT_FE)(DMA_IT_TC)~(DMA_IT_TC)mask_cpltlevel(DMA_FLAG_HTIF0_4 | DMA_FLAG_TCIF0_4)(DMA_FLAG_HTIF0_4)HAL_TIMEOUT_DMA_ABORTIS_DMA_BUFFER_SIZE(DataLength)IS_DMA_STREAM_ALL_INSTANCE(hdma->Instance)(uint32_t)0x00000021UIS_DMA_CHANNEL(hdma->Init.Channel)IS_DMA_DIRECTION(hdma->Init.Direction)IS_DMA_PERIPHERAL_INC_STATE(hdma->Init.PeriphInc)IS_DMA_MEMORY_INC_STATE(hdma->Init.MemInc)IS_DMA_PERIPHERAL_DATA_SIZE(hdma->Init.PeriphDataAlignment)IS_DMA_MEMORY_DATA_SIZE(hdma->Init.MemDataAlignment)IS_DMA_MODE(hdma->Init.Mode)IS_DMA_PRIORITY(hdma->Init.Priority)IS_DMA_FIFO_MODE_STATE(hdma->Init.FIFOMode)IS_DMA_FIFO_THRESHOLD(hdma->Init.FIFOThreshold)IS_DMA_MEMORY_BURST(hdma->Init.MemBurst)IS_DMA_PERIPHERAL_BURST(hdma->Init.PeriphBurst)503316480528482304629145653477376053497036824576534994944535001088535002112535002624535002880535003072535527360535789504(DMA_SxCR_CHSEL | DMA_SxCR_MBURST | DMA_SxCR_PBURST | \
                      DMA_SxCR_PL    | DMA_SxCR_MSIZE  | DMA_SxCR_PSIZE  | \
                      DMA_SxCR_MINC  | DMA_SxCR_PINC   | DMA_SxCR_CIRC   | \
                      DMA_SxCR_DIR   | DMA_SxCR_CT     | DMA_SxCR_DBM)3759177791(uint32_t)~(DMA_SxCR_CHSEL | DMA_SxCR_MBURST | DMA_SxCR_PBURST | \
                      DMA_SxCR_PL    | DMA_SxCR_MSIZE  | DMA_SxCR_PSIZE  | \
                      DMA_SxCR_MINC  | DMA_SxCR_PINC   | DMA_SxCR_CIRC   | \
                      DMA_SxCR_DIR   | DMA_SxCR_CT     | DMA_SxCR_DBM)((uint32_t)~(DMA_SxCR_CHSEL | DMA_SxCR_MBURST | DMA_SxCR_PBURST | \
                      DMA_SxCR_PL    | DMA_SxCR_MSIZE  | DMA_SxCR_PSIZE  | \
                      DMA_SxCR_MINC  | DMA_SxCR_PINC   | DMA_SxCR_CIRC   | \
                      DMA_SxCR_DIR   | DMA_SxCR_CT     | DMA_SxCR_DBM))(DMA_SxFCR_DMDIS | DMA_SxFCR_FTH)4294967288(uint32_t)~(DMA_SxFCR_DMDIS | DMA_SxFCR_FTH)DMA_Base_RegistersReserved0((uint32_t)5)/* Memory Data size equal to Word *//* Memory Data size equal to Half-Word *//* Memory Data size equal to Byte *//**
  * @brief  Check compatibility between FIFO threshold level and size of the memory burst
  * @param  hdma       pointer to a DMA_HandleTypeDef structure that contains
  *                     the configuration information for the specified DMA Stream. 
  * @retval HAL status
  *//* return pointer to LISR and LIFCR *//* return pointer to HISR and HIFCR *//* lookup table for necessary bitshift of flags within status registers *//**
  * @brief  Returns the DMA Stream base address depending on stream number
  * @param  hdma       pointer to a DMA_HandleTypeDef structure that contains
  *                     the configuration information for the specified DMA Stream. 
  * @retval Stream base address
  *//* Configure DMA Stream destination address *//* Configure DMA Stream source address *//* Peripheral to Memory *//* Memory to Peripheral *//* Configure DMA Stream data length *//* Clear DBM bit *//**
  * @brief  Sets the DMA Transfer parameter.
  * @param  hdma       pointer to a DMA_HandleTypeDef structure that contains
  *                     the configuration information for the specified DMA Stream.
  * @param  SrcAddress The source memory Buffer address
  * @param  DstAddress The destination memory Buffer address
  * @param  DataLength The length of data to be transferred from source to destination
  * @retval HAL status
  *//** @addtogroup DMA_Private_Functions
  * @{
  *//**
  * @brief  Return the DMA error code
  * @param  hdma  pointer to a DMA_HandleTypeDef structure that contains
  *              the configuration information for the specified DMA Stream.
  * @retval DMA Error Code
  *//**
  * @brief  Returns the DMA state.
  * @param  hdma pointer to a DMA_HandleTypeDef structure that contains
  *               the configuration information for the specified DMA Stream.
  * @retval HAL state
  *//** @addtogroup DMA_Exported_Functions_Group3
  *
@verbatim
 ===============================================================================
                    ##### State and Errors functions #####
 ===============================================================================
    [..]
    This subsection provides functions allowing to
      (+) Check the DMA state
      (+) Get error code

@endverbatim
  * @{
  *//**
  * @brief  UnRegister callbacks
  * @param  hdma                 pointer to a DMA_HandleTypeDef structure that contains
  *                               the configuration information for the specified DMA Stream.
  * @param  CallbackID           User Callback identifier
  *                               a HAL_DMA_CallbackIDTypeDef ENUM as parameter.
  * @retval HAL status
  *//**
  * @brief  Register callbacks
  * @param  hdma                 pointer to a DMA_HandleTypeDef structure that contains
  *                               the configuration information for the specified DMA Stream.
  * @param  CallbackID           User Callback identifier
  *                               a DMA_HandleTypeDef structure as parameter.
  * @param  pCallback            pointer to private callbacsk function which has pointer to 
  *                               a DMA_HandleTypeDef structure as parameter.
  * @retval HAL status
  *//* Transfer error callback *//* Change the DMA state *//* Disable the stream *//* manage error case *//* Transfer complete callback *//* Disable the transfer complete interrupt *//* Disable the transfer complete interrupt if the DMA mode is not CIRCULAR *//* Transfer complete Callback for memory0 *//* Current memory buffer used is Memory 1 *//* Transfer complete Callback for memory1 *//* Current memory buffer used is Memory 0 *//* Clear all interrupt flags at correct offset within the register *//* Disable all the transfer interrupts *//* Clear the transfer complete flag *//* Transfer Complete Interrupt management ***********************************//* Half transfer callback *//* Disable the half transfer interrupt *//* Disable the half transfer interrupt if the DMA mode is not CIRCULAR *//* Multi_Buffering mode enabled *//* Clear the half transfer complete flag *//* Half Transfer Complete Interrupt management ******************************//* Clear the direct mode error flag *//* Direct Mode Error Interrupt management ***********************************//* Clear the FIFO error flag *//* FIFO Error Interrupt management ******************************************//* Clear the transfer error flag *//* Disable the transfer error interrupt *//* Transfer Error Interrupt management ***************************************//* calculate DMA base and stream number *//**
  * @brief  Handles DMA interrupt request.
  * @param  hdma pointer to a DMA_HandleTypeDef structure that contains
  *               the configuration information for the specified DMA Stream.  
  * @retval None
  *//* Clear the half transfer flag *//* Clear the half transfer and transfer complete flags *//* Get the level transfer complete flag *//* Clear the Direct Mode error flag *//* Get the ISR register value *//* Check for the Timeout (Not applicable in circular mode)*//* Half Transfer Complete flag *//* Transfer Complete flag *//* Polling mode not supported in circular mode and double buffering mode *//* No transfer ongoing *//**
  * @brief  Polling for transfer complete.
  * @param  hdma          pointer to a DMA_HandleTypeDef structure that contains
  *                        the configuration information for the specified DMA Stream.
  * @param  CompleteLevel Specifies the DMA level complete.
  * @note   The polling mode is kept in this version for legacy. it is recommended to use the IT model instead.
  *         This model could be used for debug purpose.
  * @note   The HAL_DMA_PollForTransfer API cannot be used in circular and double buffering mode (automatic circular mode). 
  * @param  Timeout       Timeout duration.
  * @retval HAL status
  *//* Set Abort State  *//**
  * @brief  Aborts the DMA Transfer in Interrupt mode.
  * @param  hdma   pointer to a DMA_HandleTypeDef structure that contains
  *                 the configuration information for the specified DMA Stream.
  * @retval HAL status
  *//* Change the DMA state*//* Check if the DMA Stream is effectively disabled *//**
  * @brief  Aborts the DMA Transfer.
  * @param  hdma   pointer to a DMA_HandleTypeDef structure that contains
  *                 the configuration information for the specified DMA Stream.
  *                   
  * @note  After disabling a DMA Stream, a check for wait until the DMA Stream is 
  *        effectively disabled is added. If a Stream is disabled 
  *        while a data transfer is ongoing, the current data will be transferred
  *        and the Stream will be effectively disabled only after the transfer of
  *        this single data is finished.  
  * @retval HAL status
  *//* Enable Common interrupts*//* Configure the source, destination address and the data length *//* Initialize the error code *//* Change DMA peripheral state *//**
  * @brief  Start the DMA Transfer with interrupt enabled.
  * @param  hdma       pointer to a DMA_HandleTypeDef structure that contains
  *                     the configuration information for the specified DMA Stream.  
  * @param  SrcAddress The source memory Buffer address
  * @param  DstAddress The destination memory Buffer address
  * @param  DataLength The length of data to be transferred from source to destination
  * @retval HAL status
  *//**
  * @brief  Starts the DMA Transfer.
  * @param  hdma       pointer to a DMA_HandleTypeDef structure that contains
  *                     the configuration information for the specified DMA Stream.
  * @param  SrcAddress The source memory Buffer address
  * @param  DstAddress The destination memory Buffer address
  * @param  DataLength The length of data to be transferred from source to destination
  * @retval HAL status
  *//** @addtogroup DMA_Exported_Functions_Group2
  *
@verbatim   
 ===============================================================================
                      #####  IO operation functions  #####
 ===============================================================================
    [..]  This section provides functions allowing to:
      (+) Configure the source, destination address and data length and Start DMA transfer
      (+) Configure the source, destination address and data length and 
          Start DMA transfer with interrupt
      (+) Abort DMA transfer
      (+) Poll for transfer complete
      (+) Handle DMA interrupt request  

@endverbatim
  * @{
  *//* Reset the DMA state *//* Reset the error code *//* Clean all callbacks *//* Get DMA steam Base Address *//* Reset DMA Streamx FIFO control register *//* Reset DMA Streamx memory 1 address register *//* Reset DMA Streamx memory 0 address register *//* Reset DMA Streamx peripheral address register *//* Reset DMA Streamx number of data to transfer register *//* Reset DMA Streamx control register *//* Disable the selected DMA Streamx *//* Check the DMA peripheral state *//**
  * @brief  DeInitializes the DMA peripheral 
  * @param  hdma pointer to a DMA_HandleTypeDef structure that contains
  *               the configuration information for the specified DMA Stream.  
  * @retval HAL status
  *//* Initialize the DMA state *//* Clear all interrupt flags *//* Initialize StreamBaseAddress and StreamIndex parameters to be used to calculate
     DMA steam Base Address needed by HAL_DMA_IRQHandler() and HAL_DMA_PollForTransfer() *//* Write to DMA Stream FCR *//* for INCR4, INCR8, INCR16 bursts *//* Check compatibility between FIFO threshold level and size of the memory burst *//* Get the FIFO threshold *//* The FIFO threshold is not used when the FIFO mode is disabled *//* Prepare the DMA Stream FIFO configuration *//* Clear Direct mode and FIFO threshold bits *//* Get the FCR register value *//* Write to DMA Stream CR register *//* Get memory burst and peripheral burst *//* the Memory burst and peripheral burst are not used when the FIFO is disabled *//* Prepare the DMA Stream configuration *//* Clear CHSEL, MBURST, PBURST, PL, MSIZE, PSIZE, MINC, PINC, CIRC, DIR, CT and DBM bits *//* Get the CR register value *//* Disable the peripheral *//* Allocate lock resource *//* Check the memory burst, peripheral burst and FIFO threshold parameters only
     when FIFO mode is enabled *//**
  * @brief  Initialize the DMA according to the specified
  *         parameters in the DMA_InitTypeDef and create the associated handle.
  * @param  hdma Pointer to a DMA_HandleTypeDef structure that contains
  *               the configuration information for the specified DMA Stream.  
  * @retval HAL status
  *//** @addtogroup DMA_Exported_Functions_Group1
  *
@verbatim
 ===============================================================================
             ##### Initialization and de-initialization functions  #####
 ===============================================================================
    [..]
    This section provides functions allowing to initialize the DMA Stream source
    and destination addresses, incrementation and data sizes, transfer direction, 
    circular/normal mode selection, memory-to-memory mode selection and Stream priority value.
    [..]
    The HAL_DMA_Init() function follows the DMA configuration procedures as described in
    reference manual.

@endverbatim
  * @{
  *//** @addtogroup DMA_Exported_Functions
  * @{
  *//* 5 ms *//** @addtogroup DMA_Private_Constants
 * @{
 *//*!< DMA interrupt flag clear register *//*!< DMA interrupt status register *//** @defgroup DMA DMA
  * @brief DMA HAL module driver
  * @{
  *//**
  ******************************************************************************
  * @file    stm32f7xx_hal_dma.c
  * @author  MCD Application Team
  * @brief   DMA HAL module driver.
  *    
  *          This file provides firmware functions to manage the following 
  *          functionalities of the Direct Memory Access (DMA) peripheral:
  *           + Initialization and de-initialization functions
  *           + IO operation functions
  *           + Peripheral State and errors functions
  @verbatim     
  ==============================================================================
                        ##### How to use this driver #####
  ==============================================================================
  [..]
   (#) Enable and configure the peripheral to be connected to the DMA Stream
       (except for internal SRAM/FLASH memories: no initialization is 
       necessary) please refer to Reference manual for connection between peripherals
       and DMA requests.

   (#) For a given Stream, program the required configuration through the following parameters:
       Transfer Direction, Source and Destination data formats, 
       Circular, Normal or peripheral flow control mode, Stream Priority level, 
       Source and Destination Increment mode, FIFO mode and its Threshold (if needed), 
       Burst mode for Source and/or Destination (if needed) using HAL_DMA_Init() function.

   -@-   Prior to HAL_DMA_Init() the clock must be enabled for DMA through the following macros:
         __HAL_RCC_DMA1_CLK_ENABLE() or __HAL_RCC_DMA2_CLK_ENABLE().

     *** Polling mode IO operation ***
     =================================
    [..]
          (+) Use HAL_DMA_Start() to start DMA transfer after the configuration of Source 
              address and destination address and the Length of data to be transferred.
          (+) Use HAL_DMA_PollForTransfer() to poll for the end of current transfer, in this  
              case a fixed Timeout can be configured by User depending from his application.
          (+) Use HAL_DMA_Abort() function to abort the current transfer.

     *** Interrupt mode IO operation ***
     ===================================
    [..]
          (+) Configure the DMA interrupt priority using HAL_NVIC_SetPriority()
          (+) Enable the DMA IRQ handler using HAL_NVIC_EnableIRQ()
          (+) Select Callbacks functions using HAL_DMA_RegisterCallback()
          (+) Use HAL_DMA_Start_IT() to start DMA transfer after the configuration of  
              Source address and destination address and the Length of data to be transferred. In this 
              case the DMA interrupt is configured 
          (+) Use HAL_DMA_IRQHandler() called under DMA_IRQHandler() Interrupt subroutine
          (+) At the end of data transfer HAL_DMA_IRQHandler() function is executed and user can 
              add his own function by customization of function pointer XferCpltCallback and 
              XferErrorCallback (i.e a member of DMA handle structure).
    [..]
     (#) Use HAL_DMA_GetState() function to return the DMA state and HAL_DMA_GetError() in case of error 
         detection.

     (#) Use HAL_DMA_Abort_IT() function to abort the current transfer

     -@-   In Memory-to-Memory transfer mode, Circular mode is not allowed.

     -@-   The FIFO is used mainly to reduce bus usage and to allow data packing/unpacking: it is
           possible to set different Data Sizes for the Peripheral and the Memory (ie. you can set
           Half-Word data size for the peripheral to access its data register and set Word data size
           for the Memory to gain in access time. Each two half words will be packed and written in
           a single access to a Word in the Memory).

     -@-   When FIFO is disabled, it is not allowed to configure different Data Sizes for Source
           and Destination. In this case the Peripheral Data Size will be applied to both Source
           and Destination.

     *** DMA HAL driver macros list ***
     =============================================
     [..]
       Below the list of most used macros in DMA HAL driver.
       
      (+) __HAL_DMA_ENABLE: Enable the specified DMA Stream.
      (+) __HAL_DMA_DISABLE: Disable the specified DMA Stream.
      (+) __HAL_DMA_GET_IT_SOURCE: Check whether the specified DMA Stream interrupt has occurred or not. 

     [..]
      (@) You can refer to the DMA HAL driver header file for more useful macros

  @endverbatim
  ******************************************************************************
  * @attention
  *
  * Copyright (c) 2017 STMicroelectronics.
  * All rights reserved.
  *
  * This software is licensed under terms that can be found in the LICENSE file in
  * the root directory of this software component.
  * If no LICENSE file comes with this software, it is provided AS-IS.
  *
  ******************************************************************************
  *//Users/jie/Documents/posixGen_Demos-main/LwIP_StreamingServer/Drivers/STM32F7xx_HAL_Driver/Src/stm32f7xx_hal_dma2d.cDMA2D_SetConfigtmp4hdma2d->Instance->NLR(DMA2D_NLR_NL | DMA2D_NLR_PL)((0xFFFFUL << (0U)) | (0x3FFFUL << (16U)))(Height | (Width << DMA2D_NLR_PL_Pos))(Height | (Width << (16U)))(hdma2d->Instance->NLR)(((READ_REG(hdma2d->Instance->NLR)) & (~(((0xFFFFUL << (0U)) | (0x3FFFUL << (16U)))))) | ((Height | (Width << (16U)))))(((((hdma2d->Instance->NLR))) & (~(((0xFFFFUL << (0U)) | (0x3FFFUL << (16U)))))) | ((Height | (Width << (16U)))))1638310736762881073741823hdma2d->Instance->OMARhdma2d->Instance->OCOLRhdma2d->Instance->FGMARhdma2d->Instance->AMTCR(0xFFUL << (8U))(((uint32_t) DeadTime) << DMA2D_AMTCR_DT_Pos)(((uint32_t) DeadTime) << (8U))(hdma2d->Instance->AMTCR)(((READ_REG(hdma2d->Instance->AMTCR)) & (~((0xFFUL << (8U))))) | ((((uint32_t) DeadTime) << (8U))))(((((hdma2d->Instance->AMTCR))) & (~((0xFFUL << (8U))))) | ((((uint32_t) DeadTime) << (8U))))4294902015hdma2d->Instance->LWRIS_DMA2D_LAYER(LayerIdx)IS_DMA2D_CLUT_CM(CLUTCfg.CLUTColorMode)IS_DMA2D_CLUT_SIZE(CLUTCfg.Size)hdma2d->Instance->BGCMAR(uint32_t)CLUTCfg.pCLUThdma2d->Instance->BGPFCCR(DMA2D_BGPFCCR_CS | DMA2D_BGPFCCR_CCM)((0xFFUL << (8U)) | (0x1UL << (4U)))((CLUTCfg.Size << DMA2D_BGPFCCR_CS_Pos) | (CLUTCfg.CLUTColorMode << DMA2D_BGPFCCR_CCM_Pos))((CLUTCfg.Size << (8U)) | (CLUTCfg.CLUTColorMode << (4U)))(hdma2d->Instance->BGPFCCR)(((READ_REG(hdma2d->Instance->BGPFCCR)) & (~(((0xFFUL << (8U)) | (0x1UL << (4U)))))) | (((CLUTCfg.Size << (8U)) | (CLUTCfg.CLUTColorMode << (4U)))))(((((hdma2d->Instance->BGPFCCR))) & (~(((0xFFUL << (8U)) | (0x1UL << (4U)))))) | (((CLUTCfg.Size << (8U)) | (CLUTCfg.CLUTColorMode << (4U)))))hdma2d->Instance->FGCMARhdma2d->Instance->FGPFCCR(DMA2D_FGPFCCR_CS | DMA2D_FGPFCCR_CCM)((CLUTCfg.Size << DMA2D_FGPFCCR_CS_Pos) | (CLUTCfg.CLUTColorMode << DMA2D_FGPFCCR_CCM_Pos))(hdma2d->Instance->FGPFCCR)(((READ_REG(hdma2d->Instance->FGPFCCR)) & (~(((0xFFUL << (8U)) | (0x1UL << (4U)))))) | (((CLUTCfg.Size << (8U)) | (CLUTCfg.CLUTColorMode << (4U)))))(((((hdma2d->Instance->FGPFCCR))) & (~(((0xFFUL << (8U)) | (0x1UL << (4U)))))) | (((CLUTCfg.Size << (8U)) | (CLUTCfg.CLUTColorMode << (4U)))))652964294901999regMaskregValueIS_DMA2D_OFFSET(hdma2d->LayerCfg[LayerIdx].InputOffset)IS_DMA2D_INPUT_COLOR_MODE(hdma2d->LayerCfg[LayerIdx].InputColorMode)IS_DMA2D_ALPHA_MODE(hdma2d->LayerCfg[LayerIdx].AlphaMode)IS_DMA2D_ALPHA_INVERTED(hdma2d->LayerCfg[LayerIdx].AlphaInverted)IS_DMA2D_RB_SWAP(hdma2d->LayerCfg[LayerIdx].RedBlueSwap)196623427838670342794352794281532431(DMA2D_BGPFCCR_CM | DMA2D_BGPFCCR_AM | DMA2D_BGPFCCR_ALPHA | DMA2D_BGPFCCR_AI | DMA2D_BGPFCCR_RBS)(((READ_REG(hdma2d->Instance->BGPFCCR)) & (~(regMask))) | (regValue))(((((hdma2d->Instance->BGPFCCR))) & (~(regMask))) | (regValue))hdma2d->Instance->BGORpLayerCfg->InputOffsethdma2d->Instance->BGCOLRpLayerCfg->InputAlpha & (DMA2D_BGCOLR_BLUE | DMA2D_BGCOLR_GREEN | DMA2D_BGCOLR_RED)pLayerCfg->InputAlpha & ((0xFFUL << (0U)) | (0xFFUL << (8U)) | (0xFFUL << (16U)))(((READ_REG(hdma2d->Instance->FGPFCCR)) & (~(regMask))) | (regValue))(((((hdma2d->Instance->FGPFCCR))) & (~(regMask))) | (regValue))hdma2d->Instance->FGORhdma2d->Instance->FGCOLRpLayerCfg->InputAlpha & (DMA2D_FGCOLR_BLUE | DMA2D_FGCOLR_GREEN | DMA2D_FGCOLR_RED)hdma2d->Instance->ISRisrflagshdma2d->Instance->CRcrflags(0x1UL << (13U))(0x1UL << (12U))layer_start0x0UDMA2D_FLAG_CE | DMA2D_FLAG_TE(0x1UL << (5U)) | (0x1UL << (0U))(DMA2D_FLAG_CE | DMA2D_FLAG_TE)DMA2D_FLAG_CAE | DMA2D_FLAG_CE | DMA2D_FLAG_TE(0x1UL << (3U)) | (0x1UL << (5U)) | (0x1UL << (0U))(DMA2D_FLAG_CAE | DMA2D_FLAG_CE | DMA2D_FLAG_TE)DMA2D_FLAG_TC | DMA2D_FLAG_CTC(0x1UL << (1U)) | (0x1UL << (4U))loadsuspendedconst volatile uint32_t *DMA2D_TIMEOUT_SUSPENDDMA2D_TIMEOUT_ABORTDMA2D_IT_CTC | DMA2D_IT_TE | DMA2D_IT_CE | DMA2D_IT_CAE(0x1UL << (12U)) | (0x1UL << (8U)) | (0x1UL << (13U)) | (0x1UL << (11U))145924294952703IS_DMA2D_CLUT_CM(CLUTCfg->CLUTColorMode)IS_DMA2D_CLUT_SIZE(CLUTCfg->Size)(uint32_t)CLUTCfg->pCLUT((CLUTCfg->Size << DMA2D_BGPFCCR_CS_Pos) | (CLUTCfg->CLUTColorMode << DMA2D_BGPFCCR_CCM_Pos))((CLUTCfg->Size << (8U)) | (CLUTCfg->CLUTColorMode << (4U)))(((READ_REG(hdma2d->Instance->BGPFCCR)) & (~(((0xFFUL << (8U)) | (0x1UL << (4U)))))) | (((CLUTCfg->Size << (8U)) | (CLUTCfg->CLUTColorMode << (4U)))))(((((hdma2d->Instance->BGPFCCR))) & (~(((0xFFUL << (8U)) | (0x1UL << (4U)))))) | (((CLUTCfg->Size << (8U)) | (CLUTCfg->CLUTColorMode << (4U)))))((CLUTCfg->Size << DMA2D_FGPFCCR_CS_Pos) | (CLUTCfg->CLUTColorMode << DMA2D_FGPFCCR_CCM_Pos))(((READ_REG(hdma2d->Instance->FGPFCCR)) & (~(((0xFFUL << (8U)) | (0x1UL << (4U)))))) | (((CLUTCfg->Size << (8U)) | (CLUTCfg->CLUTColorMode << (4U)))))(((((hdma2d->Instance->FGPFCCR))) & (~(((0xFFUL << (8U)) | (0x1UL << (4U)))))) | (((CLUTCfg->Size << (8U)) | (CLUTCfg->CLUTColorMode << (4U)))))(DMA2D_CR_SUSP | DMA2D_CR_START)((0x1UL << (1U)) | (0x1UL << (0U)))4294967292DMA2D_CR_SUSP | DMA2D_CR_START(0x1UL << (1U)) | (0x1UL << (0U))(hdma2d->Instance->CR)(((READ_REG(hdma2d->Instance->CR)) & (~((0x1UL << (1U)) | (0x1UL << (0U))))) | ((0x1UL << (1U))))(((((hdma2d->Instance->CR))) & (~((0x1UL << (1U)) | (0x1UL << (0U))))) | ((0x1UL << (1U))))DMA2D_CR_ABORT | DMA2D_CR_START(0x1UL << (2U)) | (0x1UL << (0U))(((READ_REG(hdma2d->Instance->CR)) & (~((0x1UL << (2U)) | (0x1UL << (0U))))) | ((0x1UL << (2U))))(((((hdma2d->Instance->CR))) & (~((0x1UL << (2U)) | (0x1UL << (0U))))) | ((0x1UL << (2U))))4294967290DMA2D_IT_TC | DMA2D_IT_TE | DMA2D_IT_CE(0x1UL << (9U)) | (0x1UL << (8U)) | (0x1UL << (13U))4294958335IS_DMA2D_LINE(Height)IS_DMA2D_PIXEL(Width)hdma2d->Instance->BGMARIS_DMA2D_ALL_INSTANCE(hdma2d->Instance)IS_DMA2D_MODE(hdma2d->Init.Mode)IS_DMA2D_CMODE(hdma2d->Init.ColorMode)IS_DMA2D_OFFSET(hdma2d->Init.OutputOffset)IS_DMA2D_ALPHA_INVERTED(hdma2d->Init.AlphaInverted)IS_DMA2D_RB_SWAP(hdma2d->Init.RedBlueSwap)(0x3UL << (16U))hdma2d->Init.Mode(((READ_REG(hdma2d->Instance->CR)) & (~((0x3UL << (16U))))) | (hdma2d->Init.Mode))(((((hdma2d->Instance->CR))) & (~((0x3UL << (16U))))) | (hdma2d->Init.Mode))hdma2d->Instance->OPFCCRhdma2d->Init.ColorMode(hdma2d->Instance->OPFCCR)(((READ_REG(hdma2d->Instance->OPFCCR)) & (~((0x7UL << (0U))))) | (hdma2d->Init.ColorMode))(((((hdma2d->Instance->OPFCCR))) & (~((0x7UL << (0U))))) | (hdma2d->Init.ColorMode))hdma2d->Instance->OOR(0x3FFFUL << (0U))hdma2d->Init.OutputOffset(hdma2d->Instance->OOR)(((READ_REG(hdma2d->Instance->OOR)) & (~((0x3FFFUL << (0U))))) | (hdma2d->Init.OutputOffset))(((((hdma2d->Instance->OOR))) & (~((0x3FFFUL << (0U))))) | (hdma2d->Init.OutputOffset))4294950912(DMA2D_OPFCCR_AI | DMA2D_OPFCCR_RBS)((0x1UL << (20U)) | (0x1UL << (21U)))((hdma2d->Init.AlphaInverted << DMA2D_OPFCCR_AI_Pos) | (hdma2d->Init.RedBlueSwap << DMA2D_OPFCCR_RBS_Pos))((hdma2d->Init.AlphaInverted << (20U)) | (hdma2d->Init.RedBlueSwap << (21U)))(((READ_REG(hdma2d->Instance->OPFCCR)) & (~(((0x1UL << (20U)) | (0x1UL << (21U)))))) | (((hdma2d->Init.AlphaInverted << (20U)) | (hdma2d->Init.RedBlueSwap << (21U)))))(((((hdma2d->Instance->OPFCCR))) & (~(((0x1UL << (20U)) | (0x1UL << (21U)))))) | (((hdma2d->Init.AlphaInverted << (20U)) | (hdma2d->Init.RedBlueSwap << (21U)))))(1000U)/* DMA2D *//* Configure DMA2D source address *//* M2M, M2M_PFC or M2M_Blending DMA2D Mode *//* Write to DMA2D OCOLR register *//* Dhdma2d->Init.ColorMode = DMA2D_OUTPUT_ARGB4444 *//* Prepare the value to be written to the OCOLR register according to the color mode *//* Register to memory DMA2D mode selected *//* Configure DMA2D destination address *//* Configure DMA2D data size *//**
  * @brief  Set the DMA2D transfer parameters.
  * @param  hdma2d     Pointer to a DMA2D_HandleTypeDef structure that contains
  *                     the configuration information for the specified DMA2D.
  * @param  pdata      The source memory Buffer address
  * @param  DstAddress The destination memory Buffer address
  * @param  Width      The width of data to be transferred from source to destination.
  * @param  Height     The height of data to be transferred from source to destination.
  * @retval HAL status
  *//** @defgroup DMA2D_Private_Functions DMA2D Private Functions
  * @{
  *//**
  * @brief  Return the DMA2D error code
  * @param  hdma2d  pointer to a DMA2D_HandleTypeDef structure that contains
  *               the configuration information for DMA2D.
  * @retval DMA2D Error Code
  *//**
  * @brief  Return the DMA2D state
  * @param  hdma2d pointer to a DMA2D_HandleTypeDef structure that contains
  *                 the configuration information for the DMA2D.
  * @retval HAL state
  *//** @defgroup DMA2D_Exported_Functions_Group4 Peripheral State and Error functions
  *  @brief    Peripheral State functions
  *
@verbatim
 ===============================================================================
                  ##### Peripheral State and Errors functions #####
 ===============================================================================
    [..]
    This subsection provides functions allowing to:
      (+) Get the DMA2D state
      (+) Get the DMA2D error code

@endverbatim
  * @{
  *//* Set DMA2D_AMTCR DT field *//**
  * @brief Configure dead time.
  * @note The dead time value represents the guaranteed minimum number of cycles between
  *       two consecutive transactions on the AHB bus.
  * @param hdma2d DMA2D handle.
  * @param DeadTime dead time value.
  * @retval HAL status
  *//* Clear DMA2D_AMTCR EN bit *//**
  * @brief Disable DMA2D dead time feature.
  * @param hdma2d DMA2D handle.
  * @retval HAL status
  *//* Set DMA2D_AMTCR EN bit *//**
  * @brief Enable DMA2D dead time feature.
  * @param hdma2d DMA2D handle.
  * @retval HAL status
  *//* Initialize the DMA2D state*//* Enable the Line interrupt *//* Sets the Line watermark configuration *//* Change DMA2D peripheral state *//**
  * @brief  Configure the line watermark.
  * @param  hdma2d Pointer to a DMA2D_HandleTypeDef structure that contains
  *                 the configuration information for the DMA2D.
  * @param  Line   Line Watermark configuration (maximum 16-bit long value expected).
  * @note   HAL_DMA2D_ProgramLineEvent() API enables the transfer watermark interrupt.
  * @note   The transfer watermark interrupt is disabled once it has occurred.
  * @retval HAL status
  *//* Set the DMA2D state to Ready*//* Write foreground CLUT size and CLUT color mode *//* Write foreground CLUT memory address *//* Configure the CLUT of the foreground DMA2D layer *//* Write background CLUT size and CLUT color mode *//* Write background CLUT memory address *//* Configure the CLUT of the background DMA2D layer *//**
  * @brief  Configure the DMA2D CLUT Transfer.
  * @param  hdma2d   Pointer to a DMA2D_HandleTypeDef structure that contains
  *                   the configuration information for the DMA2D.
  * @param  CLUTCfg  Pointer to a DMA2D_CLUTCfgTypeDef structure that contains
  *                   the configuration information for the color look up table.
  * @param  LayerIdx DMA2D Layer index.
  *                   This parameter can be one of the following values:
  *                   DMA2D_BACKGROUND_LAYER(0) / DMA2D_FOREGROUND_LAYER(1)
  * @note API obsolete and maintained for compatibility with legacy. User is invited
  *      to resort to HAL_DMA2D_CLUTStartLoad() instead to benefit from code compactness,
  *      code size and improved heap usage.
  * @retval HAL status
  *//* DMA2D FGCOLR register configuration -------------------------------------*//* DMA2D FGOR register configuration -------------------------------------*//* Write DMA2D FGPFCCR register *//* Configure the foreground DMA2D layer *//* DMA2D BGCOLR register configuration -------------------------------------*//* DMA2D BGOR register configuration -------------------------------------*//* Write DMA2D BGPFCCR register *//* Configure the background DMA2D layer *//* Prepare the value to be written to the BGPFCCR or FGPFCCR register *//**
  * @brief  Configure the DMA2D Layer according to the specified
  *         parameters in the DMA2D_HandleTypeDef.
  * @param  hdma2d Pointer to a DMA2D_HandleTypeDef structure that contains
  *                 the configuration information for the DMA2D.
  * @param  LayerIdx DMA2D Layer index.
  *                   This parameter can be one of the following values:
  *                   DMA2D_BACKGROUND_LAYER(0) / DMA2D_FOREGROUND_LAYER(1)
  * @retval HAL status
  *//** @defgroup DMA2D_Exported_Functions_Group3 Peripheral Control functions
  *  @brief    Peripheral Control functions
  *
@verbatim
 ===============================================================================
                    ##### Peripheral Control functions #####
 ===============================================================================
    [..]  This section provides functions allowing to:
      (+) Configure the DMA2D foreground or background layer parameters.
      (+) Configure the DMA2D CLUT transfer.
      (+) Configure the line watermark
      (+) Configure the dead time value.
      (+) Enable or disable the dead time value functionality.


@endverbatim
  * @{
  *//* NOTE : This function should not be modified; when the callback is needed,
            the HAL_DMA2D_CLUTLoadingCpltCallback can be implemented in the user file.
   *//**
  * @brief  CLUT Transfer Complete callback.
  * @param  hdma2d pointer to a DMA2D_HandleTypeDef structure that contains
  *                 the configuration information for the DMA2D.
  * @retval None
  *//* NOTE : This function should not be modified; when the callback is needed,
            the HAL_DMA2D_LineEventCallback can be implemented in the user file.
   *//**
  * @brief  Transfer watermark callback.
  * @param  hdma2d pointer to a DMA2D_HandleTypeDef structure that contains
  *                 the configuration information for the DMA2D.
  * @retval None
  *//* CLUT Transfer complete Callback *//* Change DMA2D state *//* Clear the CLUT transfer complete flag *//* Disable the CLUT transfer complete interrupt *//* CLUT Transfer Complete Interrupt management ******************************//* Transfer complete Callback *//* Transfer Complete Interrupt management ************************************//* Transfer watermark Callback *//* Clear the transfer watermark flag *//* Disable the transfer watermark interrupt *//* Transfer watermark Interrupt management **********************************//* Transfer error Callback *//* Clear the CLUT access error flag *//* Disable the CLUT access error interrupt *//* CLUT access Error Interrupt management ***********************************//* Clear the Configuration error flag *//* Disable the Configuration Error interrupt *//* Configuration Error Interrupt management **********************************//* Disable the transfer Error interrupt *//**
  * @brief  Handle DMA2D interrupt request.
  * @param  hdma2d Pointer to a DMA2D_HandleTypeDef structure that contains
  *                 the configuration information for the DMA2D.
  * @retval HAL status
  *//* Clear the transfer complete and CLUT loading flags *//* Change the DMA2D state *//* Clear the CLUT Access Error, Configuration Error and Transfer Error flags *//* Polling for CLUT loading (foreground or background) *//* Clear the transfer and configuration error flags *//* Polling for DMA2D transfer *//**

  * @brief  Polling for transfer complete or CLUT loading.
  * @param  hdma2d Pointer to a DMA2D_HandleTypeDef structure that contains
  *                 the configuration information for the DMA2D.
  * @param  Timeout Timeout duration
  * @retval HAL status
  *//* Resume the CLUT loading *//* Ongoing CLUT loading is suspended: change the DMA2D state before resuming *//* Foreground CLUT loading suspension check *//* Background CLUT loading suspension check *//* Check the SUSP and START bits for background or foreground CLUT loading *//**
  * @brief  Resume the DMA2D CLUT loading.
  * @param  hdma2d pointer to a DMA2D_HandleTypeDef structure that contains
  *                 the configuration information for the DMA2D.
  * @param  LayerIdx DMA2D Layer index.
  *                   This parameter can be one of the following values:
  *                   DMA2D_BACKGROUND_LAYER(0) / DMA2D_FOREGROUND_LAYER(1)
  * @retval HAL status
  *//* Make sure SUSP bit is cleared since it is meaningless
       when no transfer is on-going *//* Check whether or not a transfer is actually suspended and change the DMA2D state accordingly *//* 2nd condition: Not Start Check *//* 1st condition: Suspend Check *//* Check if the CLUT loading is suspended *//* If foreground CLUT loading is considered, update local variables *//* Suspend the CLUT loading *//* by default, point at background register *//**
  * @brief  Suspend the DMA2D CLUT loading.
  * @param  hdma2d Pointer to a DMA2D_HandleTypeDef structure that contains
  *                 the configuration information for the DMA2D.
  * @param  LayerIdx DMA2D Layer index.
  *                   This parameter can be one of the following values:
  *                   DMA2D_BACKGROUND_LAYER(0) / DMA2D_FOREGROUND_LAYER(1)
  * @retval HAL status
  *//* Change the DMA2D state*//* Disable the CLUT Transfer Complete, Transfer Error, Configuration Error and CLUT Access Error interrupts *//* Check if the CLUT loading is aborted *//* Abort the CLUT loading *//**
  * @brief  Abort the DMA2D CLUT loading.
  * @param  hdma2d  Pointer to a DMA2D_HandleTypeDef structure that contains
  *                  the configuration information for the DMA2D.
  * @param  LayerIdx DMA2D Layer index.
  *                   This parameter can be one of the following values:
  *                   DMA2D_BACKGROUND_LAYER(0) / DMA2D_FOREGROUND_LAYER(1)
  * @retval HAL status
  *//* Enable the CLUT loading for the foreground *//* Enable the CLUT Transfer Complete, transfer Error, configuration Error and CLUT Access Error interrupts *//* Enable the CLUT loading for the background *//**
  * @brief  Start DMA2D CLUT Loading with interrupt enabled.
  * @param  hdma2d   Pointer to a DMA2D_HandleTypeDef structure that contains
  *                   the configuration information for the DMA2D.
  * @param  CLUTCfg  Pointer to a DMA2D_CLUTCfgTypeDef structure that contains
  *                   the configuration information for the color look up table.
  * @param  LayerIdx DMA2D Layer index.
  *                   This parameter can be one of the following values:
  *                   DMA2D_BACKGROUND_LAYER(0) / DMA2D_FOREGROUND_LAYER(1)
  * @note API obsolete and maintained for compatibility with legacy. User is
  *      invited to resort to HAL_DMA2D_CLUTStartLoad_IT() instead to benefit
  *      from code compactness, code size and improved heap usage.
  * @retval HAL status
  *//**
  * @brief  Start DMA2D CLUT Loading.
  * @param  hdma2d   Pointer to a DMA2D_HandleTypeDef structure that contains
  *                   the configuration information for the DMA2D.
  * @param  CLUTCfg  Pointer to a DMA2D_CLUTCfgTypeDef structure that contains
  *                   the configuration information for the color look up table.
  * @param  LayerIdx DMA2D Layer index.
  *                   This parameter can be one of the following values:
  *                   DMA2D_BACKGROUND_LAYER(0) / DMA2D_FOREGROUND_LAYER(1)
  * @note API obsolete and maintained for compatibility with legacy. User is
  *      invited to resort to HAL_DMA2D_CLUTStartLoad() instead to benefit from
  *      code compactness, code size and improved heap usage.
  * @retval HAL status
  *//**
  * @brief  Start DMA2D CLUT Loading with interrupt enabled.
  * @param  hdma2d   Pointer to a DMA2D_HandleTypeDef structure that contains
  *                   the configuration information for the DMA2D.
  * @param  CLUTCfg  Pointer to a DMA2D_CLUTCfgTypeDef structure that contains
  *                   the configuration information for the color look up table.
  * @param  LayerIdx DMA2D Layer index.
  *                   This parameter can be one of the following values:
  *                   DMA2D_BACKGROUND_LAYER(0) / DMA2D_FOREGROUND_LAYER(1)
  * @retval HAL status
  *//**
  * @brief  Start DMA2D CLUT Loading.
  * @param  hdma2d   Pointer to a DMA2D_HandleTypeDef structure that contains
  *                   the configuration information for the DMA2D.
  * @param  CLUTCfg  Pointer to a DMA2D_CLUTCfgTypeDef structure that contains
  *                   the configuration information for the color look up table.
  * @param  LayerIdx DMA2D Layer index.
  *                   This parameter can be one of the following values:
  *                   DMA2D_BACKGROUND_LAYER(0) / DMA2D_FOREGROUND_LAYER(1)
  * @retval HAL status
  *//* Enable the foreground CLUT loading *//* Enable the background CLUT loading *//**
  * @brief  Enable the DMA2D CLUT Transfer.
  * @param  hdma2d   Pointer to a DMA2D_HandleTypeDef structure that contains
  *                   the configuration information for the DMA2D.
  * @param  LayerIdx DMA2D Layer index.
  *                   This parameter can be one of the following values:
  *                   DMA2D_BACKGROUND_LAYER(0) / DMA2D_FOREGROUND_LAYER(1)
  * @retval HAL status
  *//* START bit is reset to make sure not to set it again, in the event the HW clears it
     between the register read and the register write by the CPU (writing 0 has no
     effect on START bitvalue). *//* Resume the DMA2D transfer *//* Ongoing transfer is suspended: change the DMA2D state before resuming *//* Check the SUSP and START bits *//**
  * @brief  Resume the DMA2D Transfer.
  * @param  hdma2d pointer to a DMA2D_HandleTypeDef structure that contains
  *                 the configuration information for the DMA2D.
  * @retval HAL status
  *//* Check if the DMA2D is effectively suspended *//* Suspend the DMA2D transfer *//**
  * @brief  Suspend the DMA2D Transfer.
  * @param  hdma2d pointer to a DMA2D_HandleTypeDef structure that contains
  *                 the configuration information for the DMA2D.
  * @retval HAL status
  *//* Disable the Transfer Complete, Transfer Error and Configuration Error interrupts *//* Check if the DMA2D is effectively disabled *//* START bit is reset to make sure not to set it again, in the event the HW clears it
     between the register read and the register write by the CPU (writing 0 has no
     effect on START bitvalue) *//* Abort the DMA2D transfer *//**
  * @brief  Abort the DMA2D Transfer.
  * @param  hdma2d  pointer to a DMA2D_HandleTypeDef structure that contains
  *                  the configuration information for the DMA2D.
  * @retval HAL status
  *//* Enable the transfer complete, transfer error and configuration error interrupts *//* Configure the source, destination address and the data size *//* Configure DMA2D Stream source2 address *//**
  * @brief  Start the multi-source DMA2D Transfer with interrupt enabled.
  * @param  hdma2d     Pointer to a DMA2D_HandleTypeDef structure that contains
  *                     the configuration information for the DMA2D.
  * @param  SrcAddress1 The source memory Buffer address for the foreground layer.
  * @param  SrcAddress2 The source memory Buffer address for the background layer.
  * @param  DstAddress  The destination memory Buffer address.
  * @param  Width       The width of data to be transferred from source
  *                     to destination (expressed in number of pixels per line).
  * @param  Height      The height of data to be transferred from source to destination (expressed in number of lines).
  * @retval HAL status
  *//**
  * @brief  Start the multi-source DMA2D Transfer.
  * @param  hdma2d      Pointer to a DMA2D_HandleTypeDef structure that contains
  *                      the configuration information for the DMA2D.
  * @param  SrcAddress1 The source memory Buffer address for the foreground layer.
  * @param  SrcAddress2 The source memory Buffer address for the background layer.
  * @param  DstAddress  The destination memory Buffer address.
  * @param  Width       The width of data to be transferred from source
  *                     to destination (expressed in number of pixels per line).
  * @param  Height      The height of data to be transferred from source to destination (expressed in number of lines).
  * @retval HAL status
  *//**
  * @brief  Start the DMA2D Transfer with interrupt enabled.
  * @param  hdma2d     Pointer to a DMA2D_HandleTypeDef structure that contains
  *                     the configuration information for the DMA2D.
  * @param  pdata      Configure the source memory Buffer address if
  *                     the Memory-to-Memory or Memory-to-Memory with pixel format
  *                     conversion mode is selected, or configure
  *                     the color value if Register-to-Memory mode is selected.
  * @param  DstAddress The destination memory Buffer address.
  * @param  Width      The width of data to be transferred from source
  *                    to destination (expressed in number of pixels per line).
  * @param  Height     The height of data to be transferred from source to destination (expressed in number of lines).
  * @retval HAL status
  *//**
  * @brief  Start the DMA2D Transfer.
  * @param  hdma2d     Pointer to a DMA2D_HandleTypeDef structure that contains
  *                     the configuration information for the DMA2D.
  * @param  pdata      Configure the source memory Buffer address if
  *                     Memory-to-Memory or Memory-to-Memory with pixel format
  *                     conversion mode is selected, or configure
  *                     the color value if Register-to-Memory mode is selected.
  * @param  DstAddress The destination memory Buffer address.
  * @param  Width      The width of data to be transferred from source
  *                    to destination (expressed in number of pixels per line).
  * @param  Height     The height of data to be transferred from source to destination (expressed in number of lines).
  * @retval HAL status
  *//** @defgroup DMA2D_Exported_Functions_Group2 IO operation functions
  *  @brief   IO operation functions
  *
@verbatim
 ===============================================================================
                      #####  IO operation functions  #####
 ===============================================================================
    [..]  This section provides functions allowing to:
      (+) Configure the pdata, destination address and data size then
          start the DMA2D transfer.
      (+) Configure the source for foreground and background, destination address
          and data size then start a MultiBuffer DMA2D transfer.
      (+) Configure the pdata, destination address and data size then
          start the DMA2D transfer with interrupt.
      (+) Configure the source for foreground and background, destination address
          and data size then start a MultiBuffer DMA2D transfer with interrupt.
      (+) Abort DMA2D transfer.
      (+) Suspend DMA2D transfer.
      (+) Resume DMA2D transfer.
      (+) Enable CLUT transfer.
      (+) Configure CLUT loading then start transfer in polling mode.
      (+) Configure CLUT loading then start transfer in interrupt mode.
      (+) Abort DMA2D CLUT loading.
      (+) Suspend DMA2D CLUT loading.
      (+) Resume DMA2D CLUT loading.
      (+) Poll for transfer complete.
      (+) handle DMA2D interrupt request.
      (+) Transfer watermark callback.
      (+) CLUT Transfer Complete callback.


@endverbatim
  * @{
  *//* Legacy weak (overridden) Msp DeInit *//* Legacy weak (overridden) Msp Init *//**
  * @brief  Unregister a DMA2D Callback
  *         DMA2D Callback is redirected to the weak (overridden) predefined callback
  * @param hdma2d DMA2D handle
  * @param CallbackID ID of the callback to be unregistered
  *        This parameter can be one of the following values:
  *          @arg @ref HAL_DMA2D_TRANSFERCOMPLETE_CB_ID DMA2D transfer complete Callback ID
  *          @arg @ref HAL_DMA2D_TRANSFERERROR_CB_ID DMA2D transfer error Callback ID
  *          @arg @ref HAL_DMA2D_LINEEVENT_CB_ID DMA2D line event Callback ID
  *          @arg @ref HAL_DMA2D_CLUTLOADINGCPLT_CB_ID DMA2D CLUT loading completion Callback ID
  *          @arg @ref HAL_DMA2D_MSPINIT_CB_ID DMA2D MspInit callback ID
  *          @arg @ref HAL_DMA2D_MSPDEINIT_CB_ID DMA2D MspDeInit callback ID
  * @note No weak predefined callbacks are defined for HAL_DMA2D_TRANSFERCOMPLETE_CB_ID or HAL_DMA2D_TRANSFERERROR_CB_ID
  * @retval status
  *//**
  * @brief  Register a User DMA2D Callback
  *         To be used instead of the weak (overridden) predefined callback
  * @param hdma2d DMA2D handle
  * @param CallbackID ID of the callback to be registered
  *        This parameter can be one of the following values:
  *          @arg @ref HAL_DMA2D_TRANSFERCOMPLETE_CB_ID DMA2D transfer complete Callback ID
  *          @arg @ref HAL_DMA2D_TRANSFERERROR_CB_ID DMA2D transfer error Callback ID
  *          @arg @ref HAL_DMA2D_LINEEVENT_CB_ID DMA2D line event Callback ID
  *          @arg @ref HAL_DMA2D_CLUTLOADINGCPLT_CB_ID DMA2D CLUT loading completion Callback ID
  *          @arg @ref HAL_DMA2D_MSPINIT_CB_ID DMA2D MspInit callback ID
  *          @arg @ref HAL_DMA2D_MSPDEINIT_CB_ID DMA2D MspDeInit callback ID
  * @param pCallback pointer to the Callback function
  * @note No weak predefined callbacks are defined for HAL_DMA2D_TRANSFERCOMPLETE_CB_ID or HAL_DMA2D_TRANSFERERROR_CB_ID
  * @retval status
  *//* NOTE : This function should not be modified; when the callback is needed,
            the HAL_DMA2D_MspDeInit can be implemented in the user file.
   *//**
  * @brief  DeInitializes the DMA2D MSP.
  * @param  hdma2d pointer to a DMA2D_HandleTypeDef structure that contains
  *                 the configuration information for the DMA2D.
  * @retval None
  *//* NOTE : This function should not be modified; when the callback is needed,
            the HAL_DMA2D_MspInit can be implemented in the user file.
   *//**
  * @brief  Initializes the DMA2D MSP.
  * @param  hdma2d pointer to a DMA2D_HandleTypeDef structure that contains
  *                 the configuration information for the DMA2D.
  * @retval None
  *//* Carry on with de-initialization of low level hardware *//* DeInit the low level hardware *//* Reset DMA2D control registers*//* Issue when aborting foreground CLUT loading *//* Abort foreground CLUT loading if any *//* Issue when aborting background CLUT loading *//* Abort background CLUT loading if any *//* Issue when aborting DMA2D transfer *//* Abort DMA2D transfer if any *//* Before aborting any DMA2D transfer or CLUT loading, check
     first whether or not DMA2D clock is enabled *//* Check the DMA2D peripheral state *//**
  * @brief  Deinitializes the DMA2D peripheral registers to their default reset
  *         values.
  * @param  hdma2d pointer to a DMA2D_HandleTypeDef structure that contains
  *                 the configuration information for the DMA2D.
  * @retval None
  *//* DMA2D OPFCCR AI and RBS fields setting (Output Alpha Inversion)*//* DMA2D OOR register configuration ------------------------------------------*//* DMA2D OPFCCR register configuration ---------------------------------------*//* DMA2D CR register configuration -------------------------------------------*//* Reset Callback pointers in HAL_DMA2D_STATE_RESET only *//**
  * @brief  Initialize the DMA2D according to the specified
  *         parameters in the DMA2D_InitTypeDef and create the associated handle.
  * @param  hdma2d pointer to a DMA2D_HandleTypeDef structure that contains
  *                 the configuration information for the DMA2D.
  * @retval HAL status
  *//** @defgroup DMA2D_Exported_Functions_Group1 Initialization and de-initialization functions
  *  @brief   Initialization and Configuration functions
  *
@verbatim
 ===============================================================================
                ##### Initialization and Configuration functions #####
 ===============================================================================
    [..]  This section provides functions allowing to:
      (+) Initialize and configure the DMA2D
      (+) De-initialize the DMA2D

@endverbatim
  * @{
  *//** @defgroup DMA2D_Exported_Functions DMA2D Exported Functions
  * @{
  *//** @addtogroup DMA2D_Private_Functions DMA2D Private Functions
  * @{
  *//*!<  1s  *//** @defgroup DMA2D_TimeOut DMA2D Time Out
  * @{
  *//** @defgroup DMA2D_Private_Constants DMA2D Private Constants
  * @{
  *//** @defgroup DMA2D  DMA2D
  * @brief DMA2D HAL module driver
  * @{
  *//**
  ******************************************************************************
  * @file    stm32f7xx_hal_dma2d.c
  * @author  MCD Application Team
  * @brief   DMA2D HAL module driver.
  *          This file provides firmware functions to manage the following
  *          functionalities of the DMA2D peripheral:
  *           + Initialization and de-initialization functions
  *           + IO operation functions
  *           + Peripheral Control functions
  *           + Peripheral State and Errors functions
  *
  ******************************************************************************
  * @attention
  *
  * Copyright (c) 2017 STMicroelectronics.
  * All rights reserved.
  *
  * This software is licensed under terms that can be found in the LICENSE file
  * in the root directory of this software component.
  * If no LICENSE file comes with this software, it is provided AS-IS.
  *
  ******************************************************************************
  @verbatim
  ==============================================================================
                        ##### How to use this driver #####
  ==============================================================================
    [..]
      (#) Program the required configuration through the following parameters:
          the transfer mode, the output color mode and the output offset using
          HAL_DMA2D_Init() function.

      (#) Program the required configuration through the following parameters:
          the input color mode, the input color, the input alpha value, the alpha mode,
          the red/blue swap mode, the inverted alpha mode and the input offset using
          HAL_DMA2D_ConfigLayer() function for foreground or/and background layer.

     *** Polling mode IO operation ***
     =================================
    [..]
       (#) Configure pdata parameter (explained hereafter), destination and data length
           and enable the transfer using HAL_DMA2D_Start().
       (#) Wait for end of transfer using HAL_DMA2D_PollForTransfer(), at this stage
           user can specify the value of timeout according to his end application.

     *** Interrupt mode IO operation ***
     ===================================
     [..]
       (#) Configure pdata parameter, destination and data length and enable
           the transfer using HAL_DMA2D_Start_IT().
       (#) Use HAL_DMA2D_IRQHandler() called under DMA2D_IRQHandler() interrupt subroutine.
       (#) At the end of data transfer HAL_DMA2D_IRQHandler() function is executed and user can
           add his own function by customization of function pointer XferCpltCallback (member
           of DMA2D handle structure).
       (#) In case of error, the HAL_DMA2D_IRQHandler() function calls the callback
           XferErrorCallback.

         -@-   In Register-to-Memory transfer mode, pdata parameter is the register
               color, in Memory-to-memory or Memory-to-Memory with pixel format
               conversion pdata is the source address.

         -@-   Configure the foreground source address, the background source address,
               the destination and data length then Enable the transfer using
               HAL_DMA2D_BlendingStart() in polling mode and HAL_DMA2D_BlendingStart_IT()
               in interrupt mode.

         -@-   HAL_DMA2D_BlendingStart() and HAL_DMA2D_BlendingStart_IT() functions
               are used if the memory to memory with blending transfer mode is selected.

      (#) Optionally, configure and enable the CLUT using HAL_DMA2D_CLUTLoad() in polling
          mode or HAL_DMA2D_CLUTLoad_IT() in interrupt mode.

      (#) Optionally, configure the line watermark in using the API HAL_DMA2D_ProgramLineEvent().

      (#) Optionally, configure the dead time value in the AHB clock cycle inserted between two
          consecutive accesses on the AHB master port in using the API HAL_DMA2D_ConfigDeadTime()
          and enable/disable the functionality  with the APIs HAL_DMA2D_EnableDeadTime() or
          HAL_DMA2D_DisableDeadTime().

      (#) The transfer can be suspended, resumed and aborted using the following
          functions: HAL_DMA2D_Suspend(), HAL_DMA2D_Resume(), HAL_DMA2D_Abort().

      (#) The CLUT loading can be suspended, resumed and aborted using the following
          functions: HAL_DMA2D_CLUTLoading_Suspend(), HAL_DMA2D_CLUTLoading_Resume(),
          HAL_DMA2D_CLUTLoading_Abort().

      (#) To control the DMA2D state, use the following function: HAL_DMA2D_GetState().

      (#) To read the DMA2D error code, use the following function: HAL_DMA2D_GetError().

     *** DMA2D HAL driver macros list ***
     =============================================
     [..]
       Below the list of most used macros in DMA2D HAL driver :

      (+) __HAL_DMA2D_ENABLE: Enable the DMA2D peripheral.
      (+) __HAL_DMA2D_GET_FLAG: Get the DMA2D pending flags.
      (+) __HAL_DMA2D_CLEAR_FLAG: Clear the DMA2D pending flags.
      (+) __HAL_DMA2D_ENABLE_IT: Enable the specified DMA2D interrupts.
      (+) __HAL_DMA2D_DISABLE_IT: Disable the specified DMA2D interrupts.
      (+) __HAL_DMA2D_GET_IT_SOURCE: Check whether the specified DMA2D interrupt is enabled or not.

     *** Callback registration ***
     ===================================
     [..]
      (#) The compilation define  USE_HAL_DMA2D_REGISTER_CALLBACKS when set to 1
          allows the user to configure dynamically the driver callbacks.
          Use function @ref HAL_DMA2D_RegisterCallback() to register a user callback.

      (#) Function @ref HAL_DMA2D_RegisterCallback() allows to register following callbacks:
            (+) XferCpltCallback : callback for transfer complete.
            (+) XferErrorCallback : callback for transfer error.
            (+) LineEventCallback : callback for line event.
            (+) CLUTLoadingCpltCallback : callback for CLUT loading completion.
            (+) MspInitCallback    : DMA2D MspInit.
            (+) MspDeInitCallback  : DMA2D MspDeInit.
          This function takes as parameters the HAL peripheral handle, the Callback ID
          and a pointer to the user callback function.

      (#) Use function @ref HAL_DMA2D_UnRegisterCallback() to reset a callback to the default
          weak (overridden) function.
          @ref HAL_DMA2D_UnRegisterCallback() takes as parameters the HAL peripheral handle,
          and the Callback ID.
          This function allows to reset following callbacks:
            (+) XferCpltCallback : callback for transfer complete.
            (+) XferErrorCallback : callback for transfer error.
            (+) LineEventCallback : callback for line event.
            (+) CLUTLoadingCpltCallback : callback for CLUT loading completion.
            (+) MspInitCallback    : DMA2D MspInit.
            (+) MspDeInitCallback  : DMA2D MspDeInit.

      (#) By default, after the @ref HAL_DMA2D_Init and if the state is HAL_DMA2D_STATE_RESET
          all callbacks are reset to the corresponding legacy weak (overridden) functions:
          examples @ref HAL_DMA2D_LineEventCallback(), @ref HAL_DMA2D_CLUTLoadingCpltCallback()
          Exception done for MspInit and MspDeInit callbacks that are respectively
          reset to the legacy weak (overridden) functions in the @ref HAL_DMA2D_Init
          and @ref HAL_DMA2D_DeInit only when these callbacks are null (not registered beforehand)
          If not, MspInit or MspDeInit are not null, the @ref HAL_DMA2D_Init and @ref HAL_DMA2D_DeInit
          keep and use the user MspInit/MspDeInit callbacks (registered beforehand).

          Exception as well for Transfer Completion and Transfer Error callbacks that are not defined
          as weak (overridden) functions. They must be defined by the user to be resorted to.

          Callbacks can be registered/unregistered in READY state only.
          Exception done for MspInit/MspDeInit callbacks that can be registered/unregistered
          in READY or RESET state, thus registered (user) MspInit/DeInit callbacks can be used
          during the Init/DeInit.
          In that case first register the MspInit/MspDeInit user callbacks
          using @ref HAL_DMA2D_RegisterCallback before calling @ref HAL_DMA2D_DeInit
          or @ref HAL_DMA2D_Init function.

          When The compilation define USE_HAL_DMA2D_REGISTER_CALLBACKS is set to 0 or
          not defined, the callback registering feature is not available
          and weak (overridden) callbacks are used.

     [..]
      (@) You can refer to the DMA2D HAL driver header file for more useful macros

  @endverbatim
  ******************************************************************************
  *//Users/jie/Documents/posixGen_Demos-main/LwIP_StreamingServer/Drivers/STM32F7xx_HAL_Driver/Src/stm32f7xx_hal_dma_ex.cDMA_MultiBufferSetConfig__HAL_DMA_GET_TC_FLAG_INDEX(hdma)(((uint32_t)((hdma)->Instance) == ((uint32_t)((DMA_Stream_TypeDef *) (((0x40000000UL + 0x00020000UL) + 0x6000UL) + 0x010UL))))? 0x00000020U : ((uint32_t)((hdma)->Instance) == ((uint32_t)((DMA_Stream_TypeDef *) (((0x40000000UL + 0x00020000UL) + 0x6400UL) + 0x010UL))))? 0x00000020U : ((uint32_t)((hdma)->Instance) == ((uint32_t)((DMA_Stream_TypeDef *) (((0x40000000UL + 0x00020000UL) + 0x6000UL) + 0x070UL))))? 0x00000020U : ((uint32_t)((hdma)->Instance) == ((uint32_t)((DMA_Stream_TypeDef *) (((0x40000000UL + 0x00020000UL) + 0x6400UL) + 0x070UL))))? 0x00000020U : ((uint32_t)((hdma)->Instance) == ((uint32_t)((DMA_Stream_TypeDef *) (((0x40000000UL + 0x00020000UL) + 0x6000UL) + 0x028UL))))? 0x00000800U : ((uint32_t)((hdma)->Instance) == ((uint32_t)((DMA_Stream_TypeDef *) (((0x40000000UL + 0x00020000UL) + 0x6400UL) + 0x028UL))))? 0x00000800U : ((uint32_t)((hdma)->Instance) == ((uint32_t)((DMA_Stream_TypeDef *) (((0x40000000UL + 0x00020000UL) + 0x6000UL) + 0x088UL))))? 0x00000800U : ((uint32_t)((hdma)->Instance) == ((uint32_t)((DMA_Stream_TypeDef *) (((0x40000000UL + 0x00020000UL) + 0x6400UL) + 0x088UL))))? 0x00000800U : ((uint32_t)((hdma)->Instance) == ((uint32_t)((DMA_Stream_TypeDef *) (((0x40000000UL + 0x00020000UL) + 0x6000UL) + 0x040UL))))? 0x00200000U : ((uint32_t)((hdma)->Instance) == ((uint32_t)((DMA_Stream_TypeDef *) (((0x40000000UL + 0x00020000UL) + 0x6400UL) + 0x040UL))))? 0x00200000U : ((uint32_t)((hdma)->Instance) == ((uint32_t)((DMA_Stream_TypeDef *) (((0x40000000UL + 0x00020000UL) + 0x6000UL) + 0x0A0UL))))? 0x00200000U : ((uint32_t)((hdma)->Instance) == ((uint32_t)((DMA_Stream_TypeDef *) (((0x40000000UL + 0x00020000UL) + 0x6400UL) + 0x0A0UL))))? 0x00200000U : 0x08000000U)__HAL_DMA_GET_HT_FLAG_INDEX(hdma)(((uint32_t)((hdma)->Instance) == ((uint32_t)((DMA_Stream_TypeDef *) (((0x40000000UL + 0x00020000UL) + 0x6000UL) + 0x010UL))))? 0x00000010U : ((uint32_t)((hdma)->Instance) == ((uint32_t)((DMA_Stream_TypeDef *) (((0x40000000UL + 0x00020000UL) + 0x6400UL) + 0x010UL))))? 0x00000010U : ((uint32_t)((hdma)->Instance) == ((uint32_t)((DMA_Stream_TypeDef *) (((0x40000000UL + 0x00020000UL) + 0x6000UL) + 0x070UL))))? 0x00000010U : ((uint32_t)((hdma)->Instance) == ((uint32_t)((DMA_Stream_TypeDef *) (((0x40000000UL + 0x00020000UL) + 0x6400UL) + 0x070UL))))? 0x00000010U : ((uint32_t)((hdma)->Instance) == ((uint32_t)((DMA_Stream_TypeDef *) (((0x40000000UL + 0x00020000UL) + 0x6000UL) + 0x028UL))))? 0x00000400U : ((uint32_t)((hdma)->Instance) == ((uint32_t)((DMA_Stream_TypeDef *) (((0x40000000UL + 0x00020000UL) + 0x6400UL) + 0x028UL))))? 0x00000400U : ((uint32_t)((hdma)->Instance) == ((uint32_t)((DMA_Stream_TypeDef *) (((0x40000000UL + 0x00020000UL) + 0x6000UL) + 0x088UL))))? 0x00000400U : ((uint32_t)((hdma)->Instance) == ((uint32_t)((DMA_Stream_TypeDef *) (((0x40000000UL + 0x00020000UL) + 0x6400UL) + 0x088UL))))? 0x00000400U : ((uint32_t)((hdma)->Instance) == ((uint32_t)((DMA_Stream_TypeDef *) (((0x40000000UL + 0x00020000UL) + 0x6000UL) + 0x040UL))))? 0x00100000U : ((uint32_t)((hdma)->Instance) == ((uint32_t)((DMA_Stream_TypeDef *) (((0x40000000UL + 0x00020000UL) + 0x6400UL) + 0x040UL))))? 0x00100000U : ((uint32_t)((hdma)->Instance) == ((uint32_t)((DMA_Stream_TypeDef *) (((0x40000000UL + 0x00020000UL) + 0x6000UL) + 0x0A0UL))))? 0x00100000U : ((uint32_t)((hdma)->Instance) == ((uint32_t)((DMA_Stream_TypeDef *) (((0x40000000UL + 0x00020000UL) + 0x6400UL) + 0x0A0UL))))? 0x00100000U : 0x04000000U)__HAL_DMA_GET_TE_FLAG_INDEX(hdma)(((uint32_t)((hdma)->Instance) == ((uint32_t)((DMA_Stream_TypeDef *) (((0x40000000UL + 0x00020000UL) + 0x6000UL) + 0x010UL))))? 0x00000008U : ((uint32_t)((hdma)->Instance) == ((uint32_t)((DMA_Stream_TypeDef *) (((0x40000000UL + 0x00020000UL) + 0x6400UL) + 0x010UL))))? 0x00000008U : ((uint32_t)((hdma)->Instance) == ((uint32_t)((DMA_Stream_TypeDef *) (((0x40000000UL + 0x00020000UL) + 0x6000UL) + 0x070UL))))? 0x00000008U : ((uint32_t)((hdma)->Instance) == ((uint32_t)((DMA_Stream_TypeDef *) (((0x40000000UL + 0x00020000UL) + 0x6400UL) + 0x070UL))))? 0x00000008U : ((uint32_t)((hdma)->Instance) == ((uint32_t)((DMA_Stream_TypeDef *) (((0x40000000UL + 0x00020000UL) + 0x6000UL) + 0x028UL))))? 0x00000200U : ((uint32_t)((hdma)->Instance) == ((uint32_t)((DMA_Stream_TypeDef *) (((0x40000000UL + 0x00020000UL) + 0x6400UL) + 0x028UL))))? 0x00000200U : ((uint32_t)((hdma)->Instance) == ((uint32_t)((DMA_Stream_TypeDef *) (((0x40000000UL + 0x00020000UL) + 0x6000UL) + 0x088UL))))? 0x00000200U : ((uint32_t)((hdma)->Instance) == ((uint32_t)((DMA_Stream_TypeDef *) (((0x40000000UL + 0x00020000UL) + 0x6400UL) + 0x088UL))))? 0x00000200U : ((uint32_t)((hdma)->Instance) == ((uint32_t)((DMA_Stream_TypeDef *) (((0x40000000UL + 0x00020000UL) + 0x6000UL) + 0x040UL))))? 0x00080000U : ((uint32_t)((hdma)->Instance) == ((uint32_t)((DMA_Stream_TypeDef *) (((0x40000000UL + 0x00020000UL) + 0x6400UL) + 0x040UL))))? 0x00080000U : ((uint32_t)((hdma)->Instance) == ((uint32_t)((DMA_Stream_TypeDef *) (((0x40000000UL + 0x00020000UL) + 0x6000UL) + 0x0A0UL))))? 0x00080000U : ((uint32_t)((hdma)->Instance) == ((uint32_t)((DMA_Stream_TypeDef *) (((0x40000000UL + 0x00020000UL) + 0x6400UL) + 0x0A0UL))))? 0x00080000U : 0x02000000U)__HAL_DMA_GET_DME_FLAG_INDEX(hdma)(((uint32_t)((hdma)->Instance) == ((uint32_t)((DMA_Stream_TypeDef *) (((0x40000000UL + 0x00020000UL) + 0x6000UL) + 0x010UL))))? 0x00000004U : ((uint32_t)((hdma)->Instance) == ((uint32_t)((DMA_Stream_TypeDef *) (((0x40000000UL + 0x00020000UL) + 0x6400UL) + 0x010UL))))? 0x00000004U : ((uint32_t)((hdma)->Instance) == ((uint32_t)((DMA_Stream_TypeDef *) (((0x40000000UL + 0x00020000UL) + 0x6000UL) + 0x070UL))))? 0x00000004U : ((uint32_t)((hdma)->Instance) == ((uint32_t)((DMA_Stream_TypeDef *) (((0x40000000UL + 0x00020000UL) + 0x6400UL) + 0x070UL))))? 0x00000004U : ((uint32_t)((hdma)->Instance) == ((uint32_t)((DMA_Stream_TypeDef *) (((0x40000000UL + 0x00020000UL) + 0x6000UL) + 0x028UL))))? 0x00000100U : ((uint32_t)((hdma)->Instance) == ((uint32_t)((DMA_Stream_TypeDef *) (((0x40000000UL + 0x00020000UL) + 0x6400UL) + 0x028UL))))? 0x00000100U : ((uint32_t)((hdma)->Instance) == ((uint32_t)((DMA_Stream_TypeDef *) (((0x40000000UL + 0x00020000UL) + 0x6000UL) + 0x088UL))))? 0x00000100U : ((uint32_t)((hdma)->Instance) == ((uint32_t)((DMA_Stream_TypeDef *) (((0x40000000UL + 0x00020000UL) + 0x6400UL) + 0x088UL))))? 0x00000100U : ((uint32_t)((hdma)->Instance) == ((uint32_t)((DMA_Stream_TypeDef *) (((0x40000000UL + 0x00020000UL) + 0x6000UL) + 0x040UL))))? 0x00040000U : ((uint32_t)((hdma)->Instance) == ((uint32_t)((DMA_Stream_TypeDef *) (((0x40000000UL + 0x00020000UL) + 0x6400UL) + 0x040UL))))? 0x00040000U : ((uint32_t)((hdma)->Instance) == ((uint32_t)((DMA_Stream_TypeDef *) (((0x40000000UL + 0x00020000UL) + 0x6000UL) + 0x0A0UL))))? 0x00040000U : ((uint32_t)((hdma)->Instance) == ((uint32_t)((DMA_Stream_TypeDef *) (((0x40000000UL + 0x00020000UL) + 0x6400UL) + 0x0A0UL))))? 0x00040000U : 0x01000000U)__HAL_DMA_GET_FE_FLAG_INDEX(hdma)(((uint32_t)((hdma)->Instance) == ((uint32_t)((DMA_Stream_TypeDef *) (((0x40000000UL + 0x00020000UL) + 0x6000UL) + 0x010UL))))? 0x00000001U : ((uint32_t)((hdma)->Instance) == ((uint32_t)((DMA_Stream_TypeDef *) (((0x40000000UL + 0x00020000UL) + 0x6400UL) + 0x010UL))))? 0x00000001U : ((uint32_t)((hdma)->Instance) == ((uint32_t)((DMA_Stream_TypeDef *) (((0x40000000UL + 0x00020000UL) + 0x6000UL) + 0x070UL))))? 0x00000001U : ((uint32_t)((hdma)->Instance) == ((uint32_t)((DMA_Stream_TypeDef *) (((0x40000000UL + 0x00020000UL) + 0x6400UL) + 0x070UL))))? 0x00000001U : ((uint32_t)((hdma)->Instance) == ((uint32_t)((DMA_Stream_TypeDef *) (((0x40000000UL + 0x00020000UL) + 0x6000UL) + 0x028UL))))? 0x00000040U : ((uint32_t)((hdma)->Instance) == ((uint32_t)((DMA_Stream_TypeDef *) (((0x40000000UL + 0x00020000UL) + 0x6400UL) + 0x028UL))))? 0x00000040U : ((uint32_t)((hdma)->Instance) == ((uint32_t)((DMA_Stream_TypeDef *) (((0x40000000UL + 0x00020000UL) + 0x6000UL) + 0x088UL))))? 0x00000040U : ((uint32_t)((hdma)->Instance) == ((uint32_t)((DMA_Stream_TypeDef *) (((0x40000000UL + 0x00020000UL) + 0x6400UL) + 0x088UL))))? 0x00000040U : ((uint32_t)((hdma)->Instance) == ((uint32_t)((DMA_Stream_TypeDef *) (((0x40000000UL + 0x00020000UL) + 0x6000UL) + 0x040UL))))? 0x00010000U : ((uint32_t)((hdma)->Instance) == ((uint32_t)((DMA_Stream_TypeDef *) (((0x40000000UL + 0x00020000UL) + 0x6400UL) + 0x040UL))))? 0x00010000U : ((uint32_t)((hdma)->Instance) == ((uint32_t)((DMA_Stream_TypeDef *) (((0x40000000UL + 0x00020000UL) + 0x6000UL) + 0x0A0UL))))? 0x00010000U : ((uint32_t)((hdma)->Instance) == ((uint32_t)((DMA_Stream_TypeDef *) (((0x40000000UL + 0x00020000UL) + 0x6400UL) + 0x0A0UL))))? 0x00010000U : 0x00400000U)(uint32_t)DMA_SxCR_DBMDMA_TypeDef *10738974721073897488107389758410738975121073898536107389760810738975361073898560107389763218410738976561073897560/**
  * @brief  Set the DMA Transfer parameter.
  * @param  hdma       pointer to a DMA_HandleTypeDef structure that contains
  *                     the configuration information for the specified DMA Stream.  
  * @param  SrcAddress The source memory Buffer address
  * @param  DstAddress The destination memory Buffer address
  * @param  DataLength The length of data to be transferred from source to destination
  * @retval HAL status
  *//** @addtogroup DMAEx_Private_Functions
  * @{
  *//* change the memory1 address *//* change the memory0 address *//**
  * @brief  Change the memory0 or memory1 address on the fly.
  * @param  hdma       pointer to a DMA_HandleTypeDef structure that contains
  *                     the configuration information for the specified DMA Stream.  
  * @param  Address    The new address
  * @param  memory     the memory to be changed, This parameter can be one of 
  *                     the following values:
  *                      MEMORY0 /
  *                      MEMORY1
  * @note   The MEMORY0 address can be changed only when the current transfer use
  *         MEMORY1 and the MEMORY1 address can be changed only when the current 
  *         transfer use MEMORY0.
  * @retval HAL status
  *//* Enable the peripheral *//* Clear all flags *//* Enable the Double buffer mode *//* Memory-to-memory transfer not supported in double buffering mode *//**
  * @brief  Starts the multi_buffer DMA Transfer with interrupt enabled.
  * @param  hdma       pointer to a DMA_HandleTypeDef structure that contains
  *                     the configuration information for the specified DMA Stream.  
  * @param  SrcAddress The source memory Buffer address
  * @param  DstAddress The destination memory Buffer address
  * @param  SecondMemAddress The second memory Buffer address in case of multi buffer Transfer  
  * @param  DataLength The length of data to be transferred from source to destination
  * @retval HAL status
  *//* Enable the double buffer mode *//**
  * @brief  Starts the multi_buffer DMA Transfer.
  * @param  hdma       pointer to a DMA_HandleTypeDef structure that contains
  *                     the configuration information for the specified DMA Stream.  
  * @param  SrcAddress The source memory Buffer address
  * @param  DstAddress The destination memory Buffer address
  * @param  SecondMemAddress The second memory Buffer address in case of multi buffer Transfer  
  * @param  DataLength The length of data to be transferred from source to destination
  * @retval HAL status
  *//** @addtogroup DMAEx_Exported_Functions_Group1
  *
@verbatim
 ===============================================================================
                #####  Extended features functions  #####
 ===============================================================================  
    [..]  This section provides functions allowing to:
      (+) Configure the source, destination address and data length and 
          Start MultiBuffer DMA transfer
      (+) Configure the source, destination address and data length and 
          Start MultiBuffer DMA transfer with interrupt
      (+) Change on the fly the memory0 or memory1 address.
      
@endverbatim
  * @{
  *//** @addtogroup DMAEx_Exported_Functions
  * @{
  *//* Private Constants ---------------------------------------------------------*//** @defgroup DMAEx DMAEx
  * @brief DMA Extended HAL module driver
  * @{
  *//**
  ******************************************************************************
  * @file    stm32f7xx_hal_dma_ex.c
  * @author  MCD Application Team
  * @brief   DMA Extension HAL module driver
  *         This file provides firmware functions to manage the following 
  *         functionalities of the DMA Extension peripheral:
  *           + Extended features functions
  *
  @verbatim
  ==============================================================================
                        ##### How to use this driver #####
  ==============================================================================
  [..]
  The DMA Extension HAL driver can be used as follows:
   (+) Start a multi buffer transfer using the HAL_DMA_MultiBufferStart() function
       for polling mode or HAL_DMA_MultiBufferStart_IT() for interrupt mode.

     -@-  In Memory-to-Memory transfer mode, Multi (Double) Buffer mode is not allowed.
     -@-  When Multi (Double) Buffer mode is enabled, the transfer is circular by default.
     -@-  In Multi (Double) buffer mode, it is possible to update the base address for 
          the AHB memory port on the fly (DMA_SxM0AR or DMA_SxM1AR) when the stream is enabled.
  
  @endverbatim
  ******************************************************************************
  * @attention
  *
  * Copyright (c) 2017 STMicroelectronics.
  * All rights reserved.
  *
  * This software is licensed under terms that can be found in the LICENSE file in
  * the root directory of this software component.
  * If no LICENSE file comes with this software, it is provided AS-IS.
  *
  ******************************************************************************
  *//Users/jie/Documents/posixGen_Demos-main/LwIP_StreamingServer/Drivers/STM32F7xx_HAL_Driver/Src/stm32f7xx_hal_dsi.cIS_FUNCTIONAL_STATE(State)~DSI_WPCR0_CDOFFDL~DSI_WPCR0_PDEN~DSI_WPCR0_TDDL~DSI_WPCR1_FLPRXLPM~DSI_WPCR0_FTXSMCL~DSI_WPCR0_FTXSMDL~DSI_WPCR0_TCLKPOSTEN4294967040~DSI_WPCR4_TCLKPOST~DSI_WPCR0_TLPXCEN~DSI_WPCR3_TLPXC4261412863~DSI_WPCR0_THSEXITEN4278255615~DSI_WPCR3_THSEXIT4278190079~DSI_WPCR0_TLPXDEN~DSI_WPCR3_TLPXD~DSI_WPCR0_THSZEROEN~DSI_WPCR3_THSZERO~DSI_WPCR0_THSTRAILEN~DSI_WPCR2_THSTRAIL~DSI_WPCR0_THSPREPEN~DSI_WPCR2_THSPREP4293918719~DSI_WPCR0_TCLKZEROEN~DSI_WPCR2_TCLKZERO4294443007~DSI_WPCR0_TCLKPREPEN~DSI_WPCR2_TCLKPREP~DSI_WPCR0_SWCL~DSI_WPCR0_SWDL0~DSI_WPCR0_SWDL1~DSI_WPCR0_HSICL~DSI_WPCR0_HSIDL0~DSI_WPCR0_HSIDL1~DSI_WPCR1_SDDC1006632964194303999~DSI_WPCR1_LPRXFT~DSI_WPCR1_HSTXSRCCL7864324294180863~DSI_WPCR1_HSTXSRCDL4294967103~DSI_WPCR1_LPSRCCL4294966527~DSI_WPCR1_LPSRCDL~DSI_WPCR1_HSTXDCL~DSI_WPCR1_HSTXDDL~DSI_VMCR_PGE17825792(DSI_VMCR_PGM | DSI_VMCR_PGO)4277141503~(DSI_VMCR_PGM | DSI_VMCR_PGO)124126(DSI_PSR_RUE0 | DSI_PSR_UAN0 | DSI_PSR_PSS0 | \
                                DSI_PSR_UANC | DSI_PSR_PSSC | DSI_PSR_PD)368496504508510(DSI_PSR_RUE0 | DSI_PSR_UAN0 | DSI_PSR_PSS0 | DSI_PSR_UAN1 | \
                                DSI_PSR_PSS1 | DSI_PSR_UANC | DSI_PSR_PSSC | DSI_PSR_PD)(hdsi)->Instance->WRPCRDSI_TIMEOUT_VALUE(DSI_PUCR_UECL | DSI_PUCR_UEDL)(DSI_PSR_UAN0 | DSI_PSR_UANC)288296(DSI_PSR_UAN0 | DSI_PSR_UAN1 | DSI_PSR_UANC)(DSI_PSR_UAN0 | DSI_PSR_UAN1 |
                                                                                    DSI_PSR_UANC)RCC->DCKCFGR2((RCC_TypeDef *) ((0x40000000UL + 0x00020000UL) + 0x3800UL))->DCKCFGR2(0x1UL << (30U))(uint32_t)(((uint32_t)0x00000000U))(((RCC_TypeDef *) ((0x40000000UL + 0x00020000UL) + 0x3800UL))->DCKCFGR2)(((READ_REG(((RCC_TypeDef *) ((0x40000000UL + 0x00020000UL) + 0x3800UL))->DCKCFGR2)) & (~((0x1UL << (30U))))) | ((uint32_t)(((uint32_t)0x00000000U))))(((((((RCC_TypeDef *) ((0x40000000UL + 0x00020000UL) + 0x3800UL))->DCKCFGR2))) & (~((0x1UL << (30U))))) | ((uint32_t)(((uint32_t)0x00000000U))))3221225471(DSI_PSR_UAN0 | DSI_PSR_PSS0)432(DSI_PSR_UAN0 | DSI_PSR_PSS0 | DSI_PSR_PSS1 | \
                                DSI_PSR_UAN1)(DSI_PSR_UAN0 | DSI_PSR_PSS0 | DSI_PSR_PSS1 | DSI_PSR_UAN1)(DSI_PCTLR_CKE | DSI_PCTLR_DEN)(DSI_PUCR_UEDL | DSI_PUCR_URDL | DSI_PUCR_UECL | DSI_PUCR_URCL)~DSI_CLCR_DPCC((uint32_t)(0x1UL << (30U)))(uint32_t)(((uint32_t)(0x1UL << (30U))))(((READ_REG(((RCC_TypeDef *) ((0x40000000UL + 0x00020000UL) + 0x3800UL))->DCKCFGR2)) & (~((0x1UL << (30U))))) | ((uint32_t)(((uint32_t)(0x1UL << (30U))))))(((((((RCC_TypeDef *) ((0x40000000UL + 0x00020000UL) + 0x3800UL))->DCKCFGR2))) & (~((0x1UL << (30U))))) | ((uint32_t)(((uint32_t)(0x1UL << (30U))))))(DSI_PUCR_URCL | DSI_PUCR_URDL)(DSI_PSR_UAN0  | DSI_PSR_UAN1)(DSI_PSR_UAN0 | DSI_PSR_UAN1)(DSI_PSR_UAN0  |  DSI_PSR_UAN1)(DSI_PUCR_UEDL | DSI_PUCR_URDL)fifowordnbbytesIS_DSI_READ_PACKET_TYPE(Mode)uicounternbBytespparamsIS_DSI_LONG_WRITE_PACKET_TYPE(Mode)0x00FFU0xFF00UIS_DSI_SHORT_WRITE_PACKET_TYPE(Mode)IS_DSI_SHUT_DOWN(Shutdown)~DSI_WCR_SHTDN~DSI_WCR_COLM(hdsi)->Instance->CR(hdsi)->Instance->WCR~DSI_CCR_TOCKDIV~DSI_TCCR0_HSTX_TOCNT~DSI_TCCR0_LPRX_TOCNT~DSI_TCCR1_HSRD_TOCNT~DSI_TCCR2_LPRD_TOCNT~DSI_TCCR3_HSWR_TOCNT~DSI_TCCR3_PM~DSI_TCCR4_LPWR_TOCNT~DSI_TCCR5_BTA_TOCNTmaxTime6704332867044351(DSI_CLTCR_LP2HS_TIME | DSI_CLTCR_HS2LP_TIME)4227922944~(DSI_CLTCR_LP2HS_TIME | DSI_CLTCR_HS2LP_TIME)167444474294934527(DSI_DLTCR_MRD_TIME | DSI_DLTCR_LP2HS_TIME | DSI_DLTCR_HS2LP_TIME)~(DSI_DLTCR_MRD_TIME | DSI_DLTCR_LP2HS_TIME | DSI_DLTCR_HS2LP_TIME)~DSI_PCONFR_SW_TIME~DSI_FLOW_CONTROL_ALLIS_DSI_LP_GSW0P(LPCmd->LPGenShortWriteNoP)IS_DSI_LP_GSW1P(LPCmd->LPGenShortWriteOneP)IS_DSI_LP_GSW2P(LPCmd->LPGenShortWriteTwoP)IS_DSI_LP_GSR0P(LPCmd->LPGenShortReadNoP)IS_DSI_LP_GSR1P(LPCmd->LPGenShortReadOneP)IS_DSI_LP_GSR2P(LPCmd->LPGenShortReadTwoP)IS_DSI_LP_GLW(LPCmd->LPGenLongWrite)IS_DSI_LP_DSW0P(LPCmd->LPDcsShortWriteNoP)IS_DSI_LP_DSW1P(LPCmd->LPDcsShortWriteOneP)IS_DSI_LP_DSR0P(LPCmd->LPDcsShortReadNoP)IS_DSI_LP_DLW(LPCmd->LPDcsLongWrite)IS_DSI_LP_MRDP(LPCmd->LPMaxReadPacket)IS_DSI_ACK_REQUEST(LPCmd->AcknowledgeRequest)161283251298048229120491264101555217792768(DSI_CMCR_GSW0TX | \
                            DSI_CMCR_GSW1TX | \
                            DSI_CMCR_GSW2TX | \
                            DSI_CMCR_GSR0TX | \
                            DSI_CMCR_GSR1TX | \
                            DSI_CMCR_GSR2TX | \
                            DSI_CMCR_GLWTX  | \
                            DSI_CMCR_DSW0TX | \
                            DSI_CMCR_DSW1TX | \
                            DSI_CMCR_DSR0TX | \
                            DSI_CMCR_DLWTX  | \
                            DSI_CMCR_MRDPS)4277174527~(DSI_CMCR_GSW0TX | \
                            DSI_CMCR_GSW1TX | \
                            DSI_CMCR_GSW2TX | \
                            DSI_CMCR_GSR0TX | \
                            DSI_CMCR_GSR1TX | \
                            DSI_CMCR_GSR2TX | \
                            DSI_CMCR_GLWTX  | \
                            DSI_CMCR_DSW0TX | \
                            DSI_CMCR_DSW1TX | \
                            DSI_CMCR_DSR0TX | \
                            DSI_CMCR_DLWTX  | \
                            DSI_CMCR_MRDPS)~DSI_CMCR_AREIS_DSI_COLOR_CODING(CmdCfg->ColorCoding)IS_DSI_TE_SOURCE(CmdCfg->TearingEffectSource)IS_DSI_TE_POLARITY(CmdCfg->TearingEffectPolarity)IS_DSI_AUTOMATIC_REFRESH(CmdCfg->AutomaticRefresh)IS_DSI_VS_POLARITY(CmdCfg->VSyncPol)IS_DSI_TE_ACK_REQUEST(CmdCfg->TEAcknowledgeRequest)IS_DSI_DE_POLARITY(CmdCfg->DEPolarity)IS_DSI_VSYNC_POLARITY(CmdCfg->VSPolarity)IS_DSI_HSYNC_POLARITY(CmdCfg->HSPolarity)~DSI_WCFGR_DSIM~DSI_LVCIDR_VCID(DSI_LPCR_DEP | DSI_LPCR_VSP | DSI_LPCR_HSP)~(DSI_LPCR_DEP | DSI_LPCR_VSP | DSI_LPCR_HSP)4294967280~DSI_LCOLCR_COLC4294967281~DSI_WCFGR_COLMUX~DSI_LCCR_CMDSIZE(DSI_WCFGR_TESRC | DSI_WCFGR_TEPOL | DSI_WCFGR_AR | DSI_WCFGR_VSPOL)4294967055~(DSI_WCFGR_TESRC | DSI_WCFGR_TEPOL | DSI_WCFGR_AR | DSI_WCFGR_VSPOL)~DSI_CMCR_TEAREIS_DSI_COLOR_CODING(VidCfg->ColorCoding)IS_DSI_VIDEO_MODE_TYPE(VidCfg->Mode)IS_DSI_LP_COMMAND(VidCfg->LPCommandEnable)IS_DSI_LP_HFP(VidCfg->LPHorizontalFrontPorchEnable)IS_DSI_LP_HBP(VidCfg->LPHorizontalBackPorchEnable)IS_DSI_LP_VACTIVE(VidCfg->LPVerticalActiveEnable)IS_DSI_LP_VFP(VidCfg->LPVerticalFrontPorchEnable)IS_DSI_LP_VBP(VidCfg->LPVerticalBackPorchEnable)IS_DSI_LP_VSYNC(VidCfg->LPVerticalSyncActiveEnable)IS_DSI_FBTAA(VidCfg->FrameBTAAcknowledgeEnable)IS_DSI_DE_POLARITY(VidCfg->DEPolarity)IS_DSI_VSYNC_POLARITY(VidCfg->VSPolarity)IS_DSI_HSYNC_POLARITY(VidCfg->HSPolarity)IS_DSI_LOOSELY_PACKED(VidCfg->LooselyPacked)~DSI_MCR_CMDM~DSI_VMCR_VMT~DSI_VPCR_VPSIZE81914294959104~DSI_VCCR_NUMC~DSI_VNPCR_NPSIZE~DSI_LCOLCR_LPE~DSI_VHSACR_HSA~DSI_VHBPCR_HBP4294934528~DSI_VLCR_HLINE~DSI_VVSACR_VSA~DSI_VVBPCR_VBP~DSI_VVFPCR_VFP~DSI_VVACR_VA~DSI_VMCR_LPCE~DSI_LPMCR_LPSIZE~DSI_LPMCR_VLPSIZE~DSI_VMCR_LPHFPE~DSI_VMCR_LPHBPE~DSI_VMCR_LPVAE~DSI_VMCR_LPVFPE~DSI_VMCR_LPVBPE~DSI_VMCR_LPVSAE~DSI_VMCR_FBTAAE~DSI_GVCIDR_VCIDErrorStatus0ErrorStatus12047DSI_ERROR_ACK_MASK4587522031616DSI_ERROR_PHY_MASKDSI_ERROR_ECC_MASKDSI_ERROR_GEN_MASK~(DSI_PCTLR_CKE | DSI_PCTLR_DEN)(0x1UL << (24U))unitIntervalx4tempIDFIS_DSI_PLL_NDIV(PLLInit->PLLNDIV)IS_DSI_PLL_IDF(PLLInit->PLLIDF)IS_DSI_PLL_ODF(PLLInit->PLLODF)IS_DSI_AUTO_CLKLANE_CONTROL(hdsi->Init.AutomaticClockLaneControl)IS_DSI_NUMBER_OF_LANES(hdsi->Init.NumberOfLanes)3072031228227836(DSI_WRPCR_PLL_NDIV | DSI_WRPCR_PLL_IDF | DSI_WRPCR_PLL_ODF)4294739459~(DSI_WRPCR_PLL_NDIV | DSI_WRPCR_PLL_IDF | DSI_WRPCR_PLL_ODF)~DSI_CCR_TXECKDIV~DSI_PCONFR_NL(DSI_PSR_PSS0 | DSI_PSR_PSSC)(DSI_PSR_PSS0 | DSI_PSR_PSS1 | DSI_PSR_PSSC)(DSI_PSR_PSS0 | \
                                                                                    DSI_PSR_PSS1 | DSI_PSR_PSSC)40000004000000U0x3U2500000025000(HSE_VALUE / 1000U)4294967232~DSI_WPCR0_UIX4(DSI_CLCR_DPCC | DSI_CLCR_ACR)~(DSI_CLCR_DPCC | DSI_CLCR_ACR)DSI_ShortWriteDSI_ConfigPacketHeader(DSI_ISR1_GCWRE | DSI_ISR1_GPWRE | DSI_ISR1_GPTXE | DSI_ISR1_GPRDE | DSI_ISR1_GPRXE)DSI_ERROR_OVF_MASKDSI_ERROR_EOT_MASKDSI_ERROR_PSE_MASKDSI_ERROR_CRC_MASK(DSI_ISR1_ECCSE | DSI_ISR1_ECCME)DSI_ERROR_RX_MASKDSI_ERROR_TX_MASK(DSI_ISR0_PE0 | DSI_ISR0_PE1 | DSI_ISR0_PE2 | DSI_ISR0_PE3 | DSI_ISR0_PE4)(DSI_ISR0_AE0 | DSI_ISR0_AE1 | DSI_ISR0_AE2 | DSI_ISR0_AE3 | DSI_ISR0_AE4 | DSI_ISR0_AE5 | DSI_ISR0_AE6 | DSI_ISR0_AE7 | DSI_ISR0_AE8 | DSI_ISR0_AE9 | DSI_ISR0_AE10 | DSI_ISR0_AE11 | DSI_ISR0_AE12 | DSI_ISR0_AE13 | DSI_ISR0_AE14 | DSI_ISR0_AE15)((uint32_t)1000U)/* Get the error code *//**
  * @brief  Return the DSI error code
  * @param  hdsi  pointer to a DSI_HandleTypeDef structure that contains
  *               the configuration information for the DSI.
  * @retval DSI Error Code
  *//**
  * @brief  Return the DSI state
  * @param  hdsi  pointer to a DSI_HandleTypeDef structure that contains
  *               the configuration information for the DSI.
  * @retval HAL state
  *//** @defgroup DSI_Group4 Peripheral State and Errors functions
  *  @brief    Peripheral State and Errors functions
  *
@verbatim
 ===============================================================================
                  ##### Peripheral State and Errors functions #####
 ===============================================================================
    [..]
    This subsection provides functions allowing to
      (+) Check the DSI state.
      (+) Get error code.

@endverbatim
  * @{
  *//* Contention Detection on Data Lanes OFF *//**
  * @brief  Switch off the contention detection on data lanes
  * @param  hdsi  pointer to a DSI_HandleTypeDef structure that contains
  *               the configuration information for the DSI.
  * @param  State  ENABLE or DISABLE
  * @retval HAL status
  *//* Enable/Disable pull-down on lanes *//**
  * @brief  Enable a pull-down on the lanes to prevent from floating states when unused
  * @param  hdsi  pointer to a DSI_HandleTypeDef structure that contains
  *               the configuration information for the DSI.
  * @param  State  ENABLE or DISABLE
  * @retval HAL status
  *//* Force Data Lanes in RX Mode *//**
  * @brief  Force Data Lanes in RX Mode after a BTA
  * @param  hdsi  pointer to a DSI_HandleTypeDef structure that contains
  *               the configuration information for the DSI.
  * @param  State  ENABLE or DISABLE
  * @retval HAL status
  *//* Force/Unforce LP Receiver in Low-Power Mode *//**
  * @brief  Force LP Receiver in Low-Power Mode
  * @param  hdsi  pointer to a DSI_HandleTypeDef structure that contains
  *               the configuration information for the DSI.
  * @param  State  ENABLE or DISABLE
  * @retval HAL status
  *//* Force/Unforce the Data Lanes in TX Stop Mode *//* Force/Unforce the Clock Lane in TX Stop Mode *//**
  * @brief  Force the Clock/Data Lane in TX Stop Mode
  * @param  hdsi  pointer to a DSI_HandleTypeDef structure that contains
  *               the configuration information for the DSI.
  * @param  Lane  select between clock or data lanes.
  *               This parameter can be any value of @arg DSI_Lane_Group
  * @param  State  ENABLE or DISABLE
  * @retval HAL status
  *//* Set custom value *//* Enable/Disable custom timing setting *//**
  * @brief  Set custom timing for the PHY
  * @param  hdsi  pointer to a DSI_HandleTypeDef structure that contains
  *               the configuration information for the DSI.
  * @param  Timing  PHY timing to be adjusted.
  *                 This parameter can be any value of @arg DSI_PHY_Timing
  * @param  State  ENABLE or DISABLE
  * @param  Value  Custom value of the timing
  * @retval HAL status
  *//* Invert HS signal on data lane 1 *//* Invert HS signal on data lane 0 *//* Invert HS signal on clock lane *//* Swap pins on data lane 1 *//* Swap pins on data lane 0 *//* Swap pins on clock lane *//**
  * @brief  Custom lane pins configuration
  * @param  hdsi  pointer to a DSI_HandleTypeDef structure that contains
  *               the configuration information for the DSI.
  * @param  CustomLane  Function to be applied on selected lane.
  *                     This parameter can be any value of @arg DSI_CustomLane
  * @param  Lane  select between clock or data lane 0 or data lane 1.
  *               This parameter can be any value of @arg DSI_Lane_Select
  * @param  State  ENABLE or DISABLE
  * @retval HAL status
  *//* Activate/Disactivate additional current path on all lanes *//**
  * @brief  Activate an additional current path on all lanes to meet the SDDTx parameter
  *         defined in the MIPI D-PHY specification
  * @param  hdsi  pointer to a DSI_HandleTypeDef structure that contains
  *               the configuration information for the DSI.
  * @param  State  ENABLE or DISABLE
  * @retval HAL status
  *//* Low-Power RX low-pass Filtering Tuning *//**
  * @brief  Low-Power Reception Filter Tuning
  * @param  hdsi  pointer to a DSI_HandleTypeDef structure that contains
  *               the configuration information for the DSI.
  * @param  Frequency  cutoff frequency of low-pass filter at the input of LPRX
  * @retval HAL status
  *//* High-Speed Transmission Delay on Data Lanes *//* High-Speed Transmission Delay on Clock Lane *//* Low-Power transmission Slew Rate Compensation on Data Lanes *//* Low-Power transmission Slew Rate Compensation on Clock Lane *//* High-Speed Transmission Slew Rate Control on Data Lanes *//* High-Speed Transmission Slew Rate Control on Clock Lane *//**
  * @brief  Set Slew-Rate And Delay Tuning
  * @param  hdsi  pointer to a DSI_HandleTypeDef structure that contains
  *               the configuration information for the DSI.
  * @param  CommDelay  Communication delay to be adjusted.
  *                    This parameter can be any value of @arg DSI_Communication_Delay
  * @param  Lane  select between clock or data lanes.
  *               This parameter can be any value of @arg DSI_Lane_Group
  * @param  Value  Custom value of the slew-rate or delay
  * @retval HAL status
  *//* Disable pattern generator by clearing PGE bit *//**
  * @brief  Stop test pattern generation
  * @param  hdsi  pointer to a DSI_HandleTypeDef structure that contains
  *               the configuration information for the DSI.
  * @retval HAL status
  *//* Enable pattern generator by setting PGE bit *//* Configure pattern generator mode and orientation *//**
  * @brief  Start test pattern generation
  * @param  hdsi  pointer to a DSI_HandleTypeDef structure that contains
  *               the configuration information for the DSI.
  * @param  Mode  Pattern generator mode
  *          This parameter can be one of the following values:
  *           0 : Color bars (horizontal or vertical)
  *           1 : BER pattern (vertical only)
  * @param  Orientation  Pattern generator orientation
  *          This parameter can be one of the following values:
  *           0 : Vertical color bars
  *           1 : Horizontal color bars
  * @retval HAL status
  *//* Wait for the lock of the PLL *//* 1ms delay is inserted that is the minimum HAL delay granularity *//* Requires min of 400us delay before reading the PLLLS flag *//* Verify that D-PHY PLL is locked *//* Verify that all active lanes are in Stop state *//* Verify that D-PHY PLL is enabled *//* Restore clock lane configuration to HS *//* Switch the lane byte clock source in the RCC from system PLL to D-PHY *//* De-assert the ULPM requests and the ULPM exit bits *//* wait for 1 ms *//* Wait until all active lanes exit ULPM *//* Exit ULPS on Clock and Data Lanes *//* Turn on the DSI PLL *//* Verify that all active lanes are in ULPM *//**
  * @brief  Exit the ULPM (Ultra Low Power Mode) with the D-PHY PLL turned off
  *         (both data and clock lanes are in ULPM)
  * @param  hdsi  pointer to a DSI_HandleTypeDef structure that contains
  *               the configuration information for the DSI.
  * @retval HAL status
  *//* Turn off the DSI PLL *//* Wait until all active lanes enter ULPM *//* ULPS Request on Clock and Data Lanes *//* Use system PLL as byte lane clock source before stopping DSIPHY clock source *//* Clock lane configuration: no more HS request *//* Verify that there are no Transmission trigger *//* Verify that there are no ULPS exit or request on both data and clock lanes *//* Verify that the D-PHY PLL and the reference bias are enabled *//* Verify that the clock lane and the digital section of the D-PHY are enabled *//* Verify the initial status of the DSI Host *//**
  * @brief  Enter the ULPM (Ultra Low Power Mode) with the D-PHY PLL turned off
  *         (both data and clock lanes are in ULPM)
  * @param  hdsi  pointer to a DSI_HandleTypeDef structure that contains
  *               the configuration information for the DSI.
  * @retval HAL status
  *//* wait for 1 ms*//* Exit ULPS on Data Lanes *//**
  * @brief  Exit the ULPM (Ultra Low Power Mode) with the D-PHY PLL running
  *         (only data lanes are in ULPM)
  * @param  hdsi  pointer to a DSI_HandleTypeDef structure that contains
  *               the configuration information for the DSI.
  * @retval HAL status
  *//* Wait until the D-PHY active lanes enter into ULPM *//* ULPS Request on Data Lanes *//* Verify that there are no ULPS exit or request on data lanes *//**
  * @brief  Enter the ULPM (Ultra Low Power Mode) with the D-PHY PLL running
  *         (only data lanes are in ULPM)
  * @param  hdsi  pointer to a DSI_HandleTypeDef structure that contains
  *               the configuration information for the DSI.
  * @retval HAL status
  *//* Need to ensure that the Read command has finished before checking PSE *//* which returns Packet Size Error.                                      *//* issued to the panel and the read data is not captured by the DSI Host *//* Software workaround to avoid HAL_TIMEOUT when a DSI read command is   *//* If DSI fifo is not empty, read requested bytes *//* Configure the packet to read command *//* set max return packet size *//**
  * @brief  Read command (DCS or generic)
  * @param  hdsi  pointer to a DSI_HandleTypeDef structure that contains
  *               the configuration information for the DSI.
  * @param  ChannelNbr  Virtual channel ID
  * @param  Array pointer to a buffer to store the payload of a read back operation.
  * @param  Size  Data size to be read (in byte).
  * @param  Mode  DSI read packet data type.
  *               This parameter can be any value of @arg DSI_SHORT_READ_PKT_Data_Type.
  * @param  DCSCmd  DCS get/read command.
  * @param  ParametersTable  Pointer to parameter values table.
  * @retval HAL status
  *//* Configure the packet to send a long DCS command *//* Set the Next parameters on the write FIFO command*//* Set the DCS code on payload byte 1, and the other parameters on the write FIFO command*//* Wait for Command FIFO Empty *//**
  * @brief  write long DCS or long Generic command
  * @param  hdsi  pointer to a DSI_HandleTypeDef structure that contains
  *               the configuration information for the DSI.
  * @param  ChannelID  Virtual channel ID.
  * @param  Mode  DSI long packet data type.
  *               This parameter can be any value of @arg DSI_LONG_WRITE_PKT_Data_Type.
  * @param  NbParams  Number of parameters.
  * @param  Param1  DSC command or first generic parameter.
  *                 This parameter can be any value of @arg DSI_DCS_Command or a
  *                 generic command code
  * @param  ParametersTable  Pointer to parameter values table.
  * @retval HAL status
  *//**
  * @brief  write short DCS or short Generic command
  * @param  hdsi  pointer to a DSI_HandleTypeDef structure that contains
  *               the configuration information for the DSI.
  * @param  ChannelID  Virtual channel ID.
  * @param  Mode  DSI short packet data type.
  *               This parameter can be any value of @arg DSI_SHORT_WRITE_PKT_Data_Type.
  * @param  Param1  DSC command or first generic parameter.
  *                 This parameter can be any value of @arg DSI_DCS_Command or a
  *                 generic command code.
  * @param  Param2  DSC parameter or second generic parameter.
  * @retval HAL status
  *//* Update the display Shutdown *//**
  * @brief  Control the display shutdown in Video mode
  * @param  hdsi  pointer to a DSI_HandleTypeDef structure that contains
  *               the configuration information for the DSI.
  * @param  Shutdown  Shut-down (Display-ON or Display-OFF).
  *                   This parameter can be any value of @arg DSI_ShutDown
  * @retval HAL status
  *//* Update the display color mode *//**
  * @brief  Controls the display color mode in Video mode
  * @param  hdsi  pointer to a DSI_HandleTypeDef structure that contains
  *               the configuration information for the DSI.
  * @param  ColorMode  Color mode (full or 8-colors).
  *                    This parameter can be any value of @arg DSI_Color_Mode
  * @retval HAL status
  *//* Update the display *//**
  * @brief  Refresh the display in command mode
  * @param  hdsi  pointer to a DSI_HandleTypeDef structure that contains
  *               the configuration information for the DSI.
  * @retval HAL status
  *//* Disable the DSI wrapper *//* Disable the DSI host *//**
  * @brief  Stop the DSI module
  * @param  hdsi  pointer to a DSI_HandleTypeDef structure that contains
  *               the configuration information for the DSI.
  * @retval HAL status
  *//* Enable the DSI wrapper *//* Enable the DSI host *//**
  * @brief  Start the DSI module
  * @param  hdsi  pointer to a DSI_HandleTypeDef structure that contains
  *               the configuration information for the DSI.
  * @retval HAL status
  *//* BTA timeout *//* Low-speed write timeout *//* High-speed write presp mode *//* High-speed write timeout *//* Low-power read timeout *//* High-speed read timeout *//* Low-power reception timeout *//* High-speed transmission timeout *//* Set the timeout clock division factor *//**
  * @brief  Configure the DSI HOST timeout parameters
  * @param  hdsi  pointer to a DSI_HandleTypeDef structure that contains
  *               the configuration information for the DSI.
  * @param  HostTimeouts  DSI_HOST_TimeoutTypeDef structure that contains
  *                       the DSI host timeout parameters
  * @retval HAL status
  *//* Configure the wait period to request HS transmission after a stop state *//* Data lane timer configuration *//* In Automatic Clock Lane control mode, the DSI Host can turn off the clock lane between two
     High-Speed transmission.
     To do so, the DSI Host calculates the time required for the clock lane to change from HighSpeed
     to Low-Power and from Low-Power to High-Speed.
     This timings are configured by the HS2LP_TIME and LP2HS_TIME in the DSI Host Clock Lane Timer Configuration
     Register (DSI_CLTCR).
     But the DSI Host is not calculating LP2HS_TIME + HS2LP_TIME but 2 x HS2LP_TIME.

     Workaround : Configure HS2LP_TIME and LP2HS_TIME with the same value being the max of HS2LP_TIME or LP2HS_TIME.
    *//* Clock lane timer configuration *//**
  * @brief  Configure the DSI PHY timer parameters
  * @param  hdsi  pointer to a DSI_HandleTypeDef structure that contains
  *               the configuration information for the DSI.
  * @param  PhyTimers  DSI_PHY_TimerTypeDef structure that contains
  *                    the DSI PHY timing parameters
  * @retval HAL status
  *//* Set the DSI Host Protocol Configuration Register *//**
  * @brief  Configure the flow control parameters
  * @param  hdsi  pointer to a DSI_HandleTypeDef structure that contains
  *               the configuration information for the DSI.
  * @param  FlowControl  flow control feature(s) to be enabled.
  *                      This parameter can be any combination of @arg DSI_FlowControl.
  * @retval HAL status
  *//* Configure the acknowledge request after each packet transmission *//* Select High-speed or Low-power for command transmission *//**
  * @brief  Configure command transmission mode: High-speed or Low-power
  *         and enable/disable acknowledge request after packet transmission
  * @param  hdsi  pointer to a DSI_HandleTypeDef structure that contains
  *               the configuration information for the DSI.
  * @param  LPCmd  pointer to a DSI_LPCmdTypeDef structure that contains
  *                the DSI command transmission mode configuration parameters
  * @retval HAL status
  *//* Enable the End of Refresh interrupt *//* Enable the Tearing Effect interrupt *//* Configure the tearing effect acknowledge request *//* Configure the tearing effect source and polarity and select the refresh mode *//* Configure the maximum allowed size for write memory command *//* Select the color coding for the wrapper *//* Select the color coding for the host *//* Configure the polarity of control signals *//* Select the virtual channel for the LTDC interface traffic *//* Select command mode by setting CMDM and DSIM bits *//**
  * @brief  Select adapted command mode and configure the corresponding parameters
  * @param  hdsi  pointer to a DSI_HandleTypeDef structure that contains
  *               the configuration information for the DSI.
  * @param  CmdCfg  pointer to a DSI_CmdCfgTypeDef structure that contains
  *                 the DSI command mode configuration parameters
  * @retval HAL status
  *//* Enable the request for an acknowledge response at the end of a frame *//* Enable LP transition in vertical sync period *//* Enable LP transition in VBP period *//* Enable LP transition in VFP period *//* Enable LP transition in VACT period *//* Enable LP transition in HBP period *//* Enable LP transition in HFP period *//* Low power VACT largest packet size *//* Low power largest packet size *//* Configure the command transmission mode *//* Set the Vertical Active period*//* Set the Vertical Front Porch (VFP)*//* Set the Vertical Back Porch (VBP)*//* Set the Vertical Synchronization Active (VSA) *//* Set the total line time (HLINE=HSA+HBP+HACT+HFP) in lane byte clock cycles *//* Set the Horizontal Back Porch (HBP) in lane byte clock cycles *//* Set the Horizontal Synchronization Active (HSA) in lane byte clock cycles *//* Enable/disable the loosely packed variant to 18-bit configuration *//* Set the size of the null packet *//* Set the chunks number to be transmitted through the DSI link *//* Configure the video packet size *//* Configure the video mode transmission type *//* Select video mode by resetting CMDM and DSIM bits *//* Check the LooselyPacked variant only in 18-bit mode *//**
  * @brief  Select video mode and configure the corresponding parameters
  * @param  hdsi  pointer to a DSI_HandleTypeDef structure that contains
  *               the configuration information for the DSI.
  * @param  VidCfg pointer to a DSI_VidCfgTypeDef structure that contains
  *                the DSI video mode configuration parameters
  * @retval HAL status
  *//* Update the GVCID register *//**
  * @brief  Configure the Generic interface read-back Virtual Channel ID.
  * @param  hdsi  pointer to a DSI_HandleTypeDef structure that contains
  *               the configuration information for the DSI.
  * @param  VirtualChannelID  Virtual channel ID
  * @retval HAL status
  *//** @defgroup DSI_Group3 Peripheral Control functions
  *  @brief    Peripheral Control functions
  *
@verbatim
 ===============================================================================
                    ##### Peripheral Control functions #####
 ===============================================================================
    [..]  This section provides functions allowing to:
      (+) Configure the Generic interface read-back Virtual Channel ID
      (+) Select video mode and configure the corresponding parameters
      (+) Configure command transmission mode: High-speed or Low-power
      (+) Configure the flow control
      (+) Configure the DSI PHY timer
      (+) Configure the DSI HOST timeout
      (+) Configure the DSI HOST timeout
      (+) Start/Stop the DSI module
      (+) Refresh the display in command mode
      (+) Controls the display color mode in Video mode
      (+) Control the display shutdown in Video mode
      (+) write short DCS or short Generic command
      (+) write long DCS or long Generic command
      (+) Read command (DCS or generic)
      (+) Enter/Exit the Ultra Low Power Mode on data only (D-PHY PLL running)
      (+) Enter/Exit the Ultra Low Power Mode on data only and clock (D-PHY PLL turned off)
      (+) Start/Stop test pattern generation
      (+) Slew-Rate And Delay Tuning
      (+) Low-Power Reception Filter Tuning
      (+) Activate an additional current path on all lanes to meet the SDDTx parameter
      (+) Custom lane pins configuration
      (+) Set custom timing for the PHY
      (+) Force the Clock/Data Lane in TX Stop Mode
      (+) Force LP Receiver in Low-Power Mode
      (+) Force Data Lanes in RX Mode after a BTA
      (+) Enable a pull-down on the lanes to prevent from floating states when unused
      (+) Switch off the contention detection on data lanes

@endverbatim
  * @{
  *//* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_DSI_ErrorCallback could be implemented in the user file
   *//**
  * @brief  Operation Error DSI callback.
  * @param  hdsi  pointer to a DSI_HandleTypeDef structure that contains
  *               the configuration information for the DSI.
  * @retval None
  *//* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_DSI_EndOfRefreshCallback could be implemented in the user file
   *//**
  * @brief  End of Refresh DSI callback.
  * @param  hdsi  pointer to a DSI_HandleTypeDef structure that contains
  *               the configuration information for the DSI.
  * @retval None
  *//* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_DSI_TearingEffectCallback could be implemented in the user file
   *//**
  * @brief  Tearing Effect DSI callback.
  * @param  hdsi  pointer to a DSI_HandleTypeDef structure that contains
  *               the configuration information for the DSI.
  * @retval None
  *//*Call Legacy Error callback *//*Call registered Error callback *//* DSI error interrupt callback *//* Check only selected errors *//* Error Interrupts management ***********************************************//*Call Legacy End of refresh callback *//*Call registered End of refresh callback *//* End of Refresh Callback *//* Clear the End of Refresh Interrupt Flag *//* End of Refresh Interrupt management ***************************************//*Call legacy Tearing Effect callback*//*Call registered Tearing Effect callback *//* Tearing Effect Callback *//* Clear the Tearing Effect Interrupt Flag *//* Tearing Effect Interrupt management ***************************************//**
  * @brief  Handles DSI interrupt request.
  * @param  hdsi  pointer to a DSI_HandleTypeDef structure that contains
  *               the configuration information for the DSI.
  * @retval HAL status
  *//** @defgroup DSI_Group2 IO operation functions
  *  @brief    IO operation functions
  *
@verbatim
 ===============================================================================
                      #####  IO operation functions  #####
 ===============================================================================
    [..]  This section provides function allowing to:
      (+) Handle DSI interrupt request

@endverbatim
  * @{
  *//* Legacy weak MspDeInit Callback *//* Legacy weak MspInit Callback   *//* Legacy weak MspDeInit Callback   *//* Legacy weak MspInit Callback     *//* Legacy weak ErrorCallback        *//* Legacy weak EndOfRefreshCallback  *//* Legacy weak TearingEffectCallback *//**
  * @brief  Unregister a DSI Callback
  *         DSI callback is redirected to the weak predefined callback
  * @param hdsi dsi handle
  * @param CallbackID ID of the callback to be unregistered
  *        This parameter can be one of the following values:
  *          @arg HAL_DSI_TEARING_EFFECT_CB_ID Tearing Effect Callback ID
  *          @arg HAL_DSI_ENDOF_REFRESH_CB_ID End Of Refresh Callback ID
  *          @arg HAL_DSI_ERROR_CB_ID Error Callback ID
  *          @arg HAL_DSI_MSPINIT_CB_ID MspInit callback ID
  *          @arg HAL_DSI_MSPDEINIT_CB_ID MspDeInit callback ID
  * @retval status
  *//**
  * @brief  Register a User DSI Callback
  *         To be used instead of the weak predefined callback
  * @param hdsi dsi handle
  * @param CallbackID ID of the callback to be registered
  *        This parameter can be one of the following values:
  *          @arg HAL_DSI_TEARING_EFFECT_CB_ID Tearing Effect Callback ID
  *          @arg HAL_DSI_ENDOF_REFRESH_CB_ID End Of Refresh Callback ID
  *          @arg HAL_DSI_ERROR_CB_ID Error Callback ID
  *          @arg HAL_DSI_MSPINIT_CB_ID MspInit callback ID
  *          @arg HAL_DSI_MSPDEINIT_CB_ID MspDeInit callback ID
  * @param pCallback pointer to the Callback function
  * @retval status
  *//* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_DSI_MspDeInit could be implemented in the user file
   *//**
  * @brief  De-initializes the DSI MSP.
  * @param  hdsi  pointer to a DSI_HandleTypeDef structure that contains
  *               the configuration information for the DSI.
  * @retval None
  *//* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_DSI_MspInit could be implemented in the user file
   *//**
  * @brief  Initializes the DSI MSP.
  * @param  hdsi  pointer to a DSI_HandleTypeDef structure that contains
  *               the configuration information for the DSI.
  * @retval None
  *//* Enable the interrupt generation on selected errors *//* Store active errors to the handle *//**
  * @brief  Enable the error monitor flags
  * @param  hdsi  pointer to a DSI_HandleTypeDef structure that contains
  *               the configuration information for the DSI.
  * @param  ActiveErrors  indicates which error interrupts will be enabled.
  *                      This parameter can be any combination of @arg DSI_Error_Data_Type.
  * @retval HAL status
  *//* Initialize the DSI state*//* Disable the regulator *//* D-PHY clock and digital disable *//* Change DSI peripheral state *//* Check the DSI handle allocation *//**
  * @brief  De-initializes the DSI peripheral registers to their default reset
  *         values.
  * @param  hdsi  pointer to a DSI_HandleTypeDef structure that contains
  *               the configuration information for the DSI.
  * @retval HAL status
  *//* Clock lane configuration *//* Disable all error interrupts and reset the Error Mask *//****************************** Error management *****************************//* Set the bit period in high-speed mode *//* Where : F_PHY_Mhz = (NDIV * HSE_Mhz) / (IDF * ODF)                    *//* The equation is : UIX4 = IntegerPart( (1000/F_PHY_Mhz) * 4 )          *//* Calculate the bit period in high-speed mode in unit of 0.25 ns (UIX4) *//* Configure the number of active data lanes *//* D-PHY clock and digital enable*//*************************** Set the PHY parameters ***************************//* Set the TX escape clock division factor *//************************ Set the DSI clock parameters ************************//* Enable the DSI PLL *//* Set the PLL division factors *//* Wait until the regulator is ready *//* Enable the regulator *//**************** Turn on the regulator and enable the DSI PLL ****************//* Initialize the low level hardware *//* Reset the DSI callback to the legacy weak callbacks *//**
  * @brief  Initializes the DSI according to the specified
  *         parameters in the DSI_InitTypeDef and create the associated handle.
  * @param  hdsi  pointer to a DSI_HandleTypeDef structure that contains
  *               the configuration information for the DSI.
  * @param  PLLInit  pointer to a DSI_PLLInitTypeDef structure that contains
  *                  the PLL Clock structure definition for the DSI.
  * @retval HAL status
  *//** @defgroup DSI_Group1 Initialization and Configuration functions
  *  @brief   Initialization and Configuration functions
  *
@verbatim
 ===============================================================================
                ##### Initialization and Configuration functions #####
 ===============================================================================
    [..]  This section provides functions allowing to:
      (+) Initialize and configure the DSI
      (+) De-initialize the DSI

@endverbatim
  * @{
  *//** @addtogroup DSI_Exported_Functions
  * @{
  *//* Update the DSI packet header with new information *//* Configure the packet to send a short DCS command with 0 or 1 parameter *//**
  * @brief  Generic DSI packet header configuration
  * @param  DSIx  Pointer to DSI register base
  * @param  ChannelID Virtual channel ID of the header packet
  * @param  DataType  Packet data type of the header packet
  *                   This parameter can be any value of :
  *                      @arg DSI_SHORT_WRITE_PKT_Data_Type
  *                      @arg DSI_LONG_WRITE_PKT_Data_Type
  *                      @arg DSI_SHORT_READ_PKT_Data_Type
  *                      @arg DSI_MAX_RETURN_PKT_SIZE
  * @param  Data0  Word count LSB
  * @param  Data1  Word count MSB
  * @retval None
  *//** @defgroup DSI_Private_Functions DSI Private Functions
  * @{
  *//* 1s *//** @addtogroup DSI_Private_Constants
  * @{
  *//** @addtogroup DSI
  * @{
  *//**
  ******************************************************************************
  * @file    stm32f7xx_hal_dsi.c
  * @author  MCD Application Team
  * @brief   DSI HAL module driver.
  *          This file provides firmware functions to manage the following
  *          functionalities of the DSI peripheral:
  *           + Initialization and de-initialization functions
  *           + IO operation functions
  *           + Peripheral Control functions
  *           + Peripheral State and Errors functions
  ******************************************************************************
  * @attention
  *
  * Copyright (c) 2017 STMicroelectronics.
  * All rights reserved.
  *
  * This software is licensed under terms that can be found in the LICENSE file
  * in the root directory of this software component.
  * If no LICENSE file comes with this software, it is provided AS-IS.
  *
  ******************************************************************************
  @verbatim
  ==============================================================================
                        ##### How to use this driver #####
  ==============================================================================
  [..]
    The DSI HAL driver can be used as follows:

    (#) Declare a DSI_HandleTypeDef handle structure, for example: DSI_HandleTypeDef  hdsi;

    (#) Initialize the DSI low level resources by implementing the HAL_DSI_MspInit() API:
        (##) Enable the DSI interface clock
        (##) NVIC configuration if you need to use interrupt process
            (+++) Configure the DSI interrupt priority
            (+++) Enable the NVIC DSI IRQ Channel

    (#) Initialize the DSI Host peripheral, the required PLL parameters, number of lances and
        TX Escape clock divider by calling the HAL_DSI_Init() API which calls HAL_DSI_MspInit().

    *** Configuration ***
    =========================
    [..]
    (#) Use HAL_DSI_ConfigAdaptedCommandMode() function to configure the DSI host in adapted
        command mode.

    (#) When operating in video mode , use HAL_DSI_ConfigVideoMode() to configure the DSI host.

    (#) Function HAL_DSI_ConfigCommand() is used to configure the DSI commands behavior in low power mode.

    (#) To configure the DSI PHY timings parameters, use function HAL_DSI_ConfigPhyTimer().

    (#) The DSI Host can be started/stopped using respectively functions HAL_DSI_Start() and HAL_DSI_Stop().
        Functions HAL_DSI_ShortWrite(), HAL_DSI_LongWrite() and HAL_DSI_Read() allows respectively
        to write DSI short packets, long packets and to read DSI packets.

    (#) The DSI Host Offers two Low power modes :
        (++) Low Power Mode on data lanes only: Only DSI data lanes are shut down.
            It is possible to enter/exit from this mode using respectively functions HAL_DSI_EnterULPMData()
            and HAL_DSI_ExitULPMData()

        (++) Low Power Mode on data and clock lanes : All DSI lanes are shut down including data and clock lanes.
            It is possible to enter/exit from this mode using respectively functions HAL_DSI_EnterULPM()
            and HAL_DSI_ExitULPM()

    (#) To control DSI state you can use the following function: HAL_DSI_GetState()

    *** Error management ***
    ========================
    [..]
    (#) User can select the DSI errors to be reported/monitored using function HAL_DSI_ConfigErrorMonitor()
        When an error occurs, the callback HAL_DSI_ErrorCallback() is asserted and then user can retrieve
        the error code by calling function HAL_DSI_GetError()

    *** DSI HAL driver macros list ***
    =============================================
    [..]
       Below the list of most used macros in DSI HAL driver.

      (+) __HAL_DSI_ENABLE: Enable the DSI Host.
      (+) __HAL_DSI_DISABLE: Disable the DSI Host.
      (+) __HAL_DSI_WRAPPER_ENABLE: Enables the DSI wrapper.
      (+) __HAL_DSI_WRAPPER_DISABLE: Disable the DSI wrapper.
      (+) __HAL_DSI_PLL_ENABLE: Enables the DSI PLL.
      (+) __HAL_DSI_PLL_DISABLE: Disables the DSI PLL.
      (+) __HAL_DSI_REG_ENABLE: Enables the DSI regulator.
      (+) __HAL_DSI_REG_DISABLE: Disables the DSI regulator.
      (+) __HAL_DSI_GET_FLAG: Get the DSI pending flags.
      (+) __HAL_DSI_CLEAR_FLAG: Clears the DSI pending flags.
      (+) __HAL_DSI_ENABLE_IT: Enables the specified DSI interrupts.
      (+) __HAL_DSI_DISABLE_IT: Disables the specified DSI interrupts.
      (+) __HAL_DSI_GET_IT_SOURCE: Checks whether the specified DSI interrupt source is enabled or not.

    [..]
      (@) You can refer to the DSI HAL driver header file for more useful macros

    *** Callback registration ***
    =============================================
    [..]
    The compilation define  USE_HAL_DSI_REGISTER_CALLBACKS when set to 1
    allows the user to configure dynamically the driver callbacks.
    Use Function HAL_DSI_RegisterCallback() to register a callback.

    [..]
    Function HAL_DSI_RegisterCallback() allows to register following callbacks:
      (+) TearingEffectCallback : DSI Tearing Effect Callback.
      (+) EndOfRefreshCallback  : DSI End Of Refresh Callback.
      (+) ErrorCallback         : DSI Error Callback
      (+) MspInitCallback       : DSI MspInit.
      (+) MspDeInitCallback     : DSI MspDeInit.
    [..]
    This function takes as parameters the HAL peripheral handle, the callback ID
    and a pointer to the user callback function.

    [..]
    Use function HAL_DSI_UnRegisterCallback() to reset a callback to the default
    weak function.
    HAL_DSI_UnRegisterCallback takes as parameters the HAL peripheral handle,
    and the callback ID.
    [..]
    This function allows to reset following callbacks:
      (+) TearingEffectCallback : DSI Tearing Effect Callback.
      (+) EndOfRefreshCallback  : DSI End Of Refresh Callback.
      (+) ErrorCallback         : DSI Error Callback
      (+) MspInitCallback       : DSI MspInit.
      (+) MspDeInitCallback     : DSI MspDeInit.

    [..]
    By default, after the HAL_DSI_Init and when the state is HAL_DSI_STATE_RESET
    all callbacks are set to the corresponding weak functions:
    examples HAL_DSI_TearingEffectCallback(), HAL_DSI_EndOfRefreshCallback().
    Exception done for MspInit and MspDeInit functions that are respectively
    reset to the legacy weak (overridden) functions in the HAL_DSI_Init()
    and HAL_DSI_DeInit() only when these callbacks are null (not registered beforehand).
    If not, MspInit or MspDeInit are not null, the HAL_DSI_Init() and HAL_DSI_DeInit()
    keep and use the user MspInit/MspDeInit callbacks (registered beforehand).

    [..]
    Callbacks can be registered/unregistered in HAL_DSI_STATE_READY state only.
    Exception done MspInit/MspDeInit that can be registered/unregistered
    in HAL_DSI_STATE_READY or HAL_DSI_STATE_RESET state,
    thus registered (user) MspInit/DeInit callbacks can be used during the Init/DeInit.
    In that case first register the MspInit/MspDeInit user callbacks
    using HAL_DSI_RegisterCallback() before calling HAL_DSI_DeInit()
    or HAL_DSI_Init() function.

    [..]
    When The compilation define USE_HAL_DSI_REGISTER_CALLBACKS is set to 0 or
    not defined, the callback registration feature is not available and all callbacks
    are set to the corresponding weak functions.

  @endverbatim
  ******************************************************************************
  */DSIxDataTypeData0Data1/Users/jie/Documents/posixGen_Demos-main/LwIP_StreamingServer/Drivers/STM32F7xx_HAL_Driver/Src/stm32f7xx_hal_eth.cETH_Prepare_Tx_Descriptorsconst ETH_TxPacketConfigTypeDefconst ETH_TxPacketConfigTypeDef *ETH_TxDescListTypeDef *dmatxdesclistdescidxfirstdescidxdescnbrdmatxdesctxbufferbd_countprimask_bitdmatxdesc->DESC0uint32_t **unsigned long **dmatxdesc->DESC2(uint32_t)txbuffer->bufferdmatxdesc->DESC1txbuffer->len(dmatxdesc->DESC1)(((READ_REG(dmatxdesc->DESC1)) & (~(0x00001FFFU))) | (txbuffer->len))(((((dmatxdesc->DESC1))) & (~(0x00001FFFU))) | (txbuffer->len))pTxConfig->AttributespTxConfig->ChecksumCtrl(dmatxdesc->DESC0)(((READ_REG(dmatxdesc->DESC0)) & (~(0x00C00000U))) | (pTxConfig->ChecksumCtrl))(((((dmatxdesc->DESC0))) & (~(0x00C00000U))) | (pTxConfig->ChecksumCtrl))(uint32_t)(0x04000000U | 0x08000000U)pTxConfig->CRCPadCtrl(((READ_REG(dmatxdesc->DESC0)) & (~((uint32_t)(0x04000000U | 0x08000000U)))) | (pTxConfig->CRCPadCtrl))(((((dmatxdesc->DESC0))) & (~((uint32_t)(0x04000000U | 0x08000000U)))) | (pTxConfig->CRCPadCtrl))20132659240936407035368709123758096383(uint32_t)RESET((uint32_t)RESET)21474836474026531839ETH_DMARxDescListInitdmarxdescdmarxdesc->DESC0dmarxdesc->DESC1dmarxdesc->DESC2dmarxdesc->DESC3dmarxdesc->BackupAddr0dmarxdesc->BackupAddr1heth->RxDescList.RxDesc[i](uint32_t)dmarxdesc(uint32_t)(heth->Init.RxDesc + i + 1U)(uint32_t)(heth->Init.RxDesc)(uint32_t)ETH_RX_DESC_CNT~ETH_DMARXDESC_DIC(uint32_t)ETH_RX_DESC_CNT - 1U((uint32_t)ETH_RX_DESC_CNT - 1U)heth->RxDescList.RxDescIdxheth->RxDescList.RxDescCntheth->RxDescList.RxBuildDescIdxheth->RxDescList.RxBuildDescCntheth->RxDescList.ItModeheth->Instance->DMARDLAR(uint32_t) heth->Init.RxDescETH_DMATxDescListInitdmatxdesc->DESC3heth->TxDescList.TxDesc[i](uint32_t)dmatxdesc(uint32_t)(heth->Init.TxDesc + i + 1U)(uint32_t)(heth->Init.TxDesc)(uint32_t)ETH_TX_DESC_CNT(uint32_t)ETH_TX_DESC_CNT - 1U((uint32_t)ETH_TX_DESC_CNT - 1U)heth->Instance->DMATDLAR(uint32_t) heth->Init.TxDescETH_MACAddressConfigtmpreg110739056641073905728ETH_MAC_ADDR_HBASE1073905732ETH_MAC_ADDR_LBASEETH_MACDMAConfigmacDefaultConfdmaDefaultConfconst ETH_MACConfigTypeDefconst ETH_MACConfigTypeDef *const ETH_DMAConfigTypeDefconst ETH_DMAConfigTypeDef *ETH_SetDMAConfig4175314723ETH_REG_WRITE_DELAYETH_SetMACConfig424676583965345ETH_FlushTransmitFIFOregindexheth->Instance->MACPMTCSR(0x1UL << (31U))heth->Instance->MACRWUFFRpFilter[regindex]ETH_MACPMTCSR_WFE | ETH_MACPMTCSR_MPE | ETH_MACPMTCSR_GU(0x1UL << (2U)) | (0x1UL << (1U)) | (0x1UL << (9U))MacAddr5184294966777heth->Instance->MACIMRpowerdownconfigETH_MACPMTCSR_MASK((0x1UL << (0U)) | (0x1UL << (2U)) | (0x1UL << (1U)) | (0x1UL << (9U)))(heth->Instance->MACPMTCSR)(((READ_REG(heth->Instance->MACPMTCSR)) & (~(((0x1UL << (0U)) | (0x1UL << (2U)) | (0x1UL << (1U)) | (0x1UL << (9U)))))) | (powerdownconfig))(((((heth->Instance->MACPMTCSR))) & (~(((0x1UL << (0U)) | (0x1UL << (2U)) | (0x1UL << (1U)) | (0x1UL << (9U)))))) | (powerdownconfig))5194294966776heth->Instance->MACVLANTR(0xFFFFUL << (0U))(heth->Instance->MACVLANTR)(((READ_REG(heth->Instance->MACVLANTR)) & (~((0xFFFFUL << (0U))))) | (VLANIdentifier))(((((heth->Instance->MACVLANTR))) & (~((0xFFFFUL << (0U))))) | (VLANIdentifier))(0x1UL << (16U))macaddrlrmacaddrhr(ETH_MACA1HR_AE | ETH_MACA1HR_SA)heth->Instance->MACFFR(0x3UL << (6U))filterconfigETH_MACFFR_MASK0x800007FFU(heth->Instance->MACFFR)(((READ_REG(heth->Instance->MACFFR)) & (~(0x800007FFU))) | (filterconfig))(((((heth->Instance->MACFFR))) & (~(0x800007FFU))) | (filterconfig))21474856952147481600hclk42949672673500000035000000U(uint32_t)ETH_MACMIIAR_CR_Div166000000060000000U(uint32_t)ETH_MACMIIAR_CR_Div26100000000(uint32_t)ETH_MACMIIAR_CR_Div42150000000150000000U(uint32_t)ETH_MACMIIAR_CR_Div62(uint32_t)ETH_MACMIIAR_CR_Div102heth->Instance->DMABMR(ETH_DMAARBITRATION_RXPRIORTX | ETH_DMAARBITRATION_ROUNDROBIN_RXTX_4_1)(0x00000002U | 0x0000C000U)49154(0x1UL << (25U))ETH_DMABMR_FB | ETH_DMABMR_MB(0x1UL << (16U)) | (0x1UL << (26U))67174400(0x3FUL << (17U))8257536(0x3FUL << (8U))(0x1FUL << (2U))heth->Instance->DMAOMR(0x1UL << (20U))(0x7UL << (14U))114688(0x3UL << (3U))heth->Instance->MACCR(0x3UL << (5U))(0x7UL << (17U))917504heth->Instance->MACFCR(0x3UL << (4U))(0xFFFFUL << (16U))~ETH_MACMIIAR_CR_MASK634881984~ETH_MACMIIAR_MWheth->Instance->MACSRmac_flagheth->Instance->DMASRdma_flagheth->Instance->DMAIERdma_itsourceEXTI->PR((EXTI_TypeDef *) ((0x40000000UL + 0x00010000UL) + 0x3C00UL))->PRexti_flag1073822720EXTI_TypeDef *ETH_DMASR_RS | ETH_DMASR_NIS(0x1UL << (6U)) | (0x1UL << (16U))65600ETH_DMASR_TS | ETH_DMASR_NIS(0x1UL << (0U)) | (0x1UL << (16U))65537(ETH_DMASR_FBES | ETH_DMASR_TPS | ETH_DMASR_RPS)((0x1UL << (13U)) | (0x7UL << (20U)) | (0x7UL << (17U)))ETH_DMAIER_NISE | ETH_DMAIER_AISE(0x1UL << (16U)) | (0x1UL << (15U))(ETH_DMASR_ETS | ETH_DMASR_RWTS | ETH_DMASR_RBUS | ETH_DMASR_AIS)((0x1UL << (10U)) | (0x1UL << (9U)) | (0x1UL << (7U)) | (0x1UL << (15U)))734003273482248265728983044294868991166434432(ETH_MACPMTCSR_WFR | ETH_MACPMTCSR_MPR)((0x1UL << (6U)) | (0x1UL << (5U)))(0x0U)(uint32_t)(0x0U)numOfBufpktTxStatuspktInUseheth->RxDescList.pRxLastRxDescETH_DMARXDESC_ERRORS_MASK((uint32_t)(0x00000004U | 0x00000008U | 0x00000800U | 0x00000010U | 0x00000040U | 0x00000002U | 0x00004000U | 0x00000080U))20602076214021421852618654ETH_UpdateDescriptortailidxdesccountallocStatus(uint32_t)buffheth->Init.RxBuffLen | ETH_DMARXDESC_DIC | ETH_DMARXDESC_RCHheth->Init.RxBuffLen | 0x80000000U | 0x00004000Uheth->Init.RxBuffLen | ETH_DMARXDESC_RCHheth->Init.RxBuffLen | 0x00004000Uheth->Instance->DMARPDR((uint32_t)(heth->Init.RxDesc + (tailidx)))desccntdesccntmaxbufflengthrxdatareadyETH_DMARXDESC_FRAMELENGTHSHIFTheth->TxDescList.CurTxDescheth->Instance->DMATPDR(uint32_t)(heth->TxDescList.TxDesc[heth->TxDescList.CurTxDesc])(ETH_DMATXDESC_FS | ETH_DMATXDESC_LS)descindex(ETH_DMAIER_NISE | ETH_DMAIER_RIE | ETH_DMAIER_TIE | ETH_DMAIER_FBEIE | ETH_DMAIER_AISE | ETH_DMAIER_RBUIE)((0x1UL << (16U)) | (0x1UL << (6U)) | (0x1UL << (0U)) | (0x1UL << (13U)) | (0x1UL << (15U)) | (0x1UL << (7U)))65601737931065611066894294860606~(SYSCFG_PMC_MII_RMII_SEL)500ETH_SWRESET_TIMEOUTETH_MACIMR_TSTIM | ETH_MACIMR_PMTIM(0x1UL << (9U)) | (0x1UL << (3U))520heth->Instance->MMCRIMRETH_MMCRIMR_RGUFM | ETH_MMCRIMR_RFAEM | ETH_MMCRIMR_RFCEM(0x1UL << (17U)) | (0x1UL << (6U)) | (0x1UL << (5U))131136131168heth->Instance->MMCTIMRETH_MMCTIMR_TGFM | ETH_MMCTIMR_TGFMSCM | ETH_MMCTIMR_TGFSCM(0x1UL << (21U)) | (0x1UL << (15U)) | (0x1UL << (14U))21299202146304INCR_RX_DESC_INDEX(inx,offset)do { (inx) += (offset); if ((inx) >= (uint32_t)ETH_RX_DESC_CNT){ (inx) = ((inx) - (uint32_t)ETH_RX_DESC_CNT);} } while (0)INCR_TX_DESC_INDEX(inx,offset)do { (inx) += (offset); if ((inx) >= (uint32_t)ETH_TX_DESC_CNT){ (inx) = ((inx) - (uint32_t)ETH_TX_DESC_CNT);} } while (0)(uint32_t)(ETH_MAC_BASE + 0x44U)(uint32_t)(ETH_MAC_BASE + 0x40U)0xF8DE3F23U0x0000FF41U0xFD20810FU0xFFFFFFE3UETH_PTPTSLR_VALUE0xBB9ACA00UETH_PTPTSHR_VALUEETH_MACTSCR_MASK0x0087FF2FUETH_MAC_US_TICK1000000U((uint32_t)(ETH_DMARXDESC_DBE | ETH_DMARXDESC_RE | ETH_DMARXDESC_OE | ETH_DMARXDESC_RWT | ETH_DMARXDESC_LC | ETH_DMARXDESC_CE | ETH_DMARXDESC_DE | ETH_DMARXDESC_IPV4HCE))ETH_MDIO_BUS_TIMEOUT500U(ETH_MACPMTCSR_PD | ETH_MACPMTCSR_WFE | ETH_MACPMTCSR_MPE | ETH_MACPMTCSR_GU)ETH_DMACRCR_MASK0x803F0000UETH_DMACTCR_MASK0x003F1010UETH_DMACCR_MASK0x00013FFFUETH_DMASBMR_MASK0x0000D001UETH_DMAMR_MASK0x00007802UETH_MTLRQOMR_MASK0x0000007BUETH_MTLTQOMR_MASK0x00000072UETH_MACRFCR_MASKETH_MACTFCR_MASK0xFFFF00F2UETH_MACWTR_MASK0x0000010FUETH_MACECR_MASK0x3F077FFFUETH_MACCR_MASK0xFFFB7F7CU/* Legacy weak RxAllocateCallback *//* Legacy weak TxPtpCallback   *//* Legacy weak TxFreeCallback   *//* Legacy weak RxLinkCallback   *//* Legacy weak WakeUpCallback   *//* Legacy weak PMTCallback      *//* Legacy weak ErrorCallback *//* Legacy weak RxCpltCallback   *//* Legacy weak TxCpltCallback   *//* Init the ETH Callback settings *//* Exit critical section: restore previous priority mask *//* Enter critical section *//* Save the current packet address to expose it to the application *//* set OWN bit of FIRST descriptor *//* Ensure rest of descriptor is written to RAM before the OWN bit *//* Get address of first descriptor *//* Mark it as LAST descriptor *//* Clear Interrupt on completion bit *//* Set Interrupt on completion bit *//* Set Own bit *//* Set header or buffer 1 Length *//* Set header or buffer 1 address *//* Get the next Tx buffer in the list *//* Clear the FD bit of new Descriptor *//* Get current descriptor address *//* Increment current tx descriptor index *//* clear previous desc own bit *//* Current Tx Descriptor Owned by DMA: cannot be used by the application  *//* Clear the LD bit of previous descriptor *//* only if the packet is split into more than one descriptors > 1 *//* Mark it as First Descriptor *//* Set Vlan Type *//**
  * @brief  Prepare Tx DMA descriptor before transmission.
  *         called by HAL_ETH_Transmit_IT and HAL_ETH_Transmit_IT() API.
  * @param  heth: pointer to a ETH_HandleTypeDef structure that contains
  *         the configuration information for ETHERNET module
  * @param  pTxConfig: Tx packet configuration
  * @param  ItMode: Enable or disable Tx EOT interrept
  * @retval Status
  *//* Set Receive Descriptor List Address *//* Set Rx descritors addresses *//* Enable Ethernet DMA Rx Descriptor interrupt *//* Set Buffer1 size and Second Address Chained bit *//* Set Own bit of the Rx descriptor Status *//**
  * @brief  Initializes the DMA Rx descriptors in chain mode.
  *         called by HAL_ETH_Init() API.
  * @param  heth: pointer to a ETH_HandleTypeDef structure that contains
  *         the configuration information for ETHERNET module
  * @retval None
  *//* Set Transmit Descriptor List Address *//* Set the DMA Tx descriptors checksum insertion *//* Set Second Address Chained bit *//* Fill each DMATxDesc descriptor with the right values *//**
  * @brief  Initializes the DMA Tx descriptors.
  *         called by HAL_ETH_Init() API.
  * @param  heth: pointer to a ETH_HandleTypeDef structure that contains
  *         the configuration information for ETHERNET module
  * @retval None
  *//* Load the selected MAC address low register *//* Calculate the selected MAC address low register *//* Load the selected MAC address high register *//* Calculate the selected MAC address high register *//**
  * @brief  Configures the selected MAC address.
  * @param  heth pointer to a ETH_HandleTypeDef structure that contains
  *         the configuration information for ETHERNET module
  * @param  MacAddr The MAC address to configure
  *          This parameter can be one of the following values:
  *             @arg ETH_MAC_Address0: MAC Address0
  *             @arg ETH_MAC_Address1: MAC Address1
  *             @arg ETH_MAC_Address2: MAC Address2
  *             @arg ETH_MAC_Address3: MAC Address3
  * @param  Addr Pointer to MAC address buffer data (6 bytes)
  * @retval HAL status
  *//* DMA default configuration *//*--------------- ETHERNET DMA registers default Configuration --------------*//* MAC default configuration *//*--------------- ETHERNET MAC registers default Configuration --------------*//**
  * @brief  Configures Ethernet MAC and DMA with default parameters.
  *         called by HAL_ETH_Init() API.
  * @param  heth: pointer to a ETH_HandleTypeDef structure that contains
  *         the configuration information for ETHERNET module
  * @retval HAL status
  *//* Wait until the write operation will be taken into account:
     at least four TX_CLK/RX_CLK clock cycles *//* Enable use of separate PBL for Rx and Tx *//* !! if 4xPBL is selected for Tx or
                                                                       Rx it is applied for the other *//*----------------------- ETHERNET DMABMR Configuration --------------------*//* Wait until the write operation will be taken into account:
  at least four TX_CLK/RX_CLK clock cycles *//* Write to ETHERNET DMAOMR *//* Clear xx bits *//* Get the ETHERNET DMAOMR value *//*----------------------- ETHERNET DMAOMR Configuration --------------------*//* Wait until the write operation will be taken into account :
  at least four TX_CLK/RX_CLK clock cycles *//* Write to ETHERNET MACFCR *//* Get the ETHERNET MACFCR value *//*----------------------- ETHERNET MACFCR Configuration --------------------*//* Write to ETHERNET MACCR *//* Clear CSTF, WD, PCE, PS, TE and RE bits *//* Get the ETHERNET MACCR value *//*------------------------ ETHERNET MACCR Configuration --------------------*//* Set the Flush Transmit FIFO bit *//**
  * @brief  Clears the ETHERNET transmit FIFO.
  * @param  heth pointer to a ETH_HandleTypeDef structure that contains
  *         the configuration information for ETHERNET module
  * @retval None
  *//** @addtogroup ETH_Private_Functions   ETH Private Functions
  * @{
  *//**
  * @brief  Returns the ETH MAC WakeUp event source
  * @param  heth: pointer to a ETH_HandleTypeDef structure that contains
  *         the configuration information for ETHERNET module
  * @retval ETH MAC WakeUp event source
  *//**
  * @brief  Returns the ETH MAC error code
  * @param  heth: pointer to a ETH_HandleTypeDef structure that contains
  *         the configuration information for ETHERNET module
  * @retval ETH MAC Error Code
  *//**
  * @brief  Returns the ETH DMA error code
  * @param  heth: pointer to a ETH_HandleTypeDef structure that contains
  *         the configuration information for ETHERNET module
  * @retval ETH DMA Error Code
  *//**
  * @brief  Returns the ETH error code
  * @param  heth: pointer to a ETH_HandleTypeDef structure that contains
  *         the configuration information for ETHERNET module
  * @retval ETH Error Code
  *//**
  * @brief  Returns the ETH state.
  * @param  heth: pointer to a ETH_HandleTypeDef structure that contains
  *         the configuration information for ETHERNET module
  * @retval HAL state
  *//** @defgroup ETH_Exported_Functions_Group4 Peripheral State and Errors functions
  *  @brief   ETH State and Errors functions
  *
@verbatim
  ==============================================================================
                 ##### Peripheral State and Errors functions #####
  ==============================================================================
 [..]
   This subsection provides a set of functions allowing to return the State of
   ETH communication process, return Peripheral Errors occurred during communication
   process


@endverbatim
  * @{
  *//* Write filter regs *//* Wake up packet filter config *//* Reset Filter Pointer *//**
  * @brief  Set the WakeUp filter.
  * @param  heth: pointer to a ETH_HandleTypeDef structure that contains
  *         the configuration information for ETHERNET module
  * @param  pFilter: pointer to filter registers values
  * @param  Count: number of filter registers, must be from 1 to 8.
  * @retval None.
  *//* Disable PMT interrupt *//* Wait until the write operation will be taken into account :
    at least four TX_CLK/RX_CLK clock cycles *//* Exit power down mode *//* clear wake up sources *//**
  * @brief  Exits from the Power down mode.
  * @param  heth: pointer to a ETH_HandleTypeDef structure that contains
  *         the configuration information for ETHERNET module
  * @retval None.
  *//**
  * @brief  Enters the Power down mode.
  * @param  heth: pointer to a ETH_HandleTypeDef structure that contains
  *         the configuration information for ETHERNET module
  * @param  pPowerDownConfig: a pointer to ETH_PowerDownConfigTypeDef structure
  *         that contains the Power Down configuration
  * @retval None.
  *//**
  * @brief  Set the VLAN Identifier for Rx packets
  * @param  heth: pointer to a ETH_HandleTypeDef structure that contains
  *         the configuration information for ETHERNET module
  * @param  ComparisonBits: 12 or 16 bit comparison mode
            must be a value of @ref ETH_VLAN_Tag_Comparison
  * @param  VLANIdentifier: VLAN Identifier value
  * @retval None
  *//**
  * @brief  Set the ETH Hash Table Value.
  * @param  heth: pointer to a ETH_HandleTypeDef structure that contains
  *         the configuration information for ETHERNET module
  * @param  pHashTable: pointer to a table of two 32 bit values, that contains
  *         the 64 bits of the hash table.
  * @retval HAL status
  *//* Enable address and set source address bit *//* Set MAC addr bits 0 to 31 *//* Set MAC addr bits 32 to 47 *//* Get mac addr low reg offset *//* Get mac addr high reg offset *//**
  * @brief  Set the source MAC Address to be matched.
  * @param  heth: pointer to a ETH_HandleTypeDef structure that contains
  *         the configuration information for ETHERNET module
  * @param  AddrNbr: The MAC address to configure
  *          This parameter must be a value of the following:
  *            ETH_MAC_ADDRESS1
  *            ETH_MAC_ADDRESS2
  *            ETH_MAC_ADDRESS3
  * @param  pMACAddr: Pointer to MAC address buffer data (6 bytes)
  * @retval HAL status
  *//**
  * @brief  Get the ETH MAC (L2) Filters configuration.
  * @param  heth: pointer to a ETH_HandleTypeDef structure that contains
  *         the configuration information for ETHERNET module
  * @param  pFilterConfig: pointer to a ETH_MACFilterConfigTypeDef structure that will hold
  *         the configuration of the ETH MAC filters.
  * @retval HAL status
  *//**
  * @brief  Set the ETH MAC (L2) Filters configuration.
  * @param  heth: pointer to a ETH_HandleTypeDef structure that contains
  *         the configuration information for ETHERNET module
  * @param  pFilterConfig: pointer to a ETH_MACFilterConfigTypeDef structure that contains
  *         the configuration of the ETH MAC filters.
  * @retval HAL status
  *//* Write to ETHERNET MAC MIIAR: Configure the ETHERNET CSR Clock Range *//* CSR Clock >= 150 MHz *//* (hclk >= 150000000)  *//* CSR Clock Range between 100-150 MHz *//* CSR Clock Range between 60-100 MHz *//* CSR Clock Range between 35-60 MHz *//* CSR Clock Range between 0-35 MHz *//* Set CR bits depending on hclk value *//* Get hclk frequency value *//* Clear CSR Clock Range CR[2:0] bits *//* Get the ETHERNET MACMIIAR value *//**
  * @brief  Configures the Clock range of ETH MDIO interface.
  * @param  heth: pointer to a ETH_HandleTypeDef structure that contains
  *         the configuration information for ETHERNET module
  * @retval None
  *//**
  * @brief  Set the ETH DMA configuration.
  * @param  heth: pointer to a ETH_HandleTypeDef structure that contains
  *         the configuration information for ETHERNET module
  * @param  dmaconf: pointer to a ETH_DMAConfigTypeDef structure that will hold
  *         the configuration of the ETH DMA.
  * @retval HAL status
  *//**
  * @brief  Set the MAC configuration.
  * @param  heth: pointer to a ETH_HandleTypeDef structure that contains
  *         the configuration information for ETHERNET module
  * @param  macconf: pointer to a ETH_MACConfigTypeDef structure that contains
  *         the configuration of the MAC.
  * @retval HAL status
  *//**
  * @brief  Get the configuration of the DMA.
  * @param  heth: pointer to a ETH_HandleTypeDef structure that contains
  *         the configuration information for ETHERNET module
  * @param  dmaconf: pointer to a ETH_DMAConfigTypeDef structure that will hold
  *         the configuration of the ETH DMA.
  * @retval HAL Status
  *//* Get MAC parameters *//**
  * @brief  Get the configuration of the MAC and MTL subsystems.
  * @param  heth: pointer to a ETH_HandleTypeDef structure that contains
  *         the configuration information for ETHERNET module
  * @param  macconf: pointer to a ETH_MACConfigTypeDef structure that will hold
  *         the configuration of the MAC.
  * @retval HAL Status
  *//** @defgroup ETH_Exported_Functions_Group3 Peripheral Control functions
  *  @brief   ETH control functions
  *
@verbatim
  ==============================================================================
                      ##### Peripheral Control functions #####
  ==============================================================================
  [..]
    This subsection provides a set of functions allowing to control the ETH
    peripheral.

@endverbatim
  * @{
  *//* Check for the Busy flag *//* Write the result value into the MII Address register *//* Give the value to the MII data register *//* Set the MII Busy bit *//* Set the write mode *//* Set the PHY register address *//* Set the PHY device address *//* Prepare the MII register address value *//* Keep only the CSR Clock Range CR[2:0] bits value *//**
  * @brief  Writes to a PHY register.
  * @param  heth: pointer to a ETH_HandleTypeDef structure that contains
  *         the configuration information for ETHERNET module
  * @param  PHYAddr: PHY port address, must be a value from 0 to 31
  * @param  PHYReg: PHY register address, must be a value from 0 to 31
  * @param  RegValue: the value to write
  * @retval HAL status
  *//* Get MACMIIDR value *//* Set the MII Busy bit         *//* Set the read mode            *//* Set the PHY device address   *//* Prepare the MII address register value *//**
  * @brief  Read a PHY register
  * @param  heth: pointer to a ETH_HandleTypeDef structure that contains
  *         the configuration information for ETHERNET module
  * @param  PHYAddr: PHY port address, must be a value from 0 to 31
  * @param  PHYReg: PHY register address, must be a value from 0 to 31
  * @param pRegValue: parameter to hold read value
  * @retval HAL status
  *//* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_ETH_WakeUpCallback could be implemented in the user file
   *//**
  * @brief  ETH WAKEUP interrupt callback
  * @param  heth: pointer to a ETH_HandleTypeDef structure that contains
  *         the configuration information for ETHERNET module
  * @retval None
  *//* NOTE : This function Should not be modified, when the callback is needed,
  the HAL_ETH_PMTCallback could be implemented in the user file
  *//**
  * @brief  Ethernet Power Management module IT callback
  * @param  heth: pointer to a ETH_HandleTypeDef structure that contains
  *         the configuration information for ETHERNET module
  * @retval None
  *//* NOTE : This function Should not be modified, when the callback is needed,
  the HAL_ETH_ErrorCallback could be implemented in the user file
  *//**
  * @brief  Ethernet transfer error callbacks
  * @param  heth: pointer to a ETH_HandleTypeDef structure that contains
  *         the configuration information for ETHERNET module
  * @retval None
  *//* NOTE : This function Should not be modified, when the callback is needed,
  the HAL_ETH_RxCpltCallback could be implemented in the user file
  *//**
  * @brief  Rx Transfer completed callbacks.
  * @param  heth: pointer to a ETH_HandleTypeDef structure that contains
  *         the configuration information for ETHERNET module
  * @retval None
  *//* NOTE : This function Should not be modified, when the callback is needed,
  the HAL_ETH_TxCpltCallback could be implemented in the user file
  *//**
  * @brief  Tx Transfer completed callbacks.
  * @param  heth: pointer to a ETH_HandleTypeDef structure that contains
  *         the configuration information for ETHERNET module
  * @retval None
  *//* ETH WAKEUP callback *//* Call registered WakeUp callback*//* Clear ETH WAKEUP Exti pending bit *//* check ETH WAKEUP exti flag *//* Ethernet PMT callback *//* Call registered PMT callback*//* Get MAC Wake-up source and clear the status register pending bit *//* ETH PMT IT *//* Ethernet DMA Error callback *//* Call registered Error callback*//* Clear the interrupt summary flag *//* Get DMA error status  *//* Set HAL state to ERROR *//* Disable all interrupts *//* Get DMA error code  *//* if fatal bus error occurred *//* ETH DMA Error *//*Call registered Transmit complete callback*//* Clear the Eth DMA Tx IT pending bits *//* Packet transmitted *//* Receive complete callback *//*Call registered Receive complete callback*//* Clear the Eth DMA Rx IT pending bits *//* Packet received *//**
  * @brief  This function handles ETH interrupt request.
  * @param  heth: pointer to a ETH_HandleTypeDef structure that contains
  *         the configuration information for ETHERNET module
  * @retval HAL status
  *//* NOTE : This function Should not be modified, when the callback is needed,
  the HAL_ETH_TxPtpCallback could be implemented in the user file
  *//**
  * @brief  Tx Ptp callback.
  * @param  buff: pointer to application buffer
  * @param  timestamp: pointer to ETH_TimeStampTypeDef structure that contains
  *         transmission timestamp
  * @retval None
  *//* Set function to allocate buffer *//**
  * @brief  Unregister the Tx Ptp callback.
  * @param  heth: pointer to a ETH_HandleTypeDef structure that contains
  *         the configuration information for ETHERNET module
  * @retval HAL status
  *//* Set Function to handle Tx Ptp *//* No buffer to save *//**
  * @brief  Register the Tx Ptp callback.
  * @param  heth: pointer to a ETH_HandleTypeDef structure that contains
  *         the configuration information for ETHERNET module
  * @param  txPtpCallback: Function to handle Ptp transmission
  * @retval HAL status
  *//* Get timestamp high *//* Get timestamp low *//**
  * @brief  Get receive timestamp.
  * @param  heth: pointer to a ETH_HandleTypeDef structure that contains
  *         the configuration information for ETHERNET module
  * @param  timestamp: pointer to ETH_TIMESTAMPTypeDef structure that contains
  *         receive timestamp
  * @retval HAL status
  *//**
  * @brief  Get transmission timestamp.
  * @param  heth: pointer to a ETH_HandleTypeDef structure that contains
  *         the configuration information for ETHERNET module
  * @param  timestamp: pointer to ETH_TIMESTAMPTypeDef structure that contains
  *         transmission timestamp
  * @retval HAL status
  *//* Enable Time Stamp transmission *//**
  * @brief  Insert Timestamp in transmission.
  * @param  heth: pointer to a ETH_HandleTypeDef structure that contains
  *         the configuration information for ETHERNET module
  * @retval HAL status
  *//* Set nanoSeconds update *//* Set Seconds update *//**
  * @brief  Update time for the Ethernet PTP registers.
  * @param  heth: pointer to a ETH_HandleTypeDef structure that contains
  *         the configuration information for ETHERNET module
  * @param  timeoffset: pointer to a ETH_PtpUpdateTypeDef structure that contains
  *         the time update information
  * @retval HAL status
  *//* Get NanoSeconds *//* Get Seconds *//**
  * @brief  Get Seconds and Nanoseconds for the Ethernet PTP registers.
  * @param  heth: pointer to a ETH_HandleTypeDef structure that contains
  *         the configuration information for ETHERNET module
  * @param  time: pointer to a ETH_TimeTypeDef structure that contains
  *         time to get
  * @retval HAL status
  *//* the system time is updated *//* Set NanoSeconds *//* Set Seconds *//**
  * @brief  Set Seconds and Nanoseconds for the Ethernet PTP registers.
  * @param  heth: pointer to a ETH_HandleTypeDef structure that contains
  *         the configuration information for ETHERNET module
  * @param  time: pointer to a ETH_TimeTypeDef structure that contains
  *         time to set
  * @retval HAL status
  *//**
  * @brief  Get the Ethernet PTP configuration.
  * @param  heth: pointer to a ETH_HandleTypeDef structure that contains
  *         the configuration information for ETHERNET module
  * @param  ptpconfig: pointer to a ETH_PTP_ConfigTypeDef structure that contains
  *         the configuration information for PTP
  * @retval HAL status
  *//* Set PTP Configuration done *//* Ptp Init *//* Enable Timestamp *//* Write to MACTSCR *//**
  * @brief  Set the Ethernet PTP configuration.
  * @param  heth: pointer to a ETH_HandleTypeDef structure that contains
  *         the configuration information for ETHERNET module
  * @param  ptpconfig: pointer to a ETH_PTP_ConfigTypeDef structure that contains
  *         the configuration information for PTP
  * @retval HAL status
  *//* Get out of the loop!  *//* Update the transmit relesae index and number of buffers in use.  *//* Clear the entry in the in-use array.  *//* Release the packet.  *//* Handle Ptp  *//* Call callbacks *//*Call registered callbacks*//* Determine if the packet has been transmitted.  *//* No packet in use, skip to next.  *//* If no packet, just examine the next packet.  *//* Loop through buffers in use.  *//**
  * @brief  Release transmitted Tx packets.
  * @param  heth: pointer to a ETH_HandleTypeDef structure that contains
  *         the configuration information for ETHERNET module
  * @retval HAL status
  *//* NOTE : This function Should not be modified, when the callback is needed,
  the HAL_ETH_TxFreeCallback could be implemented in the user file
  *//**
  * @brief  Tx Free callback.
  * @param  buff: pointer to buffer to free
  * @retval None
  *//**
  * @brief  Unregister the Tx free callback.
  * @param  heth: pointer to a ETH_HandleTypeDef structure that contains
  *         the configuration information for ETHERNET module
  * @retval HAL status
  *//* Set function to free transmmitted packet *//**
  * @brief  Set the Tx free function.
  * @param  heth: pointer to a ETH_HandleTypeDef structure that contains
  *         the configuration information for ETHERNET module
  * @param  txFreeCallback: pointer to function to release the packet
  * @retval HAL status
  *//* Get error bits. *//**
  * @brief  Get the error state of the last received packet.
  * @param  heth: pointer to a ETH_HandleTypeDef structure that contains
  *         the configuration information for ETHERNET module
  * @param  pErrorCode: pointer to uint32_t to hold the error code
  * @retval HAL status
  *//**
  * @brief  Unregister the Rx link callback.
  * @param  heth: pointer to a ETH_HandleTypeDef structure that contains
  *         the configuration information for ETHERNET module
  * @retval HAL status
  *//* Set function to link data *//**
  * @brief  Set the Rx link data function.
  * @param  heth: pointer to a ETH_HandleTypeDef structure that contains
  *         the configuration information for ETHERNET module
  * @param  rxLinkCallback: pointer to function to link data
  * @retval HAL status
  *//* NOTE : This function Should not be modified, when the callback is needed,
  the HAL_ETH_RxLinkCallback could be implemented in the user file
  *//**
  * @brief  Rx Link callback.
  * @param  pStart: pointer to packet start
  * @param  pEnd: pointer to packet end
  * @param  buff: pointer to received data
  * @param  Length: received data length
  * @retval None
  *//* NOTE : This function Should not be modified, when the callback is needed,
  the HAL_ETH_RxAllocateCallback could be implemented in the user file
  *//**
  * @brief  Rx Allocate callback.
  * @param  buff: pointer to allocated buffer
  * @retval None
  *//**
  * @brief  Unregister the Rx alloc callback.
  * @param  heth: pointer to a ETH_HandleTypeDef structure that contains
  *         the configuration information for ETHERNET module
  * @retval HAL status
  *//**
  * @brief  Register the Rx alloc callback.
  * @param  heth: pointer to a ETH_HandleTypeDef structure that contains
  *         the configuration information for ETHERNET module
  * @param  rxAllocateCallback: pointer to function to alloc buffer
  * @retval HAL status
  *//* Set the Tail pointer address *//* DMB instruction to avoid race condition *//* Set the tail pointer index *//* Increment current rx descriptor index *//* Allocate callback *//*Call registered Allocate callback*//* Get a new buffer. *//* Check if a buffer's attached the descriptor *//**
  * @brief  This function gives back Rx Desc of the last received Packet
  *         to the DMA, so ETH DMA will be able to use these descriptors
  *         to receive next Packets.
  * @param  heth: pointer to a ETH_HandleTypeDef structure that contains
  *         the configuration information for ETHERNET module
  * @retval HAL status
  *//* Packet not ready *//* Reset first element *//* Return received packet *//* Update Descriptors *//* Clear buffer pointer *//* Link callback *//*Call registered Link callback*//* Link data *//* Packet ready *//* Save Last descriptor index *//* Check if last descriptor *//* Get the Frame Length of the received packet: substruct 4 bytes of the CRC *//* Check first descriptor *//* Check if descriptor is not owned by DMA *//**
  * @brief  Read a received packet.
  * @param  heth: pointer to a ETH_HandleTypeDef structure that contains
  *         the configuration information for ETHERNET module
  * @param  pAppBuff: Pointer to an application buffer to receive the packet.
  * @retval HAL status
  *//* Resume DMA transmission*//* Clear TBUS ETHERNET DMA flag *//* issue a poll command to Tx DMA by writing address of next immediate free descriptor *//* Start transmission *//* Incr current tx desc index *//* Ensure completion of descriptor preparation before transmission start *//* Config DMA Tx descriptor by Tx Packet info *//* Save the packet pointer to release.  *//**
  * @brief  Sends an Ethernet Packet in interrupt mode.
  * @param  heth: pointer to a ETH_HandleTypeDef structure that contains
  *         the configuration information for ETHERNET module
  * @param  pTxConfig: Hold the configuration of packet to be transmitted
  * @retval HAL status
  *//* Clear TX descriptor so that we can proceed *//* Wait for data to be transmitted or timeout occurred *//* Set the ETH error code *//**
  * @brief  Sends an Ethernet Packet in polling mode.
  * @param  heth: pointer to a ETH_HandleTypeDef structure that contains
  *         the configuration information for ETHERNET module
  * @param  pTxConfig: Hold the configuration of packet to be transmitted
  * @param  Timeout: timeout value
  * @retval HAL status
  *//* Clear IOC bit to all Rx descriptors *//* Disable the MAC transmission *//* Flush Transmit FIFO *//* Disable the MAC reception *//* Disable the DMA reception *//* Disable the DMA transmission *//* Set the ETH peripheral state to BUSY *//**
  * @brief  Stop Ethernet MAC and DMA reception/transmission in Interrupt mode
  * @param  heth: pointer to a ETH_HandleTypeDef structure that contains
  *         the configuration information for ETHERNET module
  * @retval HAL status
  *//**
  * @brief  Stop Ethernet MAC and DMA reception/transmission
  * @param  heth: pointer to a ETH_HandleTypeDef structure that contains
  *         the configuration information for ETHERNET module
  * @retval HAL status
  *//* Enable ETH DMA interrupts:
    - Tx complete interrupt
    - Rx complete interrupt
    - Fatal bus interrupt
    *//* Enable the MAC reception *//* Enable the MAC transmission *//* Enable the DMA reception *//* Enable the DMA transmission *//* Build all descriptors *//* Set number of descriptors to build *//* save IT mode to ETH Handle *//**
  * @brief  Enables Ethernet MAC and DMA reception/transmission in Interrupt mode
  * @param  heth: pointer to a ETH_HandleTypeDef structure that contains
  *         the configuration information for ETHERNET module
  * @retval HAL status
  *//**
  * @brief  Enables Ethernet MAC and DMA reception and transmission
  * @param  heth: pointer to a ETH_HandleTypeDef structure that contains
  *         the configuration information for ETHERNET module
  * @retval HAL status
  *//** @defgroup ETH_Exported_Functions_Group2 IO operation functions
  *  @brief ETH Transmit and Receive functions
  *
@verbatim
  ==============================================================================
                      ##### IO operation functions #####
  ==============================================================================
  [..]
    This subsection provides a set of functions allowing to manage the ETH
    data transfer.

@endverbatim
  * @{
  *//**
  * @brief  Unregister an ETH Callback
  *         ETH callback is redirected to the weak predefined callback
  * @param heth eth handle
  * @param CallbackID ID of the callback to be unregistered
  *        This parameter can be one of the following values:
  *          @arg @ref HAL_ETH_TX_COMPLETE_CB_ID Tx Complete Callback ID
  *          @arg @ref HAL_ETH_RX_COMPLETE_CB_ID Rx Complete Callback ID
  *          @arg @ref HAL_ETH_ERROR_CB_ID       Error Callback ID
  *          @arg @ref HAL_ETH_PMT_CB_ID         Power Management Callback ID
  *          @arg @ref HAL_ETH_WAKEUP_CB_ID      Wake UP Callback ID
  *          @arg @ref HAL_ETH_MSPINIT_CB_ID     MspInit callback ID
  *          @arg @ref HAL_ETH_MSPDEINIT_CB_ID   MspDeInit callback ID
  * @retval status
  *//**
  * @brief  Register a User ETH Callback
  *         To be used instead of the weak predefined callback
  * @param heth eth handle
  * @param CallbackID ID of the callback to be registered
  *        This parameter can be one of the following values:
  *          @arg @ref HAL_ETH_TX_COMPLETE_CB_ID Tx Complete Callback ID
  *          @arg @ref HAL_ETH_RX_COMPLETE_CB_ID Rx Complete Callback ID
  *          @arg @ref HAL_ETH_ERROR_CB_ID       Error Callback ID
  *          @arg @ref HAL_ETH_PMT_CB_ID         Power Management Callback ID
  *          @arg @ref HAL_ETH_WAKEUP_CB_ID      Wake UP Callback ID
  *          @arg @ref HAL_ETH_MSPINIT_CB_ID     MspInit callback ID
  *          @arg @ref HAL_ETH_MSPDEINIT_CB_ID   MspDeInit callback ID
  * @param pCallback pointer to the Callback function
  * @retval status
  *//* NOTE : This function Should not be modified, when the callback is needed,
  the HAL_ETH_MspDeInit could be implemented in the user file
  *//**
  * @brief  DeInitializes ETH MSP.
  * @param  heth: pointer to a ETH_HandleTypeDef structure that contains
  *         the configuration information for ETHERNET module
  * @retval None
  *//* NOTE : This function Should not be modified, when the callback is needed,
  the HAL_ETH_MspInit could be implemented in the user file
  *//**
  * @brief  Initializes the ETH MSP.
  * @param  heth: pointer to a ETH_HandleTypeDef structure that contains
  *         the configuration information for ETHERNET module
  * @retval None
  *//* Set ETH HAL state to Disabled *//* (USE_HAL_ETH_REGISTER_CALLBACKS) *//* De-Init the low level hardware : GPIO, CLOCK, NVIC. *//**
  * @brief  DeInitializes the ETH peripheral.
  * @param  heth: pointer to a ETH_HandleTypeDef structure that contains
  *         the configuration information for ETHERNET module
  * @retval HAL status
  *//* Disable Tx MMC Interrupts *//* Disable Rx MMC Interrupts *//* Disable MMC Interrupts *//*--------------------- ETHERNET MAC Address Configuration ------------------*//*------------------ DMA Rx Descriptors Configuration ----------------------*//*------------------ DMA Tx Descriptors Configuration ----------------------*//*------------------ MAC, MTL and DMA default Configuration ----------------*//* Return Error *//* Set State as Error *//* Wait for software reset *//* After reset all the registers holds their respective reset values *//* Set the SWR bit: resets all MAC subsystem internal registers and logic *//* Ethernet Software reset *//* Dummy read to sync SYSCFG with ETH *//* Select MII or RMII Mode*//* Init the low level hardware : GPIO, CLOCK, NVIC. *//**
  * @brief  Initialize the Ethernet peripheral registers.
  * @param  heth: pointer to a ETH_HandleTypeDef structure that contains
  *         the configuration information for ETHERNET module
  * @retval HAL status
  *//** @defgroup ETH_Exported_Functions_Group1 Initialization and deinitialization functions
  *  @brief    Initialization and Configuration functions
  *
@verbatim
===============================================================================
            ##### Initialization and Configuration functions #####
 ===============================================================================
    [..]  This subsection provides a set of functions allowing to initialize and
          deinitialize the ETH peripheral:

      (+) User must Implement HAL_ETH_MspInit() function in which he configures
          all related peripherals resources (CLOCK, GPIO and NVIC ).

      (+) Call the function HAL_ETH_Init() to configure the selected device with
          the selected configuration:
        (++) MAC address
        (++) Media interface (MII or RMII)
        (++) Rx DMA Descriptors Tab
        (++) Tx DMA Descriptors Tab
        (++) Length of Rx Buffers

      (+) Call the function HAL_ETH_DeInit() to restore the default configuration
          of the selected ETH peripheral.

@endverbatim
  * @{
  *//** @defgroup ETH_Exported_Functions ETH Exported Functions
  * @{
  *//** @defgroup ETH_Private_Functions   ETH Private Functions
  * @{
  *//* Helper macros for RX descriptor handling *//* Helper macros for TX descriptor handling *//** @defgroup ETH_Private_Macros ETH Private Macros
  * @{
  *//* ETHERNET DMA Rx descriptors Frame length Shift *//* ETHERNET MAC address low offset *//* ETHERNET MAC address high offset *//* ETHERNET MAC address offsets *//* ETHERNET DMAOMR register Mask *//* ETHERNET MACFCR register Mask *//* ETHERNET MACCR register Mask *//* Delay to wait when writing to some Ethernet registers *//* Ethernet MACMIIAR register Mask *//* Timeout values *//** @addtogroup ETH_Private_Constants ETH Private Constants
  * @{
  *//** @defgroup ETH ETH
  * @brief ETH HAL module driver
  * @{
  *//**
  ******************************************************************************
  * @file    stm32f7xx_hal_eth.c
  * @author  MCD Application Team
  * @brief   ETH HAL module driver.
  *          This file provides firmware functions to manage the following
  *          functionalities of the Ethernet (ETH) peripheral:
  *           + Initialization and deinitialization functions
  *           + IO operation functions
  *           + Peripheral Control functions
  *           + Peripheral State and Errors functions
  *
  ******************************************************************************
  * @attention
  *
  * Copyright (c) 2017 STMicroelectronics.
  * All rights reserved.
  *
  * This software is licensed under terms that can be found in the LICENSE file
  * in the root directory of this software component.
  * If no LICENSE file comes with this software, it is provided AS-IS.
  *
  ******************************************************************************
  @verbatim
  ==============================================================================
                    ##### How to use this driver #####
  ==============================================================================
     [..]
     The ETH HAL driver can be used as follows:

      (#)Declare a ETH_HandleTypeDef handle structure, for example:
         ETH_HandleTypeDef  heth;

      (#)Fill parameters of Init structure in heth handle

      (#)Call HAL_ETH_Init() API to initialize the Ethernet peripheral (MAC, DMA, ...)

      (#)Initialize the ETH low level resources through the HAL_ETH_MspInit() API:
          (##) Enable the Ethernet interface clock using
                (+++)  __HAL_RCC_ETH1MAC_CLK_ENABLE()
                (+++)  __HAL_RCC_ETH1TX_CLK_ENABLE()
                (+++)  __HAL_RCC_ETH1RX_CLK_ENABLE()

          (##) Initialize the related GPIO clocks
          (##) Configure Ethernet pinout
          (##) Configure Ethernet NVIC interrupt (in Interrupt mode)

      (#) Ethernet data reception is asynchronous, so call the following API
          to start the listening mode:
          (##) HAL_ETH_Start():
               This API starts the MAC and DMA transmission and reception process,
               without enabling end of transfer interrupts, in this mode user
               has to poll for data reception by calling HAL_ETH_ReadData()
          (##) HAL_ETH_Start_IT():
               This API starts the MAC and DMA transmission and reception process,
               end of transfer interrupts are enabled in this mode,
               HAL_ETH_RxCpltCallback() will be executed when an Ethernet packet is received

      (#) When data is received user can call the following API to get received data:
          (##) HAL_ETH_ReadData(): Read a received packet

      (#) For transmission path, two APIs are available:
         (##) HAL_ETH_Transmit(): Transmit an ETH frame in blocking mode
         (##) HAL_ETH_Transmit_IT(): Transmit an ETH frame in interrupt mode,
              HAL_ETH_TxCpltCallback() will be executed when end of transfer occur

      (#) Communication with an external PHY device:
         (##) HAL_ETH_ReadPHYRegister(): Read a register from an external PHY
         (##) HAL_ETH_WritePHYRegister(): Write data to an external RHY register

      (#) Configure the Ethernet MAC after ETH peripheral initialization
          (##) HAL_ETH_GetMACConfig(): Get MAC actual configuration into ETH_MACConfigTypeDef
          (##) HAL_ETH_SetMACConfig(): Set MAC configuration based on ETH_MACConfigTypeDef

      (#) Configure the Ethernet DMA after ETH peripheral initialization
          (##) HAL_ETH_GetDMAConfig(): Get DMA actual configuration into ETH_DMAConfigTypeDef
          (##) HAL_ETH_SetDMAConfig(): Set DMA configuration based on ETH_DMAConfigTypeDef

      (#) Configure the Ethernet PTP after ETH peripheral initialization
          (##) Define HAL_ETH_USE_PTP to use PTP APIs.
          (##) HAL_ETH_PTP_GetConfig(): Get PTP actual configuration into ETH_PTP_ConfigTypeDef
          (##) HAL_ETH_PTP_SetConfig(): Set PTP configuration based on ETH_PTP_ConfigTypeDef
          (##) HAL_ETH_PTP_GetTime(): Get Seconds and Nanoseconds for the Ethernet PTP registers
          (##) HAL_ETH_PTP_SetTime(): Set Seconds and Nanoseconds for the Ethernet PTP registers
          (##) HAL_ETH_PTP_AddTimeOffset(): Add Seconds and Nanoseconds offset for the Ethernet PTP registers
          (##) HAL_ETH_PTP_InsertTxTimestamp(): Insert Timestamp in transmission
          (##) HAL_ETH_PTP_GetTxTimestamp(): Get transmission timestamp
          (##) HAL_ETH_PTP_GetRxTimestamp(): Get reception timestamp

      -@- The ARP offload feature is not supported in this driver.

      -@- The PTP offload feature is not supported in this driver.

  *** Callback registration ***
  =============================================

  The compilation define  USE_HAL_ETH_REGISTER_CALLBACKS when set to 1
  allows the user to configure dynamically the driver callbacks.
  Use Function HAL_ETH_RegisterCallback() to register an interrupt callback.

  Function HAL_ETH_RegisterCallback() allows to register following callbacks:
    (+) TxCpltCallback   : Tx Complete Callback.
    (+) RxCpltCallback   : Rx Complete Callback.
    (+) ErrorCallback    : Error Callback.
    (+) PMTCallback      : Power Management Callback
    (+) EEECallback      : EEE Callback.
    (+) WakeUpCallback   : Wake UP Callback
    (+) MspInitCallback  : MspInit Callback.
    (+) MspDeInitCallback: MspDeInit Callback.

  This function takes as parameters the HAL peripheral handle, the Callback ID
  and a pointer to the user callback function.

  For specific callbacks RxAllocateCallback use dedicated register callbacks:
  respectively HAL_ETH_RegisterRxAllocateCallback().

  For specific callbacks RxLinkCallback use dedicated register callbacks:
  respectively HAL_ETH_RegisterRxLinkCallback().

  For specific callbacks TxFreeCallback use dedicated register callbacks:
  respectively HAL_ETH_RegisterTxFreeCallback().

  For specific callbacks TxPtpCallback use dedicated register callbacks:
  respectively HAL_ETH_RegisterTxPtpCallback().

  Use function HAL_ETH_UnRegisterCallback() to reset a callback to the default
  weak function.
  HAL_ETH_UnRegisterCallback takes as parameters the HAL peripheral handle,
  and the Callback ID.
  This function allows to reset following callbacks:
    (+) TxCpltCallback   : Tx Complete Callback.
    (+) RxCpltCallback   : Rx Complete Callback.
    (+) ErrorCallback    : Error Callback.
    (+) PMTCallback      : Power Management Callback
    (+) EEECallback      : EEE Callback.
    (+) WakeUpCallback   : Wake UP Callback
    (+) MspInitCallback  : MspInit Callback.
    (+) MspDeInitCallback: MspDeInit Callback.

  For specific callbacks RxAllocateCallback use dedicated unregister callbacks:
  respectively HAL_ETH_UnRegisterRxAllocateCallback().

  For specific callbacks RxLinkCallback use dedicated unregister callbacks:
  respectively HAL_ETH_UnRegisterRxLinkCallback().

  For specific callbacks TxFreeCallback use dedicated unregister callbacks:
  respectively HAL_ETH_UnRegisterTxFreeCallback().

  For specific callbacks TxPtpCallback use dedicated unregister callbacks:
  respectively HAL_ETH_UnRegisterTxPtpCallback().

  By default, after the HAL_ETH_Init and when the state is HAL_ETH_STATE_RESET
  all callbacks are set to the corresponding weak functions:
  examples HAL_ETH_TxCpltCallback(), HAL_ETH_RxCpltCallback().
  Exception done for MspInit and MspDeInit functions that are
  reset to the legacy weak function in the HAL_ETH_Init/ HAL_ETH_DeInit only when
  these callbacks are null (not registered beforehand).
  if not, MspInit or MspDeInit are not null, the HAL_ETH_Init/ HAL_ETH_DeInit
  keep and use the user MspInit/MspDeInit callbacks (registered beforehand)

  Callbacks can be registered/unregistered in HAL_ETH_STATE_READY state only.
  Exception done MspInit/MspDeInit that can be registered/unregistered
  in HAL_ETH_STATE_READY or HAL_ETH_STATE_RESET state,
  thus registered (user) MspInit/DeInit callbacks can be used during the Init/DeInit.
  In that case first register the MspInit/MspDeInit user callbacks
  using HAL_ETH_RegisterCallback() before calling HAL_ETH_DeInit
  or HAL_ETH_Init function.

  When The compilation define USE_HAL_ETH_REGISTER_CALLBACKS is set to 0 or
  not defined, the callback registration feature is not available and all callbacks
  are set to the corresponding weak functions.

  @endverbatim
  ******************************************************************************
  *//Users/jie/Documents/posixGen_Demos-main/LwIP_StreamingServer/Drivers/STM32F7xx_HAL_Driver/Src/stm32f7xx_hal_flash.cFLASH_SetErrorCode((0x1UL << (1U)) | (0x1UL << (4U)) | (0x1UL << (5U)) | (0x1UL << (6U)) | (0x1UL << (7U)))114242FLASH_Program_ByteIS_FLASH_ADDRESS(Address)FLASH_Program_HalfWordFLASH_Program_WordFLASH_Program_DoubleWord50000(uint32_t)FLASH_TIMEOUT_VALUE1358669391281191551FLASH->CR((FLASH_TypeDef *) ((0x40000000UL + 0x00020000UL) + 0x3C00UL))->CRFLASH->KEYR((FLASH_TypeDef *) ((0x40000000UL + 0x00020000UL) + 0x3C00UL))->KEYR11643784033455027627temp~FLASH_CR_PG(~FLASH_CR_PG)~FLASH_CR_SER(~FLASH_CR_SER)4294967047SECTOR_MASK327724294934523~FLASH_MER_BIT(~FLASH_MER_BIT)&pFlashFLASH_ProcessTypeDef *IS_FLASH_TYPEPROGRAM(TypeProgram)FLASH_FLAG_EOP | FLASH_FLAG_OPERR | FLASH_FLAG_WRPERR | FLASH_FLAG_PGAERR | FLASH_FLAG_PGPERR| FLASH_FLAG_ERSERR(0x1UL << (0U)) | (0x1UL << (1U)) | (0x1UL << (4U)) | (0x1UL << (5U)) | (0x1UL << (6U))| (0x1UL << (7U))115243pFlash((uint32_t)50000U)((uint32_t)0xFFFFFF07U)/* Clear error programming flags *//**
  * @brief  Set the specific FLASH error flag.
  * @retval None
  *//* Data synchronous Barrier (DSB) Just after the write operation
     This will force the CPU to respect the sequence of instruction (no optimization).*//* If the previous operation is completed, proceed to program the new data *//**
  * @brief  Program byte (8-bit) at a specified address.
  * @note   This function must be used when the device voltage range is from
  *         1.7V to 3.6V.
  *
  * @note   If an erase and a program operations are requested simultaneously,    
  *         the erase operation is performed before the program one.
  *  
  * @param  Address specifies the address to be programmed.
  * @param  Data specifies the data to be programmed.
  * @retval None
  *//**
  * @brief  Program a half-word (16-bit) at a specified address.
  * @note   This function must be used when the device voltage range is from
  *         2.1V to 3.6V.
  *
  * @note   If an erase and a program operations are requested simultaneously,    
  *         the erase operation is performed before the program one.
  *  
  * @param  Address specifies the address to be programmed.
  * @param  Data specifies the data to be programmed.
  * @retval None
  *//**
  * @brief  Program word (32-bit) at a specified address.
  * @note   This function must be used when the device voltage range is from
  *         2.7V to 3.3V.
  *
  * @note   If an erase and a program operations are requested simultaneously,    
  *         the erase operation is performed before the program one.
  *  
  * @param  Address specifies the address to be programmed.
  * @param  Data specifies the data to be programmed.
  * @retval None
  *//* Program second word *//* Barrier to ensure programming is performed in 2 steps, in right order
    (independently of compiler optimization behavior) *//* Program first word *//**
  * @brief  Program a double word (64-bit) at a specified address.
  * @note   This function must be used when the device voltage range is from
  *         2.7V to 3.6V and an External Vpp is present.
  *
  * @note   If an erase and a program operations are requested simultaneously,    
  *         the erase operation is performed before the program one.
  *  
  * @param  Address specifies the address to be programmed.
  * @param  Data specifies the data to be programmed.
  * @retval None
  *//* If there is an error flag set *//* Clear FLASH End of Operation pending bit *//* Check FLASH End of Operation flag  *//*Save the error code*//* Wait for the FLASH operation to complete by polling on BUSY flag to be reset.
     Even if the FLASH operation fails, the BUSY flag will be reset and an error
     flag will be set *//* Clear Error Code *//**
  * @brief  Wait for a FLASH operation to complete.
  * @param  Timeout maximum flash operationtimeout
  * @retval HAL Status
  *//**
  * @brief  Get the specific FLASH error flag.
  * @retval FLASH_ErrorCode: The returned value can be:
  *            @arg FLASH_ERROR_ERS: FLASH Erasing Sequence error flag 
  *            @arg FLASH_ERROR_PGP: FLASH Programming Parallelism error flag  
  *            @arg FLASH_ERROR_PGA: FLASH Programming Alignment error flag
  *            @arg FLASH_ERROR_WRP: FLASH Write protected error flag
  *            @arg FLASH_ERROR_OPERATION: FLASH operation Error flag 
  *//** @defgroup FLASH_Exported_Functions_Group3 Peripheral State and Errors functions 
 *  @brief   Peripheral Errors functions 
 *
@verbatim   
 ===============================================================================
                ##### Peripheral Errors functions #####
 ===============================================================================  
    [..]
    This subsection permits to get in run-time Errors of the FLASH peripheral.

@endverbatim
  * @{
  *//* Wait for last operation to be completed *//* Set the OPTSTRT bit in OPTCR register *//**
  * @brief  Launch the option byte loading.
  * @retval HAL Status
  *//* Set the OPTLOCK Bit to lock the FLASH Option Byte Registers access *//**
  * @brief  Lock the FLASH Option Control Registers access.
  * @retval HAL Status 
  *//* Authorizes the Option Byte register programming *//**
  * @brief  Unlock the FLASH Option Control Registers access.
  * @retval HAL Status
  *//* Set the LOCK Bit to lock the FLASH Registers access *//**
  * @brief  Locks the FLASH control register access
  * @retval HAL Status
  *//* Verify Flash is unlocked *//* Authorize the FLASH Registers access *//**
  * @brief  Unlock the FLASH control register access
  * @retval HAL Status
  *//** @defgroup FLASH_Exported_Functions_Group2 Peripheral Control functions 
 *  @brief   management functions 
 *
@verbatim   
 ===============================================================================
                      ##### Peripheral Control functions #####
 ===============================================================================  
    [..]
    This subsection provides a set of functions allowing to control the FLASH 
    memory operations.

@endverbatim
  * @{
  *//* NOTE : This function Should not be modified, when the callback is needed,
  the HAL_FLASH_OperationErrorCallback could be implemented in the user file
   *//**
  * @brief  FLASH operation error interrupt callback
  * @param  ReturnValue The value saved in this parameter depends on the ongoing procedure
  *                 - Sectors Erase: Sector which has been erased (if 0xFFFFFFFF, it means that 
  *                                  all the selected sectors have been erased)
  *                 - Program      : Address which was selected for data program
  *                 - Mass Erase   : No return value expected
  * @retval None
  *//* NOTE : This function Should not be modified, when the callback is needed,
  the HAL_FLASH_EndOfOperationCallback could be implemented in the user file
  *//**
  * @brief  FLASH end of operation interrupt callback
  * @param  ReturnValue The value saved in this parameter depends on the ongoing procedure
  *                 - Sectors Erase: Sector which has been erased (if 0xFFFFFFFF, it means that 
  *                                  all the selected sectors have been erased)
  *                 - Program      : Address which was selected for data program
  *                 - Mass Erase   : No return value expected
  * @retval None
  *//* Disable Error source interrupt *//* Disable End of FLASH Operation interrupt *//*Stop the procedure ongoing *//* FLASH error interrupt user callback *//*Save the Error code*//*return the faulty address*//* No return in case of Mass Erase *//* return the faulty sector *//* Check FLASH operation error flags *//* Programming procedure is completed *//* FLASH EOP interrupt user callback *//*Program ended. Return the selected address*//* MAss Erase procedure is completed *//* MassErase ended. Return the selected bank : in this product we don't have Banks *//* Sector Erase procedure is completed *//* Reset Sector and stop Erase sectors procedure *//* No more sectors to Erase, user callback can be called.*//* Increment sector number *//* Indicate user which sector has been erased *//* Check if there are still sectors to erase *//* Nb of sector to erased can be decreased *//* if the erase operation is completed, disable the MER Bit *//* If the erase operation is completed, disable the SER Bit *//* If the program operation is completed, disable the PG Bit *//**
  * @brief This function handles FLASH interrupt request.
  * @retval None
  *//*Program double word (64-bit) at a specified address.*//*Program word (32-bit) at a specified address.*//*Program halfword (16-bit) at a specified address.*//*Program byte (8-bit) at a specified address.*//* Clear pending flags (if any) *//* Enable Error source interrupt *//* Enable End of FLASH Operation interrupt *//**
  * @brief   Program byte, halfword, word or double word at a specified address  with interrupt enabled.
  * @param  TypeProgram  Indicate the way to program at a specified address.
  *                           This parameter can be a value of @ref FLASH_Type_Program
  * @param  Address  specifies the address to be programmed.
  * @param  Data specifies the data to be programmed
  * 
  * @retval HAL Status
  *//**
  * @brief  Program byte, halfword, word or double word at a specified address
  * @param  TypeProgram  Indicate the way to program at a specified address.
  *                           This parameter can be a value of @ref FLASH_Type_Program
  * @param  Address  specifies the address to be programmed.
  * @param  Data specifies the data to be programmed
  * 
  * @retval HAL_StatusTypeDef HAL Status
  *//** @defgroup FLASH_Exported_Functions_Group1 Programming operation functions 
 *  @brief   Programming operation functions 
 *
@verbatim   
 ===============================================================================
                  ##### Programming operation functions #####
 ===============================================================================  
    [..]
    This subsection provides a set of functions allowing to manage the FLASH 
    program operations.

@endverbatim
  * @{
  *//** @defgroup FLASH_Exported_Functions FLASH Exported Functions
  * @{
  *//* Program operations *//** @addtogroup FLASH_Private_Functions
  * @{
  *//* Variable used for Erase sectors under interruption *//** @addtogroup FLASH_Private_Variables
  * @{
  *//* 50 s *//** @addtogroup FLASH_Private_Constants
  * @{
  *//** @defgroup FLASH FLASH
  * @brief FLASH HAL module driver
  * @{
  *//**
  ******************************************************************************
  * @file    stm32f7xx_hal_flash.c
  * @author  MCD Application Team
  * @brief   FLASH HAL module driver.
  *          This file provides firmware functions to manage the following 
  *          functionalities of the internal FLASH memory:
  *           + Program operations functions
  *           + Memory Control functions 
  *           + Peripheral Errors functions
  *         
  @verbatim
  ==============================================================================
                        ##### FLASH peripheral features #####
  ==============================================================================
           
  [..] The Flash memory interface manages CPU AHB I-Code and D-Code accesses 
       to the Flash memory. It implements the erase and program Flash memory operations 
       and the read and write protection mechanisms.
      
  [..] The Flash memory interface accelerates code execution with a system of instruction
       prefetch and cache lines. 

  [..] The FLASH main features are:
      (+) Flash memory read operations
      (+) Flash memory program/erase operations
      (+) Read / write protections
      (+) Prefetch on I-Code
      (+) 64 cache lines of 128 bits on I-Code
      (+) 8 cache lines of 128 bits on D-Code
      
                     ##### How to use this driver #####
  ==============================================================================
    [..]                             
      This driver provides functions and macros to configure and program the FLASH 
      memory of all STM32F7xx devices.
    
      (#) FLASH Memory IO Programming functions: 
           (++) Lock and Unlock the FLASH interface using HAL_FLASH_Unlock() and 
                HAL_FLASH_Lock() functions
           (++) Program functions: byte, half word, word and double word
           (++) There Two modes of programming :
            (+++) Polling mode using HAL_FLASH_Program() function
            (+++) Interrupt mode using HAL_FLASH_Program_IT() function
    
      (#) Interrupts and flags management functions : 
           (++) Handle FLASH interrupts by calling HAL_FLASH_IRQHandler()
           (++) Wait for last FLASH operation according to its status
           (++) Get error flag status by calling HAL_SetErrorCode()          
    [..] 
      In addition to these functions, this driver includes a set of macros allowing
      to handle the following operations:
       (+) Set the latency
       (+) Enable/Disable the prefetch buffer
       (+) Enable/Disable the Instruction cache and the Data cache
       (+) Reset the Instruction cache and the Data cache
       (+) Enable/Disable the FLASH interrupts
       (+) Monitor the FLASH flags status
    [..]	   
	(@) For any Flash memory program operation (erase or program), the CPU clock frequency
        (HCLK) must be at least 1MHz. 
	(@) The contents of the Flash memory are not guaranteed if a device reset occurs during 
	    a Flash memory operation.
    (@) Any attempt to read the Flash memory while it is being written or erased, causes the 
	    bus to stall. Read operations are processed correctly once the program operation has 
		completed. This means that code or data fetches cannot be performed while a write/erase 
		operation is ongoing.
          
  @endverbatim
  ******************************************************************************
  * @attention
  *
  * Copyright (c) 2017 STMicroelectronics.
  * All rights reserved.
  *
  * This software is licensed under terms that can be found in the LICENSE file in
  * the root directory of this software component.
  * If no LICENSE file comes with this software, it is provided AS-IS.
  ******************************************************************************
  *//Users/jie/Documents/posixGen_Demos-main/LwIP_StreamingServer/Drivers/STM32F7xx_HAL_Driver/Src/stm32f7xx_hal_flash_ex.cFLASH_OB_GetBootAddressFLASH_OB_GetBORFLASH_OB_GetRDPreadstatus1701073888277(__IO uint8_t*)(OPTCR_BYTE1_ADDRESS)FLASH_OB_BootAddressConfigIS_OB_BOOT_ADDRESS(Address)FLASH->OPTCR1((FLASH_TypeDef *) ((0x40000000UL + 0x00020000UL) + 0x3C00UL))->OPTCR1(((FLASH_TypeDef *) ((0x40000000UL + 0x00020000UL) + 0x3C00UL))->OPTCR1)(((READ_REG(((FLASH_TypeDef *) ((0x40000000UL + 0x00020000UL) + 0x3C00UL))->OPTCR1)) & (~((0xFFFFUL << (0U))))) | (Address))(((((((FLASH_TypeDef *) ((0x40000000UL + 0x00020000UL) + 0x3C00UL))->OPTCR1))) & (~((0xFFFFUL << (0U))))) | (Address))(Address << 16)(((READ_REG(((FLASH_TypeDef *) ((0x40000000UL + 0x00020000UL) + 0x3C00UL))->OPTCR1)) & (~((0xFFFFUL << (16U))))) | ((Address << 16)))(((((((FLASH_TypeDef *) ((0x40000000UL + 0x00020000UL) + 0x3C00UL))->OPTCR1))) & (~((0xFFFFUL << (16U))))) | ((Address << 16)))FLASH_OB_BOR_LevelConfigIS_OB_BOR_LEVEL(Level)FLASH->OPTCR((FLASH_TypeDef *) ((0x40000000UL + 0x00020000UL) + 0x3C00UL))->OPTCR(0x3UL << (2U))Level(((FLASH_TypeDef *) ((0x40000000UL + 0x00020000UL) + 0x3C00UL))->OPTCR)(((READ_REG(((FLASH_TypeDef *) ((0x40000000UL + 0x00020000UL) + 0x3C00UL))->OPTCR)) & (~((0x3UL << (2U))))) | (Level))(((((((FLASH_TypeDef *) ((0x40000000UL + 0x00020000UL) + 0x3C00UL))->OPTCR))) & (~((0x3UL << (2U))))) | (Level))FLASH_OB_RDP_LevelConfigIS_OB_RDP_LEVEL(Level)(__IO uint8_t*)OPTCR_BYTE1_ADDRESSFLASH_OB_DisableWRPIS_OB_WRP_SECTOR(WRPSector)FLASH_OB_EnableWRPFLASH_OB_GetUser40265320800xF00000F0UFLASH_OB_UserConfiguseroptionmaskuseroptionvalueIS_OB_WWDG_SOURCE(Wwdg)IS_OB_IWDG_SOURCE(Iwdg)IS_OB_STOP_SOURCE(Stop)IS_OB_STDBY_SOURCE(Stdby)IS_OB_IWDG_STOP_FREEZE(Iwdgstop)IS_OB_IWDG_STDBY_FREEZE(Iwdgstdby)IS_OB_NDBANK(NDBank)IS_OB_NDBOOT(NDBoot)(((READ_REG(((FLASH_TypeDef *) ((0x40000000UL + 0x00020000UL) + 0x3C00UL))->OPTCR)) & (~(useroptionmask))) | (useroptionvalue))(((((((FLASH_TypeDef *) ((0x40000000UL + 0x00020000UL) + 0x3C00UL))->OPTCR))) & (~(useroptionmask))) | (useroptionvalue))214748388832212257123489661168(FLASH_OPTCR_WWDG_SW | FLASH_OPTCR_IWDG_SW | FLASH_OPTCR_nRST_STOP | \
                      FLASH_OPTCR_nRST_STDBY | FLASH_OPTCR_IWDG_STOP | FLASH_OPTCR_IWDG_STDBY | \
                      FLASH_OPTCR_nDBOOT | FLASH_OPTCR_nDBANK)BootOptionWwdgIwdgStopStdbyIwdgstopIwdgstdbyNDBankNDBootFLASH_OB_GetWRP2683699200x0FFF0000tmp_psizeIS_FLASH_SECTOR(Sector)IS_VOLTAGERANGE(VoltageRange)(0x1FUL << (3U))FLASH_MassEraseIS_FLASH_BANK(Banks)IS_OPTIONBYTE(pOBInit->OptionType)IS_WRPSTATE(pOBInit->WRPState)IS_FLASH_TYPEERASE(pEraseInit->TypeErase)IS_FLASH_NBSECTORS(pEraseInit->NbSectors + pEraseInit->Sector)(FLASH_CR_SER | FLASH_CR_SNB)((0x1UL << (1U)) | (0x1FUL << (3U)))250429496704550000U0xFFFFFF07U/* Return the FLASH write protection Register value *//**
  * @brief  Return the FLASH PCROP_RDP option byte value.
  * @retval uint32_t FLASH PCROP_RDP option byte value
  *//**
  * @brief  Return the FLASH PCROP Protection Option Bytes value.
  * @retval uint32_t FLASH PCROP Protection Option Bytes value
  *//**
  * @brief  Set the PCROP_RDP value
  * @param  Pcrop_Rdp specifies the PCROP_RDP bit value.
  *    
  * @retval HAL Status
  *//**
  * @brief  Set the PCROP protection for sectors.
  * @param  PCROPSector specifies the sector(s) to be PCROP protected.
  *         This parameter can be one of the following values:
  *            @arg OB_PCROP_SECTOR_x: A value between OB_PCROP_SECTOR_0 and OB_PCROP_SECTOR_7
  *            @arg OB_PCROP_SECTOR_ALL
  *    
  * @retval HAL Status
  *//* Return the Boot base Address *//**
  * @brief  Configure Boot base address.
  * 
  * @param   BootOption  specifies Boot base address depending from Boot pin = 0 or pin = 1
  *          This parameter can be one of the following values:
  *            @arg OPTIONBYTE_BOOTADDR_0 : Boot address based when Boot pin = 0                 
  *            @arg OPTIONBYTE_BOOTADDR_1 : Boot address based when Boot pin = 1       
  *    
  * @retval uint32_t Boot Base Address:
  *            - OB_BOOTADDR_ITCM_RAM : Boot from ITCM RAM (0x00000000)                 
  *            - OB_BOOTADDR_SYSTEM : Boot from System memory bootloader (0x00100000) 
  *            - OB_BOOTADDR_ITCM_FLASH : Boot from Flash on ITCM interface (0x00200000)  
  *            - OB_BOOTADDR_AXIM_FLASH : Boot from Flash on AXIM interface (0x08000000)  
  *            - OB_BOOTADDR_DTCM_RAM : Boot from DTCM RAM (0x20000000)                 
  *            - OB_BOOTADDR_SRAM1 : Boot from SRAM1 (0x20010000)                    
  *            - OB_BOOTADDR_SRAM2 : Boot from SRAM2 (0x2004C000) 
  *//* Return the FLASH BOR level *//**
  * @brief  Returns the FLASH BOR level.
  * @retval uint32_t The FLASH BOR level:
  *           - OB_BOR_LEVEL3: Supply voltage ranges from 2.7 to 3.6 V
  *           - OB_BOR_LEVEL2: Supply voltage ranges from 2.4 to 2.7 V
  *           - OB_BOR_LEVEL1: Supply voltage ranges from 2.1 to 2.4 V
  *           - OB_BOR_OFF   : Supply voltage ranges from 1.62 to 2.1 V  
  *//**
  * @brief  Returns the FLASH Read Protection level.
  * @retval FlagStatus FLASH ReadOut Protection Status:
  *         This parameter can be one of the following values:
  *            @arg OB_RDP_LEVEL_0: No protection
  *            @arg OB_RDP_LEVEL_1: Read protection of the memory
  *            @arg OB_RDP_LEVEL_2: Full chip protection
  *//**
  * @brief  Configure Boot base address.
  * 
  * @param   BootOption  specifies Boot base address depending from Boot pin = 0 or pin = 1
  *          This parameter can be one of the following values:
  *            @arg OPTIONBYTE_BOOTADDR_0 : Boot address based when Boot pin = 0                 
  *            @arg OPTIONBYTE_BOOTADDR_1 : Boot address based when Boot pin = 1  
  * @param   Address specifies Boot base address
  *          This parameter can be one of the following values:
  *            @arg OB_BOOTADDR_ITCM_RAM : Boot from ITCM RAM (0x00000000)                 
  *            @arg OB_BOOTADDR_SYSTEM : Boot from System memory bootloader (0x00100000) 
  *            @arg OB_BOOTADDR_ITCM_FLASH : Boot from Flash on ITCM interface (0x00200000)  
  *            @arg OB_BOOTADDR_AXIM_FLASH : Boot from Flash on AXIM interface (0x08000000)  
  *            @arg OB_BOOTADDR_DTCM_RAM : Boot from DTCM RAM (0x20000000)                 
  *            @arg OB_BOOTADDR_SRAM1 : Boot from SRAM1 (0x20010000)                    
  *            @arg OB_BOOTADDR_SRAM2 : Boot from SRAM2 (0x2004C000)              
  *    
  * @retval HAL Status
  *//* Set the BOR Level *//**
  * @brief  Set the BOR Level. 
  * @param  Level specifies the Option Bytes BOR Reset Level.
  *          This parameter can be one of the following values:
  *            @arg OB_BOR_LEVEL3: Supply voltage ranges from 2.7 to 3.6 V
  *            @arg OB_BOR_LEVEL2: Supply voltage ranges from 2.4 to 2.7 V
  *            @arg OB_BOR_LEVEL1: Supply voltage ranges from 2.1 to 2.4 V
  *            @arg OB_BOR_OFF: Supply voltage ranges from 1.62 to 2.1 V
  * @retval HAL Status
  *//**
  * @brief  Set the read protection level.
  * @param  Level specifies the read protection level.
  *          This parameter can be one of the following values:
  *            @arg OB_RDP_LEVEL_0: No protection
  *            @arg OB_RDP_LEVEL_1: Read protection of the memory
  *            @arg OB_RDP_LEVEL_2: Full chip protection
  *   
  * @note WARNING: When enabling OB_RDP level 2 it's no more possible to go back to level 1 or 0
  *    
  * @retval HAL Status
  *//* Write protection disabled on sectors *//**
  * @brief  Disable the write protection of the desired bank1 or bank 2 sectors
  *
  * @note   When the memory read protection level is selected (RDP level = 1), 
  *         it is not possible to program or erase the flash sector i if CortexM4  
  *         debug features are connected or boot code is executed in RAM, even if nWRPi = 1  
  * 
  * @param  WRPSector specifies the sector(s) to be write protected.
  *          This parameter can be one of the following values:
  *            @arg WRPSector: A value between OB_WRP_SECTOR_0 and OB_WRP_SECTOR_7 (for STM32F74xxx/STM32F75xxx devices)
  *              or a value between OB_WRP_SECTOR_0 and OB_WRP_SECTOR_11 (in Single Bank mode for STM32F76xxx/STM32F77xxx devices)
  *              or a value between OB_WRP_DB_SECTOR_0 and OB_WRP_DB_SECTOR_23 (in Dual Bank mode for STM32F76xxx/STM32F77xxx devices)                      
  *            @arg OB_WRP_Sector_All
  *
  *
  * @retval HAL Status   
  *//*Write protection enabled on sectors *//**
  * @brief  Enable the write protection of the desired bank1 or bank2 sectors
  *
  * @note   When the memory read protection level is selected (RDP level = 1), 
  *         it is not possible to program or erase the flash sector i if CortexM7  
  *         debug features are connected or boot code is executed in RAM, even if nWRPi = 1    
  * 
  * @param  WRPSector specifies the sector(s) to be write protected.
  *          This parameter can be one of the following values:
  *            @arg WRPSector: A value between OB_WRP_SECTOR_0 and OB_WRP_SECTOR_7 (for STM32F74xxx/STM32F75xxx devices)
  *              or a value between OB_WRP_SECTOR_0 and OB_WRP_SECTOR_11 (in Single Bank mode for STM32F76xxx/STM32F77xxx devices)
  *              or a value between OB_WRP_DB_SECTOR_0 and OB_WRP_DB_SECTOR_23 (in Dual Bank mode for STM32F76xxx/STM32F77xxx devices)
  *            @arg OB_WRP_SECTOR_All
  *
  * @retval HAL FLASH State   
  *//* Return the User Option Byte *//**
  * @brief  Return the FLASH User Option Byte value.
  * @retval uint32_t FLASH User Option Bytes values: WWDG_SW(Bit4), IWDG_SW(Bit5), nRST_STOP(Bit6), 
  *         nRST_STDBY(Bit7), IWDG_STDBY(Bit30) and IWDG_STOP(Bit31).
  *//* Update User Option Byte *//**
  * @brief  Program the FLASH User Option Byte: IWDG_SW / RST_STOP / RST_STDBY.    
  * @param  Wwdg Selects the IWDG mode
  *          This parameter can be one of the following values:
  *            @arg OB_WWDG_SW: Software WWDG selected
  *            @arg OB_WWDG_HW: Hardware WWDG selected
  * @param  Iwdg Selects the WWDG mode
  *          This parameter can be one of the following values:
  *            @arg OB_IWDG_SW: Software IWDG selected
  *            @arg OB_IWDG_HW: Hardware IWDG selected
  * @param  Stop Reset event when entering STOP mode.
  *          This parameter  can be one of the following values:
  *            @arg OB_STOP_NO_RST: No reset generated when entering in STOP
  *            @arg OB_STOP_RST: Reset generated when entering in STOP
  * @param  Stdby Reset event when entering Standby mode.
  *          This parameter  can be one of the following values:
  *            @arg OB_STDBY_NO_RST: No reset generated when entering in STANDBY
  *            @arg OB_STDBY_RST: Reset generated when entering in STANDBY
  * @param  Iwdgstop Independent watchdog counter freeze in Stop mode.
  *          This parameter  can be one of the following values:
  *            @arg OB_IWDG_STOP_FREEZE: Freeze IWDG counter in STOP
  *            @arg OB_IWDG_STOP_ACTIVE: IWDG counter active in STOP
  * @param  Iwdgstdby Independent watchdog counter freeze in standby mode.
  *          This parameter  can be one of the following values:
  *            @arg OB_IWDG_STDBY_FREEZE: Freeze IWDG counter in STANDBY
  *            @arg OB_IWDG_STDBY_ACTIVE: IWDG counter active in STANDBY           
  * @retval HAL Status
  *//**
  * @brief  Return the FLASH Write Protection Option Bytes value.
  * @retval uint32_t FLASH Write Protection Option Bytes value
  *//* If the previous operation is completed, proceed to erase the sector *//**
  * @brief  Erase the specified FLASH memory sector
  * @param  Sector FLASH sector to erase
  *         The value of this parameter depend on device used within the same series      
  * @param  VoltageRange The device voltage range which defines the erase parallelism.  
  *          This parameter can be one of the following values:
  *            @arg FLASH_VOLTAGE_RANGE_1: when the device voltage range is 1.8V to 2.1V, 
  *                                  the operation will be done by byte (8-bit) 
  *            @arg FLASH_VOLTAGE_RANGE_2: when the device voltage range is 2.1V to 2.7V,
  *                                  the operation will be done by half word (16-bit)
  *            @arg FLASH_VOLTAGE_RANGE_3: when the device voltage range is 2.7V to 3.6V,
  *                                  the operation will be done by word (32-bit)
  *            @arg FLASH_VOLTAGE_RANGE_4: when the device voltage range is 2.7V to 3.6V + External Vpp, 
  *                                  the operation will be done by double word (64-bit)
  * 
  * @retval None
  *//* if the previous operation is completed, proceed to erase all sectors *//**
  * @brief  Full erase of FLASH memory sectors 
  * @param  VoltageRange The device voltage range which defines the erase parallelism.  
  *          This parameter can be one of the following values:
  *            @arg VOLTAGE_RANGE_1: when the device voltage range is 1.8V to 2.1V, 
  *                                  the operation will be done by byte (8-bit) 
  *            @arg VOLTAGE_RANGE_2: when the device voltage range is 2.1V to 2.7V,
  *                                  the operation will be done by half word (16-bit)
  *            @arg VOLTAGE_RANGE_3: when the device voltage range is 2.7V to 3.6V,
  *                                  the operation will be done by word (32-bit)
  *            @arg VOLTAGE_RANGE_4: when the device voltage range is 2.7V to 3.6V + External Vpp, 
  *                                  the operation will be done by double word (64-bit)
  *
  * @retval HAL Status
  *//**
  * @brief  Return the FLASH User Option Byte value.
  * @retval uint32_t FLASH User Option Bytes values: WWDG_SW(Bit4), IWDG_SW(Bit5), nRST_STOP(Bit6), 
  *         nRST_STDBY(Bit7), nDBOOT(Bit28), nDBANK(Bit29), IWDG_STDBY(Bit30) and IWDG_STOP(Bit31).
  *//**
  * @brief  Program the FLASH User Option Byte: IWDG_SW / RST_STOP / RST_STDBY.    
  * @param  Wwdg Selects the IWDG mode
  *          This parameter can be one of the following values:
  *            @arg OB_WWDG_SW: Software WWDG selected
  *            @arg OB_WWDG_HW: Hardware WWDG selected
  * @param  Iwdg Selects the WWDG mode
  *          This parameter can be one of the following values:
  *            @arg OB_IWDG_SW: Software IWDG selected
  *            @arg OB_IWDG_HW: Hardware IWDG selected
  * @param  Stop Reset event when entering STOP mode.
  *          This parameter  can be one of the following values:
  *            @arg OB_STOP_NO_RST: No reset generated when entering in STOP
  *            @arg OB_STOP_RST: Reset generated when entering in STOP
  * @param  Stdby Reset event when entering Standby mode.
  *          This parameter  can be one of the following values:
  *            @arg OB_STDBY_NO_RST: No reset generated when entering in STANDBY
  *            @arg OB_STDBY_RST: Reset generated when entering in STANDBY
  * @param  Iwdgstop Independent watchdog counter freeze in Stop mode.
  *          This parameter  can be one of the following values:
  *            @arg OB_IWDG_STOP_FREEZE: Freeze IWDG counter in STOP
  *            @arg OB_IWDG_STOP_ACTIVE: IWDG counter active in STOP
  * @param  Iwdgstdby Independent watchdog counter freeze in standby mode.
  *          This parameter  can be one of the following values:
  *            @arg OB_IWDG_STDBY_FREEZE: Freeze IWDG counter in STANDBY
  *            @arg OB_IWDG_STDBY_ACTIVE: IWDG counter active in STANDBY
  * @param  NDBank Flash Single Bank mode enabled.
  *          This parameter  can be one of the following values:
  *            @arg OB_NDBANK_SINGLE_BANK: enable 256 bits mode (Flash is a single bank)
  *            @arg OB_NDBANK_DUAL_BANK: disable 256 bits mode (Flash is a dual bank in 128 bits mode)  
  * @param  NDBoot Flash Dual boot mode disable.
  *          This parameter  can be one of the following values:
  *            @arg OB_DUAL_BOOT_DISABLE: Disable Dual Boot
  *            @arg OB_DUAL_BOOT_ENABLE: Enable Dual Boot

  * @retval HAL Status
  *//* Need to add offset of 4 when sector higher than FLASH_SECTOR_11 *//*Only bank1 will be erased*//*Only bank2 will be erased*//* bank1 & bank2 will be erased*//**
  * @brief  Full erase of FLASH memory sectors 
  * @param  VoltageRange The device voltage range which defines the erase parallelism.  
  *          This parameter can be one of the following values:
  *            @arg VOLTAGE_RANGE_1: when the device voltage range is 1.8V to 2.1V, 
  *                                  the operation will be done by byte (8-bit) 
  *            @arg VOLTAGE_RANGE_2: when the device voltage range is 2.1V to 2.7V,
  *                                  the operation will be done by half word (16-bit)
  *            @arg VOLTAGE_RANGE_3: when the device voltage range is 2.7V to 3.6V,
  *                                  the operation will be done by word (32-bit)
  *            @arg VOLTAGE_RANGE_4: when the device voltage range is 2.7V to 3.6V + External Vpp, 
  *                                  the operation will be done by double word (64-bit)
  * @param  Banks Banks to be erased
  *          This parameter can be one of the following values:
  *            @arg FLASH_BANK_1: Bank1 to be erased
  *            @arg FLASH_BANK_2: Bank2 to be erased
  *            @arg FLASH_BANK_BOTH: Bank1 and Bank2 to be erased
  *
  * @retval HAL Status
  *//*Get PCROP_RDP Value *//*Get PCROP Sectors *//*Get Boot Address when Boot pin = 1 *//*Get Boot Address when Boot pin = 0 *//*Get BOR Level*//*Get USER*//*Get RDP Level*//*Get WRP*//**
  * @brief  Get the Option byte configuration
  * @param  pOBInit pointer to an FLASH_OBInitStruct structure that
  *         contains the configuration information for the programming.
  * 
  * @retval None
  *//* PCROP_RDP configuration *//* PCROP configuration *//* Boot 1 Address configuration *//* Boot 0 Address configuration *//* BOR Level  configuration *//* USER  configuration *//* Read protection configuration *//*Disable of Write protection on the selected Sector*//*Enable of Write protection on the selected Sector*//* Write protection configuration *//**
  * @brief  Program option bytes
  * @param  pOBInit pointer to an FLASH_OBInitStruct structure that
  *         contains the configuration information for the programming.
  * 
  * @retval HAL Status
  *//*Erase 1st sector and wait for IT*//* Erase by sector to be done*//*Mass erase to be done*//**
  * @brief  Perform a mass erase or erase the specified FLASH memory sectors  with interrupt enabled
  * @param  pEraseInit pointer to an FLASH_EraseInitTypeDef structure that
  *         contains the configuration information for the erasing.
  * 
  * @retval HAL Status
  *//* In case of error, stop erase procedure and return the faulty sector*//* If the erase operation is completed, disable the SER Bit and SNB Bits *//* Erase by sector by sector to be done*//*Initialization of SectorError variable*//**
  * @brief  Perform a mass erase or erase the specified FLASH memory sectors 
  * @param[in]  pEraseInit pointer to an FLASH_EraseInitTypeDef structure that
  *         contains the configuration information for the erasing.
  * 
  * @param[out]  SectorError pointer to variable  that
  *         contains the configuration information on faulty sector in case of error 
  *         (0xFFFFFFFF means that all the sectors have been correctly erased)
  * 
  * @retval HAL Status
  *//** @defgroup FLASHEx_Exported_Functions_Group1 Extended IO operation functions
 *  @brief   Extended IO operation functions 
 *
@verbatim   
 ===============================================================================
                ##### Extended programming operation functions #####
 ===============================================================================  
    [..]
    This subsection provides a set of functions allowing to manage the Extension FLASH 
    programming operations Operations.

@endverbatim
  * @{
  *//** @defgroup FLASHEx_Exported_Functions FLASHEx Exported Functions
  * @{
  *//** @addtogroup FLASHEx_Private_Functions
  * @{
  *//** @addtogroup FLASHEx_Private_Variables
  * @{
  *//** @addtogroup FLASHEx_Private_Constants
  * @{
  *//** @defgroup FLASHEx FLASHEx
  * @brief FLASH HAL Extension module driver
  * @{
  *//**
  ******************************************************************************
  * @file    stm32f7xx_hal_flash_ex.c
  * @author  MCD Application Team
  * @brief   Extended FLASH HAL module driver.
  *          This file provides firmware functions to manage the following 
  *          functionalities of the FLASH extension peripheral:
  *           + Extended programming operations functions
  *  
  @verbatim
  ==============================================================================
                   ##### Flash Extension features #####
  ==============================================================================
           
  [..] Comparing to other previous devices, the FLASH interface for STM32F76xx/STM32F77xx 
       devices contains the following additional features 
       
       (+) Capacity up to 2 Mbyte with dual bank architecture supporting read-while-write
           capability (RWW)
       (+) Dual bank memory organization       
       (+) Dual boot mode
   
                      ##### How to use this driver #####
  ==============================================================================
  [..] This driver provides functions to configure and program the FLASH memory 
       of all STM32F7xx devices. It includes
      (#) FLASH Memory Erase functions: 
           (++) Lock and Unlock the FLASH interface using HAL_FLASH_Unlock() and 
                HAL_FLASH_Lock() functions
           (++) Erase function: Erase sector, erase all sectors
           (++) There are two modes of erase :
             (+++) Polling Mode using HAL_FLASHEx_Erase()
             (+++) Interrupt Mode using HAL_FLASHEx_Erase_IT()
             
      (#) Option Bytes Programming functions: Use HAL_FLASHEx_OBProgram() to :
           (++) Set/Reset the write protection
           (++) Set the Read protection Level
           (++) Set the BOR level
           (++) Program the user Option Bytes
  
  @endverbatim
  ******************************************************************************
  * @attention
  *
  * Copyright (c) 2017 STMicroelectronics.
  * All rights reserved.
  *
  * This software is licensed under terms that can be found in the LICENSE file in
  * the root directory of this software component.
  * If no LICENSE file comes with this software, it is provided AS-IS.
  ******************************************************************************
  *//Users/jie/Documents/posixGen_Demos-main/LwIP_StreamingServer/Drivers/STM32F7xx_HAL_Driver/Src/stm32f7xx_hal_gpio.cIS_GPIO_PIN(GPIO_Pin)odrGPIO_NUMBERIS_GPIO_PIN_ACTION(PinState)bitstatus(uint32_t)GPIO_PIN_RESETpositioniopositioniocurrentIS_GPIO_ALL_INSTANCE(GPIOx)(uint32_t)0x01(uint32_t)0x0F((uint32_t)0x0F)0xF(uint32_t)0xF(uint32_t)0x07IS_GPIO_PIN(GPIO_Init->Pin)IS_GPIO_MODE(GPIO_Init->Mode)IS_GPIO_SPEED(GPIO_Init->Speed)IS_GPIO_PULL(GPIO_Init->Pull)IS_GPIO_AF(GPIO_Init->Alternate)0x00u/* NOTE: This function Should not be modified, when the callback is needed,
           the HAL_GPIO_EXTI_Callback could be implemented in the user file
   *//**
  * @brief  EXTI line detection callbacks.
  * @param  GPIO_Pin Specifies the pins connected EXTI line
  * @retval None
  *//* EXTI line interrupt detected *//**
  * @brief  This function handles EXTI interrupt request.
  * @param  GPIO_Pin Specifies the pins connected EXTI line
  * @retval None
  *//* Read again in order to confirm lock is active *//* Read LCKR register. This read is mandatory to complete key lock sequence *//* Set LCKx bit(s): LCKK='1' + LCK[15-0] *//* Reset LCKx bit(s): LCKK='0' + LCK[15-0] *//* Apply lock key write sequence *//**
  * @brief  Locks GPIO Pins configuration registers.
  * @note   The locked registers are GPIOx_MODER, GPIOx_OTYPER, GPIOx_OSPEEDR,
  *         GPIOx_PUPDR, GPIOx_AFRL and GPIOx_AFRH.
  * @note   The configuration of the locked GPIO pins can no longer be modified
  *         until the next reset.
  * @param  GPIOx where x can be (A..F) to select the GPIO peripheral for STM32F7 family
  * @param  GPIO_Pin specifies the port bit to be locked.
  *         This parameter can be any combination of GPIO_PIN_x where x can be (0..15).
  * @retval None
  *//* Set selected pins that were at low level, and reset ones that were high *//* get current Output Data Register value *//**
  * @brief  Toggles the specified GPIO pins.
  * @param  GPIOx Where x can be (A..I) to select the GPIO peripheral.
  * @param  GPIO_Pin Specifies the pins to be toggled.
  *         This parameter can be any combination of GPIO_PIN_x where x can be (0..15).
  * @retval None
  *//**
  * @brief  Sets or clears the selected data port bit.
  *
  * @note   This function uses GPIOx_BSRR register to allow atomic read/modify
  *         accesses. In this way, there is no risk of an IRQ occurring between
  *         the read and the modify access.
  *
  * @param  GPIOx where x can be (A..K) to select the GPIO peripheral.
  * @param  GPIO_Pin specifies the port bit to be written.
  *         This parameter can be any combination of GPIO_PIN_x where x can be (0..15).
  * @param  PinState specifies the value to be written to the selected bit.
  *          This parameter can be one of the GPIO_PinState enum values:
  *            @arg GPIO_PIN_RESET: to clear the port pin
  *            @arg GPIO_PIN_SET: to set the port pin
  * @retval None
  *//**
  * @brief  Reads the specified input port pin.
  * @param  GPIOx where x can be (A..K) to select the GPIO peripheral.
  * @param  GPIO_Pin specifies the port bit to read.
  *         This parameter can be any combination of GPIO_PIN_x where x can be (0..15).
  * @retval The input port pin value.
  *//** @defgroup GPIO_Exported_Functions_Group2 IO operation functions
 *  @brief   GPIO Read and Write
 *
@verbatim
 ===============================================================================
                       ##### IO operation functions #####
 ===============================================================================

@endverbatim
  * @{
  *//* Configure the default value for IO Speed *//* Configure the default value IO Output Type *//* Deactivate the Pull-up and Pull-down resistor for the current IO *//* Configure the default Alternate Function in current IO *//* Configure IO Direction in Input Floating Mode *//*------------------------- GPIO Mode Configuration --------------------*//* Configure the External Interrupt or event for the current IO *//* Clear Rising Falling edge configuration *//* Clear EXTI line configuration *//*------------------------- EXTI Mode Configuration --------------------*//* Get the current IO position *//* Get the IO position *//* Configure the port pins *//**
  * @brief  De-initializes the GPIOx peripheral registers to their default reset values.
  * @param  GPIOx where x can be (A..K) to select the GPIO peripheral.
  * @param  GPIO_Pin specifies the port bit to be written.
  *          This parameter can be one of GPIO_PIN_x where x can be (0..15).
  * @retval None
  *//* Enable SYSCFG Clock *//*--------------------- EXTI Mode Configuration ------------------------*//* Configure IO Direction mode (Input, Output, Alternate or Analog) *//* Configure Alternate function mapped with the current IO *//* Check the Alternate function parameter *//* In case of Alternate function mode selection *//* Activate the Pull-up or Pull down resistor for the current IO *//* Check the Pull parameter *//* Configure the IO Output Type *//* Configure the IO Speed *//* Check the Speed parameter *//* In case of Output or Alternate function mode selection *//*--------------------- GPIO Mode Configuration ------------------------*//**
  * @brief  Initializes the GPIOx peripheral according to the specified parameters in the GPIO_Init.
  * @param  GPIOx where x can be (A..K) to select the GPIO peripheral.
  * @param  GPIO_Init pointer to a GPIO_InitTypeDef structure that contains
  *         the configuration information for the specified GPIO peripheral.
  * @retval None
  *//** @defgroup GPIO_Exported_Functions_Group1 Initialization and de-initialization functions
 *  @brief    Initialization and Configuration functions
 *
@verbatim
 ===============================================================================
              ##### Initialization and de-initialization functions #####
 ===============================================================================
  [..]
    This section provides functions allowing to initialize and de-initialize the GPIOs
    to be ready for use.

@endverbatim
  * @{
  *//** @defgroup GPIO_Exported_Functions GPIO Exported Functions
  * @{
  *//** @addtogroup GPIO_Private_Constants GPIO Private Constants
  * @{
  *//** @defgroup GPIO GPIO
  * @brief GPIO HAL module driver
  * @{
  *//**
  ******************************************************************************
  * @file    stm32f7xx_hal_gpio.c
  * @author  MCD Application Team
  * @brief   GPIO HAL module driver.
  *          This file provides firmware functions to manage the following
  *          functionalities of the General Purpose Input/Output (GPIO) peripheral:
  *           + Initialization and de-initialization functions
  *           + IO operation functions
  *
  ******************************************************************************
  * @attention
  *
  * Copyright (c) 2017 STMicroelectronics.
  * All rights reserved.
  *
  * This software is licensed under terms that can be found in the LICENSE file
  * in the root directory of this software component.
  * If no LICENSE file comes with this software, it is provided AS-IS.
  *
  ******************************************************************************
  @verbatim
  ==============================================================================
                    ##### GPIO Peripheral features #####
  ==============================================================================
  [..]
  Subject to the specific hardware characteristics of each I/O port listed in the datasheet, each
  port bit of the General Purpose IO (GPIO) Ports, can be individually configured by software
  in several modes:
  (+) Input mode
  (+) Analog mode
  (+) Output mode
  (+) Alternate function mode
  (+) External interrupt/event lines

  [..]
  During and just after reset, the alternate functions and external interrupt
  lines are not active and the I/O ports are configured in input floating mode.

  [..]
  All GPIO pins have weak internal pull-up and pull-down resistors, which can be
  activated or not.

  [..]
  In Output or Alternate mode, each IO can be configured on open-drain or push-pull
  type and the IO speed can be selected depending on the VDD value.

  [..]
  All ports have external interrupt/event capability. To use external interrupt
  lines, the port must be configured in input mode. All available GPIO pins are
  connected to the 16 external interrupt/event lines from EXTI0 to EXTI15.

  [..]
  The external interrupt/event controller consists of up to 23 edge detectors
  (16 lines are connected to GPIO) for generating event/interrupt requests (each
  input line can be independently configured to select the type (interrupt or event)
  and the corresponding trigger event (rising or falling or both). Each line can
  also be masked independently.

                     ##### How to use this driver #####
  ==============================================================================
  [..]
    (#) Enable the GPIO AHB clock using the following function: __HAL_RCC_GPIOx_CLK_ENABLE().

    (#) Configure the GPIO pin(s) using HAL_GPIO_Init().
        (++) Configure the IO mode using "Mode" member from GPIO_InitTypeDef structure
        (++) Activate Pull-up, Pull-down resistor using "Pull" member from GPIO_InitTypeDef
             structure.
        (++) In case of Output or alternate function mode selection: the speed is
             configured through "Speed" member from GPIO_InitTypeDef structure.
        (++) In alternate mode is selection, the alternate function connected to the IO
             is configured through "Alternate" member from GPIO_InitTypeDef structure.
        (++) Analog mode is required when a pin is to be used as ADC channel
             or DAC output.
        (++) In case of external interrupt/event selection the "Mode" member from
             GPIO_InitTypeDef structure select the type (interrupt or event) and
             the corresponding trigger event (rising or falling or both).

    (#) In case of external interrupt/event mode selection, configure NVIC IRQ priority
        mapped to the EXTI line using HAL_NVIC_SetPriority() and enable it using
        HAL_NVIC_EnableIRQ().

    (#) To get the level of a pin configured in input mode use HAL_GPIO_ReadPin().

    (#) To set/reset the level of a pin configured in output mode use
        HAL_GPIO_WritePin()/HAL_GPIO_TogglePin().

    (#) To lock pin configuration until next reset use HAL_GPIO_LockPin().


    (#) During and just after reset, the alternate functions are not
        active and the GPIO pins are configured in input floating mode (except JTAG
        pins).

    (#) The LSE oscillator pins OSC32_IN and OSC32_OUT can be used as general purpose
        (PC14 and PC15, respectively) when the LSE oscillator is off. The LSE has
        priority over the GPIO function.

    (#) The HSE oscillator pins OSC_IN/OSC_OUT can be used as
        general purpose PH0 and PH1, respectively, when the HSE oscillator is off.
        The HSE has priority over the GPIO function.

  @endverbatim
  ******************************************************************************
  *//Users/jie/Documents/posixGen_Demos-main/LwIP_StreamingServer/Drivers/STM32F7xx_HAL_Driver/Src/stm32f7xx_hal_i2c.cI2C_ConvertOtherXferOptions43520I2C_Disable_IRQI2C_XFER_TX_IT(uint32_t)HAL_I2C_STATE_LISTENI2C_XFER_RX_ITI2C_XFER_LISTEN_ITI2C_XFER_ERROR_ITI2C_XFER_CPLT_ITI2C_XFER_RELOAD_ITI2C_Enable_IRQ244InterruptRequest(I2C_IT_STOPI | I2C_IT_TCI)I2C_TransferConfigIS_I2C_ALL_INSTANCE(hi2c->Instance)IS_TRANSFER_MODE(Mode)IS_TRANSFER_REQUEST(Request)~0x80000000U(~0x80000000U)hi2c->Instance->CR2((I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | (I2C_CR2_RD_WRN & (uint32_t)(Request >> (31U - I2C_CR2_RD_WRN_Pos))) | I2C_CR2_START | I2C_CR2_STOP))(((0x3FFUL << (0U)) | (0xFFUL << (16U)) | (0x1UL << (24U)) | (0x1UL << (25U)) | ((0x1UL << (10U)) & (uint32_t)(Request >> (31U - (10U)))) | (0x1UL << (13U)) | (0x1UL << (14U))))(hi2c->Instance->CR2)(((READ_REG(hi2c->Instance->CR2)) & (~((((0x3FFUL << (0U)) | (0xFFUL << (16U)) | (0x1UL << (24U)) | (0x1UL << (25U)) | ((0x1UL << (10U)) & (uint32_t)(Request >> (31U - (10U)))) | (0x1UL << (13U)) | (0x1UL << (14U))))))) | (tmp))(((((hi2c->Instance->CR2))) & (~((((0x3FFUL << (0U)) | (0xFFUL << (16U)) | (0x1UL << (24U)) | (0x1UL << (25U)) | ((0x1UL << (10U)) & (uint32_t)(Request >> (31U - (10U)))) | (0x1UL << (13U)) | (0x1UL << (14U))))))) | (tmp))1671270333489919I2C_IsErrorOccurreditflag(0x1UL << (15U))RequestI2C_TIMEOUT_STOPF51191671679933494015334950394261472256I2C_WaitOnRXNEFlagUntilTimeoutI2C_WaitOnSTOPFlagUntilTimeoutI2C_WaitOnTXISFlagUntilTimeoutI2C_WaitOnFlagUntilTimeoutI2C_DMAAbortI2C_DMAErrortreatdmaerrorhi2c->hdmatxhi2c->hdmarxI2C_DMASlaveReceiveCplttmpoptionsI2C_NO_OPTION_FRAME~I2C_CR1_RXDMAENI2C_DMAMasterReceiveCpltMAX_NBYTE_SIZEI2C_DMASlaveTransmitCplt~I2C_CR1_TXDMAENI2C_DMAMasterTransmitCpltI2C_Flush_TXDRI2C_TreatErrorCallbackI2C_STATE_NONEI2C_ITErrortmpstatetmppreviousstate3277032771I2C_STATE_MASTER_BUSY_TXI2C_STATE_SLAVE_BUSY_TXI2C_STATE_MASTER_BUSY_RXI2C_STATE_SLAVE_BUSY_RXI2C_ITListenCpltITFlags131071I2C_ITSlaveCplthi2c->Instance->CR1tmpcr1valuetmpITFlags32769~I2C_FLAG_RXNEI2C_ITMasterCplttmperrorI2C_ITSlaveSeqCpltI2C_ITMasterSeqCpltI2C_ITAddrCplttransferdirectionslaveaddrcodeownadd1codeownadd2code16646144254SLAVE_ADDR_MSKSLAVE_ADDR_SHIFTI2C_RequestMemoryRead2147491840I2C_RequestMemoryWriteI2C_Slave_ISR_DMAtreatdmanackITSourcesI2C_Mem_ISR_DMAdirection2147492864I2C_Master_ISR_DMAdevaddressxfermodeI2C_Slave_ISR_ITI2C_Mem_ISR_ITI2C_Master_ISR_IThi2c->Instance->ISRitflagsitsources(HAL_I2C_ERROR_BERR | HAL_I2C_ERROR_OVR | HAL_I2C_ERROR_ARLO)tmp_mode2147500032I2C_STATE_MSKdmaxferstatusIS_I2C_TRANSFER_OPTIONS_REQUEST(XferOptions)~I2C_CR2_NACKxferrequestsizetoxferI2C_Trials 0ULhi2c->Init.AddressingModeIS_I2C_MEMADD_SIZE(MemAddSize)I2C_TIMEOUT_BUSYtmpXferCounterror(hi2c)->Instance->CR1IS_I2C_OWN_ADDRESS1(hi2c->Init.OwnAddress1)IS_I2C_ADDRESSING_MODE(hi2c->Init.AddressingMode)IS_I2C_DUAL_ADDRESS(hi2c->Init.DualAddressMode)IS_I2C_OWN_ADDRESS2(hi2c->Init.OwnAddress2)IS_I2C_OWN_ADDRESS2_MASK(hi2c->Init.OwnAddress2Masks)IS_I2C_GENERAL_CALL(hi2c->Init.GeneralCallMode)IS_I2C_NO_STRETCH(hi2c->Init.NoStretchMode)TIMING_CLEAR_MASK~I2C_OAR1_OA1EN3379233587200(I2C_CR2_AUTOEND | I2C_CR2_NACK)~I2C_DUALADDRESS_ENABLEI2C_GET_DMA_REMAIN_DATA(__HANDLE__)(0xFFFF0000U)(uint16_t)(0x0040U)(uint16_t)(0x0020U)(uint16_t)(0x0010U)(uint16_t)(0x8000U)(uint16_t)(0x0002U)(uint16_t)(0x0001U)I2C_STATE_MEM_BUSY_RX((uint32_t)(((uint32_t)HAL_I2C_STATE_BUSY_RX & I2C_STATE_MSK) | (uint32_t)HAL_I2C_MODE_MEM))I2C_STATE_MEM_BUSY_TX((uint32_t)(((uint32_t)HAL_I2C_STATE_BUSY_TX & I2C_STATE_MSK) | (uint32_t)HAL_I2C_MODE_MEM))((uint32_t)(((uint32_t)HAL_I2C_STATE_BUSY_RX & I2C_STATE_MSK) | (uint32_t)HAL_I2C_MODE_SLAVE))((uint32_t)(((uint32_t)HAL_I2C_STATE_BUSY_TX & I2C_STATE_MSK) | (uint32_t)HAL_I2C_MODE_SLAVE))((uint32_t)(((uint32_t)HAL_I2C_STATE_BUSY_RX & I2C_STATE_MSK) | (uint32_t)HAL_I2C_MODE_MASTER))((uint32_t)(((uint32_t)HAL_I2C_STATE_BUSY_TX & I2C_STATE_MSK) | (uint32_t)HAL_I2C_MODE_MASTER))((uint32_t)(HAL_I2C_MODE_NONE))((uint32_t)((uint32_t)((uint32_t)HAL_I2C_STATE_BUSY_TX | (uint32_t)HAL_I2C_STATE_BUSY_RX) & (uint32_t)(~((uint32_t)HAL_I2C_STATE_READY))))255UI2C_TIMEOUT_FLAGI2C_TIMEOUT_TXISI2C_TIMEOUT_TCRI2C_TIMEOUT_TCI2C_TIMEOUT_RXNEI2C_TIMEOUT_DIRI2C_TIMEOUT_ADDR(10000U)(0xF0FFFFFFU)/* set XferOptions to I2C_FIRST_AND_LAST_FRAME              *//* then generate a stop condition at the end of transfer    *//* it request implicitly to generate a restart condition    *//* else if user set XferOptions to I2C_OTHER_AND_LAST_FRAME *//* set XferOptions to I2C_FIRST_FRAME                    *//* it request implicitly to generate a restart condition *//* if user set XferOptions to I2C_OTHER_FRAME            *//**
  * @brief  Convert I2Cx OTHER_xxx XferOptions to functional XferOptions.
  * @param  hi2c I2C handle.
  * @retval None
  *//* all disable interrupts request are not done *//* to avoid a breaking situation like at "t" time *//* Disable interrupts only at the end *//* Enable TC interrupts *//* Enable STOP interrupts *//* Enable ERR and NACK interrupts *//* Disable ADDR, NACK and STOP interrupts *//* Disable NACK and STOP interrupts *//* Disable TC and RXI interrupts *//* Disable TC and TXI interrupts *//**
  * @brief  Manage the disabling of Interrupts.
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @param  InterruptRequest Value of @ref I2C_Interrupt_configuration_definition.
  * @retval None
  *//* all interrupts requested done *//* to avoid the risk of I2C interrupt handle execution before *//* Enable interrupts only at the end *//* Enable ERR, TC, STOP, NACK and RXI interrupts *//* Enable ERR, TC, STOP, NACK and TXI interrupts *//* Enable ERR, STOP, NACK and ADDR interrupts *//**
  * @brief  Manage the enabling of Interrupts.
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @param  InterruptRequest Value of @ref I2C_Interrupt_configuration_definition.
  * @retval None
  *//* update CR2 register *//* Declaration of tmp to prevent undefined behavior of volatile usage *//**
  * @brief  Handles I2Cx communication when starting transfer or during transfer (TC or TCR flag are set).
  * @param  hi2c I2C handle.
  * @param  DevAddress Specifies the slave address to be programmed.
  * @param  Size Specifies the number of bytes to be programmed.
  *   This parameter must be a value between 0 and 255.
  * @param  Mode New state of the I2C START condition generation.
  *   This parameter can be one of the following values:
  *     @arg @ref I2C_RELOAD_MODE Enable Reload mode .
  *     @arg @ref I2C_AUTOEND_MODE Enable Automatic end mode.
  *     @arg @ref I2C_SOFTEND_MODE Enable Software end mode.
  * @param  Request New state of the I2C START condition generation.
  *   This parameter can be one of the following values:
  *     @arg @ref I2C_NO_STARTSTOP Don't Generate stop and start condition.
  *     @arg @ref I2C_GENERATE_STOP Generate stop condition (Size should be set to 0).
  *     @arg @ref I2C_GENERATE_START_READ Generate Restart for read request.
  *     @arg @ref I2C_GENERATE_START_WRITE Generate Restart for write request.
  * @retval None
  *//* Clear Configuration Register 2 *//* Flush TX register *//* Clear ARLO flag *//* Check if an Arbitration Loss error occurred *//* Clear OVR flag *//* Check if an Over-Run/Under-Run error occurred *//* Clear BERR flag *//* Check if a Bus error occurred *//* Then verify if an additional errors occurs *//* Refresh Content of Status register *//* Clear STOP Flag *//* In case STOP Flag is detected, clear it *//* Update Tick with new reference *//* Generate Stop *//* In case of I2C still busy, try to regenerate a STOP manually *//* AutoEnd should be initiate after AF *//* Wait until STOP Flag is set or timeout occurred *//* Clear NACKF Flag *//**
  * @brief  This function handles errors detection during an I2C Communication.
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @param  Timeout Timeout duration
  * @param  Tickstart Tick start value
  * @retval HAL status
  *//* Check a no-acknowledge have been detected *//* The Reading of data from RXDR will be done in caller function *//* Return HAL_OK *//* Store Last receive data if any *//* Check if an RXNE is pending *//* Check if a STOPF is detected *//* Check if an error is detected *//**
  * @brief  This function handles I2C Communication Timeout for specific usage of RXNE flag.
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @param  Timeout Timeout duration
  * @param  Tickstart Tick start value
  * @retval HAL status
  *//**
  * @brief  This function handles I2C Communication Timeout for specific usage of STOP flag.
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @param  Timeout Timeout duration
  * @param  Tickstart Tick start value
  * @retval HAL status
  *//**
  * @brief  This function handles I2C Communication Timeout for specific usage of TXIS flag.
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @param  Timeout Timeout duration
  * @param  Tickstart Tick start value
  * @retval HAL status
  *//**
  * @brief  This function handles I2C Communication Timeout. It waits
  *                until a flag is no longer in the specified status.
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @param  Flag Specifies the I2C flag to check.
  * @param  Status The actual Flag status (SET or RESET).
  * @param  Timeout Timeout duration
  * @param  Tickstart Tick start value
  * @retval HAL status
  *//* Reset AbortCpltCallback *//* Derogation MISRAC2012-Rule-11.5 *//**
  * @brief DMA I2C communication abort callback
  *        (To be called at end of DMA Abort procedure).
  * @param hdma DMA handle.
  * @retval None
  *//* Call the corresponding callback to inform upper layer of End of Transfer *//* Disable Acknowledge *//* Check if a FIFO error is detected, if true normal use case, so no specific action to perform *//**
  * @brief  DMA I2C communication error callback.
  * @param hdma DMA handle
  * @retval None
  *//* So STOP condition should be manage through Interrupt treatment *//* Mean that this generation can arrive at any time, at the end or during DMA process *//* No specific action, Master fully manage the generation of STOP condition *//* Call I2C Slave Sequential complete process *//* Disable DMA Request *//**
  * @brief  DMA I2C slave receive process complete callback.
  * @param  hdma DMA handle
  * @retval None
  *//* Enable the DMA stream *//* Errata workaround 170323 *//* Set the XferSize to transfer *//* Update Buffer pointer *//* else prepare a new DMA transfer and enable TCReload interrupt *//* Enable STOP interrupt *//* If last transfer, enable STOP interrupt *//**
  * @brief DMA I2C master receive process complete callback.
  * @param  hdma DMA handle
  * @retval None
  *//* Last Byte is Transmitted *//**
  * @brief  DMA I2C slave transmit process complete callback.
  * @param  hdma DMA handle
  * @retval None
  *//**
  * @brief  DMA I2C master transmit process complete callback.
  * @param  hdma DMA handle
  * @retval None
  *//* Flush TX register if not empty *//* Write a dummy data in TXDR to clear it *//* If a pending TXIS flag is set *//**
  * @brief  I2C Tx data register flush process.
  * @param  hi2c I2C handle.
  * @retval None
  *//**
  * @brief  I2C Error callback treatment.
  * @param  hi2c I2C handle.
  * @retval None
  *//* Call Directly hi2c->hdmarx->XferAbortCallback function in case of error *//* Abort DMA RX *//* Set the I2C DMA Abort callback :
        will lead to call HAL_I2C_ErrorCallback() at end of DMA abort procedure *//* Abort DMA RX transfer if any *//* Call Directly XferAbortCallback function in case of error *//* Abort DMA TX *//* Set the I2C DMA Abort callback :
       will lead to call HAL_I2C_ErrorCallback() at end of DMA abort procedure *//* Abort DMA TX transfer if any *//* Set HAL_I2C_STATE_READY *//* This change will be do later *//* If state is an abort treatment on going, don't change state *//* keep HAL_I2C_STATE_LISTEN if set *//* Disable all interrupts, except interrupts related to LISTEN state *//* Disable Interrupts *//* Set new error code *//* Reset handle parameters *//**
  * @brief  I2C interrupts error process.
  * @param  hi2c I2C handle.
  * @param  ErrorCode Error code to handle.
  * @retval None
  *//* Call the Listen Complete callback, to inform upper layer of the end of Listen usecase *//* Clear NACK Flag *//* Disable all Interrupts*//* Set ErrorCode corresponding to a Non-Acknowledge *//* Increment Buffer pointer *//* Read data from RXDR *//**
  * @brief  I2C Listen complete process.
  * @param  hi2c I2C handle.
  * @param  ITFlags Interrupt flags to handle.
  * @retval None
  *//* Call the Sequential Complete callback, to inform upper layer of the end of Transfer *//* Call I2C Listen complete process *//* if no, error use case, a Non-Acknowledge of last Data is generated by the MASTER*//* Same action must be done for (tmpoptions == I2C_LAST_FRAME) which removed for
           Warning[Pa134]: left and right operands are identical *//* So clear Flag NACKF only *//* Mean XferCount == 0*//* if yes, normal use case, a NACK is sent by the MASTER when Transfer is finished *//* Check that I2C transfer finished *//* All data are not transferred, so set error code accordingly *//* Remove RXNE flag on temporary variable as read done *//* Do nothing *//* If a DMA is ongoing, Update handle size context *//* Disable Address Acknowledge *//* Disable Interrupts and Store Previous state *//**
  * @brief  I2C Slave complete process.
  * @param  hi2c I2C handle.
  * @param  ITFlags Interrupt flags to handle.
  * @retval None
  *//* hi2c->State == HAL_I2C_STATE_BUSY_RX *//* hi2c->State == HAL_I2C_STATE_BUSY_TX *//* Store current volatile hi2c->ErrorCode, misra rule *//* Fetch Last receive data if any *//* Set acknowledge error code *//**
  * @brief  I2C Master complete process.
  * @param  hi2c I2C handle.
  * @param  ITFlags Interrupt flags to handle.
  * @retval None
  *//* Remove HAL_I2C_STATE_SLAVE_BUSY_RX, keep only HAL_I2C_STATE_LISTEN *//* Remove HAL_I2C_STATE_SLAVE_BUSY_TX, keep only HAL_I2C_STATE_LISTEN *//* Reset I2C handle mode *//**
  * @brief  I2C Slave sequential complete process.
  * @param  hi2c I2C handle.
  * @retval None
  *//* The stop will be done at the end of transfer, when I2C_AUTOEND_MODE enable *//* No Generate Stop, to permit restart mode *//**
  * @brief  I2C Master sequential complete process.
  * @param  hi2c I2C handle.
  * @retval None
  *//* Clear ADDR flag *//* Else clear address flag only *//* Call Slave Addr callback *//* Disable ADDR Interrupts *//* else 7 bits addressing mode is selected *//* Reset Address Event counter *//* If 10bits addressing mode is selected *//* In case of Listen state, need to inform upper layer of address match code event *//**
  * @brief  I2C Address complete process callback.
  * @param  hi2c I2C handle.
  * @param  ITFlags Interrupt flags to handle.
  * @retval None
  *//* Wait until TC flag is set *//* Send LSB of Memory Address *//* Wait until TXIS flag is set *//* Send MSB of Memory Address *//* If Memory address size is 16Bit *//* Send Memory Address *//* If Memory address size is 8Bit *//**
  * @brief  Master sends target device address followed by internal memory address for read request.
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @param  DevAddress Target device address: The device 7 bits address value
  *         in datasheet must be shifted to the left before calling the interface
  * @param  MemAddress Internal memory address
  * @param  MemAddSize Size of internal memory address
  * @param  Timeout Timeout duration
  * @param  Tickstart Tick start value
  * @retval HAL status
  *//* Wait until TCR flag is set *//**
  * @brief  Master sends target device address followed by internal memory address for write request.
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @param  DevAddress Target device address: The device 7 bits address value
  *         in datasheet must be shifted to the left before calling the interface
  * @param  MemAddress Internal memory address
  * @param  MemAddSize Size of internal memory address
  * @param  Timeout Timeout duration
  * @param  Tickstart Tick start value
  * @retval HAL status
  *//* Only Clear NACK Flag, no DMA treatment is pending *//* Store current hi2c->State, solve MISRA2012-Rule-13.5 *//* Same action must be done for (tmpoptions == I2C_LAST_FRAME) which removed for
             Warning[Pa134]: left and right operands are identical *//* Split check of hdmatx, for MISRA compliance  *//* Split check of hdmarx, for MISRA compliance *//* Mean XferCount == 0 *//* Call I2C Slave complete process *//* Check if STOPF is set *//**
  * @brief  Interrupt Sub-Routine which handle the Interrupt Flags Slave Mode with DMA.
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @param  ITFlags Interrupt flags to handle.
  * @param  ITSources Interrupt sources enabled.
  * @retval HAL status
  *//* Call I2C Master complete process *//* Enable DMA Request *//* Update XferCount value *//* Set NBYTES to write and generate RESTART *//* Set NBYTES to write and reload if hi2c->XferCount > MAX_NBYTE_SIZE and generate RESTART *//* Enable only Error and NACK interrupt for data transfer *//* Disable Interrupt related to address step *//* Wrong size Status regarding TCR flag event *//* Prepare the new XferSize to transfer *//* Enable only Error interrupt *//* Reset Memaddress content *//* Write LSB part of Memory Address *//* Error callback will be send during stop flag treatment *//* But enable STOP interrupt, to treat it *//* No need to generate STOP, it is automatically done *//* Set corresponding Error Code *//**
  * @brief  Interrupt Sub-Routine which handle the Interrupt Flags Memory Mode with DMA.
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @param  ITFlags Interrupt flags to handle.
  * @param  ITSources Interrupt sources enabled.
  * @retval HAL status
  *//* Wrong size Status regarding TC flag event *//* Call I2C Master Sequential complete process *//* Generate a stop condition in case of no transfer option *//* Call TxCpltCallback() if no stop mode is set *//* Set the new XferSize in Nbytes register *//* Recover Slave address *//* Disable TC interrupt *//**
  * @brief  Interrupt Sub-Routine which handle the Interrupt Flags Master Mode with DMA.
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @param  ITFlags Interrupt flags to handle.
  * @param  ITSources Interrupt sources enabled.
  * @retval HAL status
  *//* Write data to TXDR *//* If it is the case, this last write in TXDR is not sent, correspond to a dummy TXIS event *//* Check if all Data have already been sent *//* A TXIS flag can be set, during STOP treatment      *//* Write data to TXDR only if XferCount not reach "0" *//**
  * @brief  Interrupt Sub-Routine which handle the Interrupt Flags Slave Mode with Interrupt.
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @param  ITFlags Interrupt flags to handle.
  * @param  ITSources Interrupt sources enabled.
  * @retval HAL status
  *//**
  * @brief  Interrupt Sub-Routine which handle the Interrupt Flags Memory Mode with Interrupt.
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @param  ITFlags Interrupt flags to handle.
  * @param  ITSources Interrupt sources enabled.
  * @retval HAL status
  *//**
  * @brief  Interrupt Sub-Routine which handle the Interrupt Flags Master Mode with Interrupt.
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @param  ITFlags Interrupt flags to handle.
  * @param  ITSources Interrupt sources enabled.
  * @retval HAL status
  *//** @addtogroup I2C_Private_Functions
  * @{
  *//**
  * @brief  Return the I2C error code.
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *              the configuration information for the specified I2C.
  * @retval I2C Error Code
  *//**
  * @brief  Returns the I2C Master, Slave, Memory or no mode.
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *         the configuration information for I2C module
  * @retval HAL mode
  *//* Return I2C handle state *//**
  * @brief  Return the I2C handle state.
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @retval HAL state
  *//** @defgroup I2C_Exported_Functions_Group3 Peripheral State, Mode and Error functions
  *  @brief   Peripheral State, Mode and Error functions
  *
@verbatim
 ===============================================================================
            ##### Peripheral State, Mode and Error functions #####
 ===============================================================================
    [..]
    This subsection permit to get in run-time the status of the peripheral
    and the data flow.

@endverbatim
  * @{
  *//* NOTE : This function should not be modified, when the callback is needed,
            the HAL_I2C_AbortCpltCallback could be implemented in the user file
   *//**
  * @brief  I2C abort callback.
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @retval None
  *//* NOTE : This function should not be modified, when the callback is needed,
            the HAL_I2C_ErrorCallback could be implemented in the user file
   *//**
  * @brief  I2C error callback.
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @retval None
  *//* NOTE : This function should not be modified, when the callback is needed,
            the HAL_I2C_MemRxCpltCallback could be implemented in the user file
   *//**
  * @brief  Memory Rx Transfer completed callback.
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @retval None
  *//* NOTE : This function should not be modified, when the callback is needed,
            the HAL_I2C_MemTxCpltCallback could be implemented in the user file
   *//**
  * @brief  Memory Tx Transfer completed callback.
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @retval None
  *//* NOTE : This function should not be modified, when the callback is needed,
            the HAL_I2C_ListenCpltCallback() could be implemented in the user file
   *//**
  * @brief  Listen Complete callback.
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @retval None
  *//* NOTE : This function should not be modified, when the callback is needed,
            the HAL_I2C_AddrCallback() could be implemented in the user file
   *//**
  * @brief  Slave Address Match callback.
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @param  TransferDirection Master request Transfer Direction (Write/Read), value of @ref I2C_XFERDIRECTION
  * @param  AddrMatchCode Address Match Code
  * @retval None
  *//* NOTE : This function should not be modified, when the callback is needed,
            the HAL_I2C_SlaveRxCpltCallback could be implemented in the user file
   *//**
  * @brief  Slave Rx Transfer completed callback.
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @retval None
  *//* NOTE : This function should not be modified, when the callback is needed,
            the HAL_I2C_SlaveTxCpltCallback could be implemented in the user file
   *//** @brief  Slave Tx Transfer completed callback.
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @retval None
  *//* NOTE : This function should not be modified, when the callback is needed,
            the HAL_I2C_MasterRxCpltCallback could be implemented in the user file
   *//**
  * @brief  Master Rx Transfer completed callback.
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @retval None
  *//* NOTE : This function should not be modified, when the callback is needed,
            the HAL_I2C_MasterTxCpltCallback could be implemented in the user file
   *//**
  * @brief  Master Tx Transfer completed callback.
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @retval None
  *//* Call the Error Callback in case of Error detected *//* I2C Arbitration Loss error interrupt occurred -------------------------------------*//* I2C Over-Run/Under-Run interrupt occurred ----------------------------------------*//* I2C Bus error interrupt occurred ------------------------------------*//**
  * @brief  This function handles I2C error interrupt request.
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @retval None
  *//* I2C events treatment -------------------------------------*//* Get current IT Flags and IT sources value *//* Derogation MISRAC2012-Rule-8.13 *//**
  * @brief  This function handles I2C event interrupt request.
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @retval None
  *//** @defgroup I2C_IRQ_Handler_and_Callbacks IRQ Handler and Callbacks
  * @{
  *//* This function should be used only in case of abort monitored by master device *//* Wrong usage of abort function *//* Note : The I2C interrupts must be enabled after unlocking current process
              to avoid the risk of I2C interrupt handle execution before current
              process unlock *//* Set AUTOEND mode, this will generate a NACK then STOP condition to abort the current transfer *//* Set NBYTES to 1 to generate a dummy read on I2C peripheral *//* Set State at HAL_I2C_STATE_ABORT *//**
  * @brief  Abort a master or memory I2C IT or DMA process communication with Interrupt.
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @param  DevAddress Target device address: The device 7 bits address value
  *         in datasheet must be shifted to the left before calling the interface
  * @retval HAL status
  *//* Disable the Address Match interrupt *//* Disable Address listen mode only if a transfer is not ongoing *//**
  * @brief  Disable the Address listen mode with Interrupt.
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C
  * @retval HAL status
  *//* Enable the Address Match interrupt *//**
  * @brief  Enable the Address listen mode with Interrupt.
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @retval HAL status
  *//* REnable ADDR interrupt *//* Note : The I2C interrupts must be enabled after unlocking current process
    to avoid the risk of I2C interrupt handle execution before current
    process unlock *//* This action will generate an acknowledge to the Master *//* Clear ADDR flag after prepare the transfer parameters *//* Update I2C error code *//* Update I2C state *//* Reset XferSize *//* Set the unused DMA callbacks to NULL *//* Set the I2C DMA transfer complete callback *//* Prepare transfer parameters *//* Enable Address Acknowledge *//* Set the I2C DMA Abort callback :
           will lead to call HAL_I2C_ErrorCallback() at end of DMA abort procedure *//* Abort DMA Xfer if any *//* Disable associated Interrupts *//* and then toggle the HAL slave TX state to RX state *//* I2C cannot manage full duplex exchange so disable previous IT enabled if any *//* Disable Interrupts, to prevent preemption during treatment in case of multicall *//**
  * @brief  Sequential receive in slave/device I2C mode an amount of data in non-blocking mode with DMA
  * @note   This interface allow to manage repeated start condition when a direction change during transfer
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @param  pData Pointer to data buffer
  * @param  Size Amount of data to be sent
  * @param  XferOptions Options of Transfer, value of @ref I2C_XFEROPTIONS
  * @retval HAL status
  *//**
  * @brief  Sequential receive in slave/device I2C mode an amount of data in non-blocking mode with Interrupt
  * @note   This interface allow to manage repeated start condition when a direction change during transfer
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @param  pData Pointer to data buffer
  * @param  Size Amount of data to be sent
  * @param  XferOptions Options of Transfer, value of @ref I2C_XFEROPTIONS
  * @retval HAL status
  *//* Enable ERR, STOP, NACK, ADDR interrupts *//* Set the I2C DMA Abort callback :
          will lead to call HAL_I2C_ErrorCallback() at end of DMA abort procedure *//* and then toggle the HAL slave RX state to TX state *//**
  * @brief  Sequential transmit in slave/device I2C mode an amount of data in non-blocking mode with DMA
  * @note   This interface allow to manage repeated start condition when a direction change during transfer
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @param  pData Pointer to data buffer
  * @param  Size Amount of data to be sent
  * @param  XferOptions Options of Transfer, value of @ref I2C_XFEROPTIONS
  * @retval HAL status
  *//**
  * @brief  Sequential transmit in slave/device I2C mode an amount of data in non-blocking mode with Interrupt
  * @note   This interface allow to manage repeated start condition when a direction change during transfer
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @param  pData Pointer to data buffer
  * @param  Size Amount of data to be sent
  * @param  XferOptions Options of Transfer, value of @ref I2C_XFEROPTIONS
  * @retval HAL status
  *//* I2C_IT_ERRI | I2C_IT_TCI | I2C_IT_STOPI | I2C_IT_NACKI |
        I2C_IT_ADDRI | I2C_IT_RXI | I2C_IT_TXI *//* possible to enable all of these *//* Enable ERR, TC, STOP, NACK, RXI interrupt *//* Note : The I2C interrupts must be enabled after unlocking current process
                to avoid the risk of I2C interrupt handle execution before current
                process unlock *//* Set NBYTES to read and generate START condition *//* Send Slave Address *//* Update Transfer ISR function pointer *//* Note : The I2C interrupts must be enabled after unlocking current process
                  to avoid the risk of I2C interrupt handle execution before current
                  process unlock *//* Send Slave Address and set NBYTES to read *//* Update xfermode accordingly if no reload is necessary *//* Convert OTHER_xxx XferOptions if any *//* Mean Previous state is same as current state *//* If transfer direction not change and there is no request to start another frame,
       do not generate Restart Condition *//* If hi2c->XferCount > MAX_NBYTE_SIZE, use reload mode *//**
  * @brief  Sequential receive in master I2C mode an amount of data in non-blocking mode with DMA
  * @note   This interface allow to manage repeated start condition when a direction change during transfer
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @param  DevAddress Target device address: The device 7 bits address value
  *         in datasheet must be shifted to the left before calling the interface
  * @param  pData Pointer to data buffer
  * @param  Size Amount of data to be sent
  * @param  XferOptions Options of Transfer, value of @ref I2C_XFEROPTIONS
  * @retval HAL status
  *//**
  * @brief  Sequential receive in master I2C mode an amount of data in non-blocking mode with Interrupt
  * @note   This interface allow to manage repeated start condition when a direction change during transfer
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @param  DevAddress Target device address: The device 7 bits address value
  *         in datasheet must be shifted to the left before calling the interface
  * @param  pData Pointer to data buffer
  * @param  Size Amount of data to be sent
  * @param  XferOptions Options of Transfer, value of @ref I2C_XFEROPTIONS
  * @retval HAL status
  *//* Enable ERR, TC, STOP, NACK, TXI interrupt *//* Set NBYTES to write and generate START condition *//* Send Slave Address and set NBYTES to write *//* Preload TX register *//**
  * @brief  Sequential transmit in master I2C mode an amount of data in non-blocking mode with DMA.
  * @note   This interface allow to manage repeated start condition when a direction change during transfer
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @param  DevAddress Target device address: The device 7 bits address value
  *         in datasheet must be shifted to the left before calling the interface
  * @param  pData Pointer to data buffer
  * @param  Size Amount of data to be sent
  * @param  XferOptions Options of Transfer, value of @ref I2C_XFEROPTIONS
  * @retval HAL status
  *//* I2C_IT_ERRI | I2C_IT_TCI | I2C_IT_STOPI | I2C_IT_NACKI |
       I2C_IT_ADDRI | I2C_IT_RXI | I2C_IT_TXI *//**
  * @brief  Sequential transmit in master I2C mode an amount of data in non-blocking mode with Interrupt.
  * @note   This interface allow to manage repeated start condition when a direction change during transfer
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @param  DevAddress Target device address: The device 7 bits address value
  *         in datasheet must be shifted to the left before calling the interface
  * @param  pData Pointer to data buffer
  * @param  Size Amount of data to be sent
  * @param  XferOptions Options of Transfer, value of @ref I2C_XFEROPTIONS
  * @retval HAL status
  *//* Increment Trials *//* Clear STOP Flag, auto generated with autoend*//* Wait until STOPF flag is reset *//* Device is ready *//* Check if the NACKF flag has not been set *//* Wait until STOPF flag is set or a NACK flag is set*//* No need to Check TC flag, with AUTOEND mode the stop is automatically generated *//* Generate Start *//**
  * @brief  Checks if target device is ready for communication.
  * @note   This function is used with Memory devices
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @param  DevAddress Target device address: The device 7 bits address value
  *         in datasheet must be shifted to the left before calling the interface
  * @param  Trials Number of trials
  * @param  Timeout Timeout duration
  * @retval HAL status
  *//* Send Slave Address and Memory Address *//* Prepare Memaddress buffer for LSB part *//* Prefetch Memory Address (MSB part, LSB will be manage through interrupt) *//* Prefetch Memory Address *//**
  * @brief  Reads an amount of data in non-blocking mode with DMA from a specific memory address.
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @param  DevAddress Target device address: The device 7 bits address value
  *         in datasheet must be shifted to the left before calling the interface
  * @param  MemAddress Internal memory address
  * @param  MemAddSize Size of internal memory address
  * @param  pData Pointer to data buffer
  * @param  Size Amount of data to be read
  * @retval HAL status
  *//**
  * @brief  Write an amount of data in non-blocking mode with DMA to a specific memory address
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @param  DevAddress Target device address: The device 7 bits address value
  *         in datasheet must be shifted to the left before calling the interface
  * @param  MemAddress Internal memory address
  * @param  MemAddSize Size of internal memory address
  * @param  pData Pointer to data buffer
  * @param  Size Amount of data to be sent
  * @retval HAL status
  *//* I2C_IT_ERRI | I2C_IT_TCI | I2C_IT_STOPI | I2C_IT_NACKI |
      I2C_IT_ADDRI | I2C_IT_RXI | I2C_IT_TXI *//**
  * @brief  Read an amount of data in non-blocking mode with Interrupt from a specific memory address
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @param  DevAddress Target device address: The device 7 bits address value
  *         in datasheet must be shifted to the left before calling the interface
  * @param  MemAddress Internal memory address
  * @param  MemAddSize Size of internal memory address
  * @param  pData Pointer to data buffer
  * @param  Size Amount of data to be sent
  * @retval HAL status
  *//**
  * @brief  Write an amount of data in non-blocking mode with Interrupt to a specific memory address
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @param  DevAddress Target device address: The device 7 bits address value
  *         in datasheet must be shifted to the left before calling the interface
  * @param  MemAddress Internal memory address
  * @param  MemAddSize Size of internal memory address
  * @param  pData Pointer to data buffer
  * @param  Size Amount of data to be sent
  * @retval HAL status
  *//* Wait until RXNE flag is set *//* Init tickstart for timeout management*//**
  * @brief  Read an amount of data in blocking mode from a specific memory address
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @param  DevAddress Target device address: The device 7 bits address value
  *         in datasheet must be shifted to the left before calling the interface
  * @param  MemAddress Internal memory address
  * @param  MemAddSize Size of internal memory address
  * @param  pData Pointer to data buffer
  * @param  Size Amount of data to be sent
  * @param  Timeout Timeout duration
  * @retval HAL status
  *//* Set NBYTES to write and reload if hi2c->XferCount > MAX_NBYTE_SIZE *//**
  * @brief  Write an amount of data in blocking mode to a specific memory address
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @param  DevAddress Target device address: The device 7 bits address value
  *         in datasheet must be shifted to the left before calling the interface
  * @param  MemAddress Internal memory address
  * @param  MemAddSize Size of internal memory address
  * @param  pData Pointer to data buffer
  * @param  Size Amount of data to be sent
  * @param  Timeout Timeout duration
  * @retval HAL status
  *//**
  * @brief  Receive in slave mode an amount of data in non-blocking mode with DMA
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @param  pData Pointer to data buffer
  * @param  Size Amount of data to be sent
  * @retval HAL status
  *//* Note : The I2C interrupts must be enabled after unlocking current process
      to avoid the risk of I2C interrupt handle execution before current
      process unlock *//* Preload TX data if no stretch enable *//**
  * @brief  Transmit in slave mode an amount of data in non-blocking mode with DMA
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @param  pData Pointer to data buffer
  * @param  Size Amount of data to be sent
  * @retval HAL status
  *//* Set NBYTES to read and reload if hi2c->XferCount > MAX_NBYTE_SIZE and generate RESTART *//**
  * @brief  Receive in master mode an amount of data in non-blocking mode with DMA
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @param  DevAddress Target device address: The device 7 bits address value
  *         in datasheet must be shifted to the left before calling the interface
  * @param  pData Pointer to data buffer
  * @param  Size Amount of data to be sent
  * @retval HAL status
  *//**
  * @brief  Transmit in master mode an amount of data in non-blocking mode with DMA
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @param  DevAddress Target device address: The device 7 bits address value
  *         in datasheet must be shifted to the left before calling the interface
  * @param  pData Pointer to data buffer
  * @param  Size Amount of data to be sent
  * @retval HAL status
  *//**
  * @brief  Receive in slave mode an amount of data in non-blocking mode with Interrupt
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @param  pData Pointer to data buffer
  * @param  Size Amount of data to be sent
  * @retval HAL status
  *//**
  * @brief  Transmit in slave mode an amount of data in non-blocking mode with Interrupt
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @param  pData Pointer to data buffer
  * @param  Size Amount of data to be sent
  * @retval HAL status
  *//**
  * @brief  Receive in master mode an amount of data in non-blocking mode with Interrupt
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @param  DevAddress Target device address: The device 7 bits address value
  *         in datasheet must be shifted to the left before calling the interface
  * @param  pData Pointer to data buffer
  * @param  Size Amount of data to be sent
  * @retval HAL status
  *//**
  * @brief  Transmit in master mode an amount of data in non-blocking mode with Interrupt
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @param  DevAddress Target device address: The device 7 bits address value
  *         in datasheet must be shifted to the left before calling the interface
  * @param  pData Pointer to data buffer
  * @param  Size Amount of data to be sent
  * @retval HAL status
  *//* Wait until BUSY flag is reset *//* Clear STOP flag *//* Wait until STOP flag is set *//* Wait until DIR flag is reset Receiver mode *//* Wait until ADDR flag is set *//**
  * @brief  Receive in slave mode an amount of data in blocking mode
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @param  pData Pointer to data buffer
  * @param  Size Amount of data to be sent
  * @param  Timeout Timeout duration
  * @retval HAL status
  *//* Clear AF flag *//* Reset ErrorCode to NONE *//* Wait until AF flag is set *//* Wait until DIR flag is set Transmitter mode *//* If 10bit addressing mode is selected *//**
  * @brief  Transmits in slave mode an amount of data in blocking mode.
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @param  pData Pointer to data buffer
  * @param  Size Amount of data to be sent
  * @param  Timeout Timeout duration
  * @retval HAL status
  *//* Wait until STOPF flag is set *//**
  * @brief  Receives in master mode an amount of data in blocking mode.
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @param  DevAddress Target device address: The device 7 bits address value
  *         in datasheet must be shifted to the left before calling the interface
  * @param  pData Pointer to data buffer
  * @param  Size Amount of data to be sent
  * @param  Timeout Timeout duration
  * @retval HAL status
  *//**
  * @brief  Transmits in master mode an amount of data in blocking mode.
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @param  DevAddress Target device address: The device 7 bits address value
  *         in datasheet must be shifted to the left before calling the interface
  * @param  pData Pointer to data buffer
  * @param  Size Amount of data to be sent
  * @param  Timeout Timeout duration
  * @retval HAL status
  *//** @defgroup I2C_Exported_Functions_Group2 Input and Output operation functions
  *  @brief   Data transfers functions
  *
@verbatim
 ===============================================================================
                      ##### IO operation functions #####
 ===============================================================================
    [..]
    This subsection provides a set of functions allowing to manage the I2C data
    transfers.

    (#) There are two modes of transfer:
       (++) Blocking mode : The communication is performed in the polling mode.
            The status of all data processing is returned by the same function
            after finishing transfer.
       (++) No-Blocking mode : The communication is performed using Interrupts
            or DMA. These functions return the status of the transfer startup.
            The end of the data processing will be indicated through the
            dedicated I2C IRQ when using Interrupt mode or the DMA IRQ when
            using DMA mode.

    (#) Blocking mode functions are :
        (++) HAL_I2C_Master_Transmit()
        (++) HAL_I2C_Master_Receive()
        (++) HAL_I2C_Slave_Transmit()
        (++) HAL_I2C_Slave_Receive()
        (++) HAL_I2C_Mem_Write()
        (++) HAL_I2C_Mem_Read()
        (++) HAL_I2C_IsDeviceReady()

    (#) No-Blocking mode functions with Interrupt are :
        (++) HAL_I2C_Master_Transmit_IT()
        (++) HAL_I2C_Master_Receive_IT()
        (++) HAL_I2C_Slave_Transmit_IT()
        (++) HAL_I2C_Slave_Receive_IT()
        (++) HAL_I2C_Mem_Write_IT()
        (++) HAL_I2C_Mem_Read_IT()
        (++) HAL_I2C_Master_Seq_Transmit_IT()
        (++) HAL_I2C_Master_Seq_Receive_IT()
        (++) HAL_I2C_Slave_Seq_Transmit_IT()
        (++) HAL_I2C_Slave_Seq_Receive_IT()
        (++) HAL_I2C_EnableListen_IT()
        (++) HAL_I2C_DisableListen_IT()
        (++) HAL_I2C_Master_Abort_IT()

    (#) No-Blocking mode functions with DMA are :
        (++) HAL_I2C_Master_Transmit_DMA()
        (++) HAL_I2C_Master_Receive_DMA()
        (++) HAL_I2C_Slave_Transmit_DMA()
        (++) HAL_I2C_Slave_Receive_DMA()
        (++) HAL_I2C_Mem_Write_DMA()
        (++) HAL_I2C_Mem_Read_DMA()
        (++) HAL_I2C_Master_Seq_Transmit_DMA()
        (++) HAL_I2C_Master_Seq_Receive_DMA()
        (++) HAL_I2C_Slave_Seq_Transmit_DMA()
        (++) HAL_I2C_Slave_Seq_Receive_DMA()

    (#) A set of Transfer Complete Callbacks are provided in non Blocking mode:
        (++) HAL_I2C_MasterTxCpltCallback()
        (++) HAL_I2C_MasterRxCpltCallback()
        (++) HAL_I2C_SlaveTxCpltCallback()
        (++) HAL_I2C_SlaveRxCpltCallback()
        (++) HAL_I2C_MemTxCpltCallback()
        (++) HAL_I2C_MemRxCpltCallback()
        (++) HAL_I2C_AddrCallback()
        (++) HAL_I2C_ListenCpltCallback()
        (++) HAL_I2C_ErrorCallback()
        (++) HAL_I2C_AbortCpltCallback()

@endverbatim
  * @{
  *//* Legacy weak AddrCallback  *//**
  * @brief  UnRegister the Slave Address Match I2C Callback
  *         Info Ready I2C Callback is redirected to the weak HAL_I2C_AddrCallback() predefined callback
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @retval HAL status
  *//**
  * @brief  Register the Slave Address Match I2C Callback
  *         To be used instead of the weak HAL_I2C_AddrCallback() predefined callback
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @param  pCallback pointer to the Address Match Callback function
  * @retval HAL status
  *//* Legacy weak AbortCpltCallback    *//* Legacy weak MemRxCpltCallback    *//* Legacy weak MemTxCpltCallback    *//* Legacy weak ListenCpltCallback   *//* Legacy weak SlaveRxCpltCallback  *//* Legacy weak SlaveTxCpltCallback  *//* Legacy weak MasterRxCpltCallback *//* Legacy weak MasterTxCpltCallback *//**
  * @brief  Unregister an I2C Callback
  *         I2C callback is redirected to the weak predefined callback
  * @note   The HAL_I2C_UnRegisterCallback() may be called before HAL_I2C_Init() in HAL_I2C_STATE_RESET
  *         to un-register callbacks for HAL_I2C_MSPINIT_CB_ID and HAL_I2C_MSPDEINIT_CB_ID.
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @param  CallbackID ID of the callback to be unregistered
  *         This parameter can be one of the following values:
  *         This parameter can be one of the following values:
  *          @arg @ref HAL_I2C_MASTER_TX_COMPLETE_CB_ID Master Tx Transfer completed callback ID
  *          @arg @ref HAL_I2C_MASTER_RX_COMPLETE_CB_ID Master Rx Transfer completed callback ID
  *          @arg @ref HAL_I2C_SLAVE_TX_COMPLETE_CB_ID Slave Tx Transfer completed callback ID
  *          @arg @ref HAL_I2C_SLAVE_RX_COMPLETE_CB_ID Slave Rx Transfer completed callback ID
  *          @arg @ref HAL_I2C_LISTEN_COMPLETE_CB_ID Listen Complete callback ID
  *          @arg @ref HAL_I2C_MEM_TX_COMPLETE_CB_ID Memory Tx Transfer callback ID
  *          @arg @ref HAL_I2C_MEM_RX_COMPLETE_CB_ID Memory Rx Transfer completed callback ID
  *          @arg @ref HAL_I2C_ERROR_CB_ID Error callback ID
  *          @arg @ref HAL_I2C_ABORT_CB_ID Abort callback ID
  *          @arg @ref HAL_I2C_MSPINIT_CB_ID MspInit callback ID
  *          @arg @ref HAL_I2C_MSPDEINIT_CB_ID MspDeInit callback ID
  * @retval HAL status
  *//**
  * @brief  Register a User I2C Callback
  *         To be used instead of the weak predefined callback
  * @note   The HAL_I2C_RegisterCallback() may be called before HAL_I2C_Init() in HAL_I2C_STATE_RESET
  *         to register callbacks for HAL_I2C_MSPINIT_CB_ID and HAL_I2C_MSPDEINIT_CB_ID.
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @param  CallbackID ID of the callback to be registered
  *         This parameter can be one of the following values:
  *          @arg @ref HAL_I2C_MASTER_TX_COMPLETE_CB_ID Master Tx Transfer completed callback ID
  *          @arg @ref HAL_I2C_MASTER_RX_COMPLETE_CB_ID Master Rx Transfer completed callback ID
  *          @arg @ref HAL_I2C_SLAVE_TX_COMPLETE_CB_ID Slave Tx Transfer completed callback ID
  *          @arg @ref HAL_I2C_SLAVE_RX_COMPLETE_CB_ID Slave Rx Transfer completed callback ID
  *          @arg @ref HAL_I2C_LISTEN_COMPLETE_CB_ID Listen Complete callback ID
  *          @arg @ref HAL_I2C_MEM_TX_COMPLETE_CB_ID Memory Tx Transfer callback ID
  *          @arg @ref HAL_I2C_MEM_RX_COMPLETE_CB_ID Memory Rx Transfer completed callback ID
  *          @arg @ref HAL_I2C_ERROR_CB_ID Error callback ID
  *          @arg @ref HAL_I2C_ABORT_CB_ID Abort callback ID
  *          @arg @ref HAL_I2C_MSPINIT_CB_ID MspInit callback ID
  *          @arg @ref HAL_I2C_MSPDEINIT_CB_ID MspDeInit callback ID
  * @param  pCallback pointer to the Callback function
  * @retval HAL status
  *//* NOTE : This function should not be modified, when the callback is needed,
            the HAL_I2C_MspDeInit could be implemented in the user file
   *//**
  * @brief DeInitialize the I2C MSP.
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @retval None
  *//* NOTE : This function should not be modified, when the callback is needed,
            the HAL_I2C_MspInit could be implemented in the user file
   *//**
  * @brief Initialize the I2C MSP.
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @retval None
  *//* DeInit the low level hardware: GPIO, CLOCK, NVIC *//* Disable the I2C Peripheral Clock *//* Check the I2C handle allocation *//**
  * @brief  DeInitialize the I2C peripheral.
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @retval HAL status
  *//* Enable the selected I2C peripheral *//* Configure I2Cx: Generalcall and NoStretch mode *//*---------------------------- I2Cx CR1 Configuration ----------------------*//* Configure I2Cx: Dual mode and Own Address2 *//* Disable Own Address2 before set the Own Address2 configuration *//*---------------------------- I2Cx OAR2 Configuration ---------------------*//* Enable the AUTOEND by default, and enable NACK (should be disable only during Slave process *//* Clear the I2C ADD10 bit *//* Configure I2Cx: Addressing Master mode *//*---------------------------- I2Cx CR2 Configuration ----------------------*//* I2C_ADDRESSINGMODE_10BIT *//* Configure I2Cx: Own Address1 and ack own address1 mode *//* Disable Own Address1 before set the Own Address1 configuration *//*---------------------------- I2Cx OAR1 Configuration ---------------------*//* Configure I2Cx: Frequency range *//*---------------------------- I2Cx TIMINGR Configuration ------------------*//* Disable the selected I2C peripheral *//* Init the low level hardware : GPIO, CLOCK, CORTEX...etc *//* Legacy weak AddrCallback         *//* Init the I2C Callback settings *//**
  * @brief  Initializes the I2C according to the specified parameters
  *         in the I2C_InitTypeDef and initialize the associated handle.
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @retval HAL status
  *//** @defgroup I2C_Exported_Functions_Group1 Initialization and de-initialization functions
  *  @brief    Initialization and Configuration functions
  *
@verbatim
 ===============================================================================
              ##### Initialization and de-initialization functions #####
 ===============================================================================
    [..]  This subsection provides a set of functions allowing to initialize and
          deinitialize the I2Cx peripheral:

      (+) User must Implement HAL_I2C_MspInit() function in which he configures
          all related peripherals resources (CLOCK, GPIO, DMA, IT and NVIC ).

      (+) Call the function HAL_I2C_Init() to configure the selected device with
          the selected configuration:
        (++) Clock Timing
        (++) Own Address 1
        (++) Addressing mode (Master, Slave)
        (++) Dual Addressing mode
        (++) Own Address 2
        (++) Own Address 2 Mask
        (++) General call mode
        (++) Nostretch mode

      (+) Call the function HAL_I2C_DeInit() to restore the default configuration
          of the selected I2Cx peripheral.

@endverbatim
  * @{
  *//** @defgroup I2C_Exported_Functions I2C Exported Functions
  * @{
  *//* Private function to Convert Specific options *//* Private function to handle  start, restart or stop a transfer *//* Private function to flush TXDR register *//* Private function to treat different error callback *//* Private functions to centralize the enable/disable of Interrupts *//* Private functions to handle flags during polling transfer *//* Private functions for I2C transfer IRQ handler *//* Private functions to handle IT transfer *//* Private functions to handle DMA transfer *//* Macro to get remaining data to transfer on DMA side *//** @addtogroup I2C_Private_Macro
  * @{
  *//* Private define Sequential Transfer Options default/reset value *//*!< Bit definition to manage only Reload of NBYTE *//*!< Bit definition to manage only STOP evenement *//*!< Bit definition to manage addition of global Error
                                                         and NACK treatment *//*!< Bit field can be combinated with @ref I2C_XFER_TX_IT
                                                         and @ref I2C_XFER_RX_IT *//*!< Bit field can be combinated with
                                                         @ref I2C_XFER_LISTEN_IT *//* Private define to centralize the enable/disable of Interrupts *//*!< Memory Busy RX, combinaison of State LSB and Mode enum *//*!< Memory Busy TX, combinaison of State LSB and Mode enum *//*!< Slave Busy RX, combinaison of State LSB and Mode enum  *//*!< Slave Busy TX, combinaison of State LSB and Mode enum *//*!< Master Busy RX, combinaison of State LSB and Mode enum *//*!< Master Busy TX, combinaison of State LSB and Mode enum *//*!< Default Value *//*!< Mask State define, keep only RX and TX bits *//* Private define for @ref PreviousState usage *//*!< 25 ms *//*!< 10 s  *//*!< I2C TIMING clear register Mask *//** @defgroup I2C_Private_Define I2C Private Define
  * @{
  *//** @defgroup I2C I2C
  * @brief I2C HAL module driver
  * @{
  *//**
  ******************************************************************************
  * @file    stm32f7xx_hal_i2c.c
  * @author  MCD Application Team
  * @brief   I2C HAL module driver.
  *          This file provides firmware functions to manage the following
  *          functionalities of the Inter Integrated Circuit (I2C) peripheral:
  *           + Initialization and de-initialization functions
  *           + IO operation functions
  *           + Peripheral State and Errors functions
  *
  ******************************************************************************
  * @attention
  *
  * Copyright (c) 2017 STMicroelectronics.
  * All rights reserved.
  *
  * This software is licensed under terms that can be found in the LICENSE file
  * in the root directory of this software component.
  * If no LICENSE file comes with this software, it is provided AS-IS.
  *
  ******************************************************************************
  @verbatim
  ==============================================================================
                        ##### How to use this driver #####
  ==============================================================================
    [..]
    The I2C HAL driver can be used as follows:

    (#) Declare a I2C_HandleTypeDef handle structure, for example:
        I2C_HandleTypeDef  hi2c;

    (#)Initialize the I2C low level resources by implementing the HAL_I2C_MspInit() API:
        (##) Enable the I2Cx interface clock
        (##) I2C pins configuration
            (+++) Enable the clock for the I2C GPIOs
            (+++) Configure I2C pins as alternate function open-drain
        (##) NVIC configuration if you need to use interrupt process
            (+++) Configure the I2Cx interrupt priority
            (+++) Enable the NVIC I2C IRQ Channel
        (##) DMA Configuration if you need to use DMA process
            (+++) Declare a DMA_HandleTypeDef handle structure for
                  the transmit or receive stream
            (+++) Enable the DMAx interface clock using
            (+++) Configure the DMA handle parameters
            (+++) Configure the DMA Tx or Rx stream
            (+++) Associate the initialized DMA handle to the hi2c DMA Tx or Rx handle
            (+++) Configure the priority and enable the NVIC for the transfer complete interrupt on
                  the DMA Tx or Rx stream

    (#) Configure the Communication Clock Timing, Own Address1, Master Addressing mode, Dual Addressing mode,
        Own Address2, Own Address2 Mask, General call and Nostretch mode in the hi2c Init structure.

    (#) Initialize the I2C registers by calling the HAL_I2C_Init(), configures also the low level Hardware
        (GPIO, CLOCK, NVIC...etc) by calling the customized HAL_I2C_MspInit(&hi2c) API.

    (#) To check if target device is ready for communication, use the function HAL_I2C_IsDeviceReady()

    (#) For I2C IO and IO MEM operations, three operation modes are available within this driver :

    *** Polling mode IO operation ***
    =================================
    [..]
      (+) Transmit in master mode an amount of data in blocking mode using HAL_I2C_Master_Transmit()
      (+) Receive in master mode an amount of data in blocking mode using HAL_I2C_Master_Receive()
      (+) Transmit in slave mode an amount of data in blocking mode using HAL_I2C_Slave_Transmit()
      (+) Receive in slave mode an amount of data in blocking mode using HAL_I2C_Slave_Receive()

    *** Polling mode IO MEM operation ***
    =====================================
    [..]
      (+) Write an amount of data in blocking mode to a specific memory address using HAL_I2C_Mem_Write()
      (+) Read an amount of data in blocking mode from a specific memory address using HAL_I2C_Mem_Read()


    *** Interrupt mode IO operation ***
    ===================================
    [..]
      (+) Transmit in master mode an amount of data in non-blocking mode using HAL_I2C_Master_Transmit_IT()
      (+) At transmission end of transfer, HAL_I2C_MasterTxCpltCallback() is executed and users can
           add their own code by customization of function pointer HAL_I2C_MasterTxCpltCallback()
      (+) Receive in master mode an amount of data in non-blocking mode using HAL_I2C_Master_Receive_IT()
      (+) At reception end of transfer, HAL_I2C_MasterRxCpltCallback() is executed and users can
           add their own code by customization of function pointer HAL_I2C_MasterRxCpltCallback()
      (+) Transmit in slave mode an amount of data in non-blocking mode using HAL_I2C_Slave_Transmit_IT()
      (+) At transmission end of transfer, HAL_I2C_SlaveTxCpltCallback() is executed and users can
           add their own code by customization of function pointer HAL_I2C_SlaveTxCpltCallback()
      (+) Receive in slave mode an amount of data in non-blocking mode using HAL_I2C_Slave_Receive_IT()
      (+) At reception end of transfer, HAL_I2C_SlaveRxCpltCallback() is executed and users can
           add their own code by customization of function pointer HAL_I2C_SlaveRxCpltCallback()
      (+) In case of transfer Error, HAL_I2C_ErrorCallback() function is executed and users can
           add their own code by customization of function pointer HAL_I2C_ErrorCallback()
      (+) Abort a master or memory I2C process communication with Interrupt using HAL_I2C_Master_Abort_IT()
      (+) End of abort process, HAL_I2C_AbortCpltCallback() is executed and users can
           add their own code by customization of function pointer HAL_I2C_AbortCpltCallback()
      (+) Discard a slave I2C process communication using __HAL_I2C_GENERATE_NACK() macro.
           This action will inform Master to generate a Stop condition to discard the communication.


    *** Interrupt mode or DMA mode IO sequential operation ***
    ==========================================================
    [..]
      (@) These interfaces allow to manage a sequential transfer with a repeated start condition
          when a direction change during transfer
    [..]
      (+) A specific option field manage the different steps of a sequential transfer
      (+) Option field values are defined through I2C_XFEROPTIONS and are listed below:
      (++) I2C_FIRST_AND_LAST_FRAME: No sequential usage, functional is same as associated interfaces in
           no sequential mode
      (++) I2C_FIRST_FRAME: Sequential usage, this option allow to manage a sequence with start condition, address
                            and data to transfer without a final stop condition
      (++) I2C_FIRST_AND_NEXT_FRAME: Sequential usage (Master only), this option allow to manage a sequence with
                            start condition, address and data to transfer without a final stop condition,
                            an then permit a call the same master sequential interface several times
                            (like HAL_I2C_Master_Seq_Transmit_IT() then HAL_I2C_Master_Seq_Transmit_IT()
                            or HAL_I2C_Master_Seq_Transmit_DMA() then HAL_I2C_Master_Seq_Transmit_DMA())
      (++) I2C_NEXT_FRAME: Sequential usage, this option allow to manage a sequence with a restart condition, address
                            and with new data to transfer if the direction change or manage only the new data to
                            transfer
                            if no direction change and without a final stop condition in both cases
      (++) I2C_LAST_FRAME: Sequential usage, this option allow to manage a sequance with a restart condition, address
                            and with new data to transfer if the direction change or manage only the new data to
                            transfer
                            if no direction change and with a final stop condition in both cases
      (++) I2C_LAST_FRAME_NO_STOP: Sequential usage (Master only), this option allow to manage a restart condition
                            after several call of the same master sequential interface several times
                            (link with option I2C_FIRST_AND_NEXT_FRAME).
                            Usage can, transfer several bytes one by one using
                              HAL_I2C_Master_Seq_Transmit_IT
                              or HAL_I2C_Master_Seq_Receive_IT
                              or HAL_I2C_Master_Seq_Transmit_DMA
                              or HAL_I2C_Master_Seq_Receive_DMA
                              with option I2C_FIRST_AND_NEXT_FRAME then I2C_NEXT_FRAME.
                             Then usage of this option I2C_LAST_FRAME_NO_STOP at the last Transmit or
                              Receive sequence permit to call the opposite interface Receive or Transmit
                              without stopping the communication and so generate a restart condition.
      (++) I2C_OTHER_FRAME: Sequential usage (Master only), this option allow to manage a restart condition after
                            each call of the same master sequential
                            interface.
                            Usage can, transfer several bytes one by one with a restart with slave address between
                            each bytes using
                              HAL_I2C_Master_Seq_Transmit_IT
                              or HAL_I2C_Master_Seq_Receive_IT
                              or HAL_I2C_Master_Seq_Transmit_DMA
                              or HAL_I2C_Master_Seq_Receive_DMA
                              with option I2C_FIRST_FRAME then I2C_OTHER_FRAME.
                            Then usage of this option I2C_OTHER_AND_LAST_FRAME at the last frame to help automatic
                            generation of STOP condition.

      (+) Different sequential I2C interfaces are listed below:
      (++) Sequential transmit in master I2C mode an amount of data in non-blocking mode using
            HAL_I2C_Master_Seq_Transmit_IT() or using HAL_I2C_Master_Seq_Transmit_DMA()
      (+++) At transmission end of current frame transfer, HAL_I2C_MasterTxCpltCallback() is executed and
            users can add their own code by customization of function pointer HAL_I2C_MasterTxCpltCallback()
      (++) Sequential receive in master I2C mode an amount of data in non-blocking mode using
            HAL_I2C_Master_Seq_Receive_IT() or using HAL_I2C_Master_Seq_Receive_DMA()
      (+++) At reception end of current frame transfer, HAL_I2C_MasterRxCpltCallback() is executed and users can
           add their own code by customization of function pointer HAL_I2C_MasterRxCpltCallback()
      (++) Abort a master or memory IT or DMA I2C process communication with Interrupt using HAL_I2C_Master_Abort_IT()
      (+++) End of abort process, HAL_I2C_AbortCpltCallback() is executed and users can
           add their own code by customization of function pointer HAL_I2C_AbortCpltCallback()
      (++) Enable/disable the Address listen mode in slave I2C mode using HAL_I2C_EnableListen_IT()
            HAL_I2C_DisableListen_IT()
      (+++) When address slave I2C match, HAL_I2C_AddrCallback() is executed and users can
           add their own code to check the Address Match Code and the transmission direction request by master
           (Write/Read).
      (+++) At Listen mode end HAL_I2C_ListenCpltCallback() is executed and users can
          add their own code by customization of function pointer HAL_I2C_ListenCpltCallback()
      (++) Sequential transmit in slave I2C mode an amount of data in non-blocking mode using
            HAL_I2C_Slave_Seq_Transmit_IT() or using HAL_I2C_Slave_Seq_Transmit_DMA()
      (+++) At transmission end of current frame transfer, HAL_I2C_SlaveTxCpltCallback() is executed and
            users can add their own code by customization of function pointer HAL_I2C_SlaveTxCpltCallback()
      (++) Sequential receive in slave I2C mode an amount of data in non-blocking mode using
            HAL_I2C_Slave_Seq_Receive_IT() or using HAL_I2C_Slave_Seq_Receive_DMA()
      (+++) At reception end of current frame transfer, HAL_I2C_SlaveRxCpltCallback() is executed and users can
           add their own code by customization of function pointer HAL_I2C_SlaveRxCpltCallback()
      (++) In case of transfer Error, HAL_I2C_ErrorCallback() function is executed and users can
           add their own code by customization of function pointer HAL_I2C_ErrorCallback()
      (++) Discard a slave I2C process communication using __HAL_I2C_GENERATE_NACK() macro.
           This action will inform Master to generate a Stop condition to discard the communication.

    *** Interrupt mode IO MEM operation ***
    =======================================
    [..]
      (+) Write an amount of data in non-blocking mode with Interrupt to a specific memory address using
          HAL_I2C_Mem_Write_IT()
      (+) At Memory end of write transfer, HAL_I2C_MemTxCpltCallback() is executed and users can
           add their own code by customization of function pointer HAL_I2C_MemTxCpltCallback()
      (+) Read an amount of data in non-blocking mode with Interrupt from a specific memory address using
          HAL_I2C_Mem_Read_IT()
      (+) At Memory end of read transfer, HAL_I2C_MemRxCpltCallback() is executed and users can
           add their own code by customization of function pointer HAL_I2C_MemRxCpltCallback()
      (+) In case of transfer Error, HAL_I2C_ErrorCallback() function is executed and users can
           add their own code by customization of function pointer HAL_I2C_ErrorCallback()

    *** DMA mode IO operation ***
    ==============================
    [..]
      (+) Transmit in master mode an amount of data in non-blocking mode (DMA) using
          HAL_I2C_Master_Transmit_DMA()
      (+) At transmission end of transfer, HAL_I2C_MasterTxCpltCallback() is executed and users can
           add their own code by customization of function pointer HAL_I2C_MasterTxCpltCallback()
      (+) Receive in master mode an amount of data in non-blocking mode (DMA) using
          HAL_I2C_Master_Receive_DMA()
      (+) At reception end of transfer, HAL_I2C_MasterRxCpltCallback() is executed and users can
           add their own code by customization of function pointer HAL_I2C_MasterRxCpltCallback()
      (+) Transmit in slave mode an amount of data in non-blocking mode (DMA) using
          HAL_I2C_Slave_Transmit_DMA()
      (+) At transmission end of transfer, HAL_I2C_SlaveTxCpltCallback() is executed and users can
           add their own code by customization of function pointer HAL_I2C_SlaveTxCpltCallback()
      (+) Receive in slave mode an amount of data in non-blocking mode (DMA) using
          HAL_I2C_Slave_Receive_DMA()
      (+) At reception end of transfer, HAL_I2C_SlaveRxCpltCallback() is executed and users can
           add their own code by customization of function pointer HAL_I2C_SlaveRxCpltCallback()
      (+) In case of transfer Error, HAL_I2C_ErrorCallback() function is executed and users can
           add their own code by customization of function pointer HAL_I2C_ErrorCallback()
      (+) Abort a master or memory I2C process communication with Interrupt using HAL_I2C_Master_Abort_IT()
      (+) End of abort process, HAL_I2C_AbortCpltCallback() is executed and users can
           add their own code by customization of function pointer HAL_I2C_AbortCpltCallback()
      (+) Discard a slave I2C process communication using __HAL_I2C_GENERATE_NACK() macro.
           This action will inform Master to generate a Stop condition to discard the communication.

    *** DMA mode IO MEM operation ***
    =================================
    [..]
      (+) Write an amount of data in non-blocking mode with DMA to a specific memory address using
          HAL_I2C_Mem_Write_DMA()
      (+) At Memory end of write transfer, HAL_I2C_MemTxCpltCallback() is executed and users can
           add their own code by customization of function pointer HAL_I2C_MemTxCpltCallback()
      (+) Read an amount of data in non-blocking mode with DMA from a specific memory address using
          HAL_I2C_Mem_Read_DMA()
      (+) At Memory end of read transfer, HAL_I2C_MemRxCpltCallback() is executed and users can
           add their own code by customization of function pointer HAL_I2C_MemRxCpltCallback()
      (+) In case of transfer Error, HAL_I2C_ErrorCallback() function is executed and users can
           add their own code by customization of function pointer HAL_I2C_ErrorCallback()


     *** I2C HAL driver macros list ***
     ==================================
     [..]
       Below the list of most used macros in I2C HAL driver.

      (+) __HAL_I2C_ENABLE: Enable the I2C peripheral
      (+) __HAL_I2C_DISABLE: Disable the I2C peripheral
      (+) __HAL_I2C_GENERATE_NACK: Generate a Non-Acknowledge I2C peripheral in Slave mode
      (+) __HAL_I2C_GET_FLAG: Check whether the specified I2C flag is set or not
      (+) __HAL_I2C_CLEAR_FLAG: Clear the specified I2C pending flag
      (+) __HAL_I2C_ENABLE_IT: Enable the specified I2C interrupt
      (+) __HAL_I2C_DISABLE_IT: Disable the specified I2C interrupt

     *** Callback registration ***
     =============================================
    [..]
     The compilation flag USE_HAL_I2C_REGISTER_CALLBACKS when set to 1
     allows the user to configure dynamically the driver callbacks.
     Use Functions HAL_I2C_RegisterCallback() or HAL_I2C_RegisterAddrCallback()
     to register an interrupt callback.
    [..]
     Function HAL_I2C_RegisterCallback() allows to register following callbacks:
       (+) MasterTxCpltCallback : callback for Master transmission end of transfer.
       (+) MasterRxCpltCallback : callback for Master reception end of transfer.
       (+) SlaveTxCpltCallback  : callback for Slave transmission end of transfer.
       (+) SlaveRxCpltCallback  : callback for Slave reception end of transfer.
       (+) ListenCpltCallback   : callback for end of listen mode.
       (+) MemTxCpltCallback    : callback for Memory transmission end of transfer.
       (+) MemRxCpltCallback    : callback for Memory reception end of transfer.
       (+) ErrorCallback        : callback for error detection.
       (+) AbortCpltCallback    : callback for abort completion process.
       (+) MspInitCallback      : callback for Msp Init.
       (+) MspDeInitCallback    : callback for Msp DeInit.
     This function takes as parameters the HAL peripheral handle, the Callback ID
     and a pointer to the user callback function.
    [..]
     For specific callback AddrCallback use dedicated register callbacks : HAL_I2C_RegisterAddrCallback().
    [..]
     Use function HAL_I2C_UnRegisterCallback to reset a callback to the default
     weak function.
     HAL_I2C_UnRegisterCallback takes as parameters the HAL peripheral handle,
     and the Callback ID.
     This function allows to reset following callbacks:
       (+) MasterTxCpltCallback : callback for Master transmission end of transfer.
       (+) MasterRxCpltCallback : callback for Master reception end of transfer.
       (+) SlaveTxCpltCallback  : callback for Slave transmission end of transfer.
       (+) SlaveRxCpltCallback  : callback for Slave reception end of transfer.
       (+) ListenCpltCallback   : callback for end of listen mode.
       (+) MemTxCpltCallback    : callback for Memory transmission end of transfer.
       (+) MemRxCpltCallback    : callback for Memory reception end of transfer.
       (+) ErrorCallback        : callback for error detection.
       (+) AbortCpltCallback    : callback for abort completion process.
       (+) MspInitCallback      : callback for Msp Init.
       (+) MspDeInitCallback    : callback for Msp DeInit.
    [..]
     For callback AddrCallback use dedicated register callbacks : HAL_I2C_UnRegisterAddrCallback().
    [..]
     By default, after the HAL_I2C_Init() and when the state is HAL_I2C_STATE_RESET
     all callbacks are set to the corresponding weak functions:
     examples HAL_I2C_MasterTxCpltCallback(), HAL_I2C_MasterRxCpltCallback().
     Exception done for MspInit and MspDeInit functions that are
     reset to the legacy weak functions in the HAL_I2C_Init()/ HAL_I2C_DeInit() only when
     these callbacks are null (not registered beforehand).
     If MspInit or MspDeInit are not null, the HAL_I2C_Init()/ HAL_I2C_DeInit()
     keep and use the user MspInit/MspDeInit callbacks (registered beforehand) whatever the state.
    [..]
     Callbacks can be registered/unregistered in HAL_I2C_STATE_READY state only.
     Exception done MspInit/MspDeInit functions that can be registered/unregistered
     in HAL_I2C_STATE_READY or HAL_I2C_STATE_RESET state,
     thus registered (user) MspInit/DeInit callbacks can be used during the Init/DeInit.
     Then, the user first registers the MspInit/MspDeInit user callbacks
     using HAL_I2C_RegisterCallback() before calling HAL_I2C_DeInit()
     or HAL_I2C_Init() function.
    [..]
     When the compilation flag USE_HAL_I2C_REGISTER_CALLBACKS is set to 0 or
     not defined, the callback registration feature is not available and all callbacks
     are set to the corresponding weak functions.

     [..]
       (@) You can refer to the I2C HAL driver header file for more useful macros

  @endverbatim
  *//Users/jie/Documents/posixGen_Demos-main/LwIP_StreamingServer/Drivers/STM32F7xx_HAL_Driver/Src/stm32f7xx_hal_i2c_ex.cIS_I2C_FASTMODEPLUS(ConfigFastModePlus)SYSCFG->PMC((SYSCFG_TypeDef *) ((0x40000000UL + 0x00010000UL) + 0x3800UL))->PMC(uint32_t)ConfigFastModePlusIS_I2C_DIGITAL_FILTER(DigitalFilter)(I2C_CR1_DNF)~(I2C_CR1_DNF)IS_I2C_ANALOG_FILTER(AnalogFilter)(I2C_CR1_ANFOFF)~(I2C_CR1_ANFOFF)/* Disable fast mode plus driving capability for selected pin *//* Enable SYSCFG clock *//* Check the parameter *//**
  * @brief Disable the I2C fast mode plus driving capability.
  * @param ConfigFastModePlus Selects the pin.
  *   This parameter can be one of the @ref I2CEx_FastModePlus values
  * @note  For I2C1, fast mode plus driving capability can be disabled on all selected
  *        I2C1 pins using I2C_FASTMODEPLUS_I2C1 parameter or independently
  *        on each one of the following pins PB6, PB7, PB8 and PB9.
  * @note  For remaining I2C1 pins (PA14, PA15...) fast mode plus driving capability
  *        can be disabled only by using I2C_FASTMODEPLUS_I2C1 parameter.
  * @note  For all I2C2 pins fast mode plus driving capability can be disabled
  *        only by using I2C_FASTMODEPLUS_I2C2 parameter.
  * @note  For all I2C3 pins fast mode plus driving capability can be disabled
  *        only by using I2C_FASTMODEPLUS_I2C3 parameter.
  * @note  For all I2C4 pins fast mode plus driving capability can be disabled
  *        only by using I2C_FASTMODEPLUS_I2C4 parameter.
  * @retval None
  *//* Enable fast mode plus driving capability for selected pin *//**
  * @brief Enable the I2C fast mode plus driving capability.
  * @param ConfigFastModePlus Selects the pin.
  *   This parameter can be one of the @ref I2CEx_FastModePlus values
  * @note  For I2C1, fast mode plus driving capability can be enabled on all selected
  *        I2C1 pins using I2C_FASTMODEPLUS_I2C1 parameter or independently
  *        on each one of the following pins PB6, PB7, PB8 and PB9.
  * @note  For remaining I2C1 pins (PA14, PA15...) fast mode plus driving capability
  *        can be enabled only by using I2C_FASTMODEPLUS_I2C1 parameter.
  * @note  For all I2C2 pins fast mode plus driving capability can be enabled
  *        only by using I2C_FASTMODEPLUS_I2C2 parameter.
  * @note  For all I2C3 pins fast mode plus driving capability can be enabled
  *        only by using I2C_FASTMODEPLUS_I2C3 parameter.
  * @note  For all I2C4 pins fast mode plus driving capability can be enabled
  *        only by using I2C_FASTMODEPLUS_I2C4 parameter.
  * @retval None
  *//** @defgroup I2CEx_Exported_Functions_Group3 Fast Mode Plus Functions
  * @brief    Fast Mode Plus Functions
  *
@verbatim
 ===============================================================================
                      ##### Fast Mode Plus Functions #####
 ===============================================================================
    [..] This section provides functions allowing to:
      (+) Configure Fast Mode Plus

@endverbatim
  * @{
  *//* Store the new register value *//* Set I2Cx DNF coefficient *//* Reset I2Cx DNF bits [11:8] *//* Get the old register value *//**
  * @brief  Configure I2C Digital noise filter.
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2Cx peripheral.
  * @param  DigitalFilter Coefficient of digital noise filter between Min_Data=0x00 and Max_Data=0x0F.
  * @retval HAL status
  *//* Set analog filter bit*//* Reset I2Cx ANOFF bit *//**
  * @brief  Configure I2C Analog noise filter.
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2Cx peripheral.
  * @param  AnalogFilter New state of the Analog filter.
  * @retval HAL status
  *//** @defgroup I2CEx_Exported_Functions_Group1 Filter Mode Functions
  * @brief    Filter Mode Functions
  *
@verbatim
 ===============================================================================
                      ##### Filter Mode Functions #####
 ===============================================================================
    [..] This section provides functions allowing to:
      (+) Configure Noise Filters

@endverbatim
  * @{
  *//** @defgroup I2CEx_Exported_Functions I2C Extended Exported Functions
  * @{
  *//** @defgroup I2CEx I2CEx
  * @brief I2C Extended HAL module driver
  * @{
  *//**
  ******************************************************************************
  * @file    stm32f7xx_hal_i2c_ex.c
  * @author  MCD Application Team
  * @brief   I2C Extended HAL module driver.
  *          This file provides firmware functions to manage the following
  *          functionalities of I2C Extended peripheral:
  *           + Filter Mode Functions
  *           + FastModePlus Functions
  *
  ******************************************************************************
  * @attention
  *
  * Copyright (c) 2017 STMicroelectronics.
  * All rights reserved.
  *
  * This software is licensed under terms that can be found in the LICENSE file
  * in the root directory of this software component.
  * If no LICENSE file comes with this software, it is provided AS-IS.
  *
  ******************************************************************************
  @verbatim
  ==============================================================================
               ##### I2C peripheral Extended features  #####
  ==============================================================================

  [..] Comparing to other previous devices, the I2C interface for STM32F7xx
       devices contains the following additional features

       (+) Possibility to disable or enable Analog Noise Filter
       (+) Use of a configured Digital Noise Filter
       (+) Disable or enable Fast Mode Plus

                     ##### How to use this driver #####
  ==============================================================================
  [..] This driver provides functions to:
    (#) Configure I2C Analog noise filter using the function HAL_I2CEx_ConfigAnalogFilter()
    (#) Configure I2C Digital noise filter using the function HAL_I2CEx_ConfigDigitalFilter()
    (#) Configure the enable or disable of fast mode plus driving capability using the functions :
          (++) HAL_I2CEx_EnableFastModePlus()
          (++) HAL_I2CEx_DisableFastModePlus()
  @endverbatim
  *//Users/jie/Documents/posixGen_Demos-main/LwIP_StreamingServer/Drivers/STM32F7xx_HAL_Driver/Src/stm32f7xx_hal_ltdc.cLTDC_SetConfig4294905855(LTDC_LxWHPCR_WHSTPOS | LTDC_LxWHPCR_WHSPPOS)61440~(LTDC_LxWHPCR_WHSTPOS | LTDC_LxWHPCR_WHSPPOS)(LTDC_LxWVPCR_WVSTPOS | LTDC_LxWVPCR_WVSPPOS)~(LTDC_LxWVPCR_WVSTPOS | LTDC_LxWVPCR_WVSPPOS)(LTDC_LxPFCR_PF)~(LTDC_LxPFCR_PF)(LTDC_LxDCCR_DCBLUE | LTDC_LxDCCR_DCGREEN | LTDC_LxDCCR_DCRED |
                                         LTDC_LxDCCR_DCALPHA)~(LTDC_LxDCCR_DCBLUE | LTDC_LxDCCR_DCGREEN | LTDC_LxDCCR_DCRED |
                                         LTDC_LxDCCR_DCALPHA)(LTDC_LxCACR_CONSTA)~(LTDC_LxCACR_CONSTA)1799(LTDC_LxBFCR_BF2 | LTDC_LxBFCR_BF1)4294965496~(LTDC_LxBFCR_BF2 | LTDC_LxBFCR_BF1)(LTDC_LxCFBAR_CFBADD)~(LTDC_LxCFBAR_CFBADD)536805376536813567(LTDC_LxCFBLR_CFBLL | LTDC_LxCFBLR_CFBP)~(LTDC_LxCFBLR_CFBLL | LTDC_LxCFBLR_CFBP)(LTDC_LxCFBLNR_CFBLNBR)4294965248~(LTDC_LxCFBLNR_CFBLNBR)(uint32_t)LTDC_LxCR_LENIS_LTDC_LAYER(LayerIdx)(uint32_t)LTDC_LxCR_CLUTEN~(uint32_t)LTDC_LxCR_CLUTEN(uint32_t)LTDC_LxCR_COLKEN~(uint32_t)LTDC_LxCR_COLKEN(LTDC_LxCKCR_CKBLUE | LTDC_LxCKCR_CKGREEN | LTDC_LxCKCR_CKRED)~(LTDC_LxCKCR_CKBLUE | LTDC_LxCKCR_CKGREEN | LTDC_LxCKCR_CKRED)pitchUpdatepixelFormat3758161919~LTDC_LxCFBLR_CFBPIS_LTDC_ALPHA(Alpha)IS_LTDC_PIXEL_FORMAT(Pixelformat)IS_LTDC_CFBLL(X0)IS_LTDC_CFBLNBR(Y0)IS_LTDC_CFBLL(XSize)IS_LTDC_CFBLNBR(YSize)IS_LTDC_HCONFIGST(pLayerCfg->WindowX0)IS_LTDC_HCONFIGSP(pLayerCfg->WindowX1)IS_LTDC_VCONFIGST(pLayerCfg->WindowY0)IS_LTDC_VCONFIGSP(pLayerCfg->WindowY1)IS_LTDC_PIXEL_FORMAT(pLayerCfg->PixelFormat)IS_LTDC_ALPHA(pLayerCfg->Alpha)IS_LTDC_ALPHA(pLayerCfg->Alpha0)IS_LTDC_BLENDING_FACTOR1(pLayerCfg->BlendingFactor1)IS_LTDC_BLENDING_FACTOR2(pLayerCfg->BlendingFactor2)IS_LTDC_CFBLL(pLayerCfg->ImageWidth)IS_LTDC_CFBLNBR(pLayerCfg->ImageHeight)IS_LTDC_RELOAD(ReloadType)IS_LTDC_LIPOS(Line)(uint32_t)LTDC_GCR_DEN~(uint32_t)LTDC_GCR_DENpcolorlut0xFF0000Uhltdc->Instance->ISRhltdc->Instance->IERIS_LTDC_ALL_INSTANCE(hltdc->Instance)(hltdc)hltdc->Instance->CDSRLTDC_TIMEOUT_VALUEIS_LTDC_HSYNC(hltdc->Init.HorizontalSync)IS_LTDC_VSYNC(hltdc->Init.VerticalSync)IS_LTDC_AHBP(hltdc->Init.AccumulatedHBP)IS_LTDC_AVBP(hltdc->Init.AccumulatedVBP)IS_LTDC_AAH(hltdc->Init.AccumulatedActiveH)IS_LTDC_AAW(hltdc->Init.AccumulatedActiveW)IS_LTDC_TOTALH(hltdc->Init.TotalHeigh)IS_LTDC_TOTALW(hltdc->Init.TotalWidth)IS_LTDC_HSPOL(hltdc->Init.HSPolarity)IS_LTDC_VSPOL(hltdc->Init.VSPolarity)IS_LTDC_DEPOL(hltdc->Init.DEPolarity)IS_LTDC_PCPOL(hltdc->Init.PCPolarity)4026531840(LTDC_GCR_HSPOL | LTDC_GCR_VSPOL | LTDC_GCR_DEPOL | LTDC_GCR_PCPOL)268435455~(LTDC_GCR_HSPOL | LTDC_GCR_VSPOL | LTDC_GCR_DEPOL | LTDC_GCR_PCPOL)268371967(LTDC_SSCR_VSH | LTDC_SSCR_HSW)4026595328~(LTDC_SSCR_VSH | LTDC_SSCR_HSW)(LTDC_BPCR_AVBP | LTDC_BPCR_AHBP)~(LTDC_BPCR_AVBP | LTDC_BPCR_AHBP)(LTDC_AWCR_AAH | LTDC_AWCR_AAW)~(LTDC_AWCR_AAH | LTDC_AWCR_AAW)(LTDC_TWCR_TOTALH | LTDC_TWCR_TOTALW)~(LTDC_TWCR_TOTALH | LTDC_TWCR_TOTALW)(LTDC_BCCR_BCBLUE | LTDC_BCCR_BCGREEN | LTDC_BCCR_BCRED)~(LTDC_BCCR_BCBLUE | LTDC_BCCR_BCGREEN | LTDC_BCCR_BCRED)LTDC_IT_TE | LTDC_IT_FU(0x1UL << (2U)) | (0x1UL << (1U))((uint32_t)100U)defined(LTDC_Layer2_BASE)/* Enable LTDC_Layer by setting LEN bit *//* Configure the frame buffer line number *//* Configure the color frame buffer pitch in byte *//* Configure the color frame buffer start address *//* Specifies the blending factors *//* Specifies the constant alpha value *//* Configure the default color values *//* Specifies the pixel format *//* Configure the vertical start and stop position *//* Configure the horizontal start and stop position *//**
  * @brief  Configure the LTDC peripheral
  * @param  hltdc     Pointer to a LTDC_HandleTypeDef structure that contains
  *                   the configuration information for the LTDC.
  * @param  pLayerCfg Pointer LTDC Layer Configuration structure
  * @param  LayerIdx  LTDC Layer index.
  *                   This parameter can be one of the following values: LTDC_LAYER_1 (0) or LTDC_LAYER_2 (1)
  * @retval None
  *//**
  * @brief  Return the LTDC handle error code.
  * @param  hltdc  pointer to a LTDC_HandleTypeDef structure that contains
  *               the configuration information for the LTDC.
  * @retval LTDC Error Code
  *//**
  * @brief  Return the LTDC handle state.
  * @param  hltdc  pointer to a LTDC_HandleTypeDef structure that contains
  *                the configuration information for the LTDC.
  * @retval HAL state
  *//** @defgroup LTDC_Exported_Functions_Group4 Peripheral State and Errors functions
  *  @brief    Peripheral State and Errors functions
  *
@verbatim
 ===============================================================================
                  ##### Peripheral State and Errors functions #####
 ===============================================================================
    [..]
    This subsection provides functions allowing to
      (+) Check the LTDC handle state.
      (+) Get the LTDC handle error code.

@endverbatim
  * @{
  *//* Change the LTDC state*//* Disable LTDC color lookup table by setting CLUTEN bit *//* Change LTDC peripheral state *//**
  * @brief  Disable the color lookup table without reloading.
  *         Variant of the function HAL_LTDC_DisableCLUT without immediate reload.
  * @param  hltdc     pointer to a LTDC_HandleTypeDef structure that contains
  *                   the configuration information for the LTDC.
  * @param  LayerIdx  LTDC Layer index.
  *                   This parameter can be one of the following values:
  *                   LTDC_LAYER_1 (0) or LTDC_LAYER_2 (1)
  * @retval  HAL status
  *//**
  * @brief  Enable the color lookup table without reloading.
  *         Variant of the function HAL_LTDC_EnableCLUT without immediate reload.
  * @param  hltdc     pointer to a LTDC_HandleTypeDef structure that contains
  *                   the configuration information for the LTDC.
  * @param  LayerIdx  LTDC Layer index.
  *                   This parameter can be one of the following values:
  *                   LTDC_LAYER_1 (0) or LTDC_LAYER_2 (1)
  * @retval  HAL status
  *//* Disable LTDC color keying by setting COLKEN bit *//**
  * @brief  Disable the color keying without reloading.
  *         Variant of the function HAL_LTDC_DisableColorKeying without immediate reload.
  * @param  hltdc     pointer to a LTDC_HandleTypeDef structure that contains
  *                   the configuration information for the LTDC.
  * @param  LayerIdx  LTDC Layer index.
  *                   This parameter can be one of the following values:
  *                   LTDC_LAYER_1 (0) or LTDC_LAYER_2 (1)
  * @retval  HAL status
  *//* Enable LTDC color keying by setting COLKEN bit *//**
  * @brief  Enable the color keying without reloading.
  *         Variant of the function HAL_LTDC_EnableColorKeying without immediate reload.
  * @param  hltdc     pointer to a LTDC_HandleTypeDef structure that contains
  *                   the configuration information for the LTDC.
  * @param  LayerIdx  LTDC Layer index.
  *                   This parameter can be one of the following values:
  *                   LTDC_LAYER_1 (0) or LTDC_LAYER_2 (1)
  * @retval  HAL status
  *//**
  * @brief  Configure the color keying without reloading.
  *         Variant of the function HAL_LTDC_ConfigColorKeying without immediate reload.
  * @param  hltdc     pointer to a LTDC_HandleTypeDef structure that contains
  *                   the configuration information for the LTDC.
  * @param  RGBValue the color key value
  * @param  LayerIdx  LTDC Layer index.
  *                   This parameter can be one of the following values:
  *                   LTDC_LAYER_1 (0) or LTDC_LAYER_2 (1)
  * @retval HAL status
  *//* Set new line pitch value *//* Clear previously set standard pitch *//* get LayerIdx used pixel format *//**
  * @brief  Function used to reconfigure the pitch for specific cases where the attached LayerIdx buffer have a width
  *         that is larger than the one intended to be displayed on screen. Example of a buffer 800x480 attached to
  *         layer for which we want to read and display on screen only a portion 320x240 taken in the center
  *         of the buffer.
  *         The pitch in pixels will be in that case 800 pixels and not 320 pixels as initially configured by
  *         previous call to HAL_LTDC_ConfigLayer().
  * @note   This function should be called only after a previous call to HAL_LTDC_ConfigLayer() to modify the default
  *         pitch configured by HAL_LTDC_ConfigLayer() when required (refer to example described just above).
  *         Variant of the function HAL_LTDC_SetPitch without immediate reload.
  * @param  hltdc              pointer to a LTDC_HandleTypeDef structure that contains
  *                            the configuration information for the LTDC.
  * @param  LinePitchInPixels  New line pitch in pixels to configure for LTDC layer 'LayerIdx'.
  * @param  LayerIdx           LTDC layer index concerned by the modification of line pitch.
  * @retval HAL status
  *//* Set LTDC parameters *//* Reconfigure the Address *//* Get layer configuration from handle structure *//**
  * @brief  Reconfigure the frame buffer Address without reloading.
  *         Variant of the function HAL_LTDC_SetAddress without immediate reload.
  * @param  hltdc     pointer to a LTDC_HandleTypeDef structure that contains
  *                   the configuration information for the LTDC.
  * @param  Address   new address value.
  * @param  LayerIdx  LTDC Layer index.
  *                   This parameter can be one of the following values:
  *                   LTDC_LAYER_1 (0) or LTDC_LAYER_2 (1).
  * @retval  HAL status
  *//* Reconfigure the Alpha value *//**
  * @brief  Reconfigure the layer alpha value without reloading.
  *         Variant of the function HAL_LTDC_SetAlpha without immediate reload.
  * @param  hltdc     pointer to a LTDC_HandleTypeDef structure that contains
  *                   the configuration information for the LTDC.
  * @param  Alpha     new alpha value.
  * @param  LayerIdx  LTDC Layer index.
  *                   This parameter can be one of the following values:
  *                   LTDC_LAYER_1 (0) or LTDC_LAYER_2 (1)
  * @retval  HAL status
  *//* Reconfigure the pixel format *//**
  * @brief  Reconfigure the pixel format without reloading.
  *         Variant of the function HAL_LTDC_SetPixelFormat without immediate reload.
  * @param  hltdc        pointer to a LTDC_HandleTypeDfef structure that contains
  *                      the configuration information for the LTDC.
  * @param  Pixelformat  new pixel format value.
  * @param  LayerIdx     LTDC Layer index.
  *                      This parameter can be one of the following values:
  *                      LTDC_LAYER_1 (0) or LTDC_LAYER_2 (1).
  * @retval  HAL status
  *//* update vertical start/stop *//* update horizontal start/stop *//**
  * @brief  Set the LTDC window position without reloading.
  *         Variant of the function HAL_LTDC_SetWindowPosition without immediate reload.
  * @param  hltdc     pointer to a LTDC_HandleTypeDef structure that contains
  *                   the configuration information for the LTDC.
  * @param  X0        LTDC window X offset
  * @param  Y0        LTDC window Y offset
  * @param  LayerIdx  LTDC Layer index.
  *                         This parameter can be one of the following values:
  *                         LTDC_LAYER_1 (0) or LTDC_LAYER_2 (1)
  * @retval  HAL status
  *//* Reconfigures the frame buffer line number *//* Reconfigures the color frame buffer pitch in byte *//* update vertical stop *//* update horizontal stop *//* Check the parameters (Layers parameters)*//**
  * @brief  Set the LTDC window size without reloading.
  *         Variant of the function HAL_LTDC_SetWindowSize without immediate reload.
  * @param  hltdc     pointer to a LTDC_HandleTypeDef structure that contains
  *                   the configuration information for the LTDC.
  * @param  XSize     LTDC Pixel per line
  * @param  YSize     LTDC Line number
  * @param  LayerIdx  LTDC Layer index.
  *                   This parameter can be one of the following values:
  *                   LTDC_LAYER_1 (0) or LTDC_LAYER_2 (1)
  * @retval  HAL status
  *//* Initialize the LTDC state*//* Configure the LTDC Layer *//* Copy new layer configuration into handle structure *//**
  * @brief  Configure the LTDC Layer according to the specified without reloading
  *         parameters in the LTDC_InitTypeDef and create the associated handle.
  *         Variant of the function HAL_LTDC_ConfigLayer without immediate reload.
  * @param  hltdc      pointer to a LTDC_HandleTypeDef structure that contains
  *                    the configuration information for the LTDC.
  * @param  pLayerCfg  pointer to a LTDC_LayerCfgTypeDef structure that contains
  *                    the configuration information for the Layer.
  * @param  LayerIdx   LTDC Layer index.
  *                    This parameter can be one of the following values:
  *                    LTDC_LAYER_1 (0) or LTDC_LAYER_2 (1)
  * @retval HAL status
  *//* Apply Reload type *//* Enable the Reload interrupt *//**
  * @brief  Reload LTDC Layers configuration.
  * @param  hltdc      pointer to a LTDC_HandleTypeDef structure that contains
  *                    the configuration information for the LTDC.
  * @param  ReloadType This parameter can be one of the following values :
  *                      LTDC_RELOAD_IMMEDIATE : Immediate Reload
  *                      LTDC_RELOAD_VERTICAL_BLANKING  : Reload in the next Vertical Blanking
  * @note   User application may resort to HAL_LTDC_ReloadEventCallback() at reload interrupt generation.
  * @retval  HAL status
  *//* Set the Line Interrupt position *//* Disable the Line interrupt *//**
  * @brief  Define the position of the line interrupt.
  * @param  hltdc   pointer to a LTDC_HandleTypeDef structure that contains
  *                 the configuration information for the LTDC.
  * @param  Line    Line Interrupt Position.
  * @note   User application may resort to HAL_LTDC_LineEventCallback() at line interrupt generation.
  * @retval  HAL status
  *//* Set the Reload type as immediate update of LTDC pitch configured above *//**
  * @brief  Function used to reconfigure the pitch for specific cases where the attached LayerIdx buffer have a width
  *         that is larger than the one intended to be displayed on screen. Example of a buffer 800x480 attached to
  *         layer for which we want to read and display on screen only a portion 320x240 taken in the center
  *         of the buffer.
  *         The pitch in pixels will be in that case 800 pixels and not 320 pixels as initially configured by previous
  *         call to HAL_LTDC_ConfigLayer().
  * @note   This function should be called only after a previous call to HAL_LTDC_ConfigLayer() to modify the default
  *         pitch configured by HAL_LTDC_ConfigLayer() when required (refer to example described just above).
  * @param  hltdc              pointer to a LTDC_HandleTypeDef structure that contains
  *                            the configuration information for the LTDC.
  * @param  LinePitchInPixels  New line pitch in pixels to configure for LTDC layer 'LayerIdx'.
  * @param  LayerIdx           LTDC layer index concerned by the modification of line pitch.
  * @retval HAL status
  *//* Set the Immediate Reload type *//**
  * @brief  Reconfigure the frame buffer Address.
  * @param  hltdc     pointer to a LTDC_HandleTypeDef structure that contains
  *                   the configuration information for the LTDC.
  * @param  Address   new address value.
  * @param  LayerIdx  LTDC Layer index.
  *                   This parameter can be one of the following values:
  *                   LTDC_LAYER_1 (0) or LTDC_LAYER_2 (1).
  * @retval  HAL status
  *//**
  * @brief  Reconfigure the layer alpha value.
  * @param  hltdc     pointer to a LTDC_HandleTypeDef structure that contains
  *                   the configuration information for the LTDC.
  * @param  Alpha     new alpha value.
  * @param  LayerIdx  LTDC Layer index.
  *                   This parameter can be one of the following values:
  *                   LTDC_LAYER_1 (0) or LTDC_LAYER_2 (1)
  * @retval  HAL status
  *//**
  * @brief  Reconfigure the pixel format.
  * @param  hltdc        pointer to a LTDC_HandleTypeDef structure that contains
  *                      the configuration information for the LTDC.
  * @param  Pixelformat  new pixel format value.
  * @param  LayerIdx     LTDC Layer index.
  *                      This parameter can be one of the following values:
  *                      LTDC_LAYER_1 (0) or LTDC_LAYER_2 (1).
  * @retval  HAL status
  *//**
  * @brief  Set the LTDC window position.
  * @param  hltdc     pointer to a LTDC_HandleTypeDef structure that contains
  *                   the configuration information for the LTDC.
  * @param  X0        LTDC window X offset
  * @param  Y0        LTDC window Y offset
  * @param  LayerIdx  LTDC Layer index.
  *                         This parameter can be one of the following values:
  *                         LTDC_LAYER_1 (0) or LTDC_LAYER_2 (1)
  * @retval  HAL status
  *//**
  * @brief  Set the LTDC window size.
  * @param  hltdc     pointer to a LTDC_HandleTypeDef structure that contains
  *                   the configuration information for the LTDC.
  * @param  XSize     LTDC Pixel per line
  * @param  YSize     LTDC Line number
  * @param  LayerIdx  LTDC Layer index.
  *                   This parameter can be one of the following values:
  *                   LTDC_LAYER_1 (0) or LTDC_LAYER_2 (1)
  * @retval  HAL status
  *//* Disable Dither by setting DTEN bit *//**
  * @brief  Disable Dither.
  * @param  hltdc  pointer to a LTDC_HandleTypeDef structure that contains
  *                the configuration information for the LTDC.
  * @retval  HAL status
  *//* Enable Dither by setting DTEN bit *//**
  * @brief  Enable Dither.
  * @param  hltdc  pointer to a LTDC_HandleTypeDef structure that contains
  *                the configuration information for the LTDC.
  * @retval  HAL status
  *//**
  * @brief  Disable the color lookup table.
  * @param  hltdc     pointer to a LTDC_HandleTypeDef structure that contains
  *                   the configuration information for the LTDC.
  * @param  LayerIdx  LTDC Layer index.
  *                   This parameter can be one of the following values:
  *                   LTDC_LAYER_1 (0) or LTDC_LAYER_2 (1)
  * @retval  HAL status
  *//* Enable LTDC color lookup table by setting CLUTEN bit *//**
  * @brief  Enable the color lookup table.
  * @param  hltdc     pointer to a LTDC_HandleTypeDef structure that contains
  *                   the configuration information for the LTDC.
  * @param  LayerIdx  LTDC Layer index.
  *                   This parameter can be one of the following values:
  *                   LTDC_LAYER_1 (0) or LTDC_LAYER_2 (1)
  * @retval  HAL status
  *//**
  * @brief  Disable the color keying.
  * @param  hltdc     pointer to a LTDC_HandleTypeDef structure that contains
  *                   the configuration information for the LTDC.
  * @param  LayerIdx  LTDC Layer index.
  *                   This parameter can be one of the following values:
  *                   LTDC_LAYER_1 (0) or LTDC_LAYER_2 (1)
  * @retval  HAL status
  *//**
  * @brief  Enable the color keying.
  * @param  hltdc     pointer to a LTDC_HandleTypeDef structure that contains
  *                   the configuration information for the LTDC.
  * @param  LayerIdx  LTDC Layer index.
  *                   This parameter can be one of the following values:
  *                   LTDC_LAYER_1 (0) or LTDC_LAYER_2 (1)
  * @retval  HAL status
  *//* Specifies the C-LUT address and RGB value *//**
  * @brief  Load the color lookup table.
  * @param  hltdc     pointer to a LTDC_HandleTypeDef structure that contains
  *                   the configuration information for the LTDC.
  * @param  pCLUT     pointer to the color lookup table address.
  * @param  CLUTSize  the color lookup table size.
  * @param  LayerIdx  LTDC Layer index.
  *                   This parameter can be one of the following values:
  *                   LTDC_LAYER_1 (0) or LTDC_LAYER_2 (1)
  * @retval HAL status
  *//**
  * @brief  Configure the color keying.
  * @param  hltdc     pointer to a LTDC_HandleTypeDef structure that contains
  *                   the configuration information for the LTDC.
  * @param  RGBValue  the color key value
  * @param  LayerIdx  LTDC Layer index.
  *                   This parameter can be one of the following values:
  *                   LTDC_LAYER_1 (0) or LTDC_LAYER_2 (1)
  * @retval HAL status
  *//**
  * @brief  Configure the LTDC Layer according to the specified
  *         parameters in the LTDC_InitTypeDef and create the associated handle.
  * @param  hltdc      pointer to a LTDC_HandleTypeDef structure that contains
  *                    the configuration information for the LTDC.
  * @param  pLayerCfg  pointer to a LTDC_LayerCfgTypeDef structure that contains
  *                    the configuration information for the Layer.
  * @param  LayerIdx  LTDC Layer index.
  *                    This parameter can be one of the following values:
  *                    LTDC_LAYER_1 (0) or LTDC_LAYER_2 (1)
  * @retval HAL status
  *//** @defgroup LTDC_Exported_Functions_Group3 Peripheral Control functions
  *  @brief    Peripheral Control functions
  *
@verbatim
 ===============================================================================
                    ##### Peripheral Control functions #####
 ===============================================================================
    [..]  This section provides functions allowing to:
      (+) Configure the LTDC foreground or/and background parameters.
      (+) Set the active layer.
      (+) Configure the color keying.
      (+) Configure the C-LUT.
      (+) Enable / Disable the color keying.
      (+) Enable / Disable the C-LUT.
      (+) Update the layer position.
      (+) Update the layer size.
      (+) Update pixel format on the fly.
      (+) Update transparency on the fly.
      (+) Update address on the fly.

@endverbatim
  * @{
  *//* NOTE : This function should not be modified, when the callback is needed,
            the HAL_LTDC_ReloadEvenCallback could be implemented in the user file
   *//**
  * @brief  Reload Event callback.
  * @param  hltdc  pointer to a LTDC_HandleTypeDef structure that contains
  *                the configuration information for the LTDC.
  * @retval None
  *//* NOTE : This function should not be modified, when the callback is needed,
            the HAL_LTDC_LineEventCallback could be implemented in the user file
   *//**
  * @brief  Line Event callback.
  * @param  hltdc  pointer to a LTDC_HandleTypeDef structure that contains
  *                the configuration information for the LTDC.
  * @retval None
  *//* NOTE : This function should not be modified, when the callback is needed,
            the HAL_LTDC_ErrorCallback could be implemented in the user file
   *//**
  * @brief  Error LTDC callback.
  * @param  hltdc  pointer to a LTDC_HandleTypeDef structure that contains
  *                the configuration information for the LTDC.
  * @retval None
  *//*Call Legacy Reload Event callback *//*Call registered reload Event callback *//* Reload interrupt Callback *//* Change LTDC state *//* Clear the register reload flag *//* Disable the register reload interrupt *//* Register reload Interrupt management ***************************************//*Call Legacy Line Event callback *//*Call registered Line Event callback *//* Call legacy error callback*//*Call registered error callback*//* Clear the FIFO underrun flag *//* Disable the FIFO underrun interrupt *//* FIFO underrun Interrupt management ***************************************//**
  * @brief  Handle LTDC interrupt request.
  * @param  hltdc  pointer to a LTDC_HandleTypeDef structure that contains
  *                the configuration information for the LTDC.
  * @retval HAL status
  *//** @defgroup LTDC_Exported_Functions_Group2 IO operation functions
  *  @brief   IO operation functions
  *
@verbatim
 ===============================================================================
                      #####  IO operation functions  #####
 ===============================================================================
    [..]  This section provides function allowing to:
      (+) Handle LTDC interrupt request

@endverbatim
  * @{
  *//* Legcay weak MspDeInit Callback     *//* Legcay weak MspInit Callback     *//* Legcay weak MspInit Callback  *//* Legacy weak ReloadEventCallback  *//**
  * @brief  Unregister an LTDC Callback
  *         LTDC callback is redirected to the weak predefined callback
  * @param hltdc ltdc handle
  * @param CallbackID ID of the callback to be unregistered
  *        This parameter can be one of the following values:
  *          @arg @ref HAL_LTDC_LINE_EVENT_CB_ID Line Event Callback ID
  *          @arg @ref HAL_LTDC_RELOAD_EVENT_CB_ID Reload Event Callback ID
  *          @arg @ref HAL_LTDC_ERROR_CB_ID Error Callback ID
  *          @arg @ref HAL_LTDC_MSPINIT_CB_ID MspInit callback ID
  *          @arg @ref HAL_LTDC_MSPDEINIT_CB_ID MspDeInit callback ID
  * @retval status
  *//**
  * @brief  Register a User LTDC Callback
  *         To be used instead of the weak predefined callback
  * @param hltdc ltdc handle
  * @param CallbackID ID of the callback to be registered
  *        This parameter can be one of the following values:
  *          @arg @ref HAL_LTDC_LINE_EVENT_CB_ID Line Event Callback ID
  *          @arg @ref HAL_LTDC_RELOAD_EVENT_CB_ID Reload Event Callback ID
  *          @arg @ref HAL_LTDC_ERROR_CB_ID Error Callback ID
  *          @arg @ref HAL_LTDC_MSPINIT_CB_ID MspInit callback ID
  *          @arg @ref HAL_LTDC_MSPDEINIT_CB_ID MspDeInit callback ID
  * @param pCallback pointer to the Callback function
  * @retval status
  *//* NOTE : This function should not be modified, when the callback is needed,
            the HAL_LTDC_MspDeInit could be implemented in the user file
   *//**
  * @brief  De-initialize the LTDC MSP.
  * @param  hltdc  pointer to a LTDC_HandleTypeDef structure that contains
  *                the configuration information for the LTDC.
  * @retval None
  *//* NOTE : This function should not be modified, when the callback is needed,
            the HAL_LTDC_MspInit could be implemented in the user file
   *//**
  * @brief  Initialize the LTDC MSP.
  * @param  hltdc  pointer to a LTDC_HandleTypeDef structure that contains
  *                the configuration information for the LTDC.
  * @retval None
  *//* Disable LTDC  *//* Wait for VSYNC Interrupt *//* Reload during vertical blanking period *//* LTDC_Layer2_BASE *//* Disable LTDC Layer 2 *//* Disable LTDC Layer 1 *//* Check the LTDC peripheral state *//**
  * @brief  De-initialize the LTDC peripheral.
  * @param  hltdc  pointer to a LTDC_HandleTypeDef structure that contains
  *                the configuration information for the LTDC.
  * @retval None
  *//* Enable LTDC by setting LTDCEN bit *//* Enable the Transfer Error and FIFO underrun interrupts *//* Set the background color value *//* Set Total Width *//* Set Accumulated Active Width *//* Set Accumulated Back porch *//* Set Synchronization size *//* Configure the HS, VS, DE and PC polarity *//* Reset the LTDC callback to the legacy weak callbacks *//**
  * @brief  Initialize the LTDC according to the specified parameters in the LTDC_InitTypeDef.
  * @param  hltdc  pointer to a LTDC_HandleTypeDef structure that contains
  *                the configuration information for the LTDC.
  * @retval HAL status
  *//** @defgroup LTDC_Exported_Functions_Group1 Initialization and Configuration functions
  *  @brief   Initialization and Configuration functions
  *
@verbatim
 ===============================================================================
                ##### Initialization and Configuration functions #####
 ===============================================================================
    [..]  This section provides functions allowing to:
      (+) Initialize and configure the LTDC
      (+) De-initialize the LTDC

@endverbatim
  * @{
  *//** @defgroup LTDC_Exported_Functions LTDC Exported Functions
  * @{
  *//* 100ms *//** @defgroup LTDC_Private_Define LTDC Private Define
  * @{
  *//**
  ******************************************************************************
  * @file    stm32f7xx_hal_ltdc.c
  * @author  MCD Application Team
  * @brief   LTDC HAL module driver.
  *          This file provides firmware functions to manage the following
  *          functionalities of the LTDC peripheral:
  *           + Initialization and de-initialization functions
  *           + IO operation functions
  *           + Peripheral Control functions
  *           + Peripheral State and Errors functions
  *
  ******************************************************************************
  * @attention
  *
  * Copyright (c) 2017 STMicroelectronics.
  * All rights reserved.
  *
  * This software is licensed under terms that can be found in the LICENSE file
  * in the root directory of this software component.
  * If no LICENSE file comes with this software, it is provided AS-IS.
  *
  ******************************************************************************
  @verbatim
  ==============================================================================
                        ##### How to use this driver #####
  ==============================================================================
     [..]
     The LTDC HAL driver can be used as follows:

     (#) Declare a LTDC_HandleTypeDef handle structure, for example: LTDC_HandleTypeDef  hltdc;

     (#) Initialize the LTDC low level resources by implementing the HAL_LTDC_MspInit() API:
         (##) Enable the LTDC interface clock
         (##) NVIC configuration if you need to use interrupt process
             (+++) Configure the LTDC interrupt priority
             (+++) Enable the NVIC LTDC IRQ Channel

     (#) Initialize the required configuration through the following parameters:
         the LTDC timing, the horizontal and vertical polarity, the pixel clock polarity,
         Data Enable polarity and the LTDC background color value using HAL_LTDC_Init() function

     *** Configuration ***
     =========================
     [..]
     (#) Program the required configuration through the following parameters:
         the pixel format, the blending factors, input alpha value, the window size
         and the image size using HAL_LTDC_ConfigLayer() function for foreground
         or/and background layer.

     (#) Optionally, configure and enable the CLUT using HAL_LTDC_ConfigCLUT() and
         HAL_LTDC_EnableCLUT functions.

     (#) Optionally, enable the Dither using HAL_LTDC_EnableDither().

     (#) Optionally, configure and enable the Color keying using HAL_LTDC_ConfigColorKeying()
         and HAL_LTDC_EnableColorKeying functions.

     (#) Optionally, configure LineInterrupt using HAL_LTDC_ProgramLineEvent()
         function

     (#) If needed, reconfigure and change the pixel format value, the alpha value
         value, the window size, the window position and the layer start address
         for foreground or/and background layer using respectively the following
         functions: HAL_LTDC_SetPixelFormat(), HAL_LTDC_SetAlpha(), HAL_LTDC_SetWindowSize(),
         HAL_LTDC_SetWindowPosition() and HAL_LTDC_SetAddress().

     (#) Variant functions with _NoReload suffix allows to set the LTDC configuration/settings without immediate reload.
         This is useful in case when the program requires to modify serval LTDC settings (on one or both layers)
         then applying(reload) these settings in one shot by calling the function HAL_LTDC_Reload().

         After calling the _NoReload functions to set different color/format/layer settings,
         the program shall call the function HAL_LTDC_Reload() to apply(reload) these settings.
         Function HAL_LTDC_Reload() can be called with the parameter ReloadType set to LTDC_RELOAD_IMMEDIATE if
         an immediate reload is required.
         Function HAL_LTDC_Reload() can be called with the parameter ReloadType set to LTDC_RELOAD_VERTICAL_BLANKING if
         the reload should be done in the next vertical blanking period,
         this option allows to avoid display flicker by applying the new settings during the vertical blanking period.


     (#) To control LTDC state you can use the following function: HAL_LTDC_GetState()

     *** LTDC HAL driver macros list ***
     =============================================
     [..]
       Below the list of most used macros in LTDC HAL driver.

      (+) __HAL_LTDC_ENABLE: Enable the LTDC.
      (+) __HAL_LTDC_DISABLE: Disable the LTDC.
      (+) __HAL_LTDC_LAYER_ENABLE: Enable an LTDC Layer.
      (+) __HAL_LTDC_LAYER_DISABLE: Disable an LTDC Layer.
      (+) __HAL_LTDC_RELOAD_IMMEDIATE_CONFIG: Reload  Layer Configuration.
      (+) __HAL_LTDC_GET_FLAG: Get the LTDC pending flags.
      (+) __HAL_LTDC_CLEAR_FLAG: Clear the LTDC pending flags.
      (+) __HAL_LTDC_ENABLE_IT: Enable the specified LTDC interrupts.
      (+) __HAL_LTDC_DISABLE_IT: Disable the specified LTDC interrupts.
      (+) __HAL_LTDC_GET_IT_SOURCE: Check whether the specified LTDC interrupt has occurred or not.

     [..]
       (@) You can refer to the LTDC HAL driver header file for more useful macros


     *** Callback registration ***
     =============================================
     [..]
     The compilation define  USE_HAL_LTDC_REGISTER_CALLBACKS when set to 1
     allows the user to configure dynamically the driver callbacks.
     Use function HAL_LTDC_RegisterCallback() to register a callback.

    [..]
    Function HAL_LTDC_RegisterCallback() allows to register following callbacks:
      (+) LineEventCallback   : LTDC Line Event Callback.
      (+) ReloadEventCallback : LTDC Reload Event Callback.
      (+) ErrorCallback       : LTDC Error Callback
      (+) MspInitCallback     : LTDC MspInit.
      (+) MspDeInitCallback   : LTDC MspDeInit.
    [..]
    This function takes as parameters the HAL peripheral handle, the callback ID
    and a pointer to the user callback function.

    [..]
    Use function HAL_LTDC_UnRegisterCallback() to reset a callback to the default
    weak function.
    HAL_LTDC_UnRegisterCallback() takes as parameters the HAL peripheral handle
    and the callback ID.
    [..]
    This function allows to reset following callbacks:
      (+) LineEventCallback   : LTDC Line Event Callback
      (+) ReloadEventCallback : LTDC Reload Event Callback
      (+) ErrorCallback       : LTDC Error Callback
      (+) MspInitCallback     : LTDC MspInit
      (+) MspDeInitCallback   : LTDC MspDeInit.

    [..]
    By default, after the HAL_LTDC_Init and when the state is HAL_LTDC_STATE_RESET
    all callbacks are set to the corresponding weak functions:
    examples HAL_LTDC_LineEventCallback(), HAL_LTDC_ErrorCallback().
    Exception done for MspInit and MspDeInit functions that are
    reset to the legacy weak (surcharged) functions in the HAL_LTDC_Init() and HAL_LTDC_DeInit()
    only when these callbacks are null (not registered beforehand).
    If not, MspInit or MspDeInit are not null, the HAL_LTDC_Init() and HAL_LTDC_DeInit()
    keep and use the user MspInit/MspDeInit callbacks (registered beforehand).

    [..]
    Callbacks can be registered/unregistered in HAL_LTDC_STATE_READY state only.
    Exception done MspInit/MspDeInit that can be registered/unregistered
    in HAL_LTDC_STATE_READY or HAL_LTDC_STATE_RESET state,
    thus registered (user) MspInit/DeInit callbacks can be used during the Init/DeInit.
    In that case first register the MspInit/MspDeInit user callbacks
    using HAL_LTDC_RegisterCallback() before calling HAL_LTDC_DeInit()
    or HAL_LTDC_Init() function.

    [..]
    When the compilation define USE_HAL_LTDC_REGISTER_CALLBACKS is set to 0 or
    not defined, the callback registration feature is not available and all callbacks
    are set to the corresponding weak functions.

  @endverbatim
  ******************************************************************************
  *//Users/jie/Documents/posixGen_Demos-main/LwIP_StreamingServer/Drivers/STM32F7xx_HAL_Driver/Src/stm32f7xx_hal_ltdc_ex.cdefined(HAL_LTDC_MODULE_ENABLED) && defined(HAL_DSI_MODULE_ENABLED)!defined(POLARITIES_INVERSION_UPDATED)/* HAL_LTCD_MODULE_ENABLED && HAL_DSI_MODULE_ENABLED *//* POLARITIES_INVERSION_UPDATED *//* Note 2: Code to be used in case LTDC polarities inversion updated in the specification *//* Note 1 : Code in line w/ Current LTDC specification *//* The following polarities are inverted:
                     LTDC_DEPOLARITY_AL <-> LTDC_DEPOLARITY_AH
                     LTDC_VSPOLARITY_AL <-> LTDC_VSPOLARITY_AH
                     LTDC_HSPOLARITY_AL <-> LTDC_HSPOLARITY_AH)*//* Retrieve signal polarities from DSI *//**
  * @brief  Retrieve common parameters from DSI Adapted command mode configuration structure
  * @param  hltdc   pointer to a LTDC_HandleTypeDef structure that contains
  *                 the configuration information for the LTDC.
  * @param  CmdCfg  pointer to a DSI_CmdCfgTypeDef structure that contains
  *                 the DSI command mode configuration parameters
  * @note   The implementation of this function is taking into account the LTDC
  *         polarities inversion as described in the current LTDC specification
  * @retval HAL status
  *//* Retrieve vertical timing parameters from DSI *//* The following polarity is inverted:
                     LTDC_DEPOLARITY_AL <-> LTDC_DEPOLARITY_AH *//**
  * @brief  Retrieve common parameters from DSI Video mode configuration structure
  * @param  hltdc   pointer to a LTDC_HandleTypeDef structure that contains
  *                 the configuration information for the LTDC.
  * @param  VidCfg  pointer to a DSI_VidCfgTypeDef structure that contains
  *                 the DSI video mode configuration parameters
  * @note   The implementation of this function is taking into account the LTDC
  *         polarities inversion as described in the current LTDC specification
  * @retval HAL status
  *//** @defgroup LTDCEx_Exported_Functions_Group1 Initialization and Configuration functions
  *  @brief   Initialization and Configuration functions
  *
@verbatim
 ===============================================================================
                ##### Initialization and Configuration functions #####
 ===============================================================================
    [..]  This section provides functions allowing to:
      (+) Initialize and configure the LTDC

@endverbatim
  * @{
  *//** @defgroup LTDCEx_Exported_Functions LTDC Extended Exported Functions
  * @{
  *//** @defgroup LTDCEx LTDCEx
  * @brief LTDC HAL module driver
  * @{
  *//**
  ******************************************************************************
  * @file    stm32f7xx_hal_ltdc_ex.c
  * @author  MCD Application Team
  * @brief   LTDC Extension HAL module driver.
  ******************************************************************************
  * @attention
  *
  * Copyright (c) 2017 STMicroelectronics.
  * All rights reserved.
  *
  * This software is licensed under terms that can be found in the LICENSE file
  * in the root directory of this software component.
  * If no LICENSE file comes with this software, it is provided AS-IS.
  *
  ******************************************************************************
  *//Users/jie/Documents/posixGen_Demos-main/LwIP_StreamingServer/Drivers/STM32F7xx_HAL_Driver/Src/stm32f7xx_hal_pwr.cSCB->SCR((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->SCR((uint32_t)SCB_SCR_SEVONPEND_Msk)((uint32_t)(1UL << 4U))((uint32_t)SCB_SCR_SLEEPONEXIT_Msk)((uint32_t)(1UL << 1U))286721073770496PWR_TypeDef *IS_PWR_REGULATOR(Regulator)IS_PWR_STOP_ENTRY(STOPEntry)(PWR_CR1_PDDS | PWR_CR1_LPDS)(uint32_t)~(PWR_CR1_PDDS | PWR_CR1_LPDS)(uint32_t)SCB_SCR_SLEEPDEEP_Msk((uint32_t)SCB_SCR_SLEEPDEEP_Msk)(uint32_t)~((uint32_t)SCB_SCR_SLEEPDEEP_Msk)IS_PWR_SLEEP_ENTRY(SLEEPEntry)((uint32_t)(1UL << 2U))IS_PWR_WAKEUP_PIN(WakeUpPinx)PWR->CSR2((PWR_TypeDef *) (0x40000000UL + 0x7000UL))->CSR2IS_PWR_WAKEUP_PIN(WakeUpPinPolarity)(PWR_EWUP_MASK & WakeUpPinPolarity)(((uint32_t)0x00003F00) & WakeUpPinPolarity)PWR->CR2((PWR_TypeDef *) (0x40000000UL + 0x7000UL))->CR2(WakeUpPinPolarity >> 0x06)(((PWR_TypeDef *) (0x40000000UL + 0x7000UL))->CR2)(((READ_REG(((PWR_TypeDef *) (0x40000000UL + 0x7000UL))->CR2)) & (~((((uint32_t)0x00003F00) & WakeUpPinPolarity)))) | ((WakeUpPinPolarity >> 0x06)))(((((((PWR_TypeDef *) (0x40000000UL + 0x7000UL))->CR2))) & (~((((uint32_t)0x00003F00) & WakeUpPinPolarity)))) | ((WakeUpPinPolarity >> 0x06)))PWR->CR1((PWR_TypeDef *) (0x40000000UL + 0x7000UL))->CR1IS_PWR_PVD_LEVEL(sConfigPVD->PVDLevel)IS_PWR_PVD_MODE(sConfigPVD->Mode)(0x7UL << (5U))sConfigPVD->PVDLevel(((PWR_TypeDef *) (0x40000000UL + 0x7000UL))->CR1)(((READ_REG(((PWR_TypeDef *) (0x40000000UL + 0x7000UL))->CR1)) & (~((0x7UL << (5U))))) | (sConfigPVD->PVDLevel))(((((((PWR_TypeDef *) (0x40000000UL + 0x7000UL))->CR1))) & (~((0x7UL << (5U))))) | (sConfigPVD->PVDLevel))4294967071EXTI->RTSR((EXTI_TypeDef *) ((0x40000000UL + 0x00010000UL) + 0x3C00UL))->RTSR((uint32_t)(0x1UL << (16U)))EXTI->FTSR((EXTI_TypeDef *) ((0x40000000UL + 0x00010000UL) + 0x3C00UL))->FTSRPVD_MODE_ITPVD_MODE_EVTPVD_RISING_EDGEPVD_FALLING_EDGEPWR_EWUP_MASK((uint32_t)0x00003F00)defined ( __CC_ARM)/* Clear SEVONPEND bit of Cortex System Control Register *//**
  * @brief Disables CORTEX M4 SEVONPEND bit. 
  * @note Clears SEVONPEND bit of SCR register. When this bit is set, this causes 
  *       WFE to wake up when an interrupt moves from inactive to pended.         
  * @retval None
  *//* Set SEVONPEND bit of Cortex System Control Register *//**
  * @brief Enables CORTEX M4 SEVONPEND bit. 
  * @note Sets SEVONPEND bit of SCR register. When this bit is set, this causes 
  *       WFE to wake up when an interrupt moves from inactive to pended.
  * @retval None
  *//* Clear SLEEPONEXIT bit of Cortex System Control Register *//**
  * @brief Disables Sleep-On-Exit feature when returning from Handler mode to Thread mode. 
  * @note Clears SLEEPONEXIT bit of SCR register. When this bit is set, the processor 
  *       re-enters SLEEP mode when an interruption handling is over.          
  * @retval None
  *//* Set SLEEPONEXIT bit of Cortex System Control Register *//**
  * @brief Indicates Sleep-On-Exit when returning from Handler mode to Thread mode. 
  * @note Set SLEEPONEXIT bit of SCR register. When this bit is set, the processor 
  *       re-enters SLEEP mode when an interruption handling is over.
  *       Setting this bit is useful when the processor is expected to run only on
  *       interruptions handling.         
  * @retval None
  *//* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_PWR_PVDCallback could be implemented in the user file
   *//**
  * @brief  PWR PVD interrupt callback
  * @retval None
  *//* Clear PWR Exti pending bit *//* PWR PVD interrupt user callback *//* Check PWR Exti flag *//**
  * @brief This function handles the PWR PVD interrupt request.
  * @note This API should be called under the PVD_IRQHandler().
  * @retval None
  *//* Request Wait For Interrupt *//* This option is used to ensure that store operations are completed *//* Set SLEEPDEEP bit of Cortex System Control Register *//* Select Standby mode *//**
  * @brief Enters Standby mode.
  * @note In Standby mode, all I/O pins are high impedance except for:
  *          - Reset pad (still available) 
  *          - RTC_AF1 pin (PC13) if configured for tamper, time-stamp, RTC 
  *            Alarm out, or RTC clock calibration out.
  *          - RTC_AF2 pin (PI8) if configured for tamper or time-stamp.  
  *          - WKUP pins if enabled.       
  * @retval None
  *//* Reset SLEEPDEEP bit of Cortex System Control Register *//* Request Wait For Event *//* Select Stop mode entry --------------------------------------------------*//* Ensure that all instructions done before entering STOP mode *//* Store the new value *//* Set LPDS, MRLVDS and LPLVDS bits according to Regulator value *//* Clear PDDS and LPDS bits *//* Select the regulator state in Stop mode ---------------------------------*//**
  * @brief Enters Stop mode. 
  * @note In Stop mode, all I/O pins keep the same state as in Run mode.
  * @note When exiting Stop mode by issuing an interrupt or a wakeup event, 
  *         the HSI RC oscillator is selected as system clock.
  * @note When the voltage regulator operates in low power mode, an additional 
  *         startup delay is incurred when waking up from Stop mode. 
  *         By keeping the internal regulator ON during Stop mode, the consumption 
  *         is higher although the startup time is reduced.    
  * @param Regulator Specifies the regulator state in Stop mode.
  *          This parameter can be one of the following values:
  *            @arg PWR_MAINREGULATOR_ON: Stop mode with regulator ON
  *            @arg PWR_LOWPOWERREGULATOR_ON: Stop mode with low power regulator ON
  * @param STOPEntry Specifies if Stop mode in entered with WFI or WFE instruction.
  *          This parameter can be one of the following values:
  *            @arg PWR_STOPENTRY_WFI: Enter Stop mode with WFI instruction
  *            @arg PWR_STOPENTRY_WFE: Enter Stop mode with WFE instruction
  * @retval None
  *//* Select SLEEP mode entry -------------------------------------------------*//* Ensure that all instructions done before entering SLEEP mode *//* Clear SLEEPDEEP bit of Cortex System Control Register *//**
  * @brief Enters Sleep mode.
  *   
  * @note In Sleep mode, all I/O pins keep the same state as in Run mode.
  * 
  * @note In Sleep mode, the systick is stopped to avoid exit from this mode with
  *       systick interrupt when used as time base for Timeout 
  *                
  * @param Regulator Specifies the regulator state in SLEEP mode.
  *            This parameter can be one of the following values:
  *            @arg PWR_MAINREGULATOR_ON: SLEEP mode with regulator ON
  *            @arg PWR_LOWPOWERREGULATOR_ON: SLEEP mode with low power regulator ON
  * @note This parameter is not used for the STM32F7 family and is kept as parameter
  *       just to maintain compatibility with the lower power families.
  * @param SLEEPEntry Specifies if SLEEP mode in entered with WFI or WFE instruction.
  *          This parameter can be one of the following values:
  *            @arg PWR_SLEEPENTRY_WFI: enter SLEEP mode with WFI instruction
  *            @arg PWR_SLEEPENTRY_WFE: enter SLEEP mode with WFE instruction
  * @retval None
  *//**
  * @brief Disables the WakeUp PINx functionality.
  * @param WakeUpPinx Specifies the Power Wake-Up pin to disable.
  *         This parameter can be one of the following values:
  *           @arg PWR_WAKEUP_PIN1
  *           @arg PWR_WAKEUP_PIN2
  *           @arg PWR_WAKEUP_PIN3
  *           @arg PWR_WAKEUP_PIN4
  *           @arg PWR_WAKEUP_PIN5
  *           @arg PWR_WAKEUP_PIN6 
  * @retval None
  *//* Specifies the Wake-Up pin polarity for the event detection
    (rising or falling edge) *//* Enable wake-up pin *//**
  * @brief Enable the WakeUp PINx functionality.
  * @param WakeUpPinPolarity Specifies which Wake-Up pin to enable.
  *         This parameter can be one of the following legacy values, which sets the default polarity: 
  *         detection on high level (rising edge):
  *           @arg PWR_WAKEUP_PIN1, PWR_WAKEUP_PIN2, PWR_WAKEUP_PIN3, PWR_WAKEUP_PIN4, PWR_WAKEUP_PIN5, PWR_WAKEUP_PIN6 
  *         or one of the following value where the user can explicitly states the enabled pin and
  *         the chosen polarity  
  *           @arg PWR_WAKEUP_PIN1_HIGH or PWR_WAKEUP_PIN1_LOW 
  *           @arg PWR_WAKEUP_PIN2_HIGH or PWR_WAKEUP_PIN2_LOW 
  *           @arg PWR_WAKEUP_PIN3_HIGH or PWR_WAKEUP_PIN3_LOW 
  *           @arg PWR_WAKEUP_PIN4_HIGH or PWR_WAKEUP_PIN4_LOW
  *           @arg PWR_WAKEUP_PIN5_HIGH or PWR_WAKEUP_PIN5_LOW 
  *           @arg PWR_WAKEUP_PIN6_HIGH or PWR_WAKEUP_PIN6_LOW 
  * @note  PWR_WAKEUP_PINx and PWR_WAKEUP_PINx_HIGH are equivalent.               
  * @retval None
  *//* Disable the power voltage detector *//**
  * @brief Disables the Power Voltage Detector(PVD).
  * @retval None
  *//* Enable the power voltage detector *//**
  * @brief Enables the Power Voltage Detector(PVD).
  * @retval None
  *//* Configure the edge *//* Configure event mode *//* Configure interrupt mode *//* Clear any previous config. Keep it clear if no event or IT mode is selected *//* Set PLS[7:5] bits according to PVDLevel value *//**
  * @brief Configures the voltage threshold detected by the Power Voltage Detector(PVD).
  * @param sConfigPVD pointer to an PWR_PVDTypeDef structure that contains the configuration
  *        information for the PVD.
  * @note Refer to the electrical characteristics of your device datasheet for
  *         more details about the voltage threshold corresponding to each 
  *         detection level.
  * @retval None
  *//** @defgroup PWR_Exported_Functions_Group2 Peripheral Control functions 
  *  @brief Low Power modes configuration functions 
  *
@verbatim

 ===============================================================================
                 ##### Peripheral Control functions #####
 ===============================================================================
     
    *** PVD configuration ***
    =========================
    [..]
      (+) The PVD is used to monitor the VDD power supply by comparing it to a 
          threshold selected by the PVD Level (PLS[2:0] bits in the PWR_CR).
      (+) A PVDO flag is available to indicate if VDD/VDDA is higher or lower 
          than the PVD threshold. This event is internally connected to the EXTI 
          line16 and can generate an interrupt if enabled. This is done through
          __HAL_PWR_PVD_EXTI_ENABLE_IT() macro.
      (+) The PVD is stopped in Standby mode.

    *** Wake-up pin configuration ***
    ================================
    [..]
      (+) Wake-up pin is used to wake up the system from Standby mode. This pin is 
          forced in input pull-down configuration and is active on rising edges.
      (+) There are up to 6 Wake-up pin in the STM32F7 devices family

    *** Low Power modes configuration ***
    =====================================
    [..]
      The devices feature 3 low-power modes:
      (+) Sleep mode: Cortex-M7 core stopped, peripherals kept running.
      (+) Stop mode: all clocks are stopped, regulator running, regulator 
          in low power mode
      (+) Standby mode: 1.2V domain powered off.
   
   *** Sleep mode ***
   ==================
    [..]
      (+) Entry:
        The Sleep mode is entered by using the HAL_PWR_EnterSLEEPMode(PWR_MAINREGULATOR_ON, PWR_SLEEPENTRY_WFI)
              functions with
          (++) PWR_SLEEPENTRY_WFI: enter SLEEP mode with WFI instruction
          (++) PWR_SLEEPENTRY_WFE: enter SLEEP mode with WFE instruction
      
      -@@- The Regulator parameter is not used for the STM32F7 family 
              and is kept as parameter just to maintain compatibility with the 
              lower power families (STM32L).
      (+) Exit:
        Any peripheral interrupt acknowledged by the nested vectored interrupt 
              controller (NVIC) can wake up the device from Sleep mode.

   *** Stop mode ***
   =================
    [..]
      In Stop mode, all clocks in the 1.2V domain are stopped, the PLL, the HSI,
      and the HSE RC oscillators are disabled. Internal SRAM and register contents 
      are preserved.
      The voltage regulator can be configured either in normal or low-power mode.
      To minimize the consumption In Stop mode, FLASH can be powered off before 
      entering the Stop mode using the HAL_PWREx_EnableFlashPowerDown() function.
      It can be switched on again by software after exiting the Stop mode using
      the HAL_PWREx_DisableFlashPowerDown() function. 

      (+) Entry:
         The Stop mode is entered using the HAL_PWR_EnterSTOPMode(PWR_MAINREGULATOR_ON) 
             function with:
          (++) Main regulator ON.
          (++) Low Power regulator ON.
      (+) Exit:
        Any EXTI Line (Internal or External) configured in Interrupt/Event mode.

   *** Standby mode ***
   ====================
    [..]
    (+)
      The Standby mode allows to achieve the lowest power consumption. It is based 
      on the Cortex-M7 deep sleep mode, with the voltage regulator disabled. 
      The 1.2V domain is consequently powered off. The PLL, the HSI oscillator and 
      the HSE oscillator are also switched off. SRAM and register contents are lost 
      except for the RTC registers, RTC backup registers, backup SRAM and Standby 
      circuitry.
   
      The voltage regulator is OFF.
      
      (++) Entry:
        (+++) The Standby mode is entered using the HAL_PWR_EnterSTANDBYMode() function.
      (++) Exit:
        (+++) WKUP pin rising or falling edge, RTC alarm (Alarm A and Alarm B), RTC
             wakeup, tamper event, time stamp event, external reset in NRST pin, IWDG reset.

   *** Auto-wakeup (AWU) from low-power mode ***
   =============================================
    [..]
    
     (+) The MCU can be woken up from low-power mode by an RTC Alarm event, an RTC 
      Wakeup event, a tamper event or a time-stamp event, without depending on 
      an external interrupt (Auto-wakeup mode).

      (+) RTC auto-wakeup (AWU) from the Stop and Standby modes
       
        (++) To wake up from the Stop mode with an RTC alarm event, it is necessary to 
              configure the RTC to generate the RTC alarm using the HAL_RTC_SetAlarm_IT() function.

        (++) To wake up from the Stop mode with an RTC Tamper or time stamp event, it 
             is necessary to configure the RTC to detect the tamper or time stamp event using the
                HAL_RTCEx_SetTimeStamp_IT() or HAL_RTCEx_SetTamper_IT() functions.
                  
        (++) To wake up from the Stop mode with an RTC WakeUp event, it is necessary to
              configure the RTC to generate the RTC WakeUp event using the HAL_RTCEx_SetWakeUpTimer_IT() function.

@endverbatim
  * @{
  *//* Disable access to RTC and backup registers *//**
  * @brief Disables access to the backup domain (RTC registers, RTC 
  *         backup data registers and backup SRAM).
  * @note If the HSE divided by 2, 3, ..31 is used as the RTC clock, the 
  *         Backup Domain Access should be kept enabled.
  * @retval None
  *//* Enable access to RTC and backup registers *//**
  * @brief Enables access to the backup domain (RTC registers, RTC 
  *         backup data registers and backup SRAM).
  * @note If the HSE divided by 2, 3, ..31 is used as the RTC clock, the 
  *         Backup Domain Access should be kept enabled.
  * @retval None
  *//**
  * @brief Deinitializes the HAL PWR peripheral registers to their default reset values.
  * @retval None
  *//** @defgroup PWR_Exported_Functions_Group1 Initialization and de-initialization functions 
  *  @brief    Initialization and de-initialization functions
  *
@verbatim
 ===============================================================================
              ##### Initialization and de-initialization functions #####
 ===============================================================================
    [..]
      After reset, the backup domain (RTC registers, RTC backup data 
      registers and backup SRAM) is protected against possible unwanted 
      write accesses. 
      To enable access to the RTC Domain and RTC registers, proceed as follows:
        (+) Enable the Power Controller (PWR) APB1 interface clock using the
            __HAL_RCC_PWR_CLK_ENABLE() macro.
        (+) Enable access to RTC domain using the HAL_PWR_EnableBkUpAccess() function.
 
@endverbatim
  * @{
  *//** @defgroup PWR_Exported_Functions PWR Exported Functions
  * @{
  *//** @defgroup PWR_ENABLE_WUP_Mask PWR Enable WUP Mask
  * @{
  *//** @defgroup PWR_PVD_Mode_Mask PWR PVD Mode Mask
  * @{
  *//** @addtogroup PWR_Private_Constants
  * @{
  *//** @defgroup PWR PWR
  * @brief PWR HAL module driver
  * @{
  *//**
  ******************************************************************************
  * @file    stm32f7xx_hal_pwr.c
  * @author  MCD Application Team
  * @brief   PWR HAL module driver.
  *          This file provides firmware functions to manage the following 
  *          functionalities of the Power Controller (PWR) peripheral:
  *           + Initialization and de-initialization functions
  *           + Peripheral Control functions 
  *         
  ******************************************************************************
  * @attention
  *
  * Copyright (c) 2017 STMicroelectronics.
  * All rights reserved.
  *
  * This software is licensed under terms that can be found in the LICENSE file
  * in the root directory of this software component.
  * If no LICENSE file comes with this software, it is provided AS-IS.
  *
  ******************************************************************************
  *//Users/jie/Documents/posixGen_Demos-main/LwIP_StreamingServer/Drivers/STM32F7xx_HAL_Driver/Src/stm32f7xx_hal_pwr_ex.cIS_PWR_REGULATOR_VOLTAGE(VoltageScaling)(0x1UL << (28U))RCC->CR((RCC_TypeDef *) ((0x40000000UL + 0x00020000UL) + 0x3800UL))->CR(0x3UL << (14U))(VoltageScaling)(((READ_REG(((PWR_TypeDef *) (0x40000000UL + 0x7000UL))->CR1)) & (~((0x3UL << (14U))))) | ((VoltageScaling)))(((((((PWR_TypeDef *) (0x40000000UL + 0x7000UL))->CR1))) & (~((0x3UL << (14U))))) | ((VoltageScaling)))PWR_VOSRDY_TIMEOUT_VALUEtempregIS_PWR_REGULATOR_UNDERDRIVE(Regulator)786688(0x3UL << (18U))PWR_UDERDRIVE_TIMEOUT_VALUE10273075(PWR_CR1_PDDS | PWR_CR1_LPDS | PWR_CR1_LPUDS | PWR_CR1_MRUDS)4294964220(uint32_t)~(PWR_CR1_PDDS | PWR_CR1_LPDS | PWR_CR1_LPUDS | PWR_CR1_MRUDS)(0x1UL << (17U))PWR_OVERDRIVE_TIMEOUT_VALUE(uint32_t)PWR_CR1_LPUDS((uint32_t)PWR_CR1_LPUDS)(uint32_t)~((uint32_t)PWR_CR1_LPUDS)(uint32_t)PWR_CR1_MRUDS((uint32_t)PWR_CR1_MRUDS)(uint32_t)~((uint32_t)PWR_CR1_MRUDS)(uint32_t)PWR_CR1_FPDS((uint32_t)PWR_CR1_FPDS)(uint32_t)~((uint32_t)PWR_CR1_FPDS)(uint32_t)PWR_CSR1_BRE((uint32_t)PWR_CSR1_BRE)(uint32_t)~((uint32_t)PWR_CSR1_BRE)PWR_BKPREG_TIMEOUT_VALUE/* Get Start Tick *//* Wait till PLL is ready *//* Enable the main PLL *//* Set Range *//* Wait till PLL is disabled *//* Disable the main PLL *//* Check if the PLL is used as system clock or not *//* Enable Power ctrl clock *//**
  * @brief Configures the main internal regulator output voltage.
  * @param  VoltageScaling specifies the regulator output voltage to achieve
  *         a tradeoff between performance and power consumption.
  *          This parameter can be one of the following values:
  *            @arg PWR_REGULATOR_VOLTAGE_SCALE1: Regulator voltage output range 1 mode,
  *                                                typical output voltage at 1.4 V,  
  *                                                system frequency up to 216 MHz.
  *            @arg PWR_REGULATOR_VOLTAGE_SCALE2: Regulator voltage output range 2 mode,
  *                                                typical output voltage at 1.2 V,                
  *                                                system frequency up to 180 MHz.
  *            @arg PWR_REGULATOR_VOLTAGE_SCALE3: Regulator voltage output range 2 mode,
  *                                                typical output voltage at 1.00 V,                
  *                                                system frequency up to 151 MHz.
  * @note To update the system clock frequency(SYSCLK):
  *        - Set the HSI or HSE as system clock frequency using the HAL_RCC_ClockConfig().
  *        - Call the HAL_RCC_OscConfig() to configure the PLL.
  *        - Call HAL_PWREx_ConfigVoltageScaling() API to adjust the voltage scale.
  *        - Set the new system clock frequency using the HAL_RCC_ClockConfig().
  * @note The scale can be modified only when the HSI or HSE clock source is selected 
  *        as system clock source, otherwise the API returns HAL_ERROR.  
  * @note When the PLL is OFF, the voltage scale 3 is automatically selected and the VOS bits
  *       value in the PWR_CR1 register are not taken in account.
  * @note This API forces the PLL state ON to allow the possibility to configure the voltage scale 1 or 2.
  * @note The new voltage scale is active only when the PLL is ON.  
  * @retval HAL Status
  *//**
  * @brief Returns Voltage Scaling Range.
  * @retval VOS bit field (PWR_REGULATOR_VOLTAGE_SCALE1, PWR_REGULATOR_VOLTAGE_SCALE2 or 
  *            PWR_REGULATOR_VOLTAGE_SCALE3)PWR_REGULATOR_VOLTAGE_SCALE1
  *//* Select STOP mode entry --------------------------------------------------*//* Set LPDS, MRLUDS and LPLUDS bits according to PWR_Regulator value *//* Clear PDDS, LPDS, MRLUDS and LPLUDS bits *//* Select the regulator state in STOP mode ---------------------------------*//* Wait for UnderDrive mode is ready *//* Enable the Under-drive *//* Clear Under-drive flag *//* Enable the Under-drive Mode ---------------------------------------------*//**
  * @brief  Enters in Under-Drive STOP mode.
  * 
  * @note    This mode can be selected only when the Under-Drive is already active 
  *   
  * @note    This mode is enabled only with STOP low power mode.
  *          In this mode, the 1.2V domain is preserved in reduced leakage mode. This 
  *          mode is only available when the main regulator or the low power regulator 
  *          is in low voltage mode
  *        
  * @note   If the Under-drive mode was enabled, it is automatically disabled after 
  *         exiting Stop mode. 
  *         When the voltage regulator operates in Under-drive mode, an additional  
  *         startup delay is induced when waking up from Stop mode.
  *                    
  * @note   In Stop mode, all I/O pins keep the same state as in Run mode.
  *   
  * @note   When exiting Stop mode by issuing an interrupt or a wakeup event, 
  *         the HSI RC oscillator is selected as system clock.
  *           
  * @note   When the voltage regulator operates in low power mode, an additional 
  *         startup delay is incurred when waking up from Stop mode. 
  *         By keeping the internal regulator ON during Stop mode, the consumption 
  *         is higher although the startup time is reduced.
  *     
  * @param  Regulator specifies the regulator state in STOP mode.
  *          This parameter can be one of the following values:
  *            @arg PWR_MAINREGULATOR_UNDERDRIVE_ON:  Main Regulator in under-drive mode 
  *                 and Flash memory in power-down when the device is in Stop under-drive mode
  *            @arg PWR_LOWPOWERREGULATOR_UNDERDRIVE_ON:  Low Power Regulator in under-drive mode 
  *                and Flash memory in power-down when the device is in Stop under-drive mode
  * @param  STOPEntry specifies if STOP mode in entered with WFI or WFE instruction.
  *          This parameter can be one of the following values:
  *            @arg PWR_SLEEPENTRY_WFI: enter STOP mode with WFI instruction
  *            @arg PWR_SLEEPENTRY_WFE: enter STOP mode with WFE instruction
  * @retval None
  *//* Disable the Over-drive *//* Disable the Over-drive switch *//**
  * @brief  Deactivates the Over-Drive mode.
  * @note   This mode allows the CPU and the core logic to operate at a higher frequency
  *         than the normal mode for a given voltage scaling (scale 1, scale 2 or scale 3).    
  * @note   It is recommended to enter or exit Over-drive mode when the application is not running 
  *         critical tasks and when the system clock source is either HSI or HSE. 
  *         During the Over-drive switch activation, no peripheral clocks should be enabled.   
  *         The peripheral clocks must be enabled once the Over-drive mode is activated.
  * @retval HAL status
  *//* Enable the Over-drive switch *//* Enable the Over-drive to extend the clock frequency to 216 MHz *//**
  * @brief  Activates the Over-Drive mode.
  * @note   This mode allows the CPU and the core logic to operate at a higher frequency
  *         than the normal mode for a given voltage scaling (scale 1, scale 2 or scale 3).   
  * @note   It is recommended to enter or exit Over-drive mode when the application is not running 
  *         critical tasks and when the system clock source is either HSI or HSE. 
  *         During the Over-drive switch activation, no peripheral clocks should be enabled.   
  *         The peripheral clocks must be enabled once the Over-drive mode is activated.   
  * @retval HAL status
  *//* Disable low power regulator *//**
  * @brief Disables Low Power Regulator low voltage mode.
  * @retval None
  *//* Enable low power regulator *//**
  * @brief Enables Low Power Regulator low voltage mode.
  * @retval None
  *//* Disable Main regulator low voltage *//**
  * @brief Disables Main Regulator low voltage mode.
  * @retval None
  *//* Enable Main regulator low voltage *//**
  * @brief Enables Main Regulator low voltage mode.
  * @retval None
  *//* Disable the Flash Power Down *//**
  * @brief Disables the Flash Power Down in Stop mode.
  * @retval None
  *//* Enable the Flash Power Down *//**
  * @brief Enables the Flash Power Down in Stop mode.
  * @retval None
  *//* Wait till Backup regulator ready flag is set *//* Id 19: PWR : No STANDBY wake-up when Back-up RAM enabled (ref. Errata Sheet p23) *//* Workaround for the following hardware bug: *//* Disable Backup regulator *//**
  * @brief Disables the Backup Regulator.
  * @retval HAL status
  *//* Enable Backup regulator *//**
  * @brief Enables the Backup Regulator.
  * @retval HAL status
  *//** @defgroup PWREx_Exported_Functions_Group1 Peripheral Extended features functions 
  *  @brief Peripheral Extended features functions 
  *
@verbatim   

 ===============================================================================
                 ##### Peripheral extended features functions #####
 ===============================================================================

    *** Main and Backup Regulators configuration ***
    ================================================
    [..] 
      (+) The backup domain includes 4 Kbytes of backup SRAM accessible only from 
          the CPU, and address in 32-bit, 16-bit or 8-bit mode. Its content is 
          retained even in Standby or VBAT mode when the low power backup regulator
          is enabled. It can be considered as an internal EEPROM when VBAT is 
          always present. You can use the HAL_PWREx_EnableBkUpReg() function to 
          enable the low power backup regulator. 

      (+) When the backup domain is supplied by VDD (analog switch connected to VDD) 
          the backup SRAM is powered from VDD which replaces the VBAT power supply to 
          save battery life.

      (+) The backup SRAM is not mass erased by a tamper event. It is read 
          protected to prevent confidential data, such as cryptographic private 
          key, from being accessed. The backup SRAM can be erased only through 
          the Flash interface when a protection level change from level 1 to 
          level 0 is requested. 
      -@- Refer to the description of Read protection (RDP) in the Flash 
          programming manual.

      (+) The main internal regulator can be configured to have a tradeoff between 
          performance and power consumption when the device does not operate at 
          the maximum frequency. This is done through __HAL_PWR_MAINREGULATORMODE_CONFIG() 
          macro which configure VOS bit in PWR_CR register
          
        Refer to the product datasheets for more details.

    *** FLASH Power Down configuration ****
    =======================================
    [..] 
      (+) By setting the FPDS bit in the PWR_CR register by using the 
          HAL_PWREx_EnableFlashPowerDown() function, the Flash memory also enters power 
          down mode when the device enters Stop mode. When the Flash memory 
          is in power down mode, an additional startup delay is incurred when 
          waking up from Stop mode.

    *** Over-Drive and Under-Drive configuration ****
    =================================================
    [..]         
       (+) In Run mode: the main regulator has 2 operating modes available:
        (++) Normal mode: The CPU and core logic operate at maximum frequency at a given 
             voltage scaling (scale 1, scale 2 or scale 3)
        (++) Over-drive mode: This mode allows the CPU and the core logic to operate at a 
            higher frequency than the normal mode for a given voltage scaling (scale 1,  
            scale 2 or scale 3). This mode is enabled through HAL_PWREx_EnableOverDrive() function and
            disabled by HAL_PWREx_DisableOverDrive() function, to enter or exit from Over-drive mode please follow 
            the sequence described in Reference manual.
             
       (+) In Stop mode: the main regulator or low power regulator supplies a low power 
           voltage to the 1.2V domain, thus preserving the content of registers 
           and internal SRAM. 2 operating modes are available:
         (++) Normal mode: the 1.2V domain is preserved in nominal leakage mode. This mode is only 
              available when the main regulator or the low power regulator is used in Scale 3 or 
              low voltage mode.
         (++) Under-drive mode: the 1.2V domain is preserved in reduced leakage mode. This mode is only
              available when the main regulator or the low power regulator is in low voltage mode.

@endverbatim
  * @{
  *//** @defgroup PWREx_Exported_Functions PWREx Exported Functions
  *  @{
  *//** @addtogroup PWREx_Private_Constants
  * @{
  *//** @defgroup PWREx PWREx
  * @brief PWR HAL module driver
  * @{
  *//**
  ******************************************************************************
  * @file    stm32f7xx_hal_pwr_ex.c
  * @author  MCD Application Team
  * @brief   Extended PWR HAL module driver.
  *          This file provides firmware functions to manage the following 
  *          functionalities of PWR extension peripheral:           
  *           + Peripheral Extended features functions
  *         
  ******************************************************************************
  * @attention
  *
  * Copyright (c) 2017 STMicroelectronics.
  * All rights reserved.
  *
  * This software is licensed under terms that can be found in the LICENSE file
  * in the root directory of this software component.
  * If no LICENSE file comes with this software, it is provided AS-IS.
  *
  ******************************************************************************
  *//Users/jie/Documents/posixGen_Demos-main/LwIP_StreamingServer/Drivers/STM32F7xx_HAL_Driver/Src/stm32f7xx_hal_rcc.c1073887244107388724632768032704(0x7UL << (28U))1879048192pllmpllvcopllpsysclockfreq16000000(uint64_t) HSE_VALUE(uint64_t) HSI_VALUE(0x1UL << (19U))IS_RCC_MCO(RCC_MCOx)IS_RCC_MCODIV(RCC_MCODiv)IS_RCC_MCO1SOURCE(RCC_MCOSource)RCC->CFGR((RCC_TypeDef *) ((0x40000000UL + 0x00020000UL) + 0x3800UL))->CFGR(RCC_CFGR_MCO1 | RCC_CFGR_MCO1PRE)((0x3UL << (21U)) | (0x7UL << (24U)))(RCC_MCOSource | RCC_MCODiv)(((RCC_TypeDef *) ((0x40000000UL + 0x00020000UL) + 0x3800UL))->CFGR)(((READ_REG(((RCC_TypeDef *) ((0x40000000UL + 0x00020000UL) + 0x3800UL))->CFGR)) & (~(((0x3UL << (21U)) | (0x7UL << (24U)))))) | ((RCC_MCOSource | RCC_MCODiv)))(((((((RCC_TypeDef *) ((0x40000000UL + 0x00020000UL) + 0x3800UL))->CFGR))) & (~(((0x3UL << (21U)) | (0x7UL << (24U)))))) | ((RCC_MCOSource | RCC_MCODiv)))IS_RCC_MCO2SOURCE(RCC_MCOSource)(RCC_CFGR_MCO2 | RCC_CFGR_MCO2PRE)((0x3UL << (30U)) | (0x7UL << (27U)))(RCC_MCOSource | (RCC_MCODiv << 3))(((READ_REG(((RCC_TypeDef *) ((0x40000000UL + 0x00020000UL) + 0x3800UL))->CFGR)) & (~(((0x3UL << (30U)) | (0x7UL << (27U)))))) | ((RCC_MCOSource | (RCC_MCODiv << 3))))(((((((RCC_TypeDef *) ((0x40000000UL + 0x00020000UL) + 0x3800UL))->CFGR))) & (~(((0x3UL << (30U)) | (0x7UL << (27U)))))) | ((RCC_MCOSource | (RCC_MCODiv << 3))))11744051212373196841712353279395240964160749568134217727IS_RCC_CLOCKTYPE(RCC_ClkInitStruct->ClockType)IS_FLASH_LATENCY(FLatency)(FLASH->ACR)(((FLASH_TypeDef *) ((0x40000000UL + 0x00020000UL) + 0x3C00UL))->ACR)(0xFUL << (0U))(uint32_t)(FLatency)(((READ_REG(((FLASH_TypeDef *) ((0x40000000UL + 0x00020000UL) + 0x3C00UL))->ACR)) & (~((0xFUL << (0U))))) | ((uint32_t)(FLatency)))(((((((FLASH_TypeDef *) ((0x40000000UL + 0x00020000UL) + 0x3C00UL))->ACR))) & (~((0xFUL << (0U))))) | ((uint32_t)(FLatency)))(0x7UL << (10U))(((READ_REG(((RCC_TypeDef *) ((0x40000000UL + 0x00020000UL) + 0x3800UL))->CFGR)) & (~((0x7UL << (10U))))) | (0x00001C00U))(((((((RCC_TypeDef *) ((0x40000000UL + 0x00020000UL) + 0x3800UL))->CFGR))) & (~((0x7UL << (10U))))) | (0x00001C00U))(0x7UL << (13U))(RCC_HCLK_DIV16 << 3)(0x00001C00U << 3)(((READ_REG(((RCC_TypeDef *) ((0x40000000UL + 0x00020000UL) + 0x3800UL))->CFGR)) & (~((0x7UL << (13U))))) | ((0x00001C00U << 3)))(((((((RCC_TypeDef *) ((0x40000000UL + 0x00020000UL) + 0x3800UL))->CFGR))) & (~((0x7UL << (13U))))) | ((0x00001C00U << 3)))IS_RCC_HCLK(RCC_ClkInitStruct->AHBCLKDivider)(0xFUL << (4U))RCC_ClkInitStruct->AHBCLKDivider(((READ_REG(((RCC_TypeDef *) ((0x40000000UL + 0x00020000UL) + 0x3800UL))->CFGR)) & (~((0xFUL << (4U))))) | (RCC_ClkInitStruct->AHBCLKDivider))(((((((RCC_TypeDef *) ((0x40000000UL + 0x00020000UL) + 0x3800UL))->CFGR))) & (~((0xFUL << (4U))))) | (RCC_ClkInitStruct->AHBCLKDivider))4294960127IS_RCC_SYSCLKSOURCE(RCC_ClkInitStruct->SYSCLKSource)RCC_ClkInitStruct->SYSCLKSource(0x3UL << (0U))(RCC_ClkInitStruct->SYSCLKSource)(((READ_REG(((RCC_TypeDef *) ((0x40000000UL + 0x00020000UL) + 0x3800UL))->CFGR)) & (~((0x3UL << (0U))))) | ((RCC_ClkInitStruct->SYSCLKSource)))(((((((RCC_TypeDef *) ((0x40000000UL + 0x00020000UL) + 0x3800UL))->CFGR))) & (~((0x3UL << (0U))))) | ((RCC_ClkInitStruct->SYSCLKSource)))5000IS_RCC_PCLK(RCC_ClkInitStruct->APB1CLKDivider)RCC_ClkInitStruct->APB1CLKDivider(((READ_REG(((RCC_TypeDef *) ((0x40000000UL + 0x00020000UL) + 0x3800UL))->CFGR)) & (~((0x7UL << (10U))))) | (RCC_ClkInitStruct->APB1CLKDivider))(((((((RCC_TypeDef *) ((0x40000000UL + 0x00020000UL) + 0x3800UL))->CFGR))) & (~((0x7UL << (10U))))) | (RCC_ClkInitStruct->APB1CLKDivider))IS_RCC_PCLK(RCC_ClkInitStruct->APB2CLKDivider)((RCC_ClkInitStruct->APB2CLKDivider) << 3)(((READ_REG(((RCC_TypeDef *) ((0x40000000UL + 0x00020000UL) + 0x3800UL))->CFGR)) & (~((0x7UL << (13U))))) | (((RCC_ClkInitStruct->APB2CLKDivider) << 3)))(((((((RCC_TypeDef *) ((0x40000000UL + 0x00020000UL) + 0x3800UL))->CFGR))) & (~((0x7UL << (13U))))) | (((RCC_ClkInitStruct->APB2CLKDivider) << 3)))pll_configpwrclkchangedIS_RCC_OSCILLATORTYPE(RCC_OscInitStruct->OscillatorType)IS_RCC_HSE(RCC_OscInitStruct->HSEState)RCC_OscInitStruct->HSEState(0x1UL << (18U))IS_RCC_HSI(RCC_OscInitStruct->HSIState)IS_RCC_CALIBRATION_VALUE(RCC_OscInitStruct->HSICalibrationValue)RCC_OscInitStruct->HSICalibrationValue(uint32_t)(RCC_OscInitStruct->HSICalibrationValue) << RCC_CR_HSITRIM_Pos(uint32_t)(RCC_OscInitStruct->HSICalibrationValue) << (3U)(((RCC_TypeDef *) ((0x40000000UL + 0x00020000UL) + 0x3800UL))->CR)(((READ_REG(((RCC_TypeDef *) ((0x40000000UL + 0x00020000UL) + 0x3800UL))->CR)) & (~((0x1FUL << (3U))))) | ((uint32_t)(RCC_OscInitStruct->HSICalibrationValue) << (3U)))(((((((RCC_TypeDef *) ((0x40000000UL + 0x00020000UL) + 0x3800UL))->CR))) & (~((0x1FUL << (3U))))) | ((uint32_t)(RCC_OscInitStruct->HSICalibrationValue) << (3U)))IS_RCC_LSI(RCC_OscInitStruct->LSIState)IS_RCC_LSE(RCC_OscInitStruct->LSEState)RCC_OscInitStruct->LSEStateRCC->BDCR((RCC_TypeDef *) ((0x40000000UL + 0x00020000UL) + 0x3800UL))->BDCRIS_RCC_PLL(RCC_OscInitStruct->PLL.PLLState)IS_RCC_PLLSOURCE(RCC_OscInitStruct->PLL.PLLSource)IS_RCC_PLLM_VALUE(RCC_OscInitStruct->PLL.PLLM)IS_RCC_PLLN_VALUE(RCC_OscInitStruct->PLL.PLLN)IS_RCC_PLLP_VALUE(RCC_OscInitStruct->PLL.PLLP)IS_RCC_PLLQ_VALUE(RCC_OscInitStruct->PLL.PLLQ)IS_RCC_PLLR_VALUE(RCC_OscInitStruct->PLL.PLLR)RCC_OscInitStruct->PLL.PLLSourceRCC_OscInitStruct->PLL.PLLMRCC_OscInitStruct->PLL.PLLNRCC_OscInitStruct->PLL.PLLPRCC_OscInitStruct->PLL.PLLQRCC_OscInitStruct->PLL.PLLR(0x3FUL << (0U))(0x1FFUL << (6U))(0xFUL << (24U))(0x10UL << (3U))RCC_CR_HSEON | RCC_CR_HSEBYP | RCC_CR_CSSON(0x1UL << (16U)) | (0x1UL << (18U)) | (0x1UL << (19U))8519684294115327(0x1UL << (29U))4112123046712116860399208067121152603992064RCC->CIR((RCC_TypeDef *) ((0x40000000UL + 0x00020000UL) + 0x3800UL))->CIRRCC_CIR_LSIRDYIE | RCC_CIR_LSERDYIE | RCC_CIR_HSIRDYIE | RCC_CIR_HSERDYIE | RCC_CIR_PLLRDYIE | RCC_CIR_PLLI2SRDYIE | RCC_CIR_PLLSAIRDYIE(0x1UL << (8U)) | (0x1UL << (9U)) | (0x1UL << (10U)) | (0x1UL << (11U)) | (0x1UL << (12U)) | (0x1UL << (13U)) | (0x1UL << (14U))4294934783RCC_CIR_LSIRDYC | RCC_CIR_LSERDYC | RCC_CIR_HSIRDYC | RCC_CIR_HSERDYC | RCC_CIR_PLLRDYC | RCC_CIR_PLLI2SRDYC | RCC_CIR_PLLSAIRDYC | RCC_CIR_CSSC(0x1UL << (16U)) | (0x1UL << (17U)) | (0x1UL << (18U)) | (0x1UL << (19U)) | (0x1UL << (20U)) | (0x1UL << (21U)) | (0x1UL << (22U)) | (0x1UL << (23U))41287688323072RCC->CSR((RCC_TypeDef *) ((0x40000000UL + 0x00020000UL) + 0x3800UL))->CSRMCO2_PINMCO2_GPIO_PORTMCO2_CLK_ENABLE()MCO1_PINMCO1_GPIO_PORTMCO1_CLK_ENABLE()defined (RCC_PLLCFGR_PLLR)/* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_RCC_CSSCallback could be implemented in the user file
   *//**
  * @brief  RCC Clock Security System interrupt callback
  * @retval None
  *//* Clear RCC CSS pending bit *//* RCC Clock Security System interrupt user callback *//* Check RCC CSSF flag  *//**
  * @brief This function handles the RCC CSS interrupt request.
  * @note This API should be called under the NMI_Handler().
  * @retval None
  *//* Get the Flash Wait State (Latency) configuration ------------------------*//* Get the APB2 configuration ----------------------------------------------*//* Get the APB1 configuration ----------------------------------------------*//* Get the HCLK configuration ----------------------------------------------*//* Get the SYSCLK configuration --------------------------------------------*//* Set all possible values for the Clock type parameter --------------------*//**
  * @brief  Configures the RCC_ClkInitStruct according to the internal
  * RCC configuration registers.
  * @param  RCC_ClkInitStruct pointer to an RCC_ClkInitTypeDef structure that
  * will be configured.
  * @param  pFLatency Pointer on the Flash Latency.
  * @retval None
  *//* Get the PLL configuration -----------------------------------------------*//* Get the LSI configuration -----------------------------------------------*//* Get the LSE configuration -----------------------------------------------*//* Get the HSI configuration -----------------------------------------------*//* Get the HSE configuration -----------------------------------------------*//* Set all possible values for the Oscillator type parameter ---------------*//**
  * @brief  Configures the RCC_OscInitStruct according to the internal
  * RCC configuration registers.
  * @param  RCC_OscInitStruct pointer to an RCC_OscInitTypeDef structure that
  * will be configured.
  * @retval None
  *//* Get HCLK source and Compute PCLK2 frequency ---------------------------*//**
  * @brief  Returns the PCLK2 frequency
  * @note   Each time PCLK2 changes, this function must be called to update the
  *         right PCLK2 value. Otherwise, any configuration based on this function will be incorrect.
  * @retval PCLK2 frequency
  *//* Get HCLK source and Compute PCLK1 frequency ---------------------------*//**
  * @brief  Returns the PCLK1 frequency
  * @note   Each time PCLK1 changes, this function must be called to update the
  *         right PCLK1 value. Otherwise, any configuration based on this function will be incorrect.
  * @retval PCLK1 frequency
  *//**
  * @brief  Returns the HCLK frequency
  * @note   Each time HCLK changes, this function must be called to update the
  *         right HCLK value. Otherwise, any configuration based on this function will be incorrect.
  * @note   The SystemCoreClock CMSIS variable is used to store System Clock Frequency.
  * @retval HCLK frequency
  *//* HSI used as PLL clock source *//* HSE used as PLL clock source *//* PLL_VCO = (HSE_VALUE or HSI_VALUE / PLLM) * PLLN
      SYSCLK = PLL_VCO / PLLP *//* PLL used as system clock  source *//* HSE used as system clock  source *//* HSI used as system clock source *//* Get SYSCLK source -------------------------------------------------------*//**
  * @brief  Returns the SYSCLK frequency
  *
  * @note   The system frequency computed by this function is not the real
  *         frequency in the chip. It is calculated based on the predefined
  *         constant and the selected clock source:
  * @note     If SYSCLK source is HSI, function returns values based on HSI_VALUE(*)
  * @note     If SYSCLK source is HSE, function returns values based on HSE_VALUE(**)
  * @note     If SYSCLK source is PLL, function returns values based on HSE_VALUE(**)
  *           or HSI_VALUE(*) multiplied/divided by the PLL factors.
  * @note     (*) HSI_VALUE is a constant defined in stm32f7xx_hal_conf.h file (default value
  *               16 MHz) but the real value may vary depending on the variations
  *               in voltage and temperature.
  * @note     (**) HSE_VALUE is a constant defined in stm32f7xx_hal_conf.h file (default value
  *                25 MHz), user has to ensure that HSE_VALUE is same as the real
  *                frequency of the crystal used. Otherwise, this function may
  *                have wrong result.
  *
  * @note   The result of this function could be not correct when using fractional
  *         value for HSE crystal.
  *
  * @note   This function can be used by the user application to compute the
  *         baudrate for the communication peripherals or configure other parameters.
  *
  * @note   Each time SYSCLK changes, this function must be called to update the
  *         right SYSCLK value. Otherwise, any configuration based on this function will be incorrect.
  *
  *
  * @retval SYSCLK frequency
  *//**
  * @brief  Disables the Clock Security System.
  * @retval None
  *//**
  * @brief  Enables the Clock Security System.
  * @note   If a failure is detected on the HSE oscillator clock, this oscillator
  *         is automatically disabled and an interrupt is generated to inform the
  *         software about the failure (Clock Security System Interrupt, CSSI),
  *         allowing the MCU to perform rescue operations. The CSSI is linked to
  *         the Cortex-M7 NMI (Non-Maskable Interrupt) exception vector.
  * @retval None
  *//* Mask MCO2 and MCO2PRE[2:0] bits then Select MCO2 clock source and prescaler *//* Configure the MCO2 pin in alternate function mode *//* MCO2 Clock Enable *//* Mask MCO1 and MCO1PRE[2:0] bits then Select MCO1 clock source and prescaler *//* Configure the MCO1 pin in alternate function mode *//* MCO1 Clock Enable *//* RCC_MCO1 *//**
  * @brief  Selects the clock source to output on MCO1 pin(PA8) or on MCO2 pin(PC9).
  * @note   PA8/PC9 should be configured in alternate function mode.
  * @param  RCC_MCOx specifies the output direction for the clock source.
  *          This parameter can be one of the following values:
  *            @arg RCC_MCO1: Clock source to output on MCO1 pin(PA8).
  *            @arg RCC_MCO2: Clock source to output on MCO2 pin(PC9).
  * @param  RCC_MCOSource specifies the clock source to output.
  *          This parameter can be one of the following values:
  *            @arg RCC_MCO1SOURCE_HSI: HSI clock selected as MCO1 source
  *            @arg RCC_MCO1SOURCE_LSE: LSE clock selected as MCO1 source
  *            @arg RCC_MCO1SOURCE_HSE: HSE clock selected as MCO1 source
  *            @arg RCC_MCO1SOURCE_PLLCLK: main PLL clock selected as MCO1 source
  *            @arg RCC_MCO2SOURCE_SYSCLK: System clock (SYSCLK) selected as MCO2 source
  *            @arg RCC_MCO2SOURCE_PLLI2SCLK: PLLI2S clock selected as MCO2 source
  *            @arg RCC_MCO2SOURCE_HSE: HSE clock selected as MCO2 source
  *            @arg RCC_MCO2SOURCE_PLLCLK: main PLL clock selected as MCO2 source
  * @param  RCC_MCODiv specifies the MCOx prescaler.
  *          This parameter can be one of the following values:
  *            @arg RCC_MCODIV_1: no division applied to MCOx clock
  *            @arg RCC_MCODIV_2: division by 2 applied to MCOx clock
  *            @arg RCC_MCODIV_3: division by 3 applied to MCOx clock
  *            @arg RCC_MCODIV_4: division by 4 applied to MCOx clock
  *            @arg RCC_MCODIV_5: division by 5 applied to MCOx clock
  * @retval None
  *//** @defgroup RCC_Exported_Functions_Group2 Peripheral Control functions
  *  @brief   RCC clocks control functions
  *
  @verbatim
  ===============================================================================
                  ##### Peripheral Control functions #####
  ===============================================================================
    [..]
    This subsection provides a set of functions allowing to control the RCC Clocks
    frequencies.

@endverbatim
  * @{
  *//* Configure the source of time base considering new system clocks settings*//* Update the SystemCoreClock global variable *//*-------------------------- PCLK2 Configuration ---------------------------*//*-------------------------- PCLK1 Configuration ---------------------------*//* Check that the new number of wait states is taken into account to access the Flash
    memory by reading the FLASH_ACR register *//* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register *//* Decreasing the number of wait states because of lower CPU frequency *//* Get Start Tick*//* Check the HSI ready flag *//* HSI is selected as System Clock Source *//* Check the PLL ready flag *//* PLL is selected as System Clock Source *//* Check the HSE ready flag *//* HSE is selected as System Clock Source *//*------------------------- SYSCLK Configuration ---------------------------*//* Set the new HCLK clock divider *//* Set the highest APBx dividers in order to ensure that we do not go through
       a non-spec phase whatever we decrease or increase HCLK. *//*-------------------------- HCLK Configuration --------------------------*//* Increasing the CPU frequency *//* To correctly read data from FLASH memory, the number of wait states (LATENCY)
     must be correctly programmed according to the frequency of the CPU clock
     (HCLK) and the supply voltage of the device. *//* Check Null pointer *//**
  * @brief  Initializes the CPU, AHB and APB buses clocks according to the specified
  *         parameters in the RCC_ClkInitStruct.
  * @param  RCC_ClkInitStruct pointer to an RCC_OscInitTypeDef structure that
  *         contains the configuration information for the RCC peripheral.
  * @param  FLatency FLASH Latency, this parameter depend on device selected
  *
  * @note   The SystemCoreClock CMSIS variable is used to store System Clock Frequency
  *         and updated by HAL_RCC_GetHCLKFreq() function called within this function
  *
  * @note   The HSI is used (enabled by hardware) as system clock source after
  *         startup from Reset, wake-up from STOP and STANDBY mode, or in case
  *         of failure of the HSE used directly or indirectly as system clock
  *         (if the Clock Security System CSS is enabled).
  *
  * @note   A switch from one clock source to another occurs only if the target
  *         clock source is ready (clock stable after startup delay or PLL locked).
  *         If a clock source which is not yet ready is selected, the switch will
  *         occur when the clock source will be ready.
  *         You can use HAL_RCC_GetClockConfig() function to know which clock is
  *         currently used as system clock source.
  * @note   Depending on the device voltage range, the software has to set correctly
  *         HPRE[3:0] bits to ensure that HCLK not exceed the maximum allowed frequency
  *         (for more details refer to section above "Initialization/de-initialization functions")
  * @retval None
  *//* Do not return HAL_ERROR if request repeats the current configuration *//* Disable the main PLL. *//* Enable the main PLL. *//* Configure the main PLL clock source, multiplication and division factors. *//*-------------------------------- PLL Configuration -----------------------*//* Restore clock configuration if changed *//* Wait till LSE is ready *//* Check the LSE State *//* Set the new LSE configuration -----------------------------------------*//* Wait for Backup domain Write protection disable *//* Enable write access to Backup domain *//* Enable Power Clock*//* Requires to enable write access to Backup Domain of necessary *//* Update LSE configuration in Backup Domain control register    *//*------------------------------ LSE Configuration -------------------------*//* Wait till LSI is ready *//* Disable the Internal Low Speed oscillator (LSI). *//* Enable the Internal Low Speed oscillator (LSI). *//* Check the LSI State *//*------------------------------ LSI Configuration -------------------------*//* Wait till HSI is ready *//* Disable the Internal High Speed oscillator (HSI). *//* Adjusts the Internal High Speed oscillator (HSI) calibration value.*//* Enable the Internal High Speed oscillator (HSI). *//* Check the HSI State *//* Otherwise, just the calibration is allowed *//* When HSI is used as system clock it will not disabled *//* Check if HSI is used as system clock or as PLL source when PLL is selected as system clock *//*----------------------------- HSI Configuration --------------------------*//* Wait till HSE is bypassed or disabled *//* Wait till HSE is ready *//* Check the HSE State *//* Set the new HSE configuration ---------------------------------------*//* When the HSE is used as system clock or clock source for PLL, It can not be disabled *//*------------------------------- HSE Configuration ------------------------*//**
  * @brief  Initializes the RCC Oscillators according to the specified parameters in the
  *         RCC_OscInitTypeDef.
  * @param  RCC_OscInitStruct pointer to an RCC_OscInitTypeDef structure that
  *         contains the configuration information for the RCC Oscillators.
  * @note   The PLL is not disabled when used as system clock.
  * @note   Transitions LSE Bypass to LSE On and LSE On to LSE Bypass are not
  *         supported by this function. User should request a transition to LSE Off
  *         first and then LSE On or LSE Bypass.
  * @note   Transition HSE Bypass to HSE On and HSE On to HSE Bypass are not
  *         supported by this function. User should request a transition to HSE Off
  *         first and then HSE On or HSE Bypass.
  * @retval HAL status
  *//* Adapt Systick interrupt period *//* Reset all CSR flags *//* Clear LSION bit *//* Reset PLLSAICFGR register to default value *//* Reset PLLI2SCFGR register to default value *//* Once PLL, PLLI2S and PLLSAI are OFF, reset PLLCFGR register to default value *//* Wait till PLLSAI is disabled *//* Reset PLLSAI bit *//* Wait till PLLI2S is disabled *//* Reset PLLI2SON bit *//* Clear PLLON bit *//* Wait till HSE is disabled *//* Clear HSEON, HSEBYP and CSSON bits *//* Wait till clock switch is ready *//* Reset CFGR register *//* Set HSITRIM[4:0] bits to the reset value *//* Set HSION bit to the reset value *//**
  * @brief  Resets the RCC clock configuration to the default reset state.
  * @note   The default reset state of the clock configuration is given below:
  *            - HSI ON and used as system clock source
  *            - HSE, PLL, PLLI2S and PLLSAI OFF
  *            - AHB, APB1 and APB2 prescaler set to 1.
  *            - CSS, MCO1 and MCO2 OFF
  *            - All interrupts disabled
  * @note   This function doesn't modify the configuration of the
  *            - Peripheral clocks
  *            - LSI, LSE and RTC clocks
  * @retval None
  *//** @defgroup RCC_Exported_Functions_Group1 Initialization and de-initialization functions
  *  @brief    Initialization and Configuration functions
  *
  @verbatim
  ===============================================================================
##### Initialization and de-initialization functions #####
  ===============================================================================
    [..]
      This section provides functions allowing to configure the internal/external oscillators
      (HSE, HSI, LSE, LSI, PLL, CSS and MCO) and the System buses clocks (SYSCLK, AHB, APB1
      and APB2).

    [..] Internal/external clock and PLL configuration
      (#) HSI (high-speed internal), 16 MHz factory-trimmed RC used directly or through
          the PLL as System clock source.

      (#) LSI (low-speed internal), 32 KHz low consumption RC used as IWDG and/or RTC
          clock source.

      (#) HSE (high-speed external), 4 to 26 MHz crystal oscillator used directly or
          through the PLL as System clock source. Can be used also as RTC clock source.

      (#) LSE (low-speed external), 32 KHz oscillator used as RTC clock source.

      (#) PLL (clocked by HSI or HSE), featuring two different output clocks:
        (++) The first output is used to generate the high speed system clock (up to 216 MHz)
        (++) The second output is used to generate the clock for the USB OTG FS (48 MHz),
             the random analog generator (<=48 MHz) and the SDIO (<= 48 MHz).

      (#) CSS (Clock security system), once enable using the function HAL_RCC_EnableCSS()
          and if a HSE clock failure occurs(HSE used directly or through PLL as System
          clock source), the System clock is automatically switched to HSI and an interrupt
          is generated if enabled. The interrupt is linked to the Cortex-M7 NMI
          (Non-Maskable Interrupt) exception vector.

      (#) MCO1 (microcontroller clock output), used to output HSI, LSE, HSE or PLL
          clock (through a configurable prescaler) on PA8 pin.

      (#) MCO2 (microcontroller clock output), used to output HSE, PLL, SYSCLK or PLLI2S
          clock (through a configurable prescaler) on PC9 pin.

    [..] System, AHB and APB buses clocks configuration
      (#) Several clock sources can be used to drive the System clock (SYSCLK): HSI,
          HSE and PLL.
          The AHB clock (HCLK) is derived from System clock through configurable
          prescaler and used to clock the CPU, memory and peripherals mapped
          on AHB bus (DMA, GPIO...). APB1 (PCLK1) and APB2 (PCLK2) clocks are derived
          from AHB clock through configurable prescalers and used to clock
          the peripherals mapped on these buses. You can use
          "HAL_RCC_GetSysClockFreq()" function to retrieve the frequencies of these clocks.

      -@- All the peripheral clocks are derived from the System clock (SYSCLK) except:
          (+@) I2S: the I2S clock can be derived either from a specific PLL (PLLI2S) or
              from an external clock mapped on the I2S_CKIN pin.
              You have to use __HAL_RCC_PLLI2S_CONFIG() macro to configure this clock.
          (+@)  SAI: the SAI clock can be derived either from a specific PLL (PLLI2S) or (PLLSAI) or
              from an external clock mapped on the I2S_CKIN pin.
               You have to use __HAL_RCC_PLLI2S_CONFIG() macro to configure this clock.
          (+@) RTC: the RTC clock can be derived either from the LSI, LSE or HSE clock
              divided by 2 to 31. You have to use __HAL_RCC_RTC_CONFIG() and __HAL_RCC_RTC_ENABLE()
              macros to configure this clock.
          (+@) USB OTG FS, SDIO and RTC: USB OTG FS require a frequency equal to 48 MHz
              to work correctly, while the SDIO require a frequency equal or lower than
              to 48. This clock is derived of the main PLL through PLLQ divider.
          (+@) IWDG clock which is always the LSI clock.
@endverbatim
  * @{
  *//** @defgroup RCC_Exported_Functions RCC Exported Functions
  * @{
  *//** @defgroup RCC_Private_Variables RCC Private Variables
  * @{
  *//** @defgroup RCC_Private_Macros RCC Private Macros
  * @{
  *//** @defgroup RCC RCC
  * @brief RCC HAL module driver
  * @{
  *//**
  ******************************************************************************
  * @file    stm32f7xx_hal_rcc.c
  * @author  MCD Application Team
  * @brief   RCC HAL module driver.
  *          This file provides firmware functions to manage the following
  *          functionalities of the Reset and Clock Control (RCC) peripheral:
  *           + Initialization and de-initialization functions
  *           + Peripheral Control functions
  *
  @verbatim
  ==============================================================================
                      ##### RCC specific features #####
  ==============================================================================
    [..]
      After reset the device is running from Internal High Speed oscillator
      (HSI 16MHz) with Flash 0 wait state, Flash prefetch buffer, D-Cache
      and I-Cache are disabled, and all peripherals are off except internal
      SRAM, Flash and JTAG.
      (+) There is no prescaler on High speed (AHB) and Low speed (APB) buses;
          all peripherals mapped on these buses are running at HSI speed.
      (+) The clock for all peripherals is switched off, except the SRAM and FLASH.
      (+) All GPIOs are in input floating state, except the JTAG pins which
          are assigned to be used for debug purpose.

    [..]
      Once the device started from reset, the user application has to:
      (+) Configure the clock source to be used to drive the System clock
          (if the application needs higher frequency/performance)
      (+) Configure the System clock frequency and Flash settings
      (+) Configure the AHB and APB buses prescalers
      (+) Enable the clock for the peripheral(s) to be used
      (+) Configure the clock source(s) for peripherals which clocks are not
          derived from the System clock (I2S, RTC, ADC, USB OTG FS/SDIO/RNG)

                      ##### RCC Limitations #####
  ==============================================================================
    [..]
      A delay between an RCC peripheral clock enable and the effective peripheral
      enabling should be taken into account in order to manage the peripheral read/write
      from/to registers.
      (+) This delay depends on the peripheral mapping.
      (+) If peripheral is mapped on AHB: the delay is 2 AHB clock cycle
          after the clock enable bit is set on the hardware register
      (+) If peripheral is mapped on APB: the delay is 2 APB clock cycle
          after the clock enable bit is set on the hardware register

    [..]
      Implemented Workaround:
      (+) For AHB & APB peripherals, a dummy read to the peripheral register has been
          inserted in each __HAL_RCC_PPP_CLK_ENABLE() macro.

  @endverbatim
  ******************************************************************************
  * @attention
  *
  * Copyright (c) 2017 STMicroelectronics.
  * All rights reserved.
  *
  * This software is licensed under terms that can be found in the LICENSE file in
  * the root directory of this software component.
  * If no LICENSE file comes with this software, it is provided AS-IS.
  ******************************************************************************
  *//Users/jie/Documents/posixGen_Demos-main/LwIP_StreamingServer/Drivers/STM32F7xx_HAL_Driver/Src/stm32f7xx_hal_rcc_ex.cIS_RCC_PLLSAIN_VALUE(PLLSAIInit->PLLSAIN)IS_RCC_PLLSAIQ_VALUE(PLLSAIInit->PLLSAIQ)IS_RCC_PLLSAIP_VALUE(PLLSAIInit->PLLSAIP)IS_RCC_PLLSAIR_VALUE(PLLSAIInit->PLLSAIR)PLLSAIInit->PLLSAINPLLSAIInit->PLLSAIPPLLSAIInit->PLLSAIQPLLSAIInit->PLLSAIRIS_RCC_PLLI2SN_VALUE(PLLI2SInit->PLLI2SN)IS_RCC_PLLI2SR_VALUE(PLLI2SInit->PLLI2SR)IS_RCC_PLLI2SQ_VALUE(PLLI2SInit->PLLI2SQ)IS_RCC_PLLI2SP_VALUE(PLLI2SInit->PLLI2SP)PLLI2SInit->PLLI2SNPLLI2SInit->PLLI2SPPLLI2SInit->PLLI2SQPLLI2SInit->PLLI2SRfrequencyvcoinputsaiclocksource122880002621457864331835009183502518350576029361616043361768176209585627512162751856275313627556962760816277105627915362832496291441146800491677720183886065218103793486539249RCC->DCKCFGR1((RCC_TypeDef *) ((0x40000000UL + 0x00020000UL) + 0x3800UL))->DCKCFGR1(0x3UL << (22U))(0x3UL << (8U))(0x3UL << (10U))(0x3UL << (12U))(0x3UL << (24U))tmpreg0plli2susedpllsaiusedIS_RCC_PERIPHCLOCK(PeriphClkInit->PeriphClockSelection)IS_RCC_I2SCLKSOURCE(PeriphClkInit->I2sClockSelection)PeriphClkInit->I2sClockSelection(RCC_PERIPHCLK_I2S)IS_RCC_SAI1CLKSOURCE(PeriphClkInit->Sai1ClockSelection)PeriphClkInit->Sai1ClockSelection(uint32_t)(PeriphClkInit->Sai1ClockSelection)(((RCC_TypeDef *) ((0x40000000UL + 0x00020000UL) + 0x3800UL))->DCKCFGR1)(((READ_REG(((RCC_TypeDef *) ((0x40000000UL + 0x00020000UL) + 0x3800UL))->DCKCFGR1)) & (~((0x3UL << (20U))))) | ((uint32_t)(PeriphClkInit->Sai1ClockSelection)))(((((((RCC_TypeDef *) ((0x40000000UL + 0x00020000UL) + 0x3800UL))->DCKCFGR1))) & (~((0x3UL << (20U))))) | ((uint32_t)(PeriphClkInit->Sai1ClockSelection)))(RCC_PERIPHCLK_SAI1)IS_RCC_SAI2CLKSOURCE(PeriphClkInit->Sai2ClockSelection)PeriphClkInit->Sai2ClockSelection(uint32_t)(PeriphClkInit->Sai2ClockSelection)(((READ_REG(((RCC_TypeDef *) ((0x40000000UL + 0x00020000UL) + 0x3800UL))->DCKCFGR1)) & (~((0x3UL << (22U))))) | ((uint32_t)(PeriphClkInit->Sai2ClockSelection)))(((((((RCC_TypeDef *) ((0x40000000UL + 0x00020000UL) + 0x3800UL))->DCKCFGR1))) & (~((0x3UL << (22U))))) | ((uint32_t)(PeriphClkInit->Sai2ClockSelection)))(RCC_PERIPHCLK_SAI2)IS_RCC_RTCCLKSOURCE(PeriphClkInit->RTCClockSelection)PeriphClkInit->RTCClockSelection(0x1FUL << (16U))((PeriphClkInit->RTCClockSelection) & 0xFFFFCFF)(((READ_REG(((RCC_TypeDef *) ((0x40000000UL + 0x00020000UL) + 0x3800UL))->CFGR)) & (~((0x1FUL << (16U))))) | (((PeriphClkInit->RTCClockSelection) & 0xFFFFCFF)))(((((((RCC_TypeDef *) ((0x40000000UL + 0x00020000UL) + 0x3800UL))->CFGR))) & (~((0x1FUL << (16U))))) | (((PeriphClkInit->RTCClockSelection) & 0xFFFFCFF)))(RCC_PERIPHCLK_RTC)(RCC_BDCR_RTCSEL)~(RCC_BDCR_RTCSEL)4292935679268434687IS_RCC_TIMPRES(PeriphClkInit->TIMPresSelection)PeriphClkInit->TIMPresSelection(RCC_PERIPHCLK_TIM)IS_RCC_I2C1CLKSOURCE(PeriphClkInit->I2c1ClockSelection)PeriphClkInit->I2c1ClockSelection(uint32_t)(PeriphClkInit->I2c1ClockSelection)(((READ_REG(((RCC_TypeDef *) ((0x40000000UL + 0x00020000UL) + 0x3800UL))->DCKCFGR2)) & (~((0x3UL << (16U))))) | ((uint32_t)(PeriphClkInit->I2c1ClockSelection)))(((((((RCC_TypeDef *) ((0x40000000UL + 0x00020000UL) + 0x3800UL))->DCKCFGR2))) & (~((0x3UL << (16U))))) | ((uint32_t)(PeriphClkInit->I2c1ClockSelection)))IS_RCC_I2C2CLKSOURCE(PeriphClkInit->I2c2ClockSelection)PeriphClkInit->I2c2ClockSelection(uint32_t)(PeriphClkInit->I2c2ClockSelection)(((READ_REG(((RCC_TypeDef *) ((0x40000000UL + 0x00020000UL) + 0x3800UL))->DCKCFGR2)) & (~((0x3UL << (18U))))) | ((uint32_t)(PeriphClkInit->I2c2ClockSelection)))(((((((RCC_TypeDef *) ((0x40000000UL + 0x00020000UL) + 0x3800UL))->DCKCFGR2))) & (~((0x3UL << (18U))))) | ((uint32_t)(PeriphClkInit->I2c2ClockSelection)))IS_RCC_I2C3CLKSOURCE(PeriphClkInit->I2c3ClockSelection)PeriphClkInit->I2c3ClockSelection(uint32_t)(PeriphClkInit->I2c3ClockSelection)(((READ_REG(((RCC_TypeDef *) ((0x40000000UL + 0x00020000UL) + 0x3800UL))->DCKCFGR2)) & (~((0x3UL << (20U))))) | ((uint32_t)(PeriphClkInit->I2c3ClockSelection)))(((((((RCC_TypeDef *) ((0x40000000UL + 0x00020000UL) + 0x3800UL))->DCKCFGR2))) & (~((0x3UL << (20U))))) | ((uint32_t)(PeriphClkInit->I2c3ClockSelection)))IS_RCC_I2C4CLKSOURCE(PeriphClkInit->I2c4ClockSelection)PeriphClkInit->I2c4ClockSelection(uint32_t)(PeriphClkInit->I2c4ClockSelection)(((READ_REG(((RCC_TypeDef *) ((0x40000000UL + 0x00020000UL) + 0x3800UL))->DCKCFGR2)) & (~((0x3UL << (22U))))) | ((uint32_t)(PeriphClkInit->I2c4ClockSelection)))(((((((RCC_TypeDef *) ((0x40000000UL + 0x00020000UL) + 0x3800UL))->DCKCFGR2))) & (~((0x3UL << (22U))))) | ((uint32_t)(PeriphClkInit->I2c4ClockSelection)))IS_RCC_USART1CLKSOURCE(PeriphClkInit->Usart1ClockSelection)PeriphClkInit->Usart1ClockSelection(uint32_t)(PeriphClkInit->Usart1ClockSelection)(((READ_REG(((RCC_TypeDef *) ((0x40000000UL + 0x00020000UL) + 0x3800UL))->DCKCFGR2)) & (~((0x3UL << (0U))))) | ((uint32_t)(PeriphClkInit->Usart1ClockSelection)))(((((((RCC_TypeDef *) ((0x40000000UL + 0x00020000UL) + 0x3800UL))->DCKCFGR2))) & (~((0x3UL << (0U))))) | ((uint32_t)(PeriphClkInit->Usart1ClockSelection)))IS_RCC_USART2CLKSOURCE(PeriphClkInit->Usart2ClockSelection)PeriphClkInit->Usart2ClockSelection(uint32_t)(PeriphClkInit->Usart2ClockSelection)(((READ_REG(((RCC_TypeDef *) ((0x40000000UL + 0x00020000UL) + 0x3800UL))->DCKCFGR2)) & (~((0x3UL << (2U))))) | ((uint32_t)(PeriphClkInit->Usart2ClockSelection)))(((((((RCC_TypeDef *) ((0x40000000UL + 0x00020000UL) + 0x3800UL))->DCKCFGR2))) & (~((0x3UL << (2U))))) | ((uint32_t)(PeriphClkInit->Usart2ClockSelection)))IS_RCC_USART3CLKSOURCE(PeriphClkInit->Usart3ClockSelection)PeriphClkInit->Usart3ClockSelection(uint32_t)(PeriphClkInit->Usart3ClockSelection)(((READ_REG(((RCC_TypeDef *) ((0x40000000UL + 0x00020000UL) + 0x3800UL))->DCKCFGR2)) & (~((0x3UL << (4U))))) | ((uint32_t)(PeriphClkInit->Usart3ClockSelection)))(((((((RCC_TypeDef *) ((0x40000000UL + 0x00020000UL) + 0x3800UL))->DCKCFGR2))) & (~((0x3UL << (4U))))) | ((uint32_t)(PeriphClkInit->Usart3ClockSelection)))4294967247IS_RCC_UART4CLKSOURCE(PeriphClkInit->Uart4ClockSelection)PeriphClkInit->Uart4ClockSelection(uint32_t)(PeriphClkInit->Uart4ClockSelection)(((READ_REG(((RCC_TypeDef *) ((0x40000000UL + 0x00020000UL) + 0x3800UL))->DCKCFGR2)) & (~((0x3UL << (6U))))) | ((uint32_t)(PeriphClkInit->Uart4ClockSelection)))(((((((RCC_TypeDef *) ((0x40000000UL + 0x00020000UL) + 0x3800UL))->DCKCFGR2))) & (~((0x3UL << (6U))))) | ((uint32_t)(PeriphClkInit->Uart4ClockSelection)))IS_RCC_UART5CLKSOURCE(PeriphClkInit->Uart5ClockSelection)PeriphClkInit->Uart5ClockSelection(uint32_t)(PeriphClkInit->Uart5ClockSelection)(((READ_REG(((RCC_TypeDef *) ((0x40000000UL + 0x00020000UL) + 0x3800UL))->DCKCFGR2)) & (~((0x3UL << (8U))))) | ((uint32_t)(PeriphClkInit->Uart5ClockSelection)))(((((((RCC_TypeDef *) ((0x40000000UL + 0x00020000UL) + 0x3800UL))->DCKCFGR2))) & (~((0x3UL << (8U))))) | ((uint32_t)(PeriphClkInit->Uart5ClockSelection)))IS_RCC_USART6CLKSOURCE(PeriphClkInit->Usart6ClockSelection)PeriphClkInit->Usart6ClockSelection(uint32_t)(PeriphClkInit->Usart6ClockSelection)(((READ_REG(((RCC_TypeDef *) ((0x40000000UL + 0x00020000UL) + 0x3800UL))->DCKCFGR2)) & (~((0x3UL << (10U))))) | ((uint32_t)(PeriphClkInit->Usart6ClockSelection)))(((((((RCC_TypeDef *) ((0x40000000UL + 0x00020000UL) + 0x3800UL))->DCKCFGR2))) & (~((0x3UL << (10U))))) | ((uint32_t)(PeriphClkInit->Usart6ClockSelection)))IS_RCC_UART7CLKSOURCE(PeriphClkInit->Uart7ClockSelection)PeriphClkInit->Uart7ClockSelection(uint32_t)(PeriphClkInit->Uart7ClockSelection)(((READ_REG(((RCC_TypeDef *) ((0x40000000UL + 0x00020000UL) + 0x3800UL))->DCKCFGR2)) & (~((0x3UL << (12U))))) | ((uint32_t)(PeriphClkInit->Uart7ClockSelection)))(((((((RCC_TypeDef *) ((0x40000000UL + 0x00020000UL) + 0x3800UL))->DCKCFGR2))) & (~((0x3UL << (12U))))) | ((uint32_t)(PeriphClkInit->Uart7ClockSelection)))4294955007IS_RCC_UART8CLKSOURCE(PeriphClkInit->Uart8ClockSelection)PeriphClkInit->Uart8ClockSelection(uint32_t)(PeriphClkInit->Uart8ClockSelection)(((READ_REG(((RCC_TypeDef *) ((0x40000000UL + 0x00020000UL) + 0x3800UL))->DCKCFGR2)) & (~((0x3UL << (14U))))) | ((uint32_t)(PeriphClkInit->Uart8ClockSelection)))(((((((RCC_TypeDef *) ((0x40000000UL + 0x00020000UL) + 0x3800UL))->DCKCFGR2))) & (~((0x3UL << (14U))))) | ((uint32_t)(PeriphClkInit->Uart8ClockSelection)))IS_RCC_CECCLKSOURCE(PeriphClkInit->CecClockSelection)PeriphClkInit->CecClockSelection(uint32_t)(PeriphClkInit->CecClockSelection)(((READ_REG(((RCC_TypeDef *) ((0x40000000UL + 0x00020000UL) + 0x3800UL))->DCKCFGR2)) & (~((0x1UL << (26U))))) | ((uint32_t)(PeriphClkInit->CecClockSelection)))(((((((RCC_TypeDef *) ((0x40000000UL + 0x00020000UL) + 0x3800UL))->DCKCFGR2))) & (~((0x1UL << (26U))))) | ((uint32_t)(PeriphClkInit->CecClockSelection)))IS_RCC_CLK48SOURCE(PeriphClkInit->Clk48ClockSelection)PeriphClkInit->Clk48ClockSelection(uint32_t)(PeriphClkInit->Clk48ClockSelection)(((READ_REG(((RCC_TypeDef *) ((0x40000000UL + 0x00020000UL) + 0x3800UL))->DCKCFGR2)) & (~((0x1UL << (27U))))) | ((uint32_t)(PeriphClkInit->Clk48ClockSelection)))(((((((RCC_TypeDef *) ((0x40000000UL + 0x00020000UL) + 0x3800UL))->DCKCFGR2))) & (~((0x1UL << (27U))))) | ((uint32_t)(PeriphClkInit->Clk48ClockSelection)))IS_RCC_LPTIM1CLK(PeriphClkInit->Lptim1ClockSelection)PeriphClkInit->Lptim1ClockSelection(uint32_t)(PeriphClkInit->Lptim1ClockSelection)(((READ_REG(((RCC_TypeDef *) ((0x40000000UL + 0x00020000UL) + 0x3800UL))->DCKCFGR2)) & (~((0x3UL << (24U))))) | ((uint32_t)(PeriphClkInit->Lptim1ClockSelection)))(((((((RCC_TypeDef *) ((0x40000000UL + 0x00020000UL) + 0x3800UL))->DCKCFGR2))) & (~((0x3UL << (24U))))) | ((uint32_t)(PeriphClkInit->Lptim1ClockSelection)))IS_RCC_SDMMC1CLKSOURCE(PeriphClkInit->Sdmmc1ClockSelection)PeriphClkInit->Sdmmc1ClockSelection(uint32_t)(PeriphClkInit->Sdmmc1ClockSelection)(((READ_REG(((RCC_TypeDef *) ((0x40000000UL + 0x00020000UL) + 0x3800UL))->DCKCFGR2)) & (~((0x1UL << (28U))))) | ((uint32_t)(PeriphClkInit->Sdmmc1ClockSelection)))(((((((RCC_TypeDef *) ((0x40000000UL + 0x00020000UL) + 0x3800UL))->DCKCFGR2))) & (~((0x1UL << (28U))))) | ((uint32_t)(PeriphClkInit->Sdmmc1ClockSelection)))IS_RCC_SDMMC2CLKSOURCE(PeriphClkInit->Sdmmc2ClockSelection)PeriphClkInit->Sdmmc2ClockSelection(uint32_t)(PeriphClkInit->Sdmmc2ClockSelection)(((READ_REG(((RCC_TypeDef *) ((0x40000000UL + 0x00020000UL) + 0x3800UL))->DCKCFGR2)) & (~((0x1UL << (29U))))) | ((uint32_t)(PeriphClkInit->Sdmmc2ClockSelection)))(((((((RCC_TypeDef *) ((0x40000000UL + 0x00020000UL) + 0x3800UL))->DCKCFGR2))) & (~((0x1UL << (29U))))) | ((uint32_t)(PeriphClkInit->Sdmmc2ClockSelection)))IS_RCC_DFSDM1CLKSOURCE(PeriphClkInit->Dfsdm1ClockSelection)PeriphClkInit->Dfsdm1ClockSelection(uint32_t)(PeriphClkInit->Dfsdm1ClockSelection)(((READ_REG(((RCC_TypeDef *) ((0x40000000UL + 0x00020000UL) + 0x3800UL))->DCKCFGR1)) & (~((0x1UL << (25U))))) | ((uint32_t)(PeriphClkInit->Dfsdm1ClockSelection)))(((((((RCC_TypeDef *) ((0x40000000UL + 0x00020000UL) + 0x3800UL))->DCKCFGR1))) & (~((0x1UL << (25U))))) | ((uint32_t)(PeriphClkInit->Dfsdm1ClockSelection)))IS_RCC_DFSDM1AUDIOCLKSOURCE(PeriphClkInit->Dfsdm1AudioClockSelection)PeriphClkInit->Dfsdm1AudioClockSelection(uint32_t)(PeriphClkInit->Dfsdm1AudioClockSelection)(((READ_REG(((RCC_TypeDef *) ((0x40000000UL + 0x00020000UL) + 0x3800UL))->DCKCFGR1)) & (~((0x1UL << (26U))))) | ((uint32_t)(PeriphClkInit->Dfsdm1AudioClockSelection)))(((((((RCC_TypeDef *) ((0x40000000UL + 0x00020000UL) + 0x3800UL))->DCKCFGR1))) & (~((0x1UL << (26U))))) | ((uint32_t)(PeriphClkInit->Dfsdm1AudioClockSelection)))IS_RCC_PLLI2SN_VALUE(PeriphClkInit->PLLI2S.PLLI2SN)IS_RCC_PLLI2SR_VALUE(PeriphClkInit->PLLI2S.PLLI2SR)PeriphClkInit->PLLI2S.PLLI2SNPeriphClkInit->PLLI2S.PLLI2SRIS_RCC_PLLI2SQ_VALUE(PeriphClkInit->PLLI2S.PLLI2SQ)IS_RCC_PLLI2S_DIVQ_VALUE(PeriphClkInit->PLLI2SDivQ)PeriphClkInit->PLLI2S.PLLI2SQPeriphClkInit->PLLI2SDivQ(PeriphClkInit->PLLI2SDivQ)-1(((READ_REG(((RCC_TypeDef *) ((0x40000000UL + 0x00020000UL) + 0x3800UL))->DCKCFGR1)) & (~((0x1FUL << (0U))))) | ((PeriphClkInit->PLLI2SDivQ)-1))(((((((RCC_TypeDef *) ((0x40000000UL + 0x00020000UL) + 0x3800UL))->DCKCFGR1))) & (~((0x1FUL << (0U))))) | ((PeriphClkInit->PLLI2SDivQ)-1))IS_RCC_PLLI2SP_VALUE(PeriphClkInit->PLLI2S.PLLI2SP)PeriphClkInit->PLLI2S.PLLI2SPIS_RCC_PLLSAIN_VALUE(PeriphClkInit->PLLSAI.PLLSAIN)IS_RCC_PLLSAIQ_VALUE(PeriphClkInit->PLLSAI.PLLSAIQ)IS_RCC_PLLSAI_DIVQ_VALUE(PeriphClkInit->PLLSAIDivQ)PeriphClkInit->PLLSAI.PLLSAINPeriphClkInit->PLLSAI.PLLSAIQPeriphClkInit->PLLSAIDivQ(0x1FUL << (8U))((PeriphClkInit->PLLSAIDivQ)-1)<<8(((READ_REG(((RCC_TypeDef *) ((0x40000000UL + 0x00020000UL) + 0x3800UL))->DCKCFGR1)) & (~((0x1FUL << (8U))))) | (((PeriphClkInit->PLLSAIDivQ)-1)<<8))(((((((RCC_TypeDef *) ((0x40000000UL + 0x00020000UL) + 0x3800UL))->DCKCFGR1))) & (~((0x1FUL << (8U))))) | (((PeriphClkInit->PLLSAIDivQ)-1)<<8))IS_RCC_PLLSAIP_VALUE(PeriphClkInit->PLLSAI.PLLSAIP)PeriphClkInit->PLLSAI.PLLSAIPIS_RCC_PLLSAIR_VALUE(PeriphClkInit->PLLSAI.PLLSAIR)IS_RCC_PLLSAI_DIVR_VALUE(PeriphClkInit->PLLSAIDivR)PeriphClkInit->PLLSAI.PLLSAIRPeriphClkInit->PLLSAIDivR(uint32_t)(PeriphClkInit->PLLSAIDivR)(((READ_REG(((RCC_TypeDef *) ((0x40000000UL + 0x00020000UL) + 0x3800UL))->DCKCFGR1)) & (~((0x3UL << (16U))))) | ((uint32_t)(PeriphClkInit->PLLSAIDivR)))(((((((RCC_TypeDef *) ((0x40000000UL + 0x00020000UL) + 0x3800UL))->DCKCFGR1))) & (~((0x3UL << (16U))))) | ((uint32_t)(PeriphClkInit->PLLSAIDivR)))4294959359(RCC_PERIPHCLK_LTDC)defined(RCC_PLLI2SCFGR_PLLI2SP)defined(RCC_PLLSAICFGR_PLLSAIR)/* return in case of Timeout detected *//* Disable the PLLSAI *//**
  * @brief  Disable PLLSAI.
  * @retval HAL status
  *//* Wait till PLLSAI is ready *//* Enable the PLLSAI *//* SAIRCLK = PLLSAI_VCO / PLLSAIR *//* SAIQCLK = PLLSAI_VCO / PLLSAIQ *//* SAIPCLK = PLLSAI_VCO / PLLSAIP *//* PLLSAI_VCO = f(VCO clock) = f(PLLSAI clock input) * PLLSAIN *//* Configure the PLLSAI division factors *//* RCC_PLLSAICFGR_PLLSAIR *//* Check for parameters *//**
  * @brief  Enable PLLSAI.
  * @param  PLLSAIInit  pointer to an RCC_PLLSAIInitTypeDef structure that
  *         contains the configuration information for the PLLSAI
  * @retval HAL status
  *//* Disable the PLLI2S *//**
  * @brief  Disable PLLI2S.
  * @retval HAL status
  *//* Wait till PLLI2S is ready *//* Enable the PLLI2S *//* I2SRCLK = PLLI2S_VCO / PLLI2SR *//* I2SQCLK = PLLI2S_VCO / PLLI2SQ *//* I2SPCLK = PLLI2S_VCO / PLLI2SP *//* PLLI2S_VCO = f(VCO clock) = f(PLLI2S clock input) * PLLI2SN *//* Configure the PLLI2S division factors *//* RCC_PLLI2SCFGR_PLLI2SP *//**
  * @brief  Enable PLLI2S.
  * @param  PLLI2SInit  pointer to an RCC_PLLI2SInitTypeDef structure that
  *         contains the configuration information for the PLLI2S
  * @retval HAL status
  *//** @defgroup RCCEx_Exported_Functions_Group2 Extended Clock management functions
 *  @brief  Extended Clock management functions
 *
@verbatim
 ===============================================================================
                ##### Extended clock management functions  #####
 ===============================================================================
    [..]
    This subsection provides a set of functions allowing to control the
    activation or deactivation of PLLI2S, PLLSAI.
@endverbatim
  * @{
  *//* In Case the main PLL Source is HSE *//* In Case the main PLL Source is HSI *//* HSI or HSE is the clock source for SAI2 *//* External clock is the clock source for SAI2 *//* SAI_CLK_x = SAI_CLK(first level)/PLLI2SDIVQ *//* SAI_CLK(first level) = PLLI2S_VCO Output/PLLI2SQ *//* PLLI2S_VCO Output = PLLI2S_VCO Input * PLLI2SN *//* In Case the PLL Source is HSE (External Clock) *//* In Case the PLL Source is HSI (Internal Clock) *//* PLLI2S_VCO Input  = PLL_SOURCE/PLLM *//* Configure the PLLI2S division factor *//* PLLI2S is the clock source for SAI2 *//* SAI_CLK_x = SAI_CLK(first level)/PLLSAIDIVQ *//* SAI_CLK(first level) = PLLSAI_VCO Output/PLLSAIQ *//* PLLSAI_VCO Output = PLLSAI_VCO Input * PLLSAIN *//* PLLSAI_VCO Input  = PLL_SOURCE/PLLM *//* Configure the PLLSAI division factor *//* PLLSAI is the clock source for SAI*//* HSI or HSE is the clock source for SAI*//* External clock is the clock source for SAI1 *//* PLLI2S is the clock source for SAI1 *//* PLLSAI is the clock source for SAI1 *//* This variable is used to store the SAI clock source *//* This variable is used to store the VCO Input (value in Hz) *//* This variable is used to store the SAI clock frequency (value in Hz) *//**
  * @brief  Return the peripheral clock frequency for a given peripheral(SAI..)
  * @note   Return 0 if peripheral clock identifier not managed by this API
  * @param  PeriphClk Peripheral clock identifier
  *         This parameter can be one of the following values:
  *            @arg RCC_PERIPHCLK_SAI1: SAI1 peripheral clock
  *            @arg RCC_PERIPHCLK_SAI2: SAI2 peripheral clock
  * @retval Frequency in KHz
  *//* Get the TIM Prescaler configuration --------------------------------------------*//* Get the RTC Clock configuration -----------------------------------------------*//* Get the SDMMC2 clock configuration -----------------------------------------------*//* Get the SDMMC1 clock configuration -----------------------------------------------*//* Get the CK48 clock configuration -----------------------------------------------*//* Get the LPTIM1 clock configuration ------------------------------------------*//* Get the UART8 clock configuration ------------------------------------------*//* Get the UART7 clock configuration ------------------------------------------*//* Get the USART6 clock configuration ------------------------------------------*//* Get the UART5 clock configuration ------------------------------------------*//* Get the UART4 clock configuration ------------------------------------------*//* Get the USART3 clock configuration ------------------------------------------*//* Get the USART2 clock configuration ------------------------------------------*//* Get the USART1 clock configuration ------------------------------------------*//* Get the I2C3 clock configuration ------------------------------------------*//* Get the I2C2 clock configuration ------------------------------------------*//* Get the I2C1 clock configuration ------------------------------------------*//* Get the I2S clock configuration ------------------------------------------*//* Get the SAI2 clock configuration ----------------------------------------------*//* Get the SAI1 clock configuration ----------------------------------------------*//* Get the PLLSAI/PLLI2S division factors -------------------------------------------*//* Get the PLLSAI Clock configuration -----------------------------------------------*//* Get the PLLI2S Clock configuration -----------------------------------------------*//* Set all possible values for the extended clock type parameter------------*//**
  * @brief  Get the RCC_PeriphCLKInitTypeDef according to the internal
  *         RCC configuration registers.
  * @param  PeriphClkInit pointer to the configured RCC_PeriphCLKInitTypeDef structure
  * @retval None
  *//* Enable PLLSAI Clock *//* 48CLK = f(PLLSAI clock output) = f(VCO clock) / PLLSAIP *//* PLLSAI_VCO = f(VCO clock) = f(PLLSAI clock input) x (PLLI2SN/PLLM) *//* Read PLLSAIQ and PLLSAIR value from PLLSAICFGR register (this value is not needed for CK48 configuration) *//* check for Parameters *//* In Case of PLLI2S is selected as source clock for CK48 *//*----------------- In Case of PLLSAI is selected as source clock for CLK48 -------------------*//* Read PLLSAIP value from PLLSAICFGR register (this value is not needed for SAI configuration) *//* check for PLLSAI/DIVQ Parameter *//* check for PLLSAIQ Parameter *//*----------------- In Case of PLLSAI is selected as source clock for SAI -------------------*//* Check the PLLSAI division factors *//* Disable PLLSAI Clock *//* PLLSAI is configured when a peripheral will use it as source clock : SAI1, SAI2, LTDC or CK48 *//*-------------------------------------- PLLSAI Configuration ---------------------------------*//* PLLI2S_VCO = f(VCO clock) = f(PLLI2S clock input) x (PLLI2SN/PLLI2SM) *//* Check for Parameters *//*----------------- In Case of PLLI2S is just selected  -----------------*//* Read PLLI2SP and PLLI2SR values from PLLI2SCFGR register (this value is not needed for SAI configuration) *//* Check for PLLI2S/DIVQ parameters *//* Check for PLLI2S Parameters *//*----------------- In Case of PLLI2S is selected as source clock for SAI -------------------*//* I2SCLK = f(PLLI2S clock output) = f(VCO clock) / PLLI2SR *//* PLLI2S_VCO = f(VCO clock) = f(PLLI2S clock input) x (PLLI2SN/PLLM) *//* Read PLLI2SQ value from PLLI2SCFGR register (this value is not needed for I2S configuration) *//*----------------- In Case of PLLI2S is selected as source clock for I2S -------------------*//* check for common PLLI2S Parameters *//* PLLI2S is configured when a peripheral will use it as source clock : SAI1, SAI2 or I2S *//*-------------------------------------- PLLI2S Configuration ---------------------------------*//* Configure the SDMMC2 clock source *//*------------------------------------- SDMMC2 Configuration ------------------------------------*//* Configure the SDMMC1 clock source *//*------------------------------------- SDMMC1 Configuration ------------------------------------*//* Configure the LTPIM1 clock source *//*-------------------------------------- LPTIM1 Configuration -----------------------------------*//* Enable the PLLSAI when it's used as clock source for CK48 *//* Configure the CLK48 source *//*-------------------------------------- CK48 Configuration -----------------------------------*//* Configure the UART8 clock source *//*-------------------------------------- UART8 Configuration -----------------------------------*//* Configure the UART7 clock source *//*-------------------------------------- UART7 Configuration -----------------------------------*//* Configure the USART6 clock source *//*-------------------------------------- USART6 Configuration -----------------------------------*//* Configure the UART5 clock source *//*-------------------------------------- UART5 Configuration -----------------------------------*//* Configure the UART4 clock source *//*-------------------------------------- UART4 Configuration -----------------------------------*//* Configure the USART3 clock source *//*-------------------------------------- USART3 Configuration -----------------------------------*//* Configure the USART2 clock source *//*-------------------------------------- USART2 Configuration -----------------------------------*//* Configure the USART1 clock source *//*-------------------------------------- USART1 Configuration -----------------------------------*//* Configure the I2C3 clock source *//*-------------------------------------- I2C3 Configuration -----------------------------------*//* Configure the I2C2 clock source *//*-------------------------------------- I2C2 Configuration -----------------------------------*//* Configure the I2C1 clock source *//*-------------------------------------- I2C1 Configuration -----------------------------------*//* Configure Timer Prescaler *//*------------------------------------ TIM configuration --------------------------------------*//* Wait for LSE reactivation if LSE was enable prior to Backup Domain reset *//* Restore the Content of BDCR register *//* RTC Clock selection can be changed only if the Backup Domain is reset *//* Store the content of BDCR register before the reset of Backup Domain *//* Reset the Backup domain only if the RTC Clock source selection is modified *//* Check for RTC Parameters used to output RTCCLK *//*------------------------------------ RTC configuration --------------------------------------*//* Enable the PLLSAI when it's used as clock source for SAI *//* Enable the PLLI2S when it's used as clock source for SAI *//* Configure SAI2 Clock source *//*------------------------------------ SAI2 configuration --------------------------------------*//* Configure SAI1 Clock source *//*------------------------------------ SAI1 configuration --------------------------------------*//* Enable the PLLI2S when it's used as clock source for I2S *//* Configure I2S Clock source *//*----------------------------------- I2S configuration ----------------------------------*//**
  * @brief  Initializes the RCC extended peripherals clocks according to the specified
  *         parameters in the RCC_PeriphCLKInitTypeDef.
  * @param  PeriphClkInit pointer to an RCC_PeriphCLKInitTypeDef structure that
  *         contains the configuration information for the Extended Peripherals
  *         clocks(I2S, SAI, RTC, TIM, UARTs, USARTs, LTPIM, SDMMC...).
  *
  * @note   Care must be taken when HAL_RCCEx_PeriphCLKConfig() is used to select
  *         the RTC clock source; in this case the Backup domain will be reset in
  *         order to modify the RTC Clock source, as consequence RTC registers (including
  *         the backup registers) are set to their reset values.
  *
  * @retval HAL status
  *//* Get the DFSDM AUDIO clock configuration -----------------------------------------------*//* Get the DFSDM clock configuration -----------------------------------------------*//* Get the CEC clock configuration -----------------------------------------------*//* Get the I2C4 clock configuration ------------------------------------------*//* LTDC_CLK = LTDC_CLK(first level)/PLLSAIDIVR *//* LTDC_CLK(first level) = PLLSAI_VCO Output/PLLSAIR *//* Read PLLSAIP and PLLSAIQ value from PLLSAICFGR register (these value are not needed for LTDC configuration) *//*---------------------------- LTDC configuration -------------------------------*//* SPDIFRXCLK = f(PLLI2S clock output) = f(VCO clock) / PLLI2SP *//* SPDIFCLK = f(PLLI2S clock output) = f(VCO clock) / PLLI2SP *//* Read PLLI2SR value from PLLI2SCFGR register (this value is not needed for SPDIF-RX configuration) *//*----------------- In Case of PLLI2S is selected as source clock for SPDIF-RX -------------------*//* Read PLLI2SP and PLLI2SQ value from PLLI2SCFGR register (this value is not needed for I2S configuration) *//* PLLI2S is configured when a peripheral will use it as source clock : SAI1, SAI2, I2S or SPDIF-RX *//* Configure the DFSDM interface clock source *//*------------------------------------- DFSDM AUDIO Configuration -------------------------------------*//* Configure the DFSDM1 interface clock source *//*------------------------------------- DFSDM1 Configuration -------------------------------------*//*-------------------------------------- LTDC Configuration -----------------------------------*//* Configure the CEC clock source *//*--------------------------------------- CEC Configuration -----------------------------------*//* Configure the I2C4 clock source *//*-------------------------------------- I2C4 Configuration -----------------------------------*//*-------------------------------------- SPDIF-RX Configuration -----------------------------------*//**
  * @brief  Initializes the RCC extended peripherals clocks according to the specified
  *         parameters in the RCC_PeriphCLKInitTypeDef.
  * @param  PeriphClkInit pointer to an RCC_PeriphCLKInitTypeDef structure that
  *         contains the configuration information for the Extended Peripherals
  *         clocks(I2S, SAI, LTDC, RTC, TIM, UARTs, USARTs, LTPIM, SDMMC...).
  *
  * @note   Care must be taken when HAL_RCCEx_PeriphCLKConfig() is used to select
  *         the RTC clock source; in this case the Backup domain will be reset in
  *         order to modify the RTC Clock source, as consequence RTC registers (including
  *         the backup registers) are set to their reset values.
  *
  * @retval HAL status
  *//** @defgroup RCCEx_Exported_Functions_Group1 Extended Peripheral Control functions
 *  @brief  Extended Peripheral Control functions
 *
@verbatim
 ===============================================================================
                ##### Extended Peripheral Control functions  #####
 ===============================================================================
    [..]
    This subsection provides a set of functions allowing to control the RCC Clocks
    frequencies.
    [..]
    (@) Important note: Care must be taken when HAL_RCCEx_PeriphCLKConfig() is used to
        select the RTC clock source; in this case the Backup domain will be reset in
        order to modify the RTC Clock source, as consequence RTC registers (including
        the backup registers) and RCC_BDCR register will be set to their reset values.

@endverbatim
  * @{
  *//** @defgroup RCCEx_Exported_Functions RCCEx Exported Functions
  * @{
  *//** @defgroup RCCEx_Private_Macros RCCEx Private Macros
 * @{
 *//** @defgroup RCCEx_Private_Defines RCCEx Private Defines
  * @{
  *//** @defgroup RCCEx RCCEx
  * @brief RCCEx HAL module driver
  * @{
  *//**
  ******************************************************************************
  * @file    stm32f7xx_hal_rcc_ex.c
  * @author  MCD Application Team
  * @brief   Extension RCC HAL module driver.
  *          This file provides firmware functions to manage the following
  *          functionalities RCC extension peripheral:
  *           + Extended Peripheral Control functions
  *
  ******************************************************************************
  * @attention
  *
  * Copyright (c) 2017 STMicroelectronics.
  * All rights reserved.
  *
  * This software is licensed under terms that can be found in the LICENSE file in
  * the root directory of this software component.
  * If no LICENSE file comes with this software, it is provided AS-IS.
  ******************************************************************************
  *//Users/jie/Documents/posixGen_Demos-main/LwIP_StreamingServer/Drivers/STM32F7xx_HAL_Driver/Src/stm32f7xx_hal_sdram.cSDRAM_DMAErrorSDRAM_DMACpltProtSDRAM_DMACpltpSdramAddresspsrcbuffpdestbuffpsdramaddress0xFFFF0000Uhsdram->Instance/* Update the SDRAM controller state *//* Disable the DMA channel *//**
  * @brief  DMA SDRAM error callback.
  * @param  hdma : DMA handle
  * @retval None
  *//**
  * @brief  DMA SRAM process complete callback.
  * @param  hdma : DMA handle
  * @retval None
  *//**
  * @brief  DMA SDRAM process complete callback.
  * @param  hdma : DMA handle
  * @retval None
  *//** @addtogroup SDRAM_Private_Functions SDRAM Private Functions
  * @{
  *//**
  * @brief  Returns the SDRAM state.
  * @param  hsdram pointer to a SDRAM_HandleTypeDef structure that contains
  *                the configuration information for SDRAM module.
  * @retval HAL state
  *//** @defgroup SDRAM_Exported_Functions_Group4 State functions
  *  @brief   Peripheral State functions
  *
@verbatim
  ==============================================================================
                      ##### SDRAM State functions #####
  ==============================================================================
  [..]
    This subsection permits to get in run-time the status of the SDRAM controller
    and the data flow.

@endverbatim
  * @{
  *//* Return the SDRAM memory current mode *//**
  * @brief  Returns the SDRAM memory current mode.
  * @param  hsdram pointer to a SDRAM_HandleTypeDef structure that contains
  *                the configuration information for SDRAM module.
  * @retval The SDRAM memory mode.
  *//* Update the SDRAM state *//* Set the Auto-Refresh number *//* Check the SDRAM controller state *//**
  * @brief  Sets the Number of consecutive SDRAM Memory auto Refresh commands.
  * @param  hsdram pointer to a SDRAM_HandleTypeDef structure that contains
  *                the configuration information for SDRAM module.
  * @param  AutoRefreshNumber The SDRAM auto Refresh number
  * @retval HAL status
  *//* Program the refresh rate *//**
  * @brief  Programs the SDRAM Memory Refresh rate.
  * @param  hsdram pointer to a SDRAM_HandleTypeDef structure that contains
  *                the configuration information for SDRAM module.
  * @param  RefreshRate The SDRAM refresh rate value
  * @retval HAL status
  *//* Update the SDRAM controller state state *//* Send SDRAM command *//**
  * @brief  Sends Command to the SDRAM bank.
  * @param  hsdram pointer to a SDRAM_HandleTypeDef structure that contains
  *                the configuration information for SDRAM module.
  * @param  Command SDRAM command structure
  * @param  Timeout Timeout duration
  * @retval HAL status
  *//* Disable write protection *//**
  * @brief  Disables dynamically SDRAM write protection.
  * @param  hsdram pointer to a SDRAM_HandleTypeDef structure that contains
  *                the configuration information for SDRAM module.
  * @retval HAL status
  *//* Enable write protection *//**
  * @brief  Enables dynamically SDRAM write protection.
  * @param  hsdram pointer to a SDRAM_HandleTypeDef structure that contains
  *                the configuration information for SDRAM module.
  * @retval HAL status
  *//** @defgroup SDRAM_Exported_Functions_Group3 Control functions
  *  @brief   management functions
  *
@verbatim
  ==============================================================================
                         ##### SDRAM Control functions #####
  ==============================================================================
  [..]
    This subsection provides a set of functions allowing to control dynamically
    the SDRAM interface.

@endverbatim
  * @{
  *//**
  * @brief  Register a User SDRAM Callback for DMA transfers
  *         To be used to override the weak predefined callback
  * @param hsdram : SDRAM handle
  * @param CallbackId : ID of the callback to be registered
  *        This parameter can be one of the following values:
  *          @arg @ref HAL_SDRAM_DMA_XFER_CPLT_CB_ID  SDRAM DMA Xfer Complete callback ID
  *          @arg @ref HAL_SDRAM_DMA_XFER_ERR_CB_ID   SDRAM DMA Xfer Error callback ID
  * @param pCallback : pointer to the Callback function
  * @retval status
  *//**
  * @brief  Unregister a User SDRAM Callback
  *         SDRAM Callback is redirected to the weak predefined callback
  * @param hsdram : SDRAM handle
  * @param CallbackId : ID of the callback to be unregistered
  *        This parameter can be one of the following values:
  *          @arg @ref HAL_SDRAM_MSP_INIT_CB_ID       SDRAM MspInit callback ID
  *          @arg @ref HAL_SDRAM_MSP_DEINIT_CB_ID     SDRAM MspDeInit callback ID
  *          @arg @ref HAL_SDRAM_REFRESH_ERR_CB_ID    SDRAM Refresh Error callback ID
  *          @arg @ref HAL_SDRAM_DMA_XFER_CPLT_CB_ID  SDRAM DMA Xfer Complete callback ID
  *          @arg @ref HAL_SDRAM_DMA_XFER_ERR_CB_ID   SDRAM DMA Xfer Error callback ID
  * @retval status
  *//**
  * @brief  Register a User SDRAM Callback
  *         To be used to override the weak predefined callback
  * @param hsdram : SDRAM handle
  * @param CallbackId : ID of the callback to be registered
  *        This parameter can be one of the following values:
  *          @arg @ref HAL_SDRAM_MSP_INIT_CB_ID       SDRAM MspInit callback ID
  *          @arg @ref HAL_SDRAM_MSP_DEINIT_CB_ID     SDRAM MspDeInit callback ID
  *          @arg @ref HAL_SDRAM_REFRESH_ERR_CB_ID    SDRAM Refresh Error callback ID
  * @param pCallback : pointer to the Callback function
  * @retval status
  *//* Configure DMA user callbacks *//**
  * @brief  Writes a Words data buffer to SDRAM memory using DMA transfer.
  * @param  hsdram pointer to a SDRAM_HandleTypeDef structure that contains
  *                the configuration information for SDRAM module.
  * @param  pAddress Pointer to write start address
  * @param  pSrcBuffer Pointer to source buffer to write
  * @param  BufferSize Size of the buffer to write to memory
  * @retval HAL status
  *//**
  * @brief  Reads a Words data from the SDRAM memory using DMA transfer.
  * @param  hsdram pointer to a SDRAM_HandleTypeDef structure that contains
  *                the configuration information for SDRAM module.
  * @param  pAddress Pointer to read start address
  * @param  pDstBuffer Pointer to destination buffer
  * @param  BufferSize Size of the buffer to read from memory
  * @retval HAL status
  *//* Write data to memory *//**
  * @brief  Writes 32-bit data buffer to SDRAM memory.
  * @param  hsdram pointer to a SDRAM_HandleTypeDef structure that contains
  *                the configuration information for SDRAM module.
  * @param  pAddress Pointer to write start address
  * @param  pSrcBuffer Pointer to source buffer to write
  * @param  BufferSize Size of the buffer to write to memory
  * @retval HAL status
  *//* Read data from source *//**
  * @brief  Reads 32-bit data buffer from the SDRAM memory.
  * @param  hsdram pointer to a SDRAM_HandleTypeDef structure that contains
  *                the configuration information for SDRAM module.
  * @param  pAddress Pointer to read start address
  * @param  pDstBuffer Pointer to destination buffer
  * @param  BufferSize Size of the buffer to read from memory
  * @retval HAL status
  *//* Write last 16-bits if size is not 32-bits multiple *//**
  * @brief  Writes 16-bit data buffer to SDRAM memory.
  * @param  hsdram pointer to a SDRAM_HandleTypeDef structure that contains
  *                the configuration information for SDRAM module.
  * @param  pAddress Pointer to write start address
  * @param  pSrcBuffer Pointer to source buffer to write
  * @param  BufferSize Size of the buffer to write to memory
  * @retval HAL status
  *//* Read last 16-bits if size is not 32-bits multiple *//* Read data from memory *//**
  * @brief  Reads 16-bit data buffer from the SDRAM memory.
  * @param  hsdram pointer to a SDRAM_HandleTypeDef structure that contains
  *                the configuration information for SDRAM module.
  * @param  pAddress Pointer to read start address
  * @param  pDstBuffer Pointer to destination buffer
  * @param  BufferSize Size of the buffer to read from memory
  * @retval HAL status
  *//**
  * @brief  Writes 8-bit data buffer to SDRAM memory.
  * @param  hsdram pointer to a SDRAM_HandleTypeDef structure that contains
  *                the configuration information for SDRAM module.
  * @param  pAddress Pointer to write start address
  * @param  pSrcBuffer Pointer to source buffer to write
  * @param  BufferSize Size of the buffer to write to memory
  * @retval HAL status
  *//**
  * @brief  Reads 8-bit data buffer from the SDRAM memory.
  * @param  hsdram pointer to a SDRAM_HandleTypeDef structure that contains
  *                the configuration information for SDRAM module.
  * @param  pAddress Pointer to read start address
  * @param  pDstBuffer Pointer to destination buffer
  * @param  BufferSize Size of the buffer to read from memory
  * @retval HAL status
  *//** @defgroup SDRAM_Exported_Functions_Group2 Input and Output functions
  * @brief    Input Output and memory control functions
  *
  @verbatim
  ==============================================================================
                    ##### SDRAM Input and Output functions #####
  ==============================================================================
  [..]
    This section provides functions allowing to use and control the SDRAM memory

@endverbatim
  * @{
  *//* NOTE: This function Should not be modified, when the callback is needed,
            the HAL_SDRAM_DMA_XferErrorCallback could be implemented in the user file
   *//**
  * @brief  DMA transfer complete error callback.
  * @param  hdma DMA handle
  * @retval None
  *//* NOTE: This function Should not be modified, when the callback is needed,
            the HAL_SDRAM_DMA_XferCpltCallback could be implemented in the user file
   *//**
  * @brief  DMA transfer complete callback.
  * @param  hdma pointer to a DMA_HandleTypeDef structure that contains
  *                the configuration information for the specified DMA module.
  * @retval None
  *//* NOTE: This function Should not be modified, when the callback is needed,
            the HAL_SDRAM_RefreshErrorCallback could be implemented in the user file
   *//**
  * @brief  SDRAM Refresh error callback.
  * @param  hsdram pointer to a SDRAM_HandleTypeDef structure that contains
  *                the configuration information for SDRAM module.
  * @retval None
  *//* Clear SDRAM refresh error interrupt pending bit *//* SDRAM refresh error interrupt callback *//* Check SDRAM interrupt Rising edge flag *//**
  * @brief  This function handles SDRAM refresh error interrupt request.
  * @param  hsdram pointer to a SDRAM_HandleTypeDef structure that contains
  *                the configuration information for SDRAM module.
  * @retval HAL status
  *//* NOTE: This function Should not be modified, when the callback is needed,
            the HAL_SDRAM_MspDeInit could be implemented in the user file
   *//**
  * @brief  SDRAM MSP DeInit.
  * @param  hsdram pointer to a SDRAM_HandleTypeDef structure that contains
  *                the configuration information for SDRAM module.
  * @retval None
  *//* NOTE: This function Should not be modified, when the callback is needed,
            the HAL_SDRAM_MspInit could be implemented in the user file
   *//**
  * @brief  SDRAM MSP Init.
  * @param  hsdram pointer to a SDRAM_HandleTypeDef structure that contains
  *                the configuration information for SDRAM module.
  * @retval None
  *//* Reset the SDRAM controller state *//* Configure the SDRAM registers with their reset values *//**
  * @brief  Perform the SDRAM device initialization sequence.
  * @param  hsdram pointer to a SDRAM_HandleTypeDef structure that contains
  *                the configuration information for SDRAM module.
  * @retval HAL status
  *//* Initialize SDRAM timing Interface *//* Initialize SDRAM control Interface *//* Initialize the SDRAM controller state *//* Check the SDRAM handle parameter *//**
  * @brief  Performs the SDRAM device initialization sequence.
  * @param  hsdram pointer to a SDRAM_HandleTypeDef structure that contains
  *                the configuration information for SDRAM module.
  * @param  Timing Pointer to SDRAM control timing structure
  * @retval HAL status
  *//** @defgroup SDRAM_Exported_Functions_Group1 Initialization and de-initialization functions
  * @brief    Initialization and Configuration functions
  *
  @verbatim
  ==============================================================================
           ##### SDRAM Initialization and de_initialization functions #####
  ==============================================================================
  [..]
    This section provides functions allowing to initialize/de-initialize
    the SDRAM memory

@endverbatim
  * @{
  *//** @defgroup SDRAM_Exported_Functions SDRAM Exported Functions
  * @{
  *//** @defgroup SDRAM SDRAM
  * @brief SDRAM driver modules
  * @{
  *//**
  ******************************************************************************
  * @file    stm32f7xx_hal_sdram.c
  * @author  MCD Application Team
  * @brief   SDRAM HAL module driver.
  *          This file provides a generic firmware to drive SDRAM memories mounted
  *          as external device.
  *
  ******************************************************************************
  * @attention
  *
  * Copyright (c) 2017 STMicroelectronics.
  * All rights reserved.
  *
  * This software is licensed under terms that can be found in the LICENSE file
  * in the root directory of this software component.
  * If no LICENSE file comes with this software, it is provided AS-IS.
  *
  ******************************************************************************
  @verbatim
  ==============================================================================
                       ##### How to use this driver #####
  ==============================================================================
  [..]
    This driver is a generic layered driver which contains a set of APIs used to
    control SDRAM memories. It uses the FMC layer functions to interface
    with SDRAM devices.
    The following sequence should be followed to configure the FMC to interface
    with SDRAM memories:

   (#) Declare a SDRAM_HandleTypeDef handle structure, for example:
          SDRAM_HandleTypeDef  hsdram

       (++) Fill the SDRAM_HandleTypeDef handle "Init" field with the allowed
            values of the structure member.

       (++) Fill the SDRAM_HandleTypeDef handle "Instance" field with a predefined
            base register instance for NOR or SDRAM device

   (#) Declare a FMC_SDRAM_TimingTypeDef structure; for example:
          FMC_SDRAM_TimingTypeDef  Timing;
      and fill its fields with the allowed values of the structure member.

   (#) Initialize the SDRAM Controller by calling the function HAL_SDRAM_Init(). This function
       performs the following sequence:

       (##) MSP hardware layer configuration using the function HAL_SDRAM_MspInit()
       (##) Control register configuration using the FMC SDRAM interface function
            FMC_SDRAM_Init()
       (##) Timing register configuration using the FMC SDRAM interface function
            FMC_SDRAM_Timing_Init()
       (##) Program the SDRAM external device by applying its initialization sequence
            according to the device plugged in your hardware. This step is mandatory
            for accessing the SDRAM device.

   (#) At this stage you can perform read/write accesses from/to the memory connected
       to the SDRAM Bank. You can perform either polling or DMA transfer using the
       following APIs:
       (++) HAL_SDRAM_Read()/HAL_SDRAM_Write() for polling read/write access
       (++) HAL_SDRAM_Read_DMA()/HAL_SDRAM_Write_DMA() for DMA read/write transfer

   (#) You can also control the SDRAM device by calling the control APIs HAL_SDRAM_WriteOperation_Enable()/
       HAL_SDRAM_WriteOperation_Disable() to respectively enable/disable the SDRAM write operation or
       the function HAL_SDRAM_SendCommand() to send a specified command to the SDRAM
       device. The command to be sent must be configured with the FMC_SDRAM_CommandTypeDef
       structure.

   (#) You can continuously monitor the SDRAM device HAL state by calling the function
       HAL_SDRAM_GetState()

   *** Callback registration ***
    =============================================
    [..]
      The compilation define  USE_HAL_SDRAM_REGISTER_CALLBACKS when set to 1
      allows the user to configure dynamically the driver callbacks.

      Use Functions HAL_SDRAM_RegisterCallback() to register a user callback,
      it allows to register following callbacks:
        (+) MspInitCallback    : SDRAM MspInit.
        (+) MspDeInitCallback  : SDRAM MspDeInit.
      This function takes as parameters the HAL peripheral handle, the Callback ID
      and a pointer to the user callback function.

      Use function HAL_SDRAM_UnRegisterCallback() to reset a callback to the default
      weak (overridden) function. It allows to reset following callbacks:
        (+) MspInitCallback    : SDRAM MspInit.
        (+) MspDeInitCallback  : SDRAM MspDeInit.
      This function) takes as parameters the HAL peripheral handle and the Callback ID.

      By default, after the HAL_SDRAM_Init and if the state is HAL_SDRAM_STATE_RESET
      all callbacks are reset to the corresponding legacy weak (overridden) functions.
      Exception done for MspInit and MspDeInit callbacks that are respectively
      reset to the legacy weak (overridden) functions in the HAL_SDRAM_Init
      and  HAL_SDRAM_DeInit only when these callbacks are null (not registered beforehand).
      If not, MspInit or MspDeInit are not null, the HAL_SDRAM_Init and HAL_SDRAM_DeInit
      keep and use the user MspInit/MspDeInit callbacks (registered beforehand)

      Callbacks can be registered/unregistered in READY state only.
      Exception done for MspInit/MspDeInit callbacks that can be registered/unregistered
      in READY or RESET state, thus registered (user) MspInit/DeInit callbacks can be used
      during the Init/DeInit.
      In that case first register the MspInit/MspDeInit user callbacks
      using HAL_SDRAM_RegisterCallback before calling HAL_SDRAM_DeInit
      or HAL_SDRAM_Init function.

      When The compilation define USE_HAL_SDRAM_REGISTER_CALLBACKS is set to 0 or
      not defined, the callback registering feature is not available
      and weak (overridden) callbacks are used.

  @endverbatim
  ******************************************************************************
  *//Users/jie/Documents/posixGen_Demos-main/LwIP_StreamingServer/Drivers/STM32F7xx_HAL_Driver/Src/stm32f7xx_hal_tim.cIS_TIM_CC1_INSTANCE(TIMx)IS_TIM_CHANNELS(Channel)0x1FUtmpsmcr(TIM_SMCR_ETF | TIM_SMCR_ETPS | TIM_SMCR_ECE | TIM_SMCR_ETP)~(TIM_SMCR_ETF | TIM_SMCR_ETPS | TIM_SMCR_ECE | TIM_SMCR_ETP)TIM_ITRx_SetConfig4294967183~TIM_SMCR_TSTIM_TI4_SetConfigtmpccmr2tmpccer~TIM_CCER_CC4E~TIM_CCMR2_CC4S~TIM_CCMR2_IC4F40960(TIM_CCER_CC4P | TIM_CCER_CC4NP)4294926335~(TIM_CCER_CC4P | TIM_CCER_CC4NP)TIM_TI3_SetConfig~TIM_CCER_CC3E~TIM_CCMR2_CC3S~TIM_CCMR2_IC3F2560(TIM_CCER_CC3P | TIM_CCER_CC3NP)4294964735~(TIM_CCER_CC3P | TIM_CCER_CC3NP)TIM_TI2_ConfigInputStagetmpccmr1~TIM_CCER_CC2E~TIM_CCMR1_IC2F(TIM_CCER_CC2P | TIM_CCER_CC2NP)4294967135~(TIM_CCER_CC2P | TIM_CCER_CC2NP)TIM_TI2_SetConfig~TIM_CCMR1_CC2STIM_TI1_ConfigInputStage~TIM_CCER_CC1E~TIM_CCMR1_IC1FInputTriggerSource4294967285~(TIM_CCER_CC1P | TIM_CCER_CC1NP)107374284810737438721073744896107380838410738237441073747968~TIM_CCMR1_CC1STIM_SlaveTimer_SetConfig655434294901752~TIM_SMCR_SMSIS_TIM_CLOCKSOURCE_ETRMODE1_INSTANCE(htim->Instance)IS_TIM_TRIGGERPRESCALER(sSlaveConfig->TriggerPrescaler)IS_TIM_TRIGGERPOLARITY(sSlaveConfig->TriggerPolarity)IS_TIM_TRIGGERFILTER(sSlaveConfig->TriggerFilter)IS_TIM_CC1_INSTANCE(htim->Instance)IS_TIM_CC2_INSTANCE(htim->Instance)TIM_OC6_SetConfigtmpccmrxtmpcr2~TIM_CCER_CC6E410316805888(TIM_CCMR3_OC6M)4278161407~(TIM_CCMR3_OC6M)(uint32_t)~TIM_CCER_CC6P~TIM_CR2_OIS6TIM_OC5_SetConfig~TIM_CCER_CC5E65648(TIM_CCMR3_OC5M)4294901647~(TIM_CCMR3_OC5M)~TIM_CCER_CC5P~TIM_CR2_OIS5TIM_OC4_SetConfig~TIM_CCMR2_OC4M~TIM_CCER_CC4PIS_TIM_OCIDLE_STATE(OC_Config->OCIdleState)~TIM_CR2_OIS4TIM_OC3_SetConfig~TIM_CCMR2_OC3M~TIM_CCER_CC3PIS_TIM_OCN_POLARITY(OC_Config->OCNPolarity)~TIM_CCER_CC3NP~TIM_CCER_CC3NEIS_TIM_OCNIDLE_STATE(OC_Config->OCNIdleState)~TIM_CR2_OIS3~TIM_CR2_OIS3N~TIM_CCMR1_OC2M~TIM_CCER_CC2P~TIM_CCER_CC2NP~TIM_CCER_CC2NE~TIM_CR2_OIS2~TIM_CR2_OIS2NTIM_OC1_SetConfig~TIM_CCMR1_OC1M~TIM_CCER_CC1P~TIM_CCER_CC1NP~TIM_CCER_CC1NE~TIM_CR2_OIS1~TIM_CR2_OIS1Ntmpcr1(TIM_CR1_DIR | TIM_CR1_CMS)~(TIM_CR1_DIR | TIM_CR1_CMS)17408107382476818432107382579210737489921073750016~TIM_CR1_CKDStructure->AutoReloadPreload(tmpcr1)(((READ_REG(tmpcr1)) & (~((0x1UL << (7U))))) | (Structure->AutoReloadPreload))(((((tmpcr1))) & (~((0x1UL << (7U))))) | (Structure->AutoReloadPreload))TIMx->SRTIM_DMATriggerHalfCpltTIM_DMATriggerCpltDMA_HandleTypeDef **__DMA_HandleTypeDef **TIM_DMAPeriodElapsedHalfCpltTIM_DMAPeriodElapsedCpltvolatile HAL_TIM_ChannelStateTypeDef *enum <unnamed> *IS_TIM_DMABURST_INSTANCE(htim->Instance)channel_stateIS_TIM_CCX_INSTANCE(htim->Instance, Channel)const volatile HAL_TIM_ChannelStateTypeDefconst volatile HAL_TIM_ChannelStateTypeDef *IS_TIM_CC3_INSTANCE(htim->Instance)IS_TIM_CC4_INSTANCE(htim->Instance)IS_TIM_SLAVE_INSTANCE(htim->Instance)IS_TIM_SLAVE_MODE(sSlaveConfig->SlaveMode)IS_TIM_TRIGGER_SELECTION(sSlaveConfig->InputTrigger)IS_TIM_XOR_INSTANCE(htim->Instance)IS_TIM_TI1SELECTION(TI1_Selection)~TIM_CR2_TI1SIS_TIM_CLOCKSOURCE(sClockSourceConfig->ClockSource)65655(TIM_SMCR_SMS | TIM_SMCR_TS)4294901640~(TIM_SMCR_SMS | TIM_SMCR_TS)IS_TIM_INSTANCE(htim->Instance)IS_TIM_CLOCKPRESCALER(sClockSourceConfig->ClockPrescaler)IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity)IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter)IS_TIM_CLOCKSOURCE_ETRMODE2_INSTANCE(htim->Instance)IS_TIM_CLOCKSOURCE_TIX_INSTANCE(htim->Instance)IS_TIM_CLOCKSOURCE_ITRX_INSTANCE(htim->Instance)(TIM_SLAVEMODE_EXTERNAL1 | TIM_CLOCKSOURCE_ETRMODE1)IS_TIM_OCXREF_CLEAR_INSTANCE(htim->Instance)IS_TIM_CLEARINPUT_SOURCE(sClearInputConfig->ClearInputSource)htim->Instance->SMCR((0xFUL << (8U)) | (0x3UL << (12U)) | (0x1UL << (14U)) | (0x1UL << (15U)))IS_TIM_CLEARINPUT_POLARITY(sClearInputConfig->ClearInputPolarity)IS_TIM_CLEARINPUT_PRESCALER(sClearInputConfig->ClearInputPrescaler)IS_TIM_CLEARINPUT_FILTER(sClearInputConfig->ClearInputFilter)htim->Instance->CCMR1htim->Instance->CCMR2htim->Instance->CCMR3(uint32_t)DISABLEIS_TIM_EVENT_SOURCE(EventSource)IS_TIM_DMA_SOURCE(BurstRequestSrc)IS_TIM_DMA_BASE(BurstBaseAddress)IS_TIM_DMA_LENGTH(BurstLength)IS_TIM_DMA_DATA_LENGTH(DataLength)temp1IS_TIM_OPM_CHANNELS(OutputChannel)IS_TIM_OPM_CHANNELS(InputChannel)TIM_OC_InitTypeDef *~TIM_CCMR1_IC1PSC~TIM_CCMR1_IC2PSCIS_TIM_PWM_MODE(sConfig->OCMode)IS_TIM_OC_POLARITY(sConfig->OCPolarity)IS_TIM_FAST_STATE(sConfig->OCFastMode)IS_TIM_CC5_INSTANCE(htim->Instance)IS_TIM_CC6_INSTANCE(htim->Instance)~TIM_CCMR1_OC1FE~TIM_CCMR1_OC2FE~TIM_CCMR2_OC3FE~TIM_CCMR2_OC4FE~TIM_CCMR3_OC5FE~TIM_CCMR3_OC6FEIS_TIM_IC_POLARITY(sConfig->ICPolarity)IS_TIM_IC_SELECTION(sConfig->ICSelection)IS_TIM_IC_PRESCALER(sConfig->ICPrescaler)IS_TIM_IC_FILTER(sConfig->ICFilter)~TIM_CCMR2_IC3PSC~TIM_CCMR2_IC4PSCIS_TIM_OC_MODE(sConfig->OCMode)itsource(TIM_FLAG_CC1)(TIM_IT_CC1)(TIM_FLAG_CC2)(TIM_IT_CC2)(TIM_FLAG_CC3)(TIM_IT_CC3)(TIM_FLAG_CC4)(TIM_IT_CC4)(TIM_FLAG_UPDATE)(TIM_IT_UPDATE)TIM_FLAG_BREAK | TIM_FLAG_SYSTEM_BREAK(0x1UL << (7U)) | (0x1UL << (13U))(TIM_FLAG_BREAK)(TIM_FLAG_SYSTEM_BREAK)(TIM_IT_BREAK)83204294958975(TIM_FLAG_BREAK2)(TIM_FLAG_TRIGGER)(TIM_IT_TRIGGER)(TIM_FLAG_COM)(TIM_IT_COM)IS_TIM_ENCODER_INTERFACE_INSTANCE(htim->Instance)27343691092channel_1_statechannel_2_statecomplementary_channel_1_statecomplementary_channel_2_stateIS_TIM_COUNTER_MODE(htim->Init.CounterMode)IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision)IS_TIM_AUTORELOAD_PRELOAD(htim->Init.AutoReloadPreload)IS_TIM_ENCODER_MODE(sConfig->EncoderMode)IS_TIM_IC_SELECTION(sConfig->IC1Selection)IS_TIM_IC_SELECTION(sConfig->IC2Selection)IS_TIM_ENCODERINPUT_POLARITY(sConfig->IC1Polarity)IS_TIM_ENCODERINPUT_POLARITY(sConfig->IC2Polarity)IS_TIM_IC_PRESCALER(sConfig->IC1Prescaler)IS_TIM_IC_PRESCALER(sConfig->IC2Prescaler)IS_TIM_IC_FILTER(sConfig->IC1Filter)IS_TIM_IC_FILTER(sConfig->IC2Filter)IS_TIM_PERIOD(htim, htim->Init.Period)81927(TIM_SMCR_SMS | TIM_SMCR_ECE)4294885368~(TIM_SMCR_SMS | TIM_SMCR_ECE)TIM_Base_InitTypeDef *(TIM_CCMR1_CC1S | TIM_CCMR1_CC2S)4294966524~(TIM_CCMR1_CC1S | TIM_CCMR1_CC2S)3084(TIM_CCMR1_IC1PSC | TIM_CCMR1_IC2PSC)4294964211~(TIM_CCMR1_IC1PSC | TIM_CCMR1_IC2PSC)61680(TIM_CCMR1_IC1F | TIM_CCMR1_IC2F)4294905615~(TIM_CCMR1_IC1F | TIM_CCMR1_IC2F)(TIM_CCER_CC1P | TIM_CCER_CC2P)~(TIM_CCER_CC1P | TIM_CCER_CC2P)(TIM_CCER_CC1NP | TIM_CCER_CC2NP)4294967159~(TIM_CCER_CC1NP | TIM_CCER_CC2NP)htim->InstanceIS_TIM_OPM_MODE(OnePulseMode)~TIM_CR1_OPMIS_TIM_CCX_CHANNEL(htim->Instance, Channel)IS_TIM_DMA_CC_INSTANCE(htim->Instance)complementary_channel_stateIS_TIM_DMA_INSTANCE(htim->Instance)/* Reset the TIM callback to the legacy weak callbacks *//**
  * @brief  Reset interrupt callbacks to the legacy weak callbacks.
  * @param  htim pointer to a TIM_HandleTypeDef structure that contains
  *                the configuration information for TIM module.
  * @retval None
  *//* 0x1FU = 31 bits max shift *//* Set or reset the CCxE Bit *//* Reset the CCxE Bit *//**
  * @brief  Enables or disables the TIM Capture Compare Channel x.
  * @param  TIMx to select the TIM peripheral
  * @param  Channel specifies the TIM Channel
  *          This parameter can be one of the following values:
  *            @arg TIM_CHANNEL_1: TIM Channel 1
  *            @arg TIM_CHANNEL_2: TIM Channel 2
  *            @arg TIM_CHANNEL_3: TIM Channel 3
  *            @arg TIM_CHANNEL_4: TIM Channel 4
  *            @arg TIM_CHANNEL_5: TIM Channel 5 selected
  *            @arg TIM_CHANNEL_6: TIM Channel 6 selected
  * @param  ChannelState specifies the TIM Channel CCxE bit new state.
  *          This parameter can be: TIM_CCx_ENABLE or TIM_CCx_DISABLE.
  * @retval None
  *//* Write to TIMx SMCR *//* Set the Prescaler, the Filter value and the Polarity *//* Reset the ETR Bits *//**
  * @brief  Configures the TIMx External Trigger (ETR).
  * @param  TIMx to select the TIM peripheral
  * @param  TIM_ExtTRGPrescaler The external Trigger Prescaler.
  *          This parameter can be one of the following values:
  *            @arg TIM_ETRPRESCALER_DIV1: ETRP Prescaler OFF.
  *            @arg TIM_ETRPRESCALER_DIV2: ETRP frequency divided by 2.
  *            @arg TIM_ETRPRESCALER_DIV4: ETRP frequency divided by 4.
  *            @arg TIM_ETRPRESCALER_DIV8: ETRP frequency divided by 8.
  * @param  TIM_ExtTRGPolarity The external Trigger Polarity.
  *          This parameter can be one of the following values:
  *            @arg TIM_ETRPOLARITY_INVERTED: active low or falling edge active.
  *            @arg TIM_ETRPOLARITY_NONINVERTED: active high or rising edge active.
  * @param  ExtTRGFilter External Trigger Filter.
  *          This parameter must be a value between 0x00 and 0x0F
  * @retval None
  *//* Set the Input Trigger source and the slave mode*//* Reset the TS Bits *//* Get the TIMx SMCR register value *//**
  * @brief  Selects the Input Trigger source
  * @param  TIMx to select the TIM peripheral
  * @param  InputTriggerSource The Input Trigger source.
  *          This parameter can be one of the following values:
  *            @arg TIM_TS_ITR0: Internal Trigger 0
  *            @arg TIM_TS_ITR1: Internal Trigger 1
  *            @arg TIM_TS_ITR2: Internal Trigger 2
  *            @arg TIM_TS_ITR3: Internal Trigger 3
  *            @arg TIM_TS_TI1F_ED: TI1 Edge Detector
  *            @arg TIM_TS_TI1FP1: Filtered Timer Input 1
  *            @arg TIM_TS_TI2FP2: Filtered Timer Input 2
  *            @arg TIM_TS_ETRF: External Trigger input
  * @retval None
  *//* Write to TIMx CCMR2 and CCER registers *//* Select the Polarity and set the CC4E Bit *//* Set the filter *//* Select the Input *//* Disable the Channel 4: Reset the CC4E Bit *//**
  * @brief  Configure the TI4 as Input.
  * @param  TIMx to select the TIM peripheral
  * @param  TIM_ICPolarity The Input Polarity.
  *          This parameter can be one of the following values:
  *            @arg TIM_ICPOLARITY_RISING
  *            @arg TIM_ICPOLARITY_FALLING
  *            @arg TIM_ICPOLARITY_BOTHEDGE
  * @param  TIM_ICSelection specifies the input to be used.
  *          This parameter can be one of the following values:
  *            @arg TIM_ICSELECTION_DIRECTTI: TIM Input 4 is selected to be connected to IC4.
  *            @arg TIM_ICSELECTION_INDIRECTTI: TIM Input 4 is selected to be connected to IC3.
  *            @arg TIM_ICSELECTION_TRC: TIM Input 4 is selected to be connected to TRC.
  * @param  TIM_ICFilter Specifies the Input Capture Filter.
  *          This parameter must be a value between 0x00 and 0x0F.
  * @note TIM_ICFilter and TIM_ICPolarity are not used in INDIRECT mode as TI4FP3
  *       (on channel1 path) is used as the input signal. Therefore CCMR2 must be
  *        protected against un-initialized filter and polarity values.
  * @retval None
  *//* Select the Polarity and set the CC3E Bit *//* Disable the Channel 3: Reset the CC3E Bit *//**
  * @brief  Configure the TI3 as Input.
  * @param  TIMx to select the TIM peripheral
  * @param  TIM_ICPolarity The Input Polarity.
  *          This parameter can be one of the following values:
  *            @arg TIM_ICPOLARITY_RISING
  *            @arg TIM_ICPOLARITY_FALLING
  *            @arg TIM_ICPOLARITY_BOTHEDGE
  * @param  TIM_ICSelection specifies the input to be used.
  *          This parameter can be one of the following values:
  *            @arg TIM_ICSELECTION_DIRECTTI: TIM Input 3 is selected to be connected to IC3.
  *            @arg TIM_ICSELECTION_INDIRECTTI: TIM Input 3 is selected to be connected to IC4.
  *            @arg TIM_ICSELECTION_TRC: TIM Input 3 is selected to be connected to TRC.
  * @param  TIM_ICFilter Specifies the Input Capture Filter.
  *          This parameter must be a value between 0x00 and 0x0F.
  * @retval None
  * @note TIM_ICFilter and TIM_ICPolarity are not used in INDIRECT mode as TI3FP4
  *       (on channel1 path) is used as the input signal. Therefore CCMR2 must be
  *        protected against un-initialized filter and polarity values.
  *//* Write to TIMx CCMR1 and CCER registers *//* Select the Polarity and set the CC2E Bit *//* Disable the Channel 2: Reset the CC2E Bit *//**
  * @brief  Configure the Polarity and Filter for TI2.
  * @param  TIMx to select the TIM peripheral.
  * @param  TIM_ICPolarity The Input Polarity.
  *          This parameter can be one of the following values:
  *            @arg TIM_ICPOLARITY_RISING
  *            @arg TIM_ICPOLARITY_FALLING
  *            @arg TIM_ICPOLARITY_BOTHEDGE
  * @param  TIM_ICFilter Specifies the Input Capture Filter.
  *          This parameter must be a value between 0x00 and 0x0F.
  * @retval None
  *//**
  * @brief  Configure the TI2 as Input.
  * @param  TIMx to select the TIM peripheral
  * @param  TIM_ICPolarity The Input Polarity.
  *          This parameter can be one of the following values:
  *            @arg TIM_ICPOLARITY_RISING
  *            @arg TIM_ICPOLARITY_FALLING
  *            @arg TIM_ICPOLARITY_BOTHEDGE
  * @param  TIM_ICSelection specifies the input to be used.
  *          This parameter can be one of the following values:
  *            @arg TIM_ICSELECTION_DIRECTTI: TIM Input 2 is selected to be connected to IC2.
  *            @arg TIM_ICSELECTION_INDIRECTTI: TIM Input 2 is selected to be connected to IC1.
  *            @arg TIM_ICSELECTION_TRC: TIM Input 2 is selected to be connected to TRC.
  * @param  TIM_ICFilter Specifies the Input Capture Filter.
  *          This parameter must be a value between 0x00 and 0x0F.
  * @retval None
  * @note TIM_ICFilter and TIM_ICPolarity are not used in INDIRECT mode as TI1FP2
  *       (on channel1 path) is used as the input signal. Therefore CCMR1 must be
  *        protected against un-initialized filter and polarity values.
  *//* Select the Polarity and set the CC1E Bit *//* Disable the Channel 1: Reset the CC1E Bit *//**
  * @brief  Configure the Polarity and Filter for TI1.
  * @param  TIMx to select the TIM peripheral.
  * @param  TIM_ICPolarity The Input Polarity.
  *          This parameter can be one of the following values:
  *            @arg TIM_ICPOLARITY_RISING
  *            @arg TIM_ICPOLARITY_FALLING
  *            @arg TIM_ICPOLARITY_BOTHEDGE
  * @param  TIM_ICFilter Specifies the Input Capture Filter.
  *          This parameter must be a value between 0x00 and 0x0F.
  * @retval None
  *//**
  * @brief  Configure the TI1 as Input.
  * @param  TIMx to select the TIM peripheral.
  * @param  TIM_ICPolarity The Input Polarity.
  *          This parameter can be one of the following values:
  *            @arg TIM_ICPOLARITY_RISING
  *            @arg TIM_ICPOLARITY_FALLING
  *            @arg TIM_ICPOLARITY_BOTHEDGE
  * @param  TIM_ICSelection specifies the input to be used.
  *          This parameter can be one of the following values:
  *            @arg TIM_ICSELECTION_DIRECTTI: TIM Input 1 is selected to be connected to IC1.
  *            @arg TIM_ICSELECTION_INDIRECTTI: TIM Input 1 is selected to be connected to IC2.
  *            @arg TIM_ICSELECTION_TRC: TIM Input 1 is selected to be connected to TRC.
  * @param  TIM_ICFilter Specifies the Input Capture Filter.
  *          This parameter must be a value between 0x00 and 0x0F.
  * @retval None
  * @note TIM_ICFilter and TIM_ICPolarity are not used in INDIRECT mode as TI2FP1
  *       (on channel2 path) is used as the input signal. Therefore CCMR1 must be
  *        protected against un-initialized filter and polarity values.
  *//* Configure TI2 Filter and Polarity *//* Configure TI1 Filter and Polarity *//* Configure the ETR Trigger source *//* Configure the trigger prescaler, filter, and polarity *//* Set the slave mode *//* Reset the slave mode Bits *//* Set the Input Trigger source *//* Reset the Trigger Selection Bits *//**
  * @brief  Slave Timer configuration function
  * @param  htim TIM handle
  * @param  sSlaveConfig Slave timer configuration
  * @retval None
  *//* Write to TIMx CCER *//* Set the Capture Compare Register value *//* Write to TIMx CCMR3 *//* Write to TIMx CR2 *//* Set the Output Idle state *//* Reset the Output Compare IDLE State *//* Set the Output Compare Polarity *//* Reset the Output Polarity level *//* Select the Output Compare Mode *//* Reset the Output Compare Mode Bits *//* Get the TIMx CCMR1 register value *//* Get the TIMx CR2 register value *//* Disable the output: Reset the CCxE Bit *//* Get the TIMx CCER register value *//**
  * @brief  Timer Output Compare 6 configuration
  * @param  TIMx to select the TIM peripheral
  * @param  OC_Config The output configuration structure
  * @retval None
  *//**
  * @brief  Timer Output Compare 5 configuration
  * @param  TIMx to select the TIM peripheral
  * @param  OC_Config The output configuration structure
  * @retval None
  *//* Write to TIMx CCMR2 *//* Check parameters *//* Reset the Output Compare mode and Capture/Compare selection Bits *//* Get the TIMx CCMR2 register value *//**
  * @brief  Timer Output Compare 4 configuration
  * @param  TIMx to select the TIM peripheral
  * @param  OC_Config The output configuration structure
  * @retval None
  *//* Set the Output N Idle state *//* Reset the Output Compare and Output Compare N IDLE State *//* Reset the Output N State *//* Set the Output N Polarity *//* Reset the Output N Polarity level *//* Disable the Channel 3: Reset the CC2E Bit *//**
  * @brief  Timer Output Compare 3 configuration
  * @param  TIMx to select the TIM peripheral
  * @param  OC_Config The output configuration structure
  * @retval None
  *//* Write to TIMx CCMR1 *//**
  * @brief  Timer Output Compare 2 configuration
  * @param  TIMx to select the TIM peripheral
  * @param  OC_Config The output configuration structure
  * @retval None
  *//**
  * @brief  Timer Output Compare 1 configuration
  * @param  TIMx to select the TIM peripheral
  * @param  OC_Config The output configuration structure
  * @retval None
  *//* Clear the update flag *//* Check if the update flag is set after the Update Generation, if so clear the UIF flag *//* Generate an update event to reload the Prescaler
     and the repetition counter (only for advanced timer) value immediately *//* Set the Repetition Counter value *//* Set the Prescaler value *//* Set the Autoreload value *//* Set the auto-reload preload *//* Set the clock division *//* Select the Counter Mode *//* Set TIM Time Base Unit parameters ---------------------------------------*//**
  * @brief  Time Base configuration
  * @param  TIMx TIM peripheral
  * @param  Structure TIM Base configuration structure
  * @retval None
  *//**
  * @brief  TIM DMA Trigger half complete callback.
  * @param  hdma pointer to DMA handle.
  * @retval None
  *//**
  * @brief  TIM DMA Trigger callback.
  * @param  hdma pointer to DMA handle.
  * @retval None
  *//**
  * @brief  TIM DMA Period Elapse half complete callback.
  * @param  hdma pointer to DMA handle.
  * @retval None
  *//**
  * @brief  TIM DMA Period Elapse complete callback.
  * @param  hdma pointer to DMA handle.
  * @retval None
  *//* nothing to do *//**
  * @brief  TIM DMA Capture half complete callback.
  * @param  hdma pointer to DMA handle.
  * @retval None
  *//**
  * @brief  TIM DMA Capture complete callback.
  * @param  hdma pointer to DMA handle.
  * @retval None
  *//**
  * @brief  TIM DMA Delay Pulse half complete callback.
  * @param  hdma pointer to DMA handle.
  * @retval None
  *//**
  * @brief  TIM DMA Delay Pulse complete callback.
  * @param  hdma pointer to DMA handle.
  * @retval None
  *//**
  * @brief  TIM DMA error callback
  * @param  hdma pointer to DMA handle.
  * @retval None
  *//**
  * @brief  Return actual state of a DMA burst operation.
  * @param  htim TIM handle
  * @retval DMA burst state
  *//**
  * @brief  Return actual state of the TIM channel.
  * @param  htim TIM handle
  * @param  Channel TIM Channel
  *          This parameter can be one of the following values:
  *            @arg TIM_CHANNEL_1: TIM Channel 1
  *            @arg TIM_CHANNEL_2: TIM Channel 2
  *            @arg TIM_CHANNEL_3: TIM Channel 3
  *            @arg TIM_CHANNEL_4: TIM Channel 4
  *            @arg TIM_CHANNEL_5: TIM Channel 5
  *            @arg TIM_CHANNEL_6: TIM Channel 6
  * @retval TIM Channel state
  *//**
  * @brief  Return the TIM Encoder Mode handle state.
  * @param  htim TIM handle
  * @retval Active channel
  *//**
  * @brief  Return the TIM Encoder Mode handle state.
  * @param  htim TIM Encoder Interface handle
  * @retval HAL state
  *//**
  * @brief  Return the TIM One Pulse Mode handle state.
  * @param  htim TIM OPM handle
  * @retval HAL state
  *//**
  * @brief  Return the TIM Input Capture handle state.
  * @param  htim TIM IC handle
  * @retval HAL state
  *//**
  * @brief  Return the TIM PWM handle state.
  * @param  htim TIM handle
  * @retval HAL state
  *//**
  * @brief  Return the TIM OC handle state.
  * @param  htim TIM Output Compare handle
  * @retval HAL state
  *//**
  * @brief  Return the TIM Base handle state.
  * @param  htim TIM Base handle
  * @retval HAL state
  *//** @defgroup TIM_Exported_Functions_Group10 TIM Peripheral State functions
  *  @brief   TIM Peripheral State functions
  *
@verbatim
  ==============================================================================
                        ##### Peripheral State functions #####
  ==============================================================================
    [..]
    This subsection permits to get in run-time the status of the peripheral
    and the data flow.

@endverbatim
  * @{
  *//* Legacy weak Hall Sensor Msp DeInit Callback *//* Legacy weak Hall Sensor Msp Init Callback *//* Legacy weak Encoder Msp DeInit Callback *//* Legacy weak Encoder Msp Init Callback *//* Legacy weak One Pulse Msp DeInit Callback *//* Legacy weak One Pulse Msp Init Callback *//* Legacy weak PWM Msp DeInit Callback *//* Legacy weak PWM Msp Init Callback *//* Legacy weak OC Msp DeInit Callback *//* Legacy weak OC Msp Init Callback *//* Legacy weak IC Msp DeInit Callback *//* Legacy weak IC Msp Init Callback *//* Legacy weak Base Msp DeInit Callback *//* Legacy weak Base MspInit Callback *//* Legacy weak Break2 Callback *//* Legacy weak Break Callback *//* Legacy weak Commutation half complete Callback *//* Legacy weak Commutation Callback *//* Legacy weak Error Callback *//* Legacy weak PWM Pulse Finished half complete Callback *//* Legacy weak PWM Pulse Finished Callback *//* Legacy weak OC Delay Elapsed Callback *//* Legacy weak IC Capture half complete Callback *//* Legacy weak IC Capture Callback *//* Legacy weak Trigger half complete Callback *//* Legacy weak Trigger Callback *//* Legacy weak Period Elapsed half complete Callback *//* Legacy weak Period Elapsed Callback *//**
  * @brief  Unregister a TIM callback
  *         TIM callback is redirected to the weak predefined callback
  * @param htim tim handle
  * @param CallbackID ID of the callback to be unregistered
  *        This parameter can be one of the following values:
  *          @arg @ref HAL_TIM_BASE_MSPINIT_CB_ID Base MspInit Callback ID
  *          @arg @ref HAL_TIM_BASE_MSPDEINIT_CB_ID Base MspDeInit Callback ID
  *          @arg @ref HAL_TIM_IC_MSPINIT_CB_ID IC MspInit Callback ID
  *          @arg @ref HAL_TIM_IC_MSPDEINIT_CB_ID IC MspDeInit Callback ID
  *          @arg @ref HAL_TIM_OC_MSPINIT_CB_ID OC MspInit Callback ID
  *          @arg @ref HAL_TIM_OC_MSPDEINIT_CB_ID OC MspDeInit Callback ID
  *          @arg @ref HAL_TIM_PWM_MSPINIT_CB_ID PWM MspInit Callback ID
  *          @arg @ref HAL_TIM_PWM_MSPDEINIT_CB_ID PWM MspDeInit Callback ID
  *          @arg @ref HAL_TIM_ONE_PULSE_MSPINIT_CB_ID One Pulse MspInit Callback ID
  *          @arg @ref HAL_TIM_ONE_PULSE_MSPDEINIT_CB_ID One Pulse MspDeInit Callback ID
  *          @arg @ref HAL_TIM_ENCODER_MSPINIT_CB_ID Encoder MspInit Callback ID
  *          @arg @ref HAL_TIM_ENCODER_MSPDEINIT_CB_ID Encoder MspDeInit Callback ID
  *          @arg @ref HAL_TIM_HALL_SENSOR_MSPINIT_CB_ID Hall Sensor MspInit Callback ID
  *          @arg @ref HAL_TIM_HALL_SENSOR_MSPDEINIT_CB_ID Hall Sensor MspDeInit Callback ID
  *          @arg @ref HAL_TIM_PERIOD_ELAPSED_CB_ID Period Elapsed Callback ID
  *          @arg @ref HAL_TIM_PERIOD_ELAPSED_HALF_CB_ID Period Elapsed half complete Callback ID
  *          @arg @ref HAL_TIM_TRIGGER_CB_ID Trigger Callback ID
  *          @arg @ref HAL_TIM_TRIGGER_HALF_CB_ID Trigger half complete Callback ID
  *          @arg @ref HAL_TIM_IC_CAPTURE_CB_ID Input Capture Callback ID
  *          @arg @ref HAL_TIM_IC_CAPTURE_HALF_CB_ID Input Capture half complete Callback ID
  *          @arg @ref HAL_TIM_OC_DELAY_ELAPSED_CB_ID Output Compare Delay Elapsed Callback ID
  *          @arg @ref HAL_TIM_PWM_PULSE_FINISHED_CB_ID PWM Pulse Finished Callback ID
  *          @arg @ref HAL_TIM_PWM_PULSE_FINISHED_HALF_CB_ID PWM Pulse Finished half complete Callback ID
  *          @arg @ref HAL_TIM_ERROR_CB_ID Error Callback ID
  *          @arg @ref HAL_TIM_COMMUTATION_CB_ID Commutation Callback ID
  *          @arg @ref HAL_TIM_COMMUTATION_HALF_CB_ID Commutation half complete Callback ID
  *          @arg @ref HAL_TIM_BREAK_CB_ID Break Callback ID
  *          @arg @ref HAL_TIM_BREAK2_CB_ID Break2 Callback ID
  *          @retval status
  *//**
  * @brief  Register a User TIM callback to be used instead of the weak predefined callback
  * @param htim tim handle
  * @param CallbackID ID of the callback to be registered
  *        This parameter can be one of the following values:
  *          @arg @ref HAL_TIM_BASE_MSPINIT_CB_ID Base MspInit Callback ID
  *          @arg @ref HAL_TIM_BASE_MSPDEINIT_CB_ID Base MspDeInit Callback ID
  *          @arg @ref HAL_TIM_IC_MSPINIT_CB_ID IC MspInit Callback ID
  *          @arg @ref HAL_TIM_IC_MSPDEINIT_CB_ID IC MspDeInit Callback ID
  *          @arg @ref HAL_TIM_OC_MSPINIT_CB_ID OC MspInit Callback ID
  *          @arg @ref HAL_TIM_OC_MSPDEINIT_CB_ID OC MspDeInit Callback ID
  *          @arg @ref HAL_TIM_PWM_MSPINIT_CB_ID PWM MspInit Callback ID
  *          @arg @ref HAL_TIM_PWM_MSPDEINIT_CB_ID PWM MspDeInit Callback ID
  *          @arg @ref HAL_TIM_ONE_PULSE_MSPINIT_CB_ID One Pulse MspInit Callback ID
  *          @arg @ref HAL_TIM_ONE_PULSE_MSPDEINIT_CB_ID One Pulse MspDeInit Callback ID
  *          @arg @ref HAL_TIM_ENCODER_MSPINIT_CB_ID Encoder MspInit Callback ID
  *          @arg @ref HAL_TIM_ENCODER_MSPDEINIT_CB_ID Encoder MspDeInit Callback ID
  *          @arg @ref HAL_TIM_HALL_SENSOR_MSPINIT_CB_ID Hall Sensor MspInit Callback ID
  *          @arg @ref HAL_TIM_HALL_SENSOR_MSPDEINIT_CB_ID Hall Sensor MspDeInit Callback ID
  *          @arg @ref HAL_TIM_PERIOD_ELAPSED_CB_ID Period Elapsed Callback ID
  *          @arg @ref HAL_TIM_PERIOD_ELAPSED_HALF_CB_ID Period Elapsed half complete Callback ID
  *          @arg @ref HAL_TIM_TRIGGER_CB_ID Trigger Callback ID
  *          @arg @ref HAL_TIM_TRIGGER_HALF_CB_ID Trigger half complete Callback ID
  *          @arg @ref HAL_TIM_IC_CAPTURE_CB_ID Input Capture Callback ID
  *          @arg @ref HAL_TIM_IC_CAPTURE_HALF_CB_ID Input Capture half complete Callback ID
  *          @arg @ref HAL_TIM_OC_DELAY_ELAPSED_CB_ID Output Compare Delay Elapsed Callback ID
  *          @arg @ref HAL_TIM_PWM_PULSE_FINISHED_CB_ID PWM Pulse Finished Callback ID
  *          @arg @ref HAL_TIM_PWM_PULSE_FINISHED_HALF_CB_ID PWM Pulse Finished half complete Callback ID
  *          @arg @ref HAL_TIM_ERROR_CB_ID Error Callback ID
  *          @arg @ref HAL_TIM_COMMUTATION_CB_ID Commutation Callback ID
  *          @arg @ref HAL_TIM_COMMUTATION_HALF_CB_ID Commutation half complete Callback ID
  *          @arg @ref HAL_TIM_BREAK_CB_ID Break Callback ID
  *          @arg @ref HAL_TIM_BREAK2_CB_ID Break2 Callback ID
  *          @param pCallback pointer to the callback function
  *          @retval status
  *//* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIM_ErrorCallback could be implemented in the user file
   *//**
  * @brief  Timer error callback in non-blocking mode
  * @param  htim TIM handle
  * @retval None
  *//* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIM_TriggerHalfCpltCallback could be implemented in the user file
   *//**
  * @brief  Hall Trigger detection half complete callback in non-blocking mode
  * @param  htim TIM handle
  * @retval None
  *//* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIM_TriggerCallback could be implemented in the user file
   *//**
  * @brief  Hall Trigger detection callback in non-blocking mode
  * @param  htim TIM handle
  * @retval None
  *//* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIM_PWM_PulseFinishedHalfCpltCallback could be implemented in the user file
   *//**
  * @brief  PWM Pulse finished half complete callback in non-blocking mode
  * @param  htim TIM handle
  * @retval None
  *//* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIM_PWM_PulseFinishedCallback could be implemented in the user file
   *//**
  * @brief  PWM Pulse finished callback in non-blocking mode
  * @param  htim TIM handle
  * @retval None
  *//* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIM_IC_CaptureHalfCpltCallback could be implemented in the user file
   *//**
  * @brief  Input Capture half complete callback in non-blocking mode
  * @param  htim TIM IC handle
  * @retval None
  *//* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIM_IC_CaptureCallback could be implemented in the user file
   *//**
  * @brief  Input Capture callback in non-blocking mode
  * @param  htim TIM IC handle
  * @retval None
  *//* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIM_OC_DelayElapsedCallback could be implemented in the user file
   *//**
  * @brief  Output Compare callback in non-blocking mode
  * @param  htim TIM OC handle
  * @retval None
  *//* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIM_PeriodElapsedHalfCpltCallback could be implemented in the user file
   *//**
  * @brief  Period elapsed half complete callback in non-blocking mode
  * @param  htim TIM handle
  * @retval None
  *//* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIM_PeriodElapsedCallback could be implemented in the user file
   *//**
  * @brief  Period elapsed callback in non-blocking mode
  * @param  htim TIM handle
  * @retval None
  *//** @defgroup TIM_Exported_Functions_Group9 TIM Callbacks functions
  *  @brief    TIM Callbacks functions
  *
@verbatim
  ==============================================================================
                        ##### TIM Callbacks functions #####
  ==============================================================================
 [..]
   This section provides TIM callback functions:
   (+) TIM Period elapsed callback
   (+) TIM Output Compare callback
   (+) TIM Input capture callback
   (+) TIM Trigger callback
   (+) TIM Error callback

@endverbatim
  * @{
  *//* Return the capture 4 value *//* Return the capture 3 value *//* Return the capture 2 value *//* Return the capture 1 value *//**
  * @brief  Read the captured value from Capture Compare unit
  * @param  htim TIM handle.
  * @param  Channel TIM Channels to be enabled
  *          This parameter can be one of the following values:
  *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
  *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
  *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
  * @retval Captured value
  *//* Disable Trigger DMA request *//* Enable Trigger Interrupt *//**
  * @brief  Configures the TIM in Slave mode in interrupt mode
  * @param  htim TIM handle.
  * @param  sSlaveConfig pointer to a TIM_SlaveConfigTypeDef structure that
  *         contains the selected trigger (internal trigger input, filtered
  *         timer input or external trigger input) and the Slave mode
  *         (Disable, Reset, Gated, Trigger, External clock mode 1).
  * @retval HAL status
  *//* Disable Trigger Interrupt *//**
  * @brief  Configures the TIM in Slave mode
  * @param  htim TIM handle.
  * @param  sSlaveConfig pointer to a TIM_SlaveConfigTypeDef structure that
  *         contains the selected trigger (internal trigger input, filtered
  *         timer input or external trigger input) and the Slave mode
  *         (Disable, Reset, Gated, Trigger, External clock mode 1).
  * @retval HAL status
  *//* Write to TIMxCR2 *//* Set the TI1 selection *//* Reset the TI1 selection *//**
  * @brief  Selects the signal connected to the TI1 input: direct from CH1_input
  *         or a XOR combination between CH1_input, CH2_input & CH3_input
  * @param  htim TIM handle.
  * @param  TI1_Selection Indicate whether or not channel 1 is connected to the
  *         output of a XOR gate.
  *          This parameter can be one of the following values:
  *            @arg TIM_TI1SELECTION_CH1: The TIMx_CH1 pin is connected to TI1 input
  *            @arg TIM_TI1SELECTION_XORCOMBINATION: The TIMx_CH1, CH2 and CH3
  *            pins are connected to the TI1 input (XOR combination)
  * @retval HAL status
  *//* Check whether or not the timer instance supports internal trigger input *//* Check TI1 input conditioning related parameters *//* Check whether or not the timer instance supports external clock mode 1 *//* Check TI2 input conditioning related parameters *//* Check whether or not the timer instance supports external clock mode 1 (ETRF)*//* Enable the External clock mode2 *//* Configure the ETR Clock source *//* Check ETR input conditioning related parameters *//* Check whether or not the timer instance supports external trigger input mode 2 (ETRF)*//* Select the External clock mode1 and the ETRF trigger *//* Check whether or not the timer instance supports external trigger input mode 1 (ETRF)*//* Reset the SMS, TS, ECE, ETPS and ETRF bits *//**
  * @brief   Configures the clock source to be used
  * @param  htim TIM handle
  * @param  sClockSourceConfig pointer to a TIM_ClockConfigTypeDef structure that
  *         contains the clock source information for the TIM peripheral.
  * @retval HAL status
  *//* Disable the OCREF clear feature for Channel 6 *//* Enable the OCREF clear feature for Channel 6 *//* Disable the OCREF clear feature for Channel 5 *//* Enable the OCREF clear feature for Channel 5 *//* Disable the OCREF clear feature for Channel 4 *//* Enable the OCREF clear feature for Channel 4 *//* Disable the OCREF clear feature for Channel 3 *//* Enable the OCREF clear feature for Channel 3 *//* Disable the OCREF clear feature for Channel 2 *//* Enable the OCREF clear feature for Channel 2 *//* Disable the OCREF clear feature for Channel 1 *//* Enable the OCREF clear feature for Channel 1 *//* When OCRef clear feature is used with ETR source, ETR prescaler must be off *//* Clear the OCREF clear selection bit and the the ETR Bits *//**
  * @brief  Configures the OCRef clear feature
  * @param  htim TIM handle
  * @param  sClearInputConfig pointer to a TIM_ClearInputConfigTypeDef structure that
  *         contains the OCREF clear feature and parameters for the TIM peripheral.
  * @param  Channel specifies the TIM Channel
  *          This parameter can be one of the following values:
  *            @arg TIM_CHANNEL_1: TIM Channel 1
  *            @arg TIM_CHANNEL_2: TIM Channel 2
  *            @arg TIM_CHANNEL_3: TIM Channel 3
  *            @arg TIM_CHANNEL_4: TIM Channel 4
  *            @arg TIM_CHANNEL_5: TIM Channel 5
  *            @arg TIM_CHANNEL_6: TIM Channel 6
  * @retval HAL status
  *//* Change the TIM state *//* Set the event sources *//**
  * @brief  Generate a software event
  * @param  htim TIM handle
  * @param  EventSource specifies the event source.
  *          This parameter can be one of the following values:
  *            @arg TIM_EVENTSOURCE_UPDATE: Timer update Event source
  *            @arg TIM_EVENTSOURCE_CC1: Timer Capture Compare 1 Event source
  *            @arg TIM_EVENTSOURCE_CC2: Timer Capture Compare 2 Event source
  *            @arg TIM_EVENTSOURCE_CC3: Timer Capture Compare 3 Event source
  *            @arg TIM_EVENTSOURCE_CC4: Timer Capture Compare 4 Event source
  *            @arg TIM_EVENTSOURCE_COM: Timer COM event source
  *            @arg TIM_EVENTSOURCE_TRIGGER: Timer Trigger Event source
  *            @arg TIM_EVENTSOURCE_BREAK: Timer Break event source
  *            @arg TIM_EVENTSOURCE_BREAK2: Timer Break2 event source
  * @note   Basic timers can only generate an update event.
  * @note   TIM_EVENTSOURCE_COM is relevant only with advanced timer instances.
  * @note   TIM_EVENTSOURCE_BREAK and TIM_EVENTSOURCE_BREAK2 are relevant
  *         only for timer instances supporting break input(s).
  * @retval HAL status
  *//* Change the DMA burst operation state *//* Disable the TIM Update DMA request *//* Abort the DMA transfer (at least disable the DMA stream) *//**
  * @brief  Stop the DMA burst reading
  * @param  htim TIM handle
  * @param  BurstRequestSrc TIM DMA Request sources to disable.
  * @retval HAL status
  *//* Enable the TIM DMA Request *//* Configure the DMA Burst Mode *//* Set the DMA trigger callbacks *//* Set the DMA commutation callbacks *//* Set the DMA capture callbacks *//* Set the DMA Period elapsed callbacks *//**
  * @brief  Configure the DMA Burst to transfer Data from the TIM peripheral to the memory
  * @param  htim TIM handle
  * @param  BurstBaseAddress TIM Base address from where the DMA  will start the Data read
  *         This parameter can be one of the following values:
  *            @arg TIM_DMABASE_CR1
  *            @arg TIM_DMABASE_CR2
  *            @arg TIM_DMABASE_SMCR
  *            @arg TIM_DMABASE_DIER
  *            @arg TIM_DMABASE_SR
  *            @arg TIM_DMABASE_EGR
  *            @arg TIM_DMABASE_CCMR1
  *            @arg TIM_DMABASE_CCMR2
  *            @arg TIM_DMABASE_CCER
  *            @arg TIM_DMABASE_CNT
  *            @arg TIM_DMABASE_PSC
  *            @arg TIM_DMABASE_ARR
  *            @arg TIM_DMABASE_RCR
  *            @arg TIM_DMABASE_CCR1
  *            @arg TIM_DMABASE_CCR2
  *            @arg TIM_DMABASE_CCR3
  *            @arg TIM_DMABASE_CCR4
  *            @arg TIM_DMABASE_BDTR
  *            @arg TIM_DMABASE_OR
  *            @arg TIM_DMABASE_CCMR3
  *            @arg TIM_DMABASE_CCR5
  *            @arg TIM_DMABASE_CCR6
  *            @arg TIM_DMABASE_AF1  (*)
  *            @arg TIM_DMABASE_AF2  (*)
  *         (*) value not defined in all devices
  * @param  BurstRequestSrc TIM DMA Request sources
  *         This parameter can be one of the following values:
  *            @arg TIM_DMA_UPDATE: TIM update Interrupt source
  *            @arg TIM_DMA_CC1: TIM Capture Compare 1 DMA source
  *            @arg TIM_DMA_CC2: TIM Capture Compare 2 DMA source
  *            @arg TIM_DMA_CC3: TIM Capture Compare 3 DMA source
  *            @arg TIM_DMA_CC4: TIM Capture Compare 4 DMA source
  *            @arg TIM_DMA_COM: TIM Commutation DMA source
  *            @arg TIM_DMA_TRIGGER: TIM Trigger DMA source
  * @param  BurstBuffer The Buffer address.
  * @param  BurstLength DMA Burst length. This parameter can be one value
  *         between: TIM_DMABURSTLENGTH_1TRANSFER and TIM_DMABURSTLENGTH_18TRANSFERS.
  * @param  DataLength Data length. This parameter can be one value
  *         between 1 and 0xFFFF.
  * @retval HAL status
  *//**
  * @brief  Configure the DMA Burst to transfer Data from the TIM peripheral to the memory
  * @param  htim TIM handle
  * @param  BurstBaseAddress TIM Base address from where the DMA  will start the Data read
  *         This parameter can be one of the following values:
  *            @arg TIM_DMABASE_CR1
  *            @arg TIM_DMABASE_CR2
  *            @arg TIM_DMABASE_SMCR
  *            @arg TIM_DMABASE_DIER
  *            @arg TIM_DMABASE_SR
  *            @arg TIM_DMABASE_EGR
  *            @arg TIM_DMABASE_CCMR1
  *            @arg TIM_DMABASE_CCMR2
  *            @arg TIM_DMABASE_CCER
  *            @arg TIM_DMABASE_CNT
  *            @arg TIM_DMABASE_PSC
  *            @arg TIM_DMABASE_ARR
  *            @arg TIM_DMABASE_RCR
  *            @arg TIM_DMABASE_CCR1
  *            @arg TIM_DMABASE_CCR2
  *            @arg TIM_DMABASE_CCR3
  *            @arg TIM_DMABASE_CCR4
  *            @arg TIM_DMABASE_BDTR
  *            @arg TIM_DMABASE_OR
  *            @arg TIM_DMABASE_CCMR3
  *            @arg TIM_DMABASE_CCR5
  *            @arg TIM_DMABASE_CCR6
  *            @arg TIM_DMABASE_AF1  (*)
  *            @arg TIM_DMABASE_AF2  (*)
  *         (*) value not defined in all devices
  * @param  BurstRequestSrc TIM DMA Request sources
  *         This parameter can be one of the following values:
  *            @arg TIM_DMA_UPDATE: TIM update Interrupt source
  *            @arg TIM_DMA_CC1: TIM Capture Compare 1 DMA source
  *            @arg TIM_DMA_CC2: TIM Capture Compare 2 DMA source
  *            @arg TIM_DMA_CC3: TIM Capture Compare 3 DMA source
  *            @arg TIM_DMA_CC4: TIM Capture Compare 4 DMA source
  *            @arg TIM_DMA_COM: TIM Commutation DMA source
  *            @arg TIM_DMA_TRIGGER: TIM Trigger DMA source
  * @param  BurstBuffer The Buffer address.
  * @param  BurstLength DMA Burst length. This parameter can be one value
  *         between: TIM_DMABURSTLENGTH_1TRANSFER and TIM_DMABURSTLENGTH_18TRANSFERS.
  * @note   This function should be used only when BurstLength is equal to DMA data transfer length.
  * @retval HAL status
  *//**
  * @brief  Stops the TIM DMA Burst mode
  * @param  htim TIM handle
  * @param  BurstRequestSrc TIM DMA Request sources to disable
  * @retval HAL status
  *//* Set the DMA compare callbacks *//**
  * @brief  Configure the DMA Burst to transfer multiple Data from the memory to the TIM peripheral
  * @param  htim TIM handle
  * @param  BurstBaseAddress TIM Base address from where the DMA will start the Data write
  *         This parameter can be one of the following values:
  *            @arg TIM_DMABASE_CR1
  *            @arg TIM_DMABASE_CR2
  *            @arg TIM_DMABASE_SMCR
  *            @arg TIM_DMABASE_DIER
  *            @arg TIM_DMABASE_SR
  *            @arg TIM_DMABASE_EGR
  *            @arg TIM_DMABASE_CCMR1
  *            @arg TIM_DMABASE_CCMR2
  *            @arg TIM_DMABASE_CCER
  *            @arg TIM_DMABASE_CNT
  *            @arg TIM_DMABASE_PSC
  *            @arg TIM_DMABASE_ARR
  *            @arg TIM_DMABASE_RCR
  *            @arg TIM_DMABASE_CCR1
  *            @arg TIM_DMABASE_CCR2
  *            @arg TIM_DMABASE_CCR3
  *            @arg TIM_DMABASE_CCR4
  *            @arg TIM_DMABASE_BDTR
  *            @arg TIM_DMABASE_OR
  *            @arg TIM_DMABASE_CCMR3
  *            @arg TIM_DMABASE_CCR5
  *            @arg TIM_DMABASE_CCR6
  *            @arg TIM_DMABASE_AF1  (*)
  *            @arg TIM_DMABASE_AF2  (*)
  *         (*) value not defined in all devices
  * @param  BurstRequestSrc TIM DMA Request sources
  *         This parameter can be one of the following values:
  *            @arg TIM_DMA_UPDATE: TIM update Interrupt source
  *            @arg TIM_DMA_CC1: TIM Capture Compare 1 DMA source
  *            @arg TIM_DMA_CC2: TIM Capture Compare 2 DMA source
  *            @arg TIM_DMA_CC3: TIM Capture Compare 3 DMA source
  *            @arg TIM_DMA_CC4: TIM Capture Compare 4 DMA source
  *            @arg TIM_DMA_COM: TIM Commutation DMA source
  *            @arg TIM_DMA_TRIGGER: TIM Trigger DMA source
  * @param  BurstBuffer The Buffer address.
  * @param  BurstLength DMA Burst length. This parameter can be one value
  *         between: TIM_DMABURSTLENGTH_1TRANSFER and TIM_DMABURSTLENGTH_18TRANSFERS.
  * @param  DataLength Data length. This parameter can be one value
  *         between 1 and 0xFFFF.
  * @retval HAL status
  *//**
  * @brief  Configure the DMA Burst to transfer Data from the memory to the TIM peripheral
  * @param  htim TIM handle
  * @param  BurstBaseAddress TIM Base address from where the DMA  will start the Data write
  *         This parameter can be one of the following values:
  *            @arg TIM_DMABASE_CR1
  *            @arg TIM_DMABASE_CR2
  *            @arg TIM_DMABASE_SMCR
  *            @arg TIM_DMABASE_DIER
  *            @arg TIM_DMABASE_SR
  *            @arg TIM_DMABASE_EGR
  *            @arg TIM_DMABASE_CCMR1
  *            @arg TIM_DMABASE_CCMR2
  *            @arg TIM_DMABASE_CCER
  *            @arg TIM_DMABASE_CNT
  *            @arg TIM_DMABASE_PSC
  *            @arg TIM_DMABASE_ARR
  *            @arg TIM_DMABASE_RCR
  *            @arg TIM_DMABASE_CCR1
  *            @arg TIM_DMABASE_CCR2
  *            @arg TIM_DMABASE_CCR3
  *            @arg TIM_DMABASE_CCR4
  *            @arg TIM_DMABASE_BDTR
  *            @arg TIM_DMABASE_OR
  *            @arg TIM_DMABASE_CCMR3
  *            @arg TIM_DMABASE_CCR5
  *            @arg TIM_DMABASE_CCR6
  *            @arg TIM_DMABASE_AF1  (*)
  *            @arg TIM_DMABASE_AF2  (*)
  *         (*) value not defined in all devices
  * @param  BurstRequestSrc TIM DMA Request sources
  *         This parameter can be one of the following values:
  *            @arg TIM_DMA_UPDATE: TIM update Interrupt source
  *            @arg TIM_DMA_CC1: TIM Capture Compare 1 DMA source
  *            @arg TIM_DMA_CC2: TIM Capture Compare 2 DMA source
  *            @arg TIM_DMA_CC3: TIM Capture Compare 3 DMA source
  *            @arg TIM_DMA_CC4: TIM Capture Compare 4 DMA source
  *            @arg TIM_DMA_COM: TIM Commutation DMA source
  *            @arg TIM_DMA_TRIGGER: TIM Trigger DMA source
  * @param  BurstBuffer The Buffer address.
  * @param  BurstLength DMA Burst length. This parameter can be one value
  *         between: TIM_DMABURSTLENGTH_1TRANSFER and TIM_DMABURSTLENGTH_18TRANSFERS.
  * @note   This function should be used only when BurstLength is equal to DMA data transfer length.
  * @retval HAL status
  *//* Select the Slave Mode *//* Select the Trigger source *//* Reset the IC2PSC Bits *//* Reset the IC1PSC Bits *//* Extract the Output compare configuration from sConfig structure *//**
  * @brief  Initializes the TIM One Pulse Channels according to the specified
  *         parameters in the TIM_OnePulse_InitTypeDef.
  * @param  htim TIM One Pulse handle
  * @param  sConfig TIM One Pulse configuration structure
  * @param  OutputChannel TIM output channel to configure
  *          This parameter can be one of the following values:
  *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
  * @param  InputChannel TIM input Channel to configure
  *          This parameter can be one of the following values:
  *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
  * @note  To output a waveform with a minimum delay user can enable the fast
  *        mode by calling the @ref __HAL_TIM_ENABLE_OCxFAST macro. Then CCx
  *        output is forced in response to the edge detection on TIx input,
  *        without taking in account the comparison.
  * @retval HAL status
  *//* Configure the Output Fast mode *//* Set the Preload enable bit for channel6 *//* Configure the Channel 6 in PWM mode *//* Set the Preload enable bit for channel5*//* Configure the Channel 5 in PWM mode *//* Set the Preload enable bit for channel4 *//* Configure the Channel 4 in PWM mode *//* Set the Preload enable bit for channel3 *//* Configure the Channel 3 in PWM mode *//* Set the Preload enable bit for channel2 *//* Configure the Channel 2 in PWM mode *//* Set the Preload enable bit for channel1 *//* Configure the Channel 1 in PWM mode *//**
  * @brief  Initializes the TIM PWM  channels according to the specified
  *         parameters in the TIM_OC_InitTypeDef.
  * @param  htim TIM PWM handle
  * @param  sConfig TIM PWM configuration structure
  * @param  Channel TIM Channels to be configured
  *          This parameter can be one of the following values:
  *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
  *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
  *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
  *            @arg TIM_CHANNEL_5: TIM Channel 5 selected
  *            @arg TIM_CHANNEL_6: TIM Channel 6 selected
  * @retval HAL status
  *//* Set the IC4PSC value *//* Reset the IC4PSC Bits *//* TI4 Configuration *//* Set the IC3PSC value *//* Reset the IC3PSC Bits *//* TI3 Configuration *//* Set the IC2PSC value *//* TI2 Configuration *//* Set the IC1PSC value *//* TI1 Configuration *//**
  * @brief  Initializes the TIM Input Capture Channels according to the specified
  *         parameters in the TIM_IC_InitTypeDef.
  * @param  htim TIM IC handle
  * @param  sConfig TIM Input Capture configuration structure
  * @param  Channel TIM Channel to configure
  *          This parameter can be one of the following values:
  *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
  *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
  *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
  * @retval HAL status
  *//* Configure the TIM Channel 6 in Output Compare *//* Configure the TIM Channel 5 in Output Compare *//* Configure the TIM Channel 4 in Output Compare *//* Configure the TIM Channel 3 in Output Compare *//* Configure the TIM Channel 2 in Output Compare *//* Configure the TIM Channel 1 in Output Compare *//**
  * @brief  Initializes the TIM Output Compare Channels according to the specified
  *         parameters in the TIM_OC_InitTypeDef.
  * @param  htim TIM Output Compare handle
  * @param  sConfig TIM Output Compare configuration structure
  * @param  Channel TIM Channels to configure
  *          This parameter can be one of the following values:
  *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
  *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
  *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
  *            @arg TIM_CHANNEL_5: TIM Channel 5 selected
  *            @arg TIM_CHANNEL_6: TIM Channel 6 selected
  * @retval HAL status
  *//** @defgroup TIM_Exported_Functions_Group8 TIM Peripheral Control functions
  *  @brief    TIM Peripheral Control functions
  *
@verbatim
  ==============================================================================
                   ##### Peripheral Control functions #####
  ==============================================================================
 [..]
   This section provides functions allowing to:
      (+) Configure The Input Output channels for OC, PWM, IC or One Pulse mode.
      (+) Configure External Clock source.
      (+) Configure Complementary channels, break features and dead time.
      (+) Configure Master and the Slave synchronization.
      (+) Configure the DMA Burst Mode.

@endverbatim
  * @{
  *//* TIM commutation event *//* TIM Trigger detection event *//* TIM Break2 input event *//* TIM Break input event *//* TIM Update event *//* Output compare event *//* Input capture event *//* Capture compare 4 event *//* Capture compare 3 event *//* Capture compare 2 event *//* Capture compare 1 event *//**
  * @brief  This function handles TIM interrupts requests.
  * @param  htim TIM  handle
  * @retval None
  *//** @defgroup TIM_Exported_Functions_Group7 TIM IRQ handler management
  *  @brief    TIM IRQ handler management
  *
@verbatim
  ==============================================================================
                        ##### IRQ handler management #####
  ==============================================================================
  [..]
    This section provides Timer IRQ handler function.

@endverbatim
  * @{
  *//* Set the TIM channel(s) state *//* Disable the Peripheral *//* Disable the capture compare DMA Request 1 and 2 *//* Disable the capture compare DMA Request 2 *//* Disable the capture compare DMA Request 1 *//* Disable the Input Capture channels 1 and 2
    (in the EncoderInterface the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2) *//**
  * @brief  Stops the TIM Encoder Interface in DMA mode.
  * @param  htim TIM Encoder Interface handle
  * @param  Channel TIM Channels to be enabled
  *          This parameter can be one of the following values:
  *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
  *            @arg TIM_CHANNEL_ALL: TIM Channel 1 and TIM Channel 2 are selected
  * @retval HAL status
  *//* Enable the Capture compare channel *//* Enable the TIM Input Capture  DMA request *//* Enable the TIM Input Capture DMA request *//**
  * @brief  Starts the TIM Encoder Interface in DMA mode.
  * @param  htim TIM Encoder Interface handle
  * @param  Channel TIM Channels to be enabled
  *          This parameter can be one of the following values:
  *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
  *            @arg TIM_CHANNEL_ALL: TIM Channel 1 and TIM Channel 2 are selected
  * @param  pData1 The destination Buffer address for IC1.
  * @param  pData2 The destination Buffer address for IC2.
  * @param  Length The length of data to be transferred from TIM peripheral to memory.
  * @retval HAL status
  *//* Disable the capture compare Interrupts 1 and 2 *//* Disable the capture compare Interrupts 2 *//* Disable the capture compare Interrupts 1 *//**
  * @brief  Stops the TIM Encoder Interface in interrupt mode.
  * @param  htim TIM Encoder Interface handle
  * @param  Channel TIM Channels to be disabled
  *          This parameter can be one of the following values:
  *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
  *            @arg TIM_CHANNEL_ALL: TIM Channel 1 and TIM Channel 2 are selected
  * @retval HAL status
  *//* Enable the capture compare Interrupts 1 and/or 2 *//* Enable the encoder interface channels *//**
  * @brief  Starts the TIM Encoder Interface in interrupt mode.
  * @param  htim TIM Encoder Interface handle
  * @param  Channel TIM Channels to be enabled
  *          This parameter can be one of the following values:
  *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
  *            @arg TIM_CHANNEL_ALL: TIM Channel 1 and TIM Channel 2 are selected
  * @retval HAL status
  *//**
  * @brief  Stops the TIM Encoder Interface.
  * @param  htim TIM Encoder Interface handle
  * @param  Channel TIM Channels to be disabled
  *          This parameter can be one of the following values:
  *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
  *            @arg TIM_CHANNEL_ALL: TIM Channel 1 and TIM Channel 2 are selected
  * @retval HAL status
  *//**
  * @brief  Starts the TIM Encoder Interface.
  * @param  htim TIM Encoder Interface handle
  * @param  Channel TIM Channels to be enabled
  *          This parameter can be one of the following values:
  *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
  *            @arg TIM_CHANNEL_ALL: TIM Channel 1 and TIM Channel 2 are selected
  * @retval HAL status
  *//* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIM_Encoder_MspDeInit could be implemented in the user file
   *//**
  * @brief  DeInitializes TIM Encoder Interface MSP.
  * @param  htim TIM Encoder Interface handle
  * @retval None
  *//* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIM_Encoder_MspInit could be implemented in the user file
   *//**
  * @brief  Initializes the TIM Encoder Interface MSP.
  * @param  htim TIM Encoder Interface handle
  * @retval None
  *//* Change TIM state *//* Set the TIM channels state *//* Disable the TIM Peripheral Clock *//**
  * @brief  DeInitializes the TIM Encoder interface
  * @param  htim TIM Encoder Interface handle
  * @retval HAL status
  *//* Initialize the TIM state*//* Initialize the DMA burst operation state *//* Set the TI1 and the TI2 Polarities *//* Set the Capture Compare 1 and the Capture Compare 2 prescalers and filters *//* Select the Capture Compare 1 and the Capture Compare 2 as input *//* Set the encoder Mode *//* Configure the Time base in the Encoder Mode *//* Reset the SMS and ECE bits *//* Set the TIM state *//* Init the low level hardware : GPIO, CLOCK, NVIC *//* Reset interrupt callbacks to legacy weak callbacks *//* Check the TIM handle allocation *//**
  * @brief  Initializes the TIM Encoder Interface and initialize the associated handle.
  * @note   Switching from Center Aligned counter mode to Edge counter mode (or reverse)
  *         requires a timer reset to avoid unexpected direction
  *         due to DIR bit readonly in center aligned mode.
  *         Ex: call @ref HAL_TIM_Encoder_DeInit() before HAL_TIM_Encoder_Init()
  * @note   Encoder mode and External clock mode 2 are not compatible and must not be selected together
  *         Ex: A call for @ref HAL_TIM_Encoder_Init will erase the settings of @ref HAL_TIM_ConfigClockSource
  *         using TIM_CLOCKSOURCE_ETRMODE2 and vice versa
  * @note   When the timer instance is initialized in Encoder mode, timer
  *         channels 1 and channel 2 are reserved and cannot be used for other
  *         purpose.
  * @param  htim TIM Encoder Interface handle
  * @param  sConfig TIM Encoder Interface configuration structure
  * @retval HAL status
  *//** @defgroup TIM_Exported_Functions_Group6 TIM Encoder functions
  *  @brief    TIM Encoder functions
  *
@verbatim
  ==============================================================================
                          ##### TIM Encoder functions #####
  ==============================================================================
  [..]
    This section provides functions allowing to:
    (+) Initialize and configure the TIM Encoder.
    (+) De-initialize the TIM Encoder.
    (+) Start the TIM Encoder.
    (+) Stop the TIM Encoder.
    (+) Start the TIM Encoder and enable interrupt.
    (+) Stop the TIM Encoder and disable interrupt.
    (+) Start the TIM Encoder and enable DMA transfer.
    (+) Stop the TIM Encoder and disable DMA transfer.

@endverbatim
  * @{
  *//* Disable the Main Output *//* Disable the Capture compare and the Input Capture channels
  (in the OPM Mode the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2)
  if TIM_CHANNEL_1 is used as output, the TIM_CHANNEL_2 will be used as input and
  if TIM_CHANNEL_1 is used as input, the TIM_CHANNEL_2 will be used as output
  whatever the combination, the TIM_CHANNEL_1 and TIM_CHANNEL_2 should be disabled together *//* Disable the TIM Capture/Compare 2 interrupt *//* Disable the TIM Capture/Compare 1 interrupt *//**
  * @brief  Stops the TIM One Pulse signal generation in interrupt mode.
  * @note Though OutputChannel parameter is deprecated and ignored by the function
  *        it has been kept to avoid HAL_TIM API compatibility break.
  * @note The pulse output channel is determined when calling
  *       @ref HAL_TIM_OnePulse_ConfigChannel().
  * @param  htim TIM One Pulse handle
  * @param  OutputChannel See note above
  * @retval HAL status
  *//* Enable the main output *//* Enable the TIM Capture/Compare 2 interrupt *//* Enable the TIM Capture/Compare 1 interrupt *//* Enable the Capture compare and the Input Capture channels
    (in the OPM Mode the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2)
    if TIM_CHANNEL_1 is used as output, the TIM_CHANNEL_2 will be used as input and
    if TIM_CHANNEL_1 is used as input, the TIM_CHANNEL_2 will be used as output
    whatever the combination, the TIM_CHANNEL_1 and TIM_CHANNEL_2 should be enabled together

    No need to enable the counter, it's enabled automatically by hardware
    (the counter starts in response to a stimulus and generate a pulse *//* Check the TIM channels state *//**
  * @brief  Starts the TIM One Pulse signal generation in interrupt mode.
  * @note Though OutputChannel parameter is deprecated and ignored by the function
  *        it has been kept to avoid HAL_TIM API compatibility break.
  * @note The pulse output channel is determined when calling
  *       @ref HAL_TIM_OnePulse_ConfigChannel().
  * @param  htim TIM One Pulse handle
  * @param  OutputChannel See note above
  * @retval HAL status
  *//**
  * @brief  Stops the TIM One Pulse signal generation.
  * @note Though OutputChannel parameter is deprecated and ignored by the function
  *        it has been kept to avoid HAL_TIM API compatibility break.
  * @note The pulse output channel is determined when calling
  *       @ref HAL_TIM_OnePulse_ConfigChannel().
  * @param  htim TIM One Pulse handle
  * @param  OutputChannel See note above
  * @retval HAL status
  *//**
  * @brief  Starts the TIM One Pulse signal generation.
  * @note Though OutputChannel parameter is deprecated and ignored by the function
  *        it has been kept to avoid HAL_TIM API compatibility break.
  * @note The pulse output channel is determined when calling
  *       @ref HAL_TIM_OnePulse_ConfigChannel().
  * @param  htim TIM One Pulse handle
  * @param  OutputChannel See note above
  * @retval HAL status
  *//* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIM_OnePulse_MspDeInit could be implemented in the user file
   *//**
  * @brief  DeInitializes TIM One Pulse MSP.
  * @param  htim TIM One Pulse handle
  * @retval None
  *//* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIM_OnePulse_MspInit could be implemented in the user file
   *//**
  * @brief  Initializes the TIM One Pulse MSP.
  * @param  htim TIM One Pulse handle
  * @retval None
  *//* Set the TIM channel state *//**
  * @brief  DeInitializes the TIM One Pulse
  * @param  htim TIM One Pulse handle
  * @retval HAL status
  *//* Initialize the TIM channels state *//* Configure the OPM Mode *//* Reset the OPM Bit *//* Configure the Time base in the One Pulse Mode *//**
  * @brief  Initializes the TIM One Pulse Time Base according to the specified
  *         parameters in the TIM_HandleTypeDef and initializes the associated handle.
  * @note   Switching from Center Aligned counter mode to Edge counter mode (or reverse)
  *         requires a timer reset to avoid unexpected direction
  *         due to DIR bit readonly in center aligned mode.
  *         Ex: call @ref HAL_TIM_OnePulse_DeInit() before HAL_TIM_OnePulse_Init()
  * @note   When the timer instance is initialized in One Pulse mode, timer
  *         channels 1 and channel 2 are reserved and cannot be used for other
  *         purpose.
  * @param  htim TIM One Pulse handle
  * @param  OnePulseMode Select the One pulse mode.
  *         This parameter can be one of the following values:
  *            @arg TIM_OPMODE_SINGLE: Only one pulse will be generated.
  *            @arg TIM_OPMODE_REPETITIVE: Repetitive pulses will be generated.
  * @retval HAL status
  *//** @defgroup TIM_Exported_Functions_Group5 TIM One Pulse functions
  *  @brief    TIM One Pulse functions
  *
@verbatim
  ==============================================================================
                        ##### TIM One Pulse functions #####
  ==============================================================================
  [..]
    This section provides functions allowing to:
    (+) Initialize and configure the TIM One Pulse.
    (+) De-initialize the TIM One Pulse.
    (+) Start the TIM One Pulse.
    (+) Stop the TIM One Pulse.
    (+) Start the TIM One Pulse and enable interrupt.
    (+) Stop the TIM One Pulse and disable interrupt.
    (+) Start the TIM One Pulse and enable DMA transfer.
    (+) Stop the TIM One Pulse and disable DMA transfer.

@endverbatim
  * @{
  *//* Disable the TIM Capture/Compare 4  DMA request *//* Disable the TIM Capture/Compare 3  DMA request *//* Disable the TIM Capture/Compare 2 DMA request *//* Disable the TIM Capture/Compare 1 DMA request *//* Disable the Input Capture channel *//**
  * @brief  Stops the TIM Input Capture measurement in DMA mode.
  * @param  htim TIM Input Capture handle
  * @param  Channel TIM Channels to be disabled
  *          This parameter can be one of the following values:
  *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
  *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
  *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
  * @retval HAL status
  *//* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger *//* Enable the TIM Capture/Compare 4  DMA request *//* Enable the TIM Capture/Compare 3  DMA request *//* Enable the TIM Capture/Compare 2  DMA request *//* Enable the TIM Capture/Compare 1 DMA request *//* Enable the Input Capture channel *//**
  * @brief  Starts the TIM Input Capture measurement in DMA mode.
  * @param  htim TIM Input Capture handle
  * @param  Channel TIM Channels to be enabled
  *          This parameter can be one of the following values:
  *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
  *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
  *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
  * @param  pData The destination Buffer address.
  * @param  Length The length of data to be transferred from TIM peripheral to memory.
  * @retval HAL status
  *//* Disable the TIM Capture/Compare 4 interrupt *//* Disable the TIM Capture/Compare 3 interrupt *//**
  * @brief  Stops the TIM Input Capture measurement in interrupt mode.
  * @param  htim TIM Input Capture handle
  * @param  Channel TIM Channels to be disabled
  *          This parameter can be one of the following values:
  *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
  *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
  *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
  * @retval HAL status
  *//* Enable the TIM Capture/Compare 4 interrupt *//* Enable the TIM Capture/Compare 3 interrupt *//* Check the TIM channel state *//**
  * @brief  Starts the TIM Input Capture measurement in interrupt mode.
  * @param  htim TIM Input Capture handle
  * @param  Channel TIM Channels to be enabled
  *          This parameter can be one of the following values:
  *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
  *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
  *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
  * @retval HAL status
  *//**
  * @brief  Stops the TIM Input Capture measurement.
  * @param  htim TIM Input Capture handle
  * @param  Channel TIM Channels to be disabled
  *          This parameter can be one of the following values:
  *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
  *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
  *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
  * @retval HAL status
  *//**
  * @brief  Starts the TIM Input Capture measurement.
  * @param  htim TIM Input Capture handle
  * @param  Channel TIM Channels to be enabled
  *          This parameter can be one of the following values:
  *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
  *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
  *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
  * @retval HAL status
  *//* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIM_IC_MspDeInit could be implemented in the user file
   *//**
  * @brief  DeInitializes TIM Input Capture MSP.
  * @param  htim TIM handle
  * @retval None
  *//* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIM_IC_MspInit could be implemented in the user file
   *//**
  * @brief  Initializes the TIM Input Capture MSP.
  * @param  htim TIM Input Capture handle
  * @retval None
  *//* Change the TIM channels state *//**
  * @brief  DeInitializes the TIM peripheral
  * @param  htim TIM Input Capture handle
  * @retval HAL status
  *//* Init the base time for the input capture *//**
  * @brief  Initializes the TIM Input Capture Time base according to the specified
  *         parameters in the TIM_HandleTypeDef and initializes the associated handle.
  * @note   Switching from Center Aligned counter mode to Edge counter mode (or reverse)
  *         requires a timer reset to avoid unexpected direction
  *         due to DIR bit readonly in center aligned mode.
  *         Ex: call @ref HAL_TIM_IC_DeInit() before HAL_TIM_IC_Init()
  * @param  htim TIM Input Capture handle
  * @retval HAL status
  *//** @defgroup TIM_Exported_Functions_Group4 TIM Input Capture functions
  *  @brief    TIM Input Capture functions
  *
@verbatim
  ==============================================================================
              ##### TIM Input Capture functions #####
  ==============================================================================
 [..]
   This section provides functions allowing to:
   (+) Initialize and configure the TIM Input Capture.
   (+) De-initialize the TIM Input Capture.
   (+) Start the TIM Input Capture.
   (+) Stop the TIM Input Capture.
   (+) Start the TIM Input Capture and enable interrupt.
   (+) Stop the TIM Input Capture and disable interrupt.
   (+) Start the TIM Input Capture and enable DMA transfer.
   (+) Stop the TIM Input Capture and disable DMA transfer.

@endverbatim
  * @{
  *//* Disable the Capture compare channel *//* Disable the TIM Capture/Compare 3 DMA request *//**
  * @brief  Stops the TIM PWM signal generation in DMA mode.
  * @param  htim TIM PWM handle
  * @param  Channel TIM Channels to be disabled
  *          This parameter can be one of the following values:
  *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
  *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
  *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
  * @retval HAL status
  *//* Enable the TIM Capture/Compare 4 DMA request *//* Enable the TIM Output Capture/Compare 3 request *//* Enable the TIM Capture/Compare 2 DMA request *//**
  * @brief  Starts the TIM PWM signal generation in DMA mode.
  * @param  htim TIM PWM handle
  * @param  Channel TIM Channels to be enabled
  *          This parameter can be one of the following values:
  *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
  *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
  *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
  * @param  pData The source Buffer address.
  * @param  Length The length of data to be transferred from memory to TIM peripheral
  * @retval HAL status
  *//**
  * @brief  Stops the PWM signal generation in interrupt mode.
  * @param  htim TIM PWM handle
  * @param  Channel TIM Channels to be disabled
  *          This parameter can be one of the following values:
  *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
  *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
  *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
  * @retval HAL status
  *//**
  * @brief  Starts the PWM signal generation in interrupt mode.
  * @param  htim TIM PWM handle
  * @param  Channel TIM Channel to be enabled
  *          This parameter can be one of the following values:
  *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
  *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
  *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
  * @retval HAL status
  *//**
  * @brief  Stops the PWM signal generation.
  * @param  htim TIM PWM handle
  * @param  Channel TIM Channels to be disabled
  *          This parameter can be one of the following values:
  *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
  *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
  *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
  *            @arg TIM_CHANNEL_5: TIM Channel 5 selected
  *            @arg TIM_CHANNEL_6: TIM Channel 6 selected
  * @retval HAL status
  *//**
  * @brief  Starts the PWM signal generation.
  * @param  htim TIM handle
  * @param  Channel TIM Channels to be enabled
  *          This parameter can be one of the following values:
  *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
  *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
  *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
  *            @arg TIM_CHANNEL_5: TIM Channel 5 selected
  *            @arg TIM_CHANNEL_6: TIM Channel 6 selected
  * @retval HAL status
  *//* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIM_PWM_MspDeInit could be implemented in the user file
   *//**
  * @brief  DeInitializes TIM PWM MSP.
  * @param  htim TIM PWM handle
  * @retval None
  *//* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIM_PWM_MspInit could be implemented in the user file
   *//**
  * @brief  Initializes the TIM PWM MSP.
  * @param  htim TIM PWM handle
  * @retval None
  *//**
  * @brief  DeInitializes the TIM peripheral
  * @param  htim TIM PWM handle
  * @retval HAL status
  *//* Init the base time for the PWM *//**
  * @brief  Initializes the TIM PWM Time Base according to the specified
  *         parameters in the TIM_HandleTypeDef and initializes the associated handle.
  * @note   Switching from Center Aligned counter mode to Edge counter mode (or reverse)
  *         requires a timer reset to avoid unexpected direction
  *         due to DIR bit readonly in center aligned mode.
  *         Ex: call @ref HAL_TIM_PWM_DeInit() before HAL_TIM_PWM_Init()
  * @param  htim TIM PWM handle
  * @retval HAL status
  *//** @defgroup TIM_Exported_Functions_Group3 TIM PWM functions
  *  @brief    TIM PWM functions
  *
@verbatim
  ==============================================================================
                          ##### TIM PWM functions #####
  ==============================================================================
  [..]
    This section provides functions allowing to:
    (+) Initialize and configure the TIM PWM.
    (+) De-initialize the TIM PWM.
    (+) Start the TIM PWM.
    (+) Stop the TIM PWM.
    (+) Start the TIM PWM and enable interrupt.
    (+) Stop the TIM PWM and disable interrupt.
    (+) Start the TIM PWM and enable DMA transfer.
    (+) Stop the TIM PWM and disable DMA transfer.

@endverbatim
  * @{
  *//* Disable the Output compare channel *//**
  * @brief  Stops the TIM Output Compare signal generation in DMA mode.
  * @param  htim TIM Output Compare handle
  * @param  Channel TIM Channel to be disabled
  *          This parameter can be one of the following values:
  *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
  *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
  *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
  * @retval HAL status
  *//* Enable the Output compare channel *//* Enable the TIM Capture/Compare 3 DMA request *//**
  * @brief  Starts the TIM Output Compare signal generation in DMA mode.
  * @param  htim TIM Output Compare handle
  * @param  Channel TIM Channel to be enabled
  *          This parameter can be one of the following values:
  *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
  *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
  *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
  * @param  pData The source Buffer address.
  * @param  Length The length of data to be transferred from memory to TIM peripheral
  * @retval HAL status
  *//**
  * @brief  Stops the TIM Output Compare signal generation in interrupt mode.
  * @param  htim TIM Output Compare handle
  * @param  Channel TIM Channel to be disabled
  *          This parameter can be one of the following values:
  *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
  *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
  *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
  * @retval HAL status
  *//**
  * @brief  Starts the TIM Output Compare signal generation in interrupt mode.
  * @param  htim TIM Output Compare handle
  * @param  Channel TIM Channel to be enabled
  *          This parameter can be one of the following values:
  *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
  *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
  *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
  * @retval HAL status
  *//**
  * @brief  Stops the TIM Output Compare signal generation.
  * @param  htim TIM Output Compare handle
  * @param  Channel TIM Channel to be disabled
  *          This parameter can be one of the following values:
  *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
  *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
  *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
  *            @arg TIM_CHANNEL_5: TIM Channel 5 selected
  *            @arg TIM_CHANNEL_6: TIM Channel 6 selected
  * @retval HAL status
  *//**
  * @brief  Starts the TIM Output Compare signal generation.
  * @param  htim TIM Output Compare handle
  * @param  Channel TIM Channel to be enabled
  *          This parameter can be one of the following values:
  *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
  *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
  *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
  *            @arg TIM_CHANNEL_5: TIM Channel 5 selected
  *            @arg TIM_CHANNEL_6: TIM Channel 6 selected
  * @retval HAL status
  *//* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIM_OC_MspDeInit could be implemented in the user file
   *//**
  * @brief  DeInitializes TIM Output Compare MSP.
  * @param  htim TIM Output Compare handle
  * @retval None
  *//* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIM_OC_MspInit could be implemented in the user file
   *//**
  * @brief  Initializes the TIM Output Compare MSP.
  * @param  htim TIM Output Compare handle
  * @retval None
  *//**
  * @brief  DeInitializes the TIM peripheral
  * @param  htim TIM Output Compare handle
  * @retval HAL status
  *//* Init the base time for the Output Compare *//**
  * @brief  Initializes the TIM Output Compare according to the specified
  *         parameters in the TIM_HandleTypeDef and initializes the associated handle.
  * @note   Switching from Center Aligned counter mode to Edge counter mode (or reverse)
  *         requires a timer reset to avoid unexpected direction
  *         due to DIR bit readonly in center aligned mode.
  *         Ex: call @ref HAL_TIM_OC_DeInit() before HAL_TIM_OC_Init()
  * @param  htim TIM Output Compare handle
  * @retval HAL status
  *//** @defgroup TIM_Exported_Functions_Group2 TIM Output Compare functions
  *  @brief    TIM Output Compare functions
  *
@verbatim
  ==============================================================================
                  ##### TIM Output Compare functions #####
  ==============================================================================
  [..]
    This section provides functions allowing to:
    (+) Initialize and configure the TIM Output Compare.
    (+) De-initialize the TIM Output Compare.
    (+) Start the TIM Output Compare.
    (+) Stop the TIM Output Compare.
    (+) Start the TIM Output Compare and enable interrupt.
    (+) Stop the TIM Output Compare and disable interrupt.
    (+) Start the TIM Output Compare and enable DMA transfer.
    (+) Stop the TIM Output Compare and disable DMA transfer.

@endverbatim
  * @{
  *//**
  * @brief  Stops the TIM Base generation in DMA mode.
  * @param  htim TIM Base handle
  * @retval HAL status
  *//* Enable the TIM Update DMA request *//**
  * @brief  Starts the TIM Base generation in DMA mode.
  * @param  htim TIM Base handle
  * @param  pData The source Buffer address.
  * @param  Length The length of data to be transferred from memory to peripheral.
  * @retval HAL status
  *//* Disable the TIM Update interrupt *//**
  * @brief  Stops the TIM Base generation in interrupt mode.
  * @param  htim TIM Base handle
  * @retval HAL status
  *//* Enable the TIM Update interrupt *//* Check the TIM state *//**
  * @brief  Starts the TIM Base generation in interrupt mode.
  * @param  htim TIM Base handle
  * @retval HAL status
  *//**
  * @brief  Stops the TIM Base generation.
  * @param  htim TIM Base handle
  * @retval HAL status
  *//**
  * @brief  Starts the TIM Base generation.
  * @param  htim TIM Base handle
  * @retval HAL status
  *//* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIM_Base_MspDeInit could be implemented in the user file
   *//**
  * @brief  DeInitializes TIM Base MSP.
  * @param  htim TIM Base handle
  * @retval None
  *//* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIM_Base_MspInit could be implemented in the user file
   *//**
  * @brief  Initializes the TIM Base MSP.
  * @param  htim TIM Base handle
  * @retval None
  *//**
  * @brief  DeInitializes the TIM Base peripheral
  * @param  htim TIM Base handle
  * @retval HAL status
  *//* Set the Time Base configuration *//**
  * @brief  Initializes the TIM Time base Unit according to the specified
  *         parameters in the TIM_HandleTypeDef and initialize the associated handle.
  * @note   Switching from Center Aligned counter mode to Edge counter mode (or reverse)
  *         requires a timer reset to avoid unexpected direction
  *         due to DIR bit readonly in center aligned mode.
  *         Ex: call @ref HAL_TIM_Base_DeInit() before HAL_TIM_Base_Init()
  * @param  htim TIM Base handle
  * @retval HAL status
  *//** @defgroup TIM_Exported_Functions_Group1 TIM Time Base functions
  *  @brief    Time Base functions
  *
@verbatim
  ==============================================================================
              ##### Time Base functions #####
  ==============================================================================
  [..]
    This section provides functions allowing to:
    (+) Initialize and configure the TIM base.
    (+) De-initialize the TIM base.
    (+) Start the Time Base.
    (+) Stop the Time Base.
    (+) Start the Time Base and enable interrupt.
    (+) Stop the Time Base and disable interrupt.
    (+) Start the Time Base and enable DMA transfer.
    (+) Stop the Time Base and disable DMA transfer.

@endverbatim
  * @{
  *//** @defgroup TIM_Exported_Functions TIM Exported Functions
  * @{
  *//** @addtogroup TIM_Private_Functions
  * @{
  *//** @defgroup TIM TIM
  * @brief TIM HAL module driver
  * @{
  *//**
  ******************************************************************************
  * @file    stm32f7xx_hal_tim.c
  * @author  MCD Application Team
  * @brief   TIM HAL module driver.
  *          This file provides firmware functions to manage the following
  *          functionalities of the Timer (TIM) peripheral:
  *           + TIM Time Base Initialization
  *           + TIM Time Base Start
  *           + TIM Time Base Start Interruption
  *           + TIM Time Base Start DMA
  *           + TIM Output Compare/PWM Initialization
  *           + TIM Output Compare/PWM Channel Configuration
  *           + TIM Output Compare/PWM  Start
  *           + TIM Output Compare/PWM  Start Interruption
  *           + TIM Output Compare/PWM Start DMA
  *           + TIM Input Capture Initialization
  *           + TIM Input Capture Channel Configuration
  *           + TIM Input Capture Start
  *           + TIM Input Capture Start Interruption
  *           + TIM Input Capture Start DMA
  *           + TIM One Pulse Initialization
  *           + TIM One Pulse Channel Configuration
  *           + TIM One Pulse Start
  *           + TIM Encoder Interface Initialization
  *           + TIM Encoder Interface Start
  *           + TIM Encoder Interface Start Interruption
  *           + TIM Encoder Interface Start DMA
  *           + Commutation Event configuration with Interruption and DMA
  *           + TIM OCRef clear configuration
  *           + TIM External Clock configuration
  ******************************************************************************
  * @attention
  *
  * Copyright (c) 2017 STMicroelectronics.
  * All rights reserved.
  *
  * This software is licensed under terms that can be found in the LICENSE file
  * in the root directory of this software component.
  * If no LICENSE file comes with this software, it is provided AS-IS.
  *
  ******************************************************************************
  @verbatim
  ==============================================================================
                      ##### TIMER Generic features #####
  ==============================================================================
  [..] The Timer features include:
       (#) 16-bit up, down, up/down auto-reload counter.
       (#) 16-bit programmable prescaler allowing dividing (also on the fly) the
           counter clock frequency either by any factor between 1 and 65536.
       (#) Up to 4 independent channels for:
           (++) Input Capture
           (++) Output Compare
           (++) PWM generation (Edge and Center-aligned Mode)
           (++) One-pulse mode output
       (#) Synchronization circuit to control the timer with external signals and to interconnect
            several timers together.
       (#) Supports incremental encoder for positioning purposes

            ##### How to use this driver #####
  ==============================================================================
    [..]
     (#) Initialize the TIM low level resources by implementing the following functions
         depending on the selected feature:
           (++) Time Base : HAL_TIM_Base_MspInit()
           (++) Input Capture : HAL_TIM_IC_MspInit()
           (++) Output Compare : HAL_TIM_OC_MspInit()
           (++) PWM generation : HAL_TIM_PWM_MspInit()
           (++) One-pulse mode output : HAL_TIM_OnePulse_MspInit()
           (++) Encoder mode output : HAL_TIM_Encoder_MspInit()

     (#) Initialize the TIM low level resources :
        (##) Enable the TIM interface clock using __HAL_RCC_TIMx_CLK_ENABLE();
        (##) TIM pins configuration
            (+++) Enable the clock for the TIM GPIOs using the following function:
             __HAL_RCC_GPIOx_CLK_ENABLE();
            (+++) Configure these TIM pins in Alternate function mode using HAL_GPIO_Init();

     (#) The external Clock can be configured, if needed (the default clock is the
         internal clock from the APBx), using the following function:
         HAL_TIM_ConfigClockSource, the clock configuration should be done before
         any start function.

     (#) Configure the TIM in the desired functioning mode using one of the
       Initialization function of this driver:
       (++) HAL_TIM_Base_Init: to use the Timer to generate a simple time base
       (++) HAL_TIM_OC_Init and HAL_TIM_OC_ConfigChannel: to use the Timer to generate an
            Output Compare signal.
       (++) HAL_TIM_PWM_Init and HAL_TIM_PWM_ConfigChannel: to use the Timer to generate a
            PWM signal.
       (++) HAL_TIM_IC_Init and HAL_TIM_IC_ConfigChannel: to use the Timer to measure an
            external signal.
       (++) HAL_TIM_OnePulse_Init and HAL_TIM_OnePulse_ConfigChannel: to use the Timer
            in One Pulse Mode.
       (++) HAL_TIM_Encoder_Init: to use the Timer Encoder Interface.

     (#) Activate the TIM peripheral using one of the start functions depending from the feature used:
           (++) Time Base : HAL_TIM_Base_Start(), HAL_TIM_Base_Start_DMA(), HAL_TIM_Base_Start_IT()
           (++) Input Capture :  HAL_TIM_IC_Start(), HAL_TIM_IC_Start_DMA(), HAL_TIM_IC_Start_IT()
           (++) Output Compare : HAL_TIM_OC_Start(), HAL_TIM_OC_Start_DMA(), HAL_TIM_OC_Start_IT()
           (++) PWM generation : HAL_TIM_PWM_Start(), HAL_TIM_PWM_Start_DMA(), HAL_TIM_PWM_Start_IT()
           (++) One-pulse mode output : HAL_TIM_OnePulse_Start(), HAL_TIM_OnePulse_Start_IT()
           (++) Encoder mode output : HAL_TIM_Encoder_Start(), HAL_TIM_Encoder_Start_DMA(), HAL_TIM_Encoder_Start_IT().

     (#) The DMA Burst is managed with the two following functions:
         HAL_TIM_DMABurst_WriteStart()
         HAL_TIM_DMABurst_ReadStart()

    *** Callback registration ***
  =============================================

  [..]
  The compilation define  USE_HAL_TIM_REGISTER_CALLBACKS when set to 1
  allows the user to configure dynamically the driver callbacks.

  [..]
  Use Function HAL_TIM_RegisterCallback() to register a callback.
  HAL_TIM_RegisterCallback() takes as parameters the HAL peripheral handle,
  the Callback ID and a pointer to the user callback function.

  [..]
  Use function HAL_TIM_UnRegisterCallback() to reset a callback to the default
  weak function.
  HAL_TIM_UnRegisterCallback takes as parameters the HAL peripheral handle,
  and the Callback ID.

  [..]
  These functions allow to register/unregister following callbacks:
    (+) Base_MspInitCallback              : TIM Base Msp Init Callback.
    (+) Base_MspDeInitCallback            : TIM Base Msp DeInit Callback.
    (+) IC_MspInitCallback                : TIM IC Msp Init Callback.
    (+) IC_MspDeInitCallback              : TIM IC Msp DeInit Callback.
    (+) OC_MspInitCallback                : TIM OC Msp Init Callback.
    (+) OC_MspDeInitCallback              : TIM OC Msp DeInit Callback.
    (+) PWM_MspInitCallback               : TIM PWM Msp Init Callback.
    (+) PWM_MspDeInitCallback             : TIM PWM Msp DeInit Callback.
    (+) OnePulse_MspInitCallback          : TIM One Pulse Msp Init Callback.
    (+) OnePulse_MspDeInitCallback        : TIM One Pulse Msp DeInit Callback.
    (+) Encoder_MspInitCallback           : TIM Encoder Msp Init Callback.
    (+) Encoder_MspDeInitCallback         : TIM Encoder Msp DeInit Callback.
    (+) HallSensor_MspInitCallback        : TIM Hall Sensor Msp Init Callback.
    (+) HallSensor_MspDeInitCallback      : TIM Hall Sensor Msp DeInit Callback.
    (+) PeriodElapsedCallback             : TIM Period Elapsed Callback.
    (+) PeriodElapsedHalfCpltCallback     : TIM Period Elapsed half complete Callback.
    (+) TriggerCallback                   : TIM Trigger Callback.
    (+) TriggerHalfCpltCallback           : TIM Trigger half complete Callback.
    (+) IC_CaptureCallback                : TIM Input Capture Callback.
    (+) IC_CaptureHalfCpltCallback        : TIM Input Capture half complete Callback.
    (+) OC_DelayElapsedCallback           : TIM Output Compare Delay Elapsed Callback.
    (+) PWM_PulseFinishedCallback         : TIM PWM Pulse Finished Callback.
    (+) PWM_PulseFinishedHalfCpltCallback : TIM PWM Pulse Finished half complete Callback.
    (+) ErrorCallback                     : TIM Error Callback.
    (+) CommutationCallback               : TIM Commutation Callback.
    (+) CommutationHalfCpltCallback       : TIM Commutation half complete Callback.
    (+) BreakCallback                     : TIM Break Callback.
    (+) Break2Callback                    : TIM Break2 Callback.

  [..]
By default, after the Init and when the state is HAL_TIM_STATE_RESET
all interrupt callbacks are set to the corresponding weak functions:
  examples HAL_TIM_TriggerCallback(), HAL_TIM_ErrorCallback().

  [..]
  Exception done for MspInit and MspDeInit functions that are reset to the legacy weak
  functionalities in the Init / DeInit only when these callbacks are null
  (not registered beforehand). If not, MspInit or MspDeInit are not null, the Init / DeInit
    keep and use the user MspInit / MspDeInit callbacks(registered beforehand)

  [..]
    Callbacks can be registered / unregistered in HAL_TIM_STATE_READY state only.
    Exception done MspInit / MspDeInit that can be registered / unregistered
    in HAL_TIM_STATE_READY or HAL_TIM_STATE_RESET state,
    thus registered(user) MspInit / DeInit callbacks can be used during the Init / DeInit.
  In that case first register the MspInit/MspDeInit user callbacks
      using HAL_TIM_RegisterCallback() before calling DeInit or Init function.

  [..]
      When The compilation define USE_HAL_TIM_REGISTER_CALLBACKS is set to 0 or
      not defined, the callback registration feature is not available and all callbacks
      are set to the corresponding weak functions.

  @endverbatim
  ******************************************************************************
  *//Users/jie/Documents/posixGen_Demos-main/LwIP_StreamingServer/Drivers/STM32F7xx_HAL_Driver/Src/stm32f7xx_hal_tim_ex.cTIM_CCxNChannelCmd0xFUTIM_DMAErrorCCxNTIM_DMADelayPulseNCpltIS_TIM_CCXN_INSTANCE(htim->Instance, ChannelN)IS_TIM_COMBINED3PHASEPWM_INSTANCE(htim->Instance)IS_TIM_GROUPCH5(Channels)(TIM_CCR5_GC5C3 | TIM_CCR5_GC5C2 | TIM_CCR5_GC5C1)536870911~(TIM_CCR5_GC5C3 | TIM_CCR5_GC5C2 | TIM_CCR5_GC5C1)IS_TIM_REMAP_INSTANCE(htim->Instance)IS_TIM_REMAP(Remap)tmporxbkin_enable_maskbkin_polarity_maskbkin_enable_bitposbkin_polarity_bitposIS_TIM_BREAK_INSTANCE(htim->Instance)IS_TIM_BREAKINPUT(BreakInput)IS_TIM_BREAKINPUTSOURCE(sBreakInputConfig->Source)IS_TIM_BREAKINPUTSOURCE_STATE(sBreakInputConfig->Enable)IS_TIM_BREAKINPUTSOURCE_POLARITY(sBreakInputConfig->Polarity)tmpbdtrIS_TIM_OSSR_STATE(sBreakDeadTimeConfig->OffStateRunMode)IS_TIM_OSSI_STATE(sBreakDeadTimeConfig->OffStateIDLEMode)IS_TIM_LOCK_LEVEL(sBreakDeadTimeConfig->LockLevel)IS_TIM_DEADTIME(sBreakDeadTimeConfig->DeadTime)IS_TIM_BREAK_STATE(sBreakDeadTimeConfig->BreakState)IS_TIM_BREAK_POLARITY(sBreakDeadTimeConfig->BreakPolarity)IS_TIM_BREAK_FILTER(sBreakDeadTimeConfig->BreakFilter)IS_TIM_AUTOMATIC_OUTPUT_STATE(sBreakDeadTimeConfig->AutomaticOutput)(0xFFUL << (0U))sBreakDeadTimeConfig->DeadTime(tmpbdtr)(((READ_REG(tmpbdtr)) & (~((0xFFUL << (0U))))) | (sBreakDeadTimeConfig->DeadTime))(((((tmpbdtr))) & (~((0xFFUL << (0U))))) | (sBreakDeadTimeConfig->DeadTime))sBreakDeadTimeConfig->LockLevel(((READ_REG(tmpbdtr)) & (~((0x3UL << (8U))))) | (sBreakDeadTimeConfig->LockLevel))(((((tmpbdtr))) & (~((0x3UL << (8U))))) | (sBreakDeadTimeConfig->LockLevel))sBreakDeadTimeConfig->OffStateIDLEMode(((READ_REG(tmpbdtr)) & (~((0x1UL << (10U))))) | (sBreakDeadTimeConfig->OffStateIDLEMode))(((((tmpbdtr))) & (~((0x1UL << (10U))))) | (sBreakDeadTimeConfig->OffStateIDLEMode))sBreakDeadTimeConfig->OffStateRunMode(((READ_REG(tmpbdtr)) & (~((0x1UL << (11U))))) | (sBreakDeadTimeConfig->OffStateRunMode))(((((tmpbdtr))) & (~((0x1UL << (11U))))) | (sBreakDeadTimeConfig->OffStateRunMode))sBreakDeadTimeConfig->BreakState(((READ_REG(tmpbdtr)) & (~((0x1UL << (12U))))) | (sBreakDeadTimeConfig->BreakState))(((((tmpbdtr))) & (~((0x1UL << (12U))))) | (sBreakDeadTimeConfig->BreakState))sBreakDeadTimeConfig->BreakPolarity(((READ_REG(tmpbdtr)) & (~((0x1UL << (13U))))) | (sBreakDeadTimeConfig->BreakPolarity))(((((tmpbdtr))) & (~((0x1UL << (13U))))) | (sBreakDeadTimeConfig->BreakPolarity))sBreakDeadTimeConfig->AutomaticOutput(((READ_REG(tmpbdtr)) & (~((0x1UL << (14U))))) | (sBreakDeadTimeConfig->AutomaticOutput))(((((tmpbdtr))) & (~((0x1UL << (14U))))) | (sBreakDeadTimeConfig->AutomaticOutput))(0xFUL << (16U))(sBreakDeadTimeConfig->BreakFilter << TIM_BDTR_BKF_Pos)(sBreakDeadTimeConfig->BreakFilter << (16U))(((READ_REG(tmpbdtr)) & (~((0xFUL << (16U))))) | ((sBreakDeadTimeConfig->BreakFilter << (16U))))(((((tmpbdtr))) & (~((0xFUL << (16U))))) | ((sBreakDeadTimeConfig->BreakFilter << (16U))))IS_TIM_BREAK2_STATE(sBreakDeadTimeConfig->Break2State)IS_TIM_BREAK2_POLARITY(sBreakDeadTimeConfig->Break2Polarity)IS_TIM_BREAK_FILTER(sBreakDeadTimeConfig->Break2Filter)(sBreakDeadTimeConfig->Break2Filter << TIM_BDTR_BK2F_Pos)(sBreakDeadTimeConfig->Break2Filter << (20U))(((READ_REG(tmpbdtr)) & (~((0xFUL << (20U))))) | ((sBreakDeadTimeConfig->Break2Filter << (20U))))(((((tmpbdtr))) & (~((0xFUL << (20U))))) | ((sBreakDeadTimeConfig->Break2Filter << (20U))))sBreakDeadTimeConfig->Break2State(((READ_REG(tmpbdtr)) & (~((0x1UL << (24U))))) | (sBreakDeadTimeConfig->Break2State))(((((tmpbdtr))) & (~((0x1UL << (24U))))) | (sBreakDeadTimeConfig->Break2State))sBreakDeadTimeConfig->Break2Polarity(((READ_REG(tmpbdtr)) & (~((0x1UL << (25U))))) | (sBreakDeadTimeConfig->Break2Polarity))(((((tmpbdtr))) & (~((0x1UL << (25U))))) | (sBreakDeadTimeConfig->Break2Polarity))IS_TIM_MASTER_INSTANCE(htim->Instance)IS_TIM_TRGO_SOURCE(sMasterConfig->MasterOutputTrigger)IS_TIM_MSM_STATE(sMasterConfig->MasterSlaveMode)IS_TIM_TRGO2_SOURCE(sMasterConfig->MasterOutputTrigger2)~TIM_CR2_MMS2~TIM_CR2_MMS~TIM_SMCR_MSMIS_TIM_COMMUTATION_EVENT_INSTANCE(htim->Instance)IS_TIM_INTERNAL_TRIGGEREVENT_SELECTION(InputTrigger)~TIM_CR2_CCUSinput_channelIS_TIM_CCXN_INSTANCE(htim->Instance, OutputChannel)IS_TIM_CCXN_INSTANCE(htim->Instance, Channel)IS_TIM_HALL_SENSOR_INTERFACE_INSTANCE(htim->Instance)IS_TIM_IC_POLARITY(sConfig->IC1Polarity)defined(DFSDM1_Channel0)/* 0xFU = 15 bits max shift *//* Set or reset the CCxNE Bit *//* Reset the CCxNE Bit *//**
  * @brief  Enables or disables the TIM Capture Compare Channel xN.
  * @param  TIMx to select the TIM peripheral
  * @param  Channel specifies the TIM Channel
  *          This parameter can be one of the following values:
  *            @arg TIM_CHANNEL_1: TIM Channel 1
  *            @arg TIM_CHANNEL_2: TIM Channel 2
  *            @arg TIM_CHANNEL_3: TIM Channel 3
  * @param  ChannelNState specifies the TIM Channel CCxNE bit new state.
  *          This parameter can be: TIM_CCxN_ENABLE or TIM_CCxN_Disable.
  * @retval None
  *//**
  * @brief  TIM DMA error callback (complementary channel)
  * @param  hdma pointer to DMA handle.
  * @retval None
  *//**
  * @brief  TIM DMA Delay Pulse complete callback (complementary channel).
  * @param  hdma pointer to DMA handle.
  * @retval None
  *//* Change the htim state *//**
  * @brief  TIM DMA Commutation half complete callback.
  * @param  hdma pointer to DMA handle.
  * @retval None
  *//**
  * @brief  TIM DMA Commutation callback.
  * @param  hdma pointer to DMA handle.
  * @retval None
  *//** @defgroup TIMEx_Private_Functions TIM Extended Private Functions
  * @{
  *//**
  * @brief  Return actual state of the TIM complementary channel.
  * @param  htim TIM handle
  * @param  ChannelN TIM Complementary channel
  *          This parameter can be one of the following values:
  *            @arg TIM_CHANNEL_1: TIM Channel 1
  *            @arg TIM_CHANNEL_2: TIM Channel 2
  *            @arg TIM_CHANNEL_3: TIM Channel 3
  * @retval TIM Complementary channel state
  *//**
  * @brief  Return the TIM Hall Sensor interface handle state.
  * @param  htim TIM Hall Sensor handle
  * @retval HAL state
  *//** @defgroup TIMEx_Exported_Functions_Group7 Extended Peripheral State functions
  * @brief    Extended Peripheral State functions
  *
@verbatim
  ==============================================================================
                ##### Extended Peripheral State functions #####
  ==============================================================================
  [..]
    This subsection permits to get in run-time the status of the peripheral
    and the data flow.

@endverbatim
  * @{
  *//* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_TIMEx_Break2Callback could be implemented in the user file
   *//**
  * @brief  Break2 detection callback in non blocking mode
  * @param  htim: TIM handle
  * @retval None
  *//* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIMEx_BreakCallback could be implemented in the user file
   *//**
  * @brief  Break detection callback in non-blocking mode
  * @param  htim TIM handle
  * @retval None
  *//* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIMEx_CommutHalfCpltCallback could be implemented in the user file
   *//**
  * @brief  Commutation half complete callback in non-blocking mode
  * @param  htim TIM handle
  * @retval None
  *//* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIMEx_CommutCallback could be implemented in the user file
   *//**
  * @brief  Commutation callback in non-blocking mode
  * @param  htim TIM handle
  * @retval None
  *//** @defgroup TIMEx_Exported_Functions_Group6 Extended Callbacks functions
  * @brief    Extended Callbacks functions
  *
@verbatim
  ==============================================================================
                    ##### Extended Callbacks functions #####
  ==============================================================================
  [..]
    This section provides Extended TIM callback functions:
    (+) Timer Commutation callback
    (+) Timer Break callback

@endverbatim
  * @{
  *//* Set GC5Cx bit fields *//* Clear GC5Cx bit fields *//**
  * @brief  Group channel 5 and channel 1, 2 or 3
  * @param  htim TIM handle.
  * @param  Channels specifies the reference signal(s) the OC5REF is combined with.
  *         This parameter can be any combination of the following values:
  *         TIM_GROUPCH5_NONE: No effect of OC5REF on OC1REFC, OC2REFC and OC3REFC
  *         TIM_GROUPCH5_OC1REFC: OC1REFC is the logical AND of OC1REFC and OC5REF
  *         TIM_GROUPCH5_OC2REFC: OC2REFC is the logical AND of OC2REFC and OC5REF
  *         TIM_GROUPCH5_OC3REFC: OC3REFC is the logical AND of OC3REFC and OC5REF
  * @retval HAL status
  *//* Set the Timer remapping configuration *//**
  * @brief  Configures the TIMx Remapping input capabilities.
  * @param  htim TIM handle.
  * @param  Remap specifies the TIM remapping source.
  *          This parameter can be one of the following values:
  *            @arg TIM_TIM2_TIM8_TRGO: TIM2 ITR1 input is connected to TIM8 Trigger output(default)
  *            @arg TIM_TIM2_ETH_PTP:   TIM2 ITR1 input is connected to ETH PTP trigger output.
  *            @arg TIM_TIM2_USBFS_SOF: TIM2 ITR1 input is connected to USB FS SOF.
  *            @arg TIM_TIM2_USBHS_SOF: TIM2 ITR1 input is connected to USB HS SOF.
  *            @arg TIM_TIM5_GPIO:      TIM5 CH4 input is connected to dedicated Timer pin(default)
  *            @arg TIM_TIM5_LSI:       TIM5 CH4 input is connected to LSI clock.
  *            @arg TIM_TIM5_LSE:       TIM5 CH4 input is connected to LSE clock.
  *            @arg TIM_TIM5_RTC:       TIM5 CH4 input is connected to RTC Output event.
  *            @arg TIM_TIM11_GPIO:     TIM11 CH4 input is connected to dedicated Timer pin(default)
  *            @arg TIM_TIM11_SPDIF:    SPDIF Frame synchronous
  *            @arg TIM_TIM11_HSE:      TIM11 CH4 input is connected to HSE_RTC clock
  *                                     (HSE divided by a programmable prescaler)
  *            @arg TIM_TIM11_MCO1:     TIM11 CH1 input is connected to MCO1
  *
  * @retval HAL status
  *//*TIM_BREAK_INPUT_SUPPORT *//* Set TIMx_AF2 *//* DFSDM1_Channel0 *//* Set the break input polarity *//* Enable the break input *//* Get the TIMx_AF2 register value *//* Set TIMx_AF1 *//* Get the TIMx_AF1 register value *//* Check input state *//**
  * @brief  Configures the break input source.
  * @param  htim TIM handle.
  * @param  BreakInput Break input to configure
  *          This parameter can be one of the following values:
  *            @arg TIM_BREAKINPUT_BRK: Timer break input
  *            @arg TIM_BREAKINPUT_BRK2: Timer break 2 input
  * @param  sBreakInputConfig Break input source configuration
  * @retval HAL status
  *//* Set TIMx_BDTR *//* Set the BREAK2 input related BDTR bits *//* Set the BDTR bits *//* Set the Lock level, the Break enable Bit and the Polarity, the OSSR State,
     the OSSI State, the dead time value and the Automatic Output Enable Bit *//* Keep this variable initialized to 0 as it is used to configure BDTR register *//**
  * @brief  Configures the Break feature, dead time, Lock level, OSSI/OSSR State
  *         and the AOE(automatic output enable).
  * @param  htim TIM handle
  * @param  sBreakDeadTimeConfig pointer to a TIM_ConfigBreakDeadConfigTypeDef structure that
  *         contains the BDTR Register configuration  information for the TIM peripheral.
  * @note   Interrupts can be generated when an active level is detected on the
  *         break input, the break 2 input or the system break input. Break
  *         interrupt can be enabled by calling the @ref __HAL_TIM_ENABLE_IT macro.
  * @retval HAL status
  *//* Update TIMx SMCR *//* Set master mode *//* Reset the MSM Bit *//* Update TIMx CR2 *//* Select the TRGO source *//* Reset the MMS Bits *//* Select the TRGO2 source*//* Clear the MMS2 bits *//* If the timer supports ADC synchronization through TRGO2, set the master mode selection 2 *//* Change the handler state *//**
  * @brief  Configures the TIM in master mode.
  * @param  htim TIM handle.
  * @param  sMasterConfig pointer to a TIM_MasterConfigTypeDef structure that
  *         contains the selected trigger output (TRGO) and the Master/Slave
  *         mode.
  * @retval HAL status
  *//* Enable the Commutation DMA Request *//* Disable Commutation Interrupt *//* Set the DMA Commutation Callback *//* Select the Commutation event source *//* Select the Capture Compare preload feature *//* Select the Input trigger *//**
  * @brief  Configure the TIM commutation event sequence with DMA.
  * @note  This function is mandatory to use the commutation event in order to
  *        update the configuration at each commutation detection on the TRGI input of the Timer,
  *        the typical use of this feature is with the use of another Timer(interface Timer)
  *        configured in Hall sensor interface, this interface Timer will generate the
  *        commutation at its TRGO output (connected to Timer used in this function) each time
  *        the TI1 of the Interface Timer detect a commutation at its input TI1.
  * @note  The user should configure the DMA in his own software, in This function only the COMDE bit is set
  * @param  htim TIM handle
  * @param  InputTrigger the Internal trigger corresponding to the Timer Interfacing with the Hall sensor
  *          This parameter can be one of the following values:
  *            @arg TIM_TS_ITR0: Internal trigger 0 selected
  *            @arg TIM_TS_ITR1: Internal trigger 1 selected
  *            @arg TIM_TS_ITR2: Internal trigger 2 selected
  *            @arg TIM_TS_ITR3: Internal trigger 3 selected
  *            @arg TIM_TS_NONE: No trigger is needed
  * @param  CommutationSource the Commutation Event source
  *          This parameter can be one of the following values:
  *            @arg TIM_COMMUTATION_TRGI: Commutation source is the TRGI of the Interface Timer
  *            @arg TIM_COMMUTATION_SOFTWARE:  Commutation source is set by software using the COMG bit
  * @retval HAL status
  *//* Enable the Commutation Interrupt *//* Disable Commutation DMA request *//**
  * @brief  Configure the TIM commutation event sequence with interrupt.
  * @note  This function is mandatory to use the commutation event in order to
  *        update the configuration at each commutation detection on the TRGI input of the Timer,
  *        the typical use of this feature is with the use of another Timer(interface Timer)
  *        configured in Hall sensor interface, this interface Timer will generate the
  *        commutation at its TRGO output (connected to Timer used in this function) each time
  *        the TI1 of the Interface Timer detect a commutation at its input TI1.
  * @param  htim TIM handle
  * @param  InputTrigger the Internal trigger corresponding to the Timer Interfacing with the Hall sensor
  *          This parameter can be one of the following values:
  *            @arg TIM_TS_ITR0: Internal trigger 0 selected
  *            @arg TIM_TS_ITR1: Internal trigger 1 selected
  *            @arg TIM_TS_ITR2: Internal trigger 2 selected
  *            @arg TIM_TS_ITR3: Internal trigger 3 selected
  *            @arg TIM_TS_NONE: No trigger is needed
  * @param  CommutationSource the Commutation Event source
  *          This parameter can be one of the following values:
  *            @arg TIM_COMMUTATION_TRGI: Commutation source is the TRGI of the Interface Timer
  *            @arg TIM_COMMUTATION_SOFTWARE:  Commutation source is set by software using the COMG bit
  * @retval HAL status
  *//**
  * @brief  Configure the TIM commutation event sequence.
  * @note  This function is mandatory to use the commutation event in order to
  *        update the configuration at each commutation detection on the TRGI input of the Timer,
  *        the typical use of this feature is with the use of another Timer(interface Timer)
  *        configured in Hall sensor interface, this interface Timer will generate the
  *        commutation at its TRGO output (connected to Timer used in this function) each time
  *        the TI1 of the Interface Timer detect a commutation at its input TI1.
  * @param  htim TIM handle
  * @param  InputTrigger the Internal trigger corresponding to the Timer Interfacing with the Hall sensor
  *          This parameter can be one of the following values:
  *            @arg TIM_TS_ITR0: Internal trigger 0 selected
  *            @arg TIM_TS_ITR1: Internal trigger 1 selected
  *            @arg TIM_TS_ITR2: Internal trigger 2 selected
  *            @arg TIM_TS_ITR3: Internal trigger 3 selected
  *            @arg TIM_TS_NONE: No trigger is needed
  * @param  CommutationSource the Commutation Event source
  *          This parameter can be one of the following values:
  *            @arg TIM_COMMUTATION_TRGI: Commutation source is the TRGI of the Interface Timer
  *            @arg TIM_COMMUTATION_SOFTWARE:  Commutation source is set by software using the COMG bit
  * @retval HAL status
  *//** @defgroup TIMEx_Exported_Functions_Group5 Extended Peripheral Control functions
  * @brief    Peripheral Control functions
  *
@verbatim
  ==============================================================================
                    ##### Peripheral Control functions #####
  ==============================================================================
  [..]
    This section provides functions allowing to:
      (+) Configure the commutation event in case of use of the Hall sensor interface.
      (+) Configure Output channels for OC and PWM mode.

      (+) Configure Complementary channels, break features and dead time.
      (+) Configure Master synchronization.
      (+) Configure timer remapping capabilities.
      (+) Enable or disable channel grouping.

@endverbatim
  * @{
  *//* Set the TIM  channels state *//* Disable the complementary One Pulse output channel and the Input Capture channel *//**
  * @brief  Stops the TIM One Pulse signal generation in interrupt mode on the
  *         complementary channel.
  * @note OutputChannel must match the pulse output channel chosen when calling
  *       @ref HAL_TIM_OnePulse_ConfigChannel().
  * @param  htim TIM One Pulse handle
  * @param  OutputChannel pulse output channel to disable
  *          This parameter can be one of the following values:
  *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
  * @retval HAL status
  *//* Enable the Main Output *//* Enable the complementary One Pulse output channel and the Input Capture channel *//**
  * @brief  Starts the TIM One Pulse signal generation in interrupt mode on the
  *         complementary channel.
  * @note OutputChannel must match the pulse output channel chosen when calling
  *       @ref HAL_TIM_OnePulse_ConfigChannel().
  * @param  htim TIM One Pulse handle
  * @param  OutputChannel pulse output channel to enable
  *          This parameter can be one of the following values:
  *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
  * @retval HAL status
  *//**
  * @brief  Stops the TIM One Pulse signal generation on the complementary
  *         output.
  * @note OutputChannel must match the pulse output channel chosen when calling
  *       @ref HAL_TIM_OnePulse_ConfigChannel().
  * @param  htim TIM One Pulse handle
  * @param  OutputChannel pulse output channel to disable
  *          This parameter can be one of the following values:
  *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
  * @retval HAL status
  *//**
  * @brief  Starts the TIM One Pulse signal generation on the complementary
  *         output.
  * @note OutputChannel must match the pulse output channel chosen when calling
  *       @ref HAL_TIM_OnePulse_ConfigChannel().
  * @param  htim TIM One Pulse handle
  * @param  OutputChannel pulse output channel to enable
  *          This parameter can be one of the following values:
  *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
  * @retval HAL status
  *//** @defgroup TIMEx_Exported_Functions_Group4 Extended Timer Complementary One Pulse functions
  * @brief    Timer Complementary One Pulse functions
  *
@verbatim
  ==============================================================================
                ##### Timer Complementary One Pulse functions #####
  ==============================================================================
  [..]
    This section provides functions allowing to:
    (+) Start the Complementary One Pulse generation.
    (+) Stop the Complementary One Pulse.
    (+) Start the Complementary One Pulse and enable interrupts.
    (+) Stop the Complementary One Pulse and disable interrupts.

@endverbatim
  * @{
  *//* Set the TIM complementary channel state *//* Disable the complementary PWM output *//**
  * @brief  Stops the TIM PWM signal generation in DMA mode on the complementary
  *         output
  * @param  htim TIM handle
  * @param  Channel TIM Channel to be disabled
  *          This parameter can be one of the following values:
  *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
  *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
  * @retval HAL status
  *//* Enable the complementary PWM output  *//**
  * @brief  Starts the TIM PWM signal generation in DMA mode on the
  *         complementary output
  * @param  htim TIM handle
  * @param  Channel TIM Channel to be enabled
  *          This parameter can be one of the following values:
  *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
  *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
  * @param  pData The source Buffer address.
  * @param  Length The length of data to be transferred from memory to TIM peripheral
  * @retval HAL status
  *//* Disable the TIM Break interrupt (only if no more channel is active) *//* Disable the complementary PWM output  *//**
  * @brief  Stops the PWM signal generation in interrupt mode on the
  *         complementary output.
  * @param  htim TIM handle
  * @param  Channel TIM Channel to be disabled
  *          This parameter can be one of the following values:
  *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
  *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
  * @retval HAL status
  *//* Enable the TIM Break interrupt *//* Check the TIM complementary channel state *//**
  * @brief  Starts the PWM signal generation in interrupt mode on the
  *         complementary output.
  * @param  htim TIM handle
  * @param  Channel TIM Channel to be disabled
  *          This parameter can be one of the following values:
  *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
  *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
  * @retval HAL status
  *//**
  * @brief  Stops the PWM signal generation on the complementary output.
  * @param  htim TIM handle
  * @param  Channel TIM Channel to be disabled
  *          This parameter can be one of the following values:
  *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
  *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
  * @retval HAL status
  *//**
  * @brief  Starts the PWM signal generation on the complementary output.
  * @param  htim TIM handle
  * @param  Channel TIM Channel to be enabled
  *          This parameter can be one of the following values:
  *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
  *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
  * @retval HAL status
  *//** @defgroup TIMEx_Exported_Functions_Group3 Extended Timer Complementary PWM functions
  * @brief    Timer Complementary PWM functions
  *
@verbatim
  ==============================================================================
                 ##### Timer Complementary PWM functions #####
  ==============================================================================
  [..]
    This section provides functions allowing to:
    (+) Start the Complementary PWM.
    (+) Stop the Complementary PWM.
    (+) Start the Complementary PWM and enable interrupts.
    (+) Stop the Complementary PWM and disable interrupts.
    (+) Start the Complementary PWM and enable DMA transfers.
    (+) Stop the Complementary PWM and disable DMA transfers.
@endverbatim
  * @{
  *//* Disable the Capture compare channel N *//* Disable the TIM Output Compare DMA request *//**
  * @brief  Stops the TIM Output Compare signal generation in DMA mode
  *         on the complementary output.
  * @param  htim TIM Output Compare handle
  * @param  Channel TIM Channel to be disabled
  *          This parameter can be one of the following values:
  *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
  *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
  * @retval HAL status
  *//* Enable the Capture compare channel N *//* Enable the TIM Output Compare DMA request *//**
  * @brief  Starts the TIM Output Compare signal generation in DMA mode
  *         on the complementary output.
  * @param  htim TIM Output Compare handle
  * @param  Channel TIM Channel to be enabled
  *          This parameter can be one of the following values:
  *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
  *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
  * @param  pData The source Buffer address.
  * @param  Length The length of data to be transferred from memory to TIM peripheral
  * @retval HAL status
  *//* Disable the TIM Output Compare interrupt *//**
  * @brief  Stops the TIM Output Compare signal generation in interrupt mode
  *         on the complementary output.
  * @param  htim TIM Output Compare handle
  * @param  Channel TIM Channel to be disabled
  *          This parameter can be one of the following values:
  *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
  *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
  * @retval HAL status
  *//* Enable the TIM Output Compare interrupt *//**
  * @brief  Starts the TIM Output Compare signal generation in interrupt mode
  *         on the complementary output.
  * @param  htim TIM OC handle
  * @param  Channel TIM Channel to be enabled
  *          This parameter can be one of the following values:
  *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
  *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
  * @retval HAL status
  *//**
  * @brief  Stops the TIM Output Compare signal generation on the complementary
  *         output.
  * @param  htim TIM handle
  * @param  Channel TIM Channel to be disabled
  *          This parameter can be one of the following values:
  *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
  *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
  * @retval HAL status
  *//**
  * @brief  Starts the TIM Output Compare signal generation on the complementary
  *         output.
  * @param  htim TIM Output Compare handle
  * @param  Channel TIM Channel to be enabled
  *          This parameter can be one of the following values:
  *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
  *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
  * @retval HAL status
  *//** @defgroup TIMEx_Exported_Functions_Group2 Extended Timer Complementary Output Compare functions
  *  @brief   Timer Complementary Output Compare functions
  *
@verbatim
  ==============================================================================
              ##### Timer Complementary Output Compare functions #####
  ==============================================================================
  [..]
    This section provides functions allowing to:
    (+) Start the Complementary Output Compare/PWM.
    (+) Stop the Complementary Output Compare/PWM.
    (+) Start the Complementary Output Compare/PWM and enable interrupts.
    (+) Stop the Complementary Output Compare/PWM and disable interrupts.
    (+) Start the Complementary Output Compare/PWM and enable DMA transfers.
    (+) Stop the Complementary Output Compare/PWM and disable DMA transfers.

@endverbatim
  * @{
  *//* Disable the capture compare Interrupts 1 event *//* Disable the Input Capture channel 1
  (in the Hall Sensor Interface the three possible channels that can be used are TIM_CHANNEL_1,
  TIM_CHANNEL_2 and TIM_CHANNEL_3) *//**
  * @brief  Stops the TIM Hall Sensor Interface in DMA mode.
  * @param  htim TIM Hall Sensor Interface handle
  * @retval HAL status
  *//* Enable the capture compare 1 Interrupt *//* Enable the DMA stream for Capture 1*//* Set the DMA Input Capture 1 Callbacks *//* Enable the Input Capture channel 1
  (in the Hall Sensor Interface the three possible channels that can be used are TIM_CHANNEL_1,
  TIM_CHANNEL_2 and TIM_CHANNEL_3) *//**
  * @brief  Starts the TIM Hall Sensor Interface in DMA mode.
  * @param  htim TIM Hall Sensor Interface handle
  * @param  pData The destination Buffer address.
  * @param  Length The length of data to be transferred from TIM peripheral to memory.
  * @retval HAL status
  *//* Disable the capture compare Interrupts event *//**
  * @brief  Stops the TIM Hall Sensor Interface in interrupt mode.
  * @param  htim TIM Hall Sensor Interface handle
  * @retval HAL status
  *//* Enable the capture compare Interrupts 1 event *//**
  * @brief  Starts the TIM Hall Sensor Interface in interrupt mode.
  * @param  htim TIM Hall Sensor Interface handle
  * @retval HAL status
  *//* Disable the Input Capture channels 1, 2 and 3
  (in the Hall Sensor Interface the three possible channels that can be used are TIM_CHANNEL_1,
  TIM_CHANNEL_2 and TIM_CHANNEL_3) *//**
  * @brief  Stops the TIM Hall sensor Interface.
  * @param  htim TIM Hall Sensor Interface handle
  * @retval HAL status
  *//**
  * @brief  Starts the TIM Hall Sensor Interface.
  * @param  htim TIM Hall Sensor Interface handle
  * @retval HAL status
  *//* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIMEx_HallSensor_MspDeInit could be implemented in the user file
   *//**
  * @brief  DeInitializes TIM Hall Sensor MSP.
  * @param  htim TIM Hall Sensor Interface handle
  * @retval None
  *//* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIMEx_HallSensor_MspInit could be implemented in the user file
   *//**
  * @brief  Initializes the TIM Hall Sensor MSP.
  * @param  htim TIM Hall Sensor Interface handle
  * @retval None
  *//**
  * @brief  DeInitializes the TIM Hall Sensor interface
  * @param  htim TIM Hall Sensor Interface handle
  * @retval HAL status
  *//* Select OC2REF as trigger output on TRGO: write the MMS bits in the TIMx_CR2
    register to 101 *//* Program channel 2 in PWM 2 mode with the desired Commutation_Delay*//* Use the TIM_TS_TI1F_ED signal to reset the TIM counter each edge detection *//* Select the TIM_TS_TI1F_ED signal as Input trigger for the TIM *//* Enable the Hall sensor interface (XOR function of the three inputs) *//* Configure the Channel 1 as Input Channel to interface with the three Outputs of the  Hall sensor *//* Reset interrupt callbacks to legacy week callbacks *//**
  * @brief  Initializes the TIM Hall Sensor Interface and initialize the associated handle.
  * @note   When the timer instance is initialized in Hall Sensor Interface mode,
  *         timer channels 1 and channel 2 are reserved and cannot be used for
  *         other purpose.
  * @param  htim TIM Hall Sensor Interface handle
  * @param  sConfig TIM Hall Sensor configuration structure
  * @retval HAL status
  *//** @defgroup TIMEx_Exported_Functions_Group1 Extended Timer Hall Sensor functions
  * @brief    Timer Hall Sensor functions
  *
@verbatim
  ==============================================================================
                      ##### Timer Hall Sensor functions #####
  ==============================================================================
  [..]
    This section provides functions allowing to:
    (+) Initialize and configure TIM HAL Sensor.
    (+) De-initialize TIM HAL Sensor.
    (+) Start the Hall Sensor Interface.
    (+) Stop the Hall Sensor Interface.
    (+) Start the Hall Sensor Interface and enable interrupts.
    (+) Stop the Hall Sensor Interface and disable interrupts.
    (+) Start the Hall Sensor Interface and enable DMA transfers.
    (+) Stop the Hall Sensor Interface and disable DMA transfers.

@endverbatim
  * @{
  *//** @defgroup TIMEx_Exported_Functions TIM Extended Exported Functions
  * @{
  *//** @defgroup TIMEx TIMEx
  * @brief TIM Extended HAL module driver
  * @{
  *//**
  ******************************************************************************
  * @file    stm32f7xx_hal_tim_ex.c
  * @author  MCD Application Team
  * @brief   TIM HAL module driver.
  *          This file provides firmware functions to manage the following
  *          functionalities of the Timer Extended peripheral:
  *           + Time Hall Sensor Interface Initialization
  *           + Time Hall Sensor Interface Start
  *           + Time Complementary signal break and dead time configuration
  *           + Time Master and Slave synchronization configuration
  *           + Time Output Compare/PWM Channel Configuration (for channels 5 and 6)
  *           + Timer remapping capabilities configuration
  ******************************************************************************
  * @attention
  *
  * Copyright (c) 2017 STMicroelectronics.
  * All rights reserved.
  *
  * This software is licensed under terms that can be found in the LICENSE file
  * in the root directory of this software component.
  * If no LICENSE file comes with this software, it is provided AS-IS.
  *
  ******************************************************************************
  @verbatim
  ==============================================================================
                      ##### TIMER Extended features #####
  ==============================================================================
  [..]
    The Timer Extended features include:
    (#) Complementary outputs with programmable dead-time for :
        (++) Output Compare
        (++) PWM generation (Edge and Center-aligned Mode)
        (++) One-pulse mode output
    (#) Synchronization circuit to control the timer with external signals and to
        interconnect several timers together.
    (#) Break input to put the timer output signals in reset state or in a known state.
    (#) Supports incremental (quadrature) encoder and hall-sensor circuitry for
        positioning purposes

            ##### How to use this driver #####
  ==============================================================================
    [..]
     (#) Initialize the TIM low level resources by implementing the following functions
         depending on the selected feature:
           (++) Hall Sensor output : HAL_TIMEx_HallSensor_MspInit()

     (#) Initialize the TIM low level resources :
        (##) Enable the TIM interface clock using __HAL_RCC_TIMx_CLK_ENABLE();
        (##) TIM pins configuration
            (+++) Enable the clock for the TIM GPIOs using the following function:
              __HAL_RCC_GPIOx_CLK_ENABLE();
            (+++) Configure these TIM pins in Alternate function mode using HAL_GPIO_Init();

     (#) The external Clock can be configured, if needed (the default clock is the
         internal clock from the APBx), using the following function:
         HAL_TIM_ConfigClockSource, the clock configuration should be done before
         any start function.

     (#) Configure the TIM in the desired functioning mode using one of the
         initialization function of this driver:
          (++) HAL_TIMEx_HallSensor_Init() and HAL_TIMEx_ConfigCommutEvent(): to use the
               Timer Hall Sensor Interface and the commutation event with the corresponding
               Interrupt and DMA request if needed (Note that One Timer is used to interface
               with the Hall sensor Interface and another Timer should be used to use
               the commutation event).

     (#) Activate the TIM peripheral using one of the start functions:
           (++) Complementary Output Compare : HAL_TIMEx_OCN_Start(), HAL_TIMEx_OCN_Start_DMA(),
                HAL_TIMEx_OCN_Start_IT()
           (++) Complementary PWM generation : HAL_TIMEx_PWMN_Start(), HAL_TIMEx_PWMN_Start_DMA(),
                HAL_TIMEx_PWMN_Start_IT()
           (++) Complementary One-pulse mode output : HAL_TIMEx_OnePulseN_Start(), HAL_TIMEx_OnePulseN_Start_IT()
           (++) Hall Sensor output : HAL_TIMEx_HallSensor_Start(), HAL_TIMEx_HallSensor_Start_DMA(),
                HAL_TIMEx_HallSensor_Start_IT().

  @endverbatim
  ******************************************************************************
  *//Users/jie/Documents/posixGen_Demos-main/LwIP_StreamingServer/Drivers/STM32F7xx_HAL_Driver/Src/stm32f7xx_hal_uart.cUART_RxISR_16BITuhMaskuhdatahuart->Instance->RDRhuart->Instance->CR1(USART_CR1_RXNEIE | USART_CR1_PEIE)((0x1UL << (5U)) | (0x1UL << (8U)))huart->Instance->CR3huart->Instance->CR24294967007UART_RxISR_8BITUART_EndTransmit_ITUART_TxISR_16BIT0x01FFULUART_TxISR_8BIT(uint8_t)0xFFUART_DMARxOnlyAbortCallbackUART_CLEAR_OREF | UART_CLEAR_NEF | UART_CLEAR_PEF | UART_CLEAR_FEF(0x1UL << (3U)) | (0x1UL << (2U)) | (0x1UL << (0U)) | (0x1UL << (1U))UART_DMATxOnlyAbortCallbackUART_DMARxAbortCallbackUART_DMATxAbortCallbackUART_DMAAbortOnErrorUART_DMAErrorconst HAL_UART_StateTypeDefgstaterxstateUART_DMARxHalfCpltUART_DMAReceiveCpltUART_DMATxHalfCpltUART_DMATransmitCpltUART_EndRxTransferUART_EndTxTransfer(USART_CR1_TXEIE | USART_CR1_TCIE)((0x1UL << (7U)) | (0x1UL << (6U)))USART_CR1_PEIE | USART_CR1_RXNEIE(0x1UL << (8U)) | (0x1UL << (5U))(USART_CR1_TXEIE)((0x1UL << (7U)))33554431IS_UART_ADVFEATURE_INIT(huart->AdvancedInit.AdvFeatureInit)huart->AdvancedInit.AdvFeatureInitIS_UART_ADVFEATURE_SWAP(huart->AdvancedInit.Swap)huart->AdvancedInit.Swap(huart->Instance->CR2)(((READ_REG(huart->Instance->CR2)) & (~((0x1UL << (15U))))) | (huart->AdvancedInit.Swap))(((((huart->Instance->CR2))) & (~((0x1UL << (15U))))) | (huart->AdvancedInit.Swap))IS_UART_ADVFEATURE_TXINV(huart->AdvancedInit.TxPinLevelInvert)huart->AdvancedInit.TxPinLevelInvert(((READ_REG(huart->Instance->CR2)) & (~((0x1UL << (17U))))) | (huart->AdvancedInit.TxPinLevelInvert))(((((huart->Instance->CR2))) & (~((0x1UL << (17U))))) | (huart->AdvancedInit.TxPinLevelInvert))IS_UART_ADVFEATURE_RXINV(huart->AdvancedInit.RxPinLevelInvert)huart->AdvancedInit.RxPinLevelInvert(((READ_REG(huart->Instance->CR2)) & (~((0x1UL << (16U))))) | (huart->AdvancedInit.RxPinLevelInvert))(((((huart->Instance->CR2))) & (~((0x1UL << (16U))))) | (huart->AdvancedInit.RxPinLevelInvert))IS_UART_ADVFEATURE_DATAINV(huart->AdvancedInit.DataInvert)huart->AdvancedInit.DataInvert(((READ_REG(huart->Instance->CR2)) & (~((0x1UL << (18U))))) | (huart->AdvancedInit.DataInvert))(((((huart->Instance->CR2))) & (~((0x1UL << (18U))))) | (huart->AdvancedInit.DataInvert))IS_UART_OVERRUN(huart->AdvancedInit.OverrunDisable)huart->AdvancedInit.OverrunDisable(huart->Instance->CR3)(((READ_REG(huart->Instance->CR3)) & (~((0x1UL << (12U))))) | (huart->AdvancedInit.OverrunDisable))(((((huart->Instance->CR3))) & (~((0x1UL << (12U))))) | (huart->AdvancedInit.OverrunDisable))IS_UART_ADVFEATURE_DMAONRXERROR(huart->AdvancedInit.DMADisableonRxError)huart->AdvancedInit.DMADisableonRxError(((READ_REG(huart->Instance->CR3)) & (~((0x1UL << (13U))))) | (huart->AdvancedInit.DMADisableonRxError))(((((huart->Instance->CR3))) & (~((0x1UL << (13U))))) | (huart->AdvancedInit.DMADisableonRxError))IS_USART_AUTOBAUDRATE_DETECTION_INSTANCE(huart->Instance)IS_UART_ADVFEATURE_AUTOBAUDRATE(huart->AdvancedInit.AutoBaudRateEnable)huart->AdvancedInit.AutoBaudRateEnable(((READ_REG(huart->Instance->CR2)) & (~((0x1UL << (20U))))) | (huart->AdvancedInit.AutoBaudRateEnable))(((((huart->Instance->CR2))) & (~((0x1UL << (20U))))) | (huart->AdvancedInit.AutoBaudRateEnable))IS_UART_ADVFEATURE_AUTOBAUDRATEMODE(huart->AdvancedInit.AutoBaudRateMode)(0x3UL << (21U))huart->AdvancedInit.AutoBaudRateMode(((READ_REG(huart->Instance->CR2)) & (~((0x3UL << (21U))))) | (huart->AdvancedInit.AutoBaudRateMode))(((((huart->Instance->CR2))) & (~((0x3UL << (21U))))) | (huart->AdvancedInit.AutoBaudRateMode))4288675839IS_UART_ADVFEATURE_MSBFIRST(huart->AdvancedInit.MSBFirst)huart->AdvancedInit.MSBFirst(((READ_REG(huart->Instance->CR2)) & (~((0x1UL << (19U))))) | (huart->AdvancedInit.MSBFirst))(((((huart->Instance->CR2))) & (~((0x1UL << (19U))))) | (huart->AdvancedInit.MSBFirst))brrtempclocksourceusartdivpclkIS_UART_BAUDRATE(huart->Init.BaudRate)IS_UART_WORD_LENGTH(huart->Init.WordLength)IS_UART_STOPBITS(huart->Init.StopBits)IS_UART_ONE_BIT_SAMPLE(huart->Init.OneBitSampling)IS_UART_PARITY(huart->Init.Parity)IS_UART_MODE(huart->Init.Mode)IS_UART_HARDWARE_FLOW_CONTROL(huart->Init.HwFlowCtl)IS_UART_OVERSAMPLING(huart->Init.OverSampling)USART_CR1_FIELDS((uint32_t)((0x10001UL << (12U)) | (0x1UL << (10U)) | (0x1UL << (9U)) | (0x1UL << (3U)) | (0x1UL << (2U)) | (0x1UL << (15U))))(huart->Instance->CR1)(((READ_REG(huart->Instance->CR1)) & (~(((uint32_t)((0x10001UL << (12U)) | (0x1UL << (10U)) | (0x1UL << (9U)) | (0x1UL << (3U)) | (0x1UL << (2U)) | (0x1UL << (15U))))))) | (tmpreg))(((((huart->Instance->CR1))) & (~(((uint32_t)((0x10001UL << (12U)) | (0x1UL << (10U)) | (0x1UL << (9U)) | (0x1UL << (3U)) | (0x1UL << (2U)) | (0x1UL << (15U))))))) | (tmpreg))2684395522684405762684410882684410962684411002684738684026493427huart->Init.StopBits(((READ_REG(huart->Instance->CR2)) & (~((0x3UL << (12U))))) | (huart->Init.StopBits))(((((huart->Instance->CR2))) & (~((0x3UL << (12U))))) | (huart->Init.StopBits))USART_CR3_FIELDS((uint32_t)((0x1UL << (8U)) | (0x1UL << (9U)) | (0x1UL << (11U))))(((READ_REG(huart->Instance->CR3)) & (~(((uint32_t)((0x1UL << (8U)) | (0x1UL << (9U)) | (0x1UL << (11U))))))) | (tmpreg))(((((huart->Instance->CR3))) & (~(((uint32_t)((0x1UL << (8U)) | (0x1UL << (9U)) | (0x1UL << (11U))))))) | (tmpreg))281642949644791073759232107376025619456107376128020480107376230410738124801073772544317441073773568huart->Init.BaudRate(uint32_t) HSI_VALUE(uint32_t) LSE_VALUEUART_BRR_MINUART_BRR_MAX655200xFFF0U0x000FU(uint16_t)0x000FUtemp2IS_UART_LIN_INSTANCE(huart->Instance)(USART_CR1_TE | USART_CR1_RE)((0x1UL << (3U)) | (0x1UL << (2U)))IS_UART_RECEIVER_TIMEOUT_VALUE(TimeoutValue)huart->Instance->RTOR(0xFFFFFFUL << (0U))(huart->Instance->RTOR)(((READ_REG(huart->Instance->RTOR)) & (~((0xFFFFFFUL << (0U))))) | (TimeoutValue))(((((huart->Instance->RTOR))) & (~((0xFFFFFFUL << (0U))))) | (TimeoutValue))huart->Instance->ISRcr1itscr3itserrorflagserrorcode2063(uint32_t)(USART_ISR_PE | USART_ISR_FE | USART_ISR_ORE | USART_ISR_NE | USART_ISR_RTOF)67109152(USART_CR1_RXNEIE | USART_CR1_PEIE | USART_CR1_RTOIE)(HAL_UART_ERROR_RTO | HAL_UART_ERROR_ORE)huart->hdmarxnb_remaining_rx_datanb_rx_data(USART_CR1_IDLEIE)((0x1UL << (4U)))abortcplt(USART_CR1_RXNEIE | USART_CR1_PEIE | USART_CR1_TXEIE | USART_CR1_TCIE)((0x1UL << (5U)) | (0x1UL << (8U)) | (0x1UL << (7U)) | (0x1UL << (6U)))4164294966815pdata8bitspdata16bits0x01FFUIS_UART_INSTANCE(huart->Instance)IS_UART_WAKEUPMETHOD(WakeUpMethod)(USART_CR2_LINEN | USART_CR2_CLKEN)((0x1UL << (14U)) | (0x1UL << (11U)))4294948863(USART_CR3_SCEN | USART_CR3_HDSEL | USART_CR3_IREN)((0x1UL << (5U)) | (0x1UL << (3U)) | (0x1UL << (1U)))4294967253(0xFFUL << (24U))((uint32_t)Address << UART_CR2_ADDRESS_LSB_POS)((uint32_t)Address << 24U)(((READ_REG(huart->Instance->CR2)) & (~((0xFFUL << (24U))))) | (((uint32_t)Address << 24U)))(((((huart->Instance->CR2))) & (~((0xFFUL << (24U))))) | (((uint32_t)Address << 24U)))(((READ_REG(huart->Instance->CR1)) & (~((0x1UL << (11U))))) | (WakeUpMethod))(((((huart->Instance->CR1))) & (~((0x1UL << (11U))))) | (WakeUpMethod))IS_UART_LIN_BREAK_DETECT_LENGTH(BreakDetectLength)(USART_CR3_HDSEL | USART_CR3_IREN | USART_CR3_SCEN)((0x1UL << (3U)) | (0x1UL << (1U)) | (0x1UL << (5U)))(((READ_REG(huart->Instance->CR2)) & (~((0x1UL << (5U))))) | (BreakDetectLength))(((((huart->Instance->CR2))) & (~((0x1UL << (5U))))) | (BreakDetectLength))IS_UART_HALFDUPLEX_INSTANCE(huart->Instance)(USART_CR3_IREN | USART_CR3_SCEN)((0x1UL << (1U)) | (0x1UL << (5U)))IS_UART_HWFLOW_INSTANCE(huart->Instance)((uint32_t)(USART_CR3_RTSE | USART_CR3_CTSE | USART_CR3_ONEBIT))((uint32_t)(USART_CR1_M | USART_CR1_PCE | USART_CR1_PS | USART_CR1_TE | USART_CR1_RE | USART_CR1_OVER8))/* Clear RXNE interrupt flag *//*Call legacy weak Rx complete callback*//*Call registered Rx complete callback*//* Standard reception API called *//* (USE_HAL_UART_REGISTER_CALLBACKS) *//*Call legacy weak Rx Event callback*//*Call registered Rx Event callback*//* Clear IDLE Flag *//* Disable IDLE interrupt *//* Set reception type to Standard *//* Check current reception Mode :
         If Reception till IDLE event has been selected : *//* Enable the UART Receiver Timeout Interrupt *//* Check that USART RTOEN bit is set *//* Initialize type of RxEvent to Transfer Complete *//* Clear RxISR function pointer *//* Rx process is completed, restore huart->RxState to Ready *//* Disable the UART Error Interrupt: (Frame error, noise error, overrun error) *//* Disable the UART Parity Error Interrupt and RXNE interrupt*//* Check that a Rx process is ongoing *//**
  * @brief RX interrupt handler for 9 bits data word length .
  * @note   Function is called under interruption only, once
  *         interruptions have been enabled by HAL_UART_Receive_IT()
  * @param huart UART handle.
  * @retval None
  *//* Disable the UART Parity Error Interrupt and RXNE interrupts *//**
  * @brief RX interrupt handler for 7 or 8 bits data word length .
  * @param huart UART handle.
  * @retval None
  *//*Call legacy weak Tx complete callback*//*Call registered Tx complete callback*//* Cleat TxISR function pointer *//* Tx process is ended, restore huart->gState to Ready *//* Disable the UART Transmit Complete Interrupt *//**
  * @brief  Wrap up transmission in non-blocking mode.
  * @param  huart pointer to a UART_HandleTypeDef structure that contains
  *                the configuration information for the specified UART module.
  * @retval None
  *//* Enable the UART Transmit Complete Interrupt *//* Disable the UART Transmit Data Register Empty Interrupt *//* Check that a Tx process is ongoing *//**
  * @brief TX interrupt handler for 9 bits data word length.
  * @note   Function is called under interruption only, once
  *         interruptions have been enabled by HAL_UART_Transmit_IT().
  * @param huart UART handle.
  * @retval None
  *//**
  * @brief TX interrupt handler for 7 or 8 bits data word length .
  * @note   Function is called under interruption only, once
  *         interruptions have been enabled by HAL_UART_Transmit_IT().
  * @param huart UART handle.
  * @retval None
  *//* Call legacy weak Abort Receive Complete Callback *//* Call registered Abort Receive Complete Callback *//* Call user Abort complete callback *//* Restore huart->RxState to Ready *//* Discard the received data *//* Clear the Error flags in the ICR register *//**
  * @brief  DMA UART Rx communication abort callback, when initiated by user by a call to
  *         HAL_UART_AbortReceive_IT API (Abort only Rx transfer)
  *         (This callback is executed at end of DMA Rx Abort procedure following user abort request,
  *         and leads to user Rx Abort Complete callback execution).
  * @param  hdma DMA handle.
  * @retval None
  *//* Call legacy weak Abort Transmit Complete Callback *//* Call registered Abort Transmit Complete Callback *//* Restore huart->gState to Ready *//**
  * @brief  DMA UART Tx communication abort callback, when initiated by user by a call to
  *         HAL_UART_AbortTransmit_IT API (Abort only Tx transfer)
  *         (This callback is executed at end of DMA Tx Abort procedure following user abort request,
  *         and leads to user Tx Abort Complete callback execution).
  * @param  hdma DMA handle.
  * @retval None
  *//* Call legacy weak Abort complete callback *//* Call registered Abort complete callback *//* Restore huart->gState and huart->RxState to Ready *//* Reset errorCode *//* No Abort process still ongoing : All DMA channels are aborted, call user Abort Complete callback *//* Check if an Abort process is still ongoing *//**
  * @brief  DMA UART Rx communication abort callback, when initiated by user
  *         (To be called at end of DMA Rx Abort procedure following user abort request).
  * @note   When this callback is executed, User Abort complete call back is called only if no
  *         Abort still ongoing for Tx DMA Handle.
  * @param  hdma DMA handle.
  * @retval None
  *//**
  * @brief  DMA UART Tx communication abort callback, when initiated by user
  *         (To be called at end of DMA Tx Abort procedure following user abort request).
  * @note   When this callback is executed, User Abort complete call back is called only if no
  *         Abort still ongoing for Rx DMA Handle.
  * @param  hdma DMA handle.
  * @retval None
  *//*Call legacy weak error callback*//**
  * @brief  DMA UART communication abort callback, when initiated by HAL services on Error
  *         (To be called at end of DMA Abort procedure following error occurrence).
  * @param  hdma DMA handle.
  * @retval None
  *//* Stop UART DMA Rx request if ongoing *//* Stop UART DMA Tx request if ongoing *//**
  * @brief DMA UART communication error callback.
  * @param hdma DMA handle.
  * @retval None
  *//*Call legacy weak Rx Half complete callback*//*Call registered Rx Half complete callback*//* In other cases : use Rx Half Complete callback *//* Check current reception Mode :
     If Reception till IDLE event has been selected : use Rx Event callback *//* Initialize type of RxEvent that correspond to RxEvent callback execution;
     In this case, Rx Event type is Half Transfer *//**
  * @brief DMA UART receive process half complete callback.
  * @param hdma DMA handle.
  * @retval None
  *//* In other cases : use Rx Complete callback *//* Initialize type of RxEvent that correspond to RxEvent callback execution;
     In this case, Rx Event type is Transfer Complete *//* If Reception till IDLE event has been selected, Disable IDLE Interrupt *//* At end of Rx process, restore huart->RxState to Ready *//* Disable the DMA transfer for the receiver request by resetting the DMAR bit
       in the UART CR3 register *//* Disable PE and ERR (Frame error, noise error, overrun error) interrupts *//* DMA Normal mode *//**
  * @brief DMA UART receive process complete callback.
  * @param hdma DMA handle.
  * @retval None
  *//*Call legacy weak Tx Half complete callback*//*Call registered Tx Half complete callback*//**
  * @brief DMA UART transmit process half complete callback.
  * @param hdma DMA handle.
  * @retval None
  *//* DMA Circular mode *//* Disable the DMA transfer for transmit request by resetting the DMAT bit
       in the UART CR3 register *//**
  * @brief DMA UART transmit process complete callback.
  * @param hdma DMA handle.
  * @retval None
  *//* Reset RxIsr function pointer *//* In case of reception waiting for IDLE event, disable also the IDLE IE interrupt source *//* Disable RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts *//**
  * @brief  End ongoing Rx transfer on UART peripheral (following error detection or Reception completion).
  * @param  huart UART handle.
  * @retval None
  *//* At end of Tx process, restore huart->gState to Ready *//* Disable TXEIE and TCIE interrupts *//**
  * @brief  End ongoing Tx transfer on UART peripheral (following error detection or Transmit completion).
  * @param  huart UART handle.
  * @retval None
  *//* Enable the DMA transfer for the receiver request by setting the DMAR bit
  in the UART CR3 register *//* Enable the UART Error Interrupt: (Frame error, noise error, overrun error) *//* Enable the UART Parity Error Interrupt *//* Restore huart->RxState to ready *//* Set error code to DMA *//* Enable the DMA channel *//* Set the DMA abort callback *//* Set the UART DMA Half transfer complete callback *//* Set the UART DMA transfer complete callback *//**
  * @brief  Start Receive operation in DMA mode.
  * @note   This function could be called by all HAL UART API providing reception in DMA mode.
  * @note   When calling this function, parameters validity is considered as already checked,
  *         i.e. Rx State, buffer address, ...
  *         UART Handle is assumed as Locked.
  * @param  huart UART handle.
  * @param  pData Pointer to data buffer (u8 or u16 data elements).
  * @param  Size  Amount of data elements (u8 or u16) to be received.
  * @retval HAL status
  *//* Enable the UART Parity Error interrupt and Data Register Not Empty interrupt *//* Set the Rx ISR function pointer according to the data word length *//* Computation of UART mask to apply to RDR register *//**
  * @brief  Start Receive operation in interrupt mode.
  * @note   This function could be called by all HAL UART API providing reception in Interrupt mode.
  * @note   When calling this function, parameters validity is considered as already checked,
  *         i.e. Rx State, buffer address, ...
  *         UART Handle is assumed as Locked.
  * @param  huart UART handle.
  * @param  pData Pointer to data buffer (u8 or u16 data elements).
  * @param  Size  Amount of data elements (u8 or u16) to be received.
  * @retval HAL status
  *//* Blocking error : transfer is aborted
          Set the UART state ready to be able to start again the process,
          Disable Rx Interrupts if ongoing *//* Clear Receiver Timeout flag*//* Clear Overrun Error flag*//* Wait until flag is set *//**
  * @brief  This function handles UART Communication Timeout. It waits
  *                  until a flag is no longer in the specified status.
  * @param huart     UART handle.
  * @param Flag      Specifies the UART flag to check
  * @param Status    The actual Flag status (SET or RESET)
  * @param Tickstart Tick start value
  * @param Timeout   Timeout duration
  * @retval HAL status
  *//* Initialize the UART State *//* Timeout occurred *//* Disable RXNE, PE and ERR (Frame error, noise error, overrun error)
      interrupts for the interrupt process *//* Wait until REACK flag is set *//* Check if the Receiver is enabled *//* Disable TXE interrupt for the interrupt process *//* Wait until TEACK flag is set *//* Check if the Transmitter is enabled *//* Init tickstart for timeout management *//* Initialize the UART ErrorCode *//**
  * @brief Check the UART Idle State.
  * @param huart UART handle.
  * @retval HAL status
  *//* if required, configure MSB first on communication line *//* set auto Baudrate detection parameters if detection is enabled *//* if required, configure auto Baud rate detection scheme *//* if required, configure DMA disabling on reception error *//* if required, configure RX overrun detection disabling *//* if required, configure data inversion *//* if required, configure RX pin active level inversion *//* if required, configure TX pin active level inversion *//* if required, configure RX/TX pins swap *//* Check whether the set of advanced features to configure is properly set *//**
  * @brief Configure the UART peripheral advanced features.
  * @param huart UART handle.
  * @retval None
  *//* Clear ISR function pointers *//* USARTDIV must be greater than or equal to 0d16 *//*-------------------------- USART BRR Configuration -----------------------*//* Configure
  * - UART HardWare Flow Control: set CTSE and RTSE bits according
  *   to huart->Init.HwFlowCtl value
  * - one-bit sampling method versus three samples' majority rule according
  *   to huart->Init.OneBitSampling (not applicable to LPUART) *//*-------------------------- USART CR3 Configuration -----------------------*//* Configure the UART Stop Bits: Set STOP[13:12] bits according
  * to huart->Init.StopBits value *//*-------------------------- USART CR2 Configuration -----------------------*//* Clear M, PCE, PS, TE, RE and OVER8 bits and configure
  *  the UART Word Length, Parity, Mode and oversampling:
  *  set the M bits according to huart->Init.WordLength value
  *  set PCE and PS bits according to huart->Init.Parity value
  *  set TE and RE bits according to huart->Init.Mode value
  *  set OVER8 bit according to huart->Init.OverSampling value *//*-------------------------- USART CR1 Configuration -----------------------*//**
  * @brief Configure the UART peripheral.
  * @param huart UART handle.
  * @retval HAL status
  *//* Legacy weak RxEventCallback           *//* Legacy weak WakeupCallback            *//* Legacy weak AbortReceiveCpltCallback  *//* Legacy weak AbortTransmitCpltCallback *//* Legacy weak AbortCpltCallback         *//* Legacy weak ErrorCallback             *//* Legacy weak RxCpltCallback            *//* Legacy weak RxHalfCpltCallback        *//* Legacy weak TxCpltCallback            *//* Legacy weak TxHalfCpltCallback        *//* Init the UART Callback settings *//**
  * @brief  Initialize the callbacks to their default values.
  * @param  huart UART handle.
  * @retval none
  *//** @defgroup UART_Private_Functions UART Private Functions
  * @{
  *//**
  * @brief  Return the UART handle error code.
  * @param  huart Pointer to a UART_HandleTypeDef structure that contains
  *               the configuration information for the specified UART.
  * @retval UART Error Code
  *//**
  * @brief Return the UART handle state.
  * @param  huart Pointer to a UART_HandleTypeDef structure that contains
  *               the configuration information for the specified UART.
  * @retval HAL state
  *//** @defgroup UART_Exported_Functions_Group4 Peripheral State and Error functions
  *  @brief   UART Peripheral State functions
  *
@verbatim
  ==============================================================================
            ##### Peripheral State and Error functions #####
  ==============================================================================
    [..]
    This subsection provides functions allowing to :
      (+) Return the UART handle state.
      (+) Return the UART handle error code

@endverbatim
  * @{
  *//* Send break characters *//**
  * @brief  Transmit break characters.
  * @param  huart UART handle.
  * @retval HAL status
  *//* Enable the USART's receive interface by setting the RE bit in the USART CR1 register *//* Clear TE and RE bits *//**
  * @brief  Enable the UART receiver and disable the UART transmitter.
  * @param  huart UART handle.
  * @retval HAL status.
  *//* Enable the USART's transmit interface by setting the TE bit in the USART CR1 register *//**
  * @brief  Enable the UART transmitter and disable the UART receiver.
  * @param  huart UART handle.
  * @retval HAL status
  *//**
  * @brief Enter UART mute mode (means UART actually enters mute mode).
  * @note  To exit from mute mode, HAL_MultiProcessor_DisableMuteMode() API must be called.
  * @param huart UART handle.
  * @retval None
  *//* Disable USART mute mode by clearing the MME bit in the CR1 register *//**
  * @brief  Disable UART mute mode (does not mean the UART actually exits mute mode
  *         as it may not have been in mute mode at this very moment).
  * @param  huart UART handle.
  * @retval HAL status
  *//* Enable USART mute mode by setting the MME bit in the CR1 register *//**
  * @brief  Enable UART in mute mode (does not mean UART enters mute mode;
  *         to enter mute mode, HAL_MultiProcessor_EnterMuteMode() API must be called).
  * @param  huart UART handle.
  * @retval HAL status
  *//* Clear the USART RTOEN bit *//**
  * @brief  Disable the UART receiver timeout feature.
  * @param  huart Pointer to a UART_HandleTypeDef structure that contains
  *                    the configuration information for the specified UART module.
  * @retval HAL status
  *//* Set the USART RTOEN bit *//**
  * @brief  Enable the UART receiver timeout feature.
  * @param  huart Pointer to a UART_HandleTypeDef structure that contains
  *                    the configuration information for the specified UART module.
  * @retval HAL status
  *//**
  * @brief  Update on the fly the receiver timeout value in RTOR register.
  * @param  huart Pointer to a UART_HandleTypeDef structure that contains
  *                    the configuration information for the specified UART module.
  * @param  TimeoutValue receiver timeout value in number of baud blocks. The timeout
  *                     value must be less or equal to 0x0FFFFFFFF.
  * @retval None
  *//** @defgroup UART_Exported_Functions_Group3 Peripheral Control functions
  *  @brief   UART control functions
  *
@verbatim
 ===============================================================================
                      ##### Peripheral Control functions #####
 ===============================================================================
    [..]
    This subsection provides a set of functions allowing to control the UART.
     (+) HAL_UART_ReceiverTimeout_Config() API allows to configure the receiver timeout value on the fly
     (+) HAL_UART_EnableReceiverTimeout() API enables the receiver timeout feature
     (+) HAL_UART_DisableReceiverTimeout() API disables the receiver timeout feature
     (+) HAL_MultiProcessor_EnableMuteMode() API enables mute mode
     (+) HAL_MultiProcessor_DisableMuteMode() API disables mute mode
     (+) HAL_MultiProcessor_EnterMuteMode() API enters mute mode
     (+) UART_SetConfig() API configures the UART peripheral
     (+) UART_AdvFeatureConfig() API optionally configures the UART advanced features
     (+) UART_CheckIdleState() API ensures that TEACK and/or REACK are set after initialization
     (+) HAL_HalfDuplex_EnableTransmitter() API disables receiver and enables transmitter
     (+) HAL_HalfDuplex_EnableReceiver() API disables transmitter and enables receiver
     (+) HAL_LIN_SendBreak() API transmits the break characters
@endverbatim
  * @{
  *//* NOTE : This function should not be modified, when the callback is needed,
            the HAL_UARTEx_WakeupCallback can be implemented in the user file.
   *//**
  * @brief UART wakeup from Stop mode callback.
  * @param huart UART handle.
  * @retval None
  *//* NOTE : This function should not be modified, when the callback is needed,
            the HAL_UARTEx_RxEventCallback can be implemented in the user file.
   *//**
  * @brief  Reception Event Callback (Rx event notification called after use of advanced reception service).
  * @param  huart UART handle
  * @param  Size  Number of data available in application reception buffer (indicates a position in
  *               reception buffer until which, data are available)
  * @retval None
  *//* NOTE : This function should not be modified, when the callback is needed,
            the HAL_UART_AbortReceiveCpltCallback can be implemented in the user file.
   *//**
  * @brief  UART Abort Receive Complete callback.
  * @param  huart UART handle.
  * @retval None
  *//* NOTE : This function should not be modified, when the callback is needed,
            the HAL_UART_AbortTransmitCpltCallback can be implemented in the user file.
   *//**
  * @brief  UART Abort Complete callback.
  * @param  huart UART handle.
  * @retval None
  *//* NOTE : This function should not be modified, when the callback is needed,
            the HAL_UART_AbortCpltCallback can be implemented in the user file.
   *//* NOTE : This function should not be modified, when the callback is needed,
            the HAL_UART_ErrorCallback can be implemented in the user file.
   *//**
  * @brief  UART error callback.
  * @param  huart UART handle.
  * @retval None
  *//* NOTE: This function should not be modified, when the callback is needed,
           the HAL_UART_RxHalfCpltCallback can be implemented in the user file.
   *//**
  * @brief  Rx Half Transfer completed callback.
  * @param  huart UART handle.
  * @retval None
  *//* NOTE : This function should not be modified, when the callback is needed,
            the HAL_UART_RxCpltCallback can be implemented in the user file.
   *//**
  * @brief  Rx Transfer completed callback.
  * @param  huart UART handle.
  * @retval None
  *//* NOTE: This function should not be modified, when the callback is needed,
           the HAL_UART_TxHalfCpltCallback can be implemented in the user file.
   *//**
  * @brief  Tx Half Transfer completed callback.
  * @param  huart UART handle.
  * @retval None
  *//* NOTE : This function should not be modified, when the callback is needed,
            the HAL_UART_TxCpltCallback can be implemented in the user file.
   *//**
  * @brief Tx Transfer completed callback.
  * @param huart UART handle.
  * @retval None
  *//* UART in mode Transmitter (transmission end) -----------------------------*//* UART in mode Transmitter ------------------------------------------------*//* Call legacy weak Wakeup Callback *//* Call registered Wakeup Callback *//* UART Rx state is not reset as a reception process might be ongoing.
       If UART handle state fields need to be reset to READY, this could be done in Wakeup callback *//* UART wakeup from Stop mode interrupt occurred ---------------------------*//* Initialize type of RxEvent that correspond to RxEvent callback execution;
           In this case, Rx Event type is Idle Event *//* Check received length : If all expected data are received, do nothing.
         Otherwise, if at least one data has already been received, IDLE event is to be notified to user *//* DMA mode not enabled *//* Last bytes received, so no need as the abort is immediate *//* Disable the DMA transfer for the receiver request by resetting the DMAR bit
             in the UART CR3 register *//* In Normal mode, end DMA xfer and HAL UART Rx process*//* Reception is not complete *//* Check received length : If all expected data are received, do nothing,
         (DMA cplt callback will be called).
         Otherwise, if at least one data has already been received, IDLE event is to be notified to user *//* DMA mode enabled *//* Check if DMA mode is enabled in UART *//* Check current reception Mode :
     If Reception till IDLE event has been selected : *//* End if some error occurs *//* Non Blocking error : transfer could go on.
           Error is notified to user through user error callback *//* Call user error callback *//* Call Directly huart->hdmarx->XferAbortCallback function in case of error *//* Set the UART DMA Abort callback :
               will lead to call HAL_UART_ErrorCallback() at end of DMA abort procedure *//* Abort the UART DMA Rx channel *//* Disable the UART DMA Rx request if enabled *//* Abort the UART DMA Rx channel if enabled *//* Blocking error : transfer is aborted
           Set the UART state ready to be able to start again the process,
           Disable Rx Interrupts, and disable Rx DMA request, if ongoing *//* If Error is to be considered as blocking :
          - Receiver Timeout error in Reception
          - Overrun error in Reception
          - any error occurs in DMA mode reception
      *//* UART in mode Receiver --------------------------------------------------*//* Call UART Error Call back function if need be ----------------------------*//* UART Receiver Timeout interrupt occurred ---------------------------------*//* UART Over-Run interrupt occurred -----------------------------------------*//* UART noise error interrupt occurred --------------------------------------*//* UART frame error interrupt occurred --------------------------------------*//* UART parity error interrupt occurred -------------------------------------*//* If some errors occur *//* UART in mode Receiver ---------------------------------------------------*//* If no error occurs *//**
  * @brief Handle UART interrupt request.
  * @param huart UART handle.
  * @retval None
  *//* As no DMA to be aborted, call directly user Abort complete callback *//* Reset Rx transfer counter *//* Set the UART DMA Abort callback :
         will lead to call HAL_UART_AbortCpltCallback() at end of DMA abort procedure *//* Abort the UART DMA Rx channel : use non blocking DMA Abort API (callback) *//* If Reception till IDLE event was ongoing, disable IDLEIE interrupt *//**
  * @brief  Abort ongoing Receive transfer (Interrupt mode).
  * @param  huart UART handle.
  * @note   This procedure could be used for aborting any ongoing Rx transfer started in Interrupt or DMA mode.
  *         This procedure performs following operations :
  *           - Disable UART Interrupts (Rx)
  *           - Disable the DMA transfer in the peripheral register (if enabled)
  *           - Abort DMA transfer by calling HAL_DMA_Abort_IT (in case of transfer in DMA mode)
  *           - Set handle State to READY
  *           - At abort completion, call user abort complete callback
  * @note   This procedure is executed in Interrupt mode, meaning that abort procedure could be
  *         considered as completed only when user abort complete callback is executed (not when exiting function).
  * @retval HAL status
  *//* Clear TxISR function pointers *//* Reset Tx transfer counter *//* Call Directly huart->hdmatx->XferAbortCallback function in case of error *//* Abort the UART DMA Tx channel : use non blocking DMA Abort API (callback) *//* Disable the UART DMA Tx request if enabled *//* Abort the UART DMA Tx channel if enabled *//* Disable interrupts *//**
  * @brief  Abort ongoing Transmit transfer (Interrupt mode).
  * @param  huart UART handle.
  * @note   This procedure could be used for aborting any ongoing Tx transfer started in Interrupt or DMA mode.
  *         This procedure performs following operations :
  *           - Disable UART Interrupts (Tx)
  *           - Disable the DMA transfer in the peripheral register (if enabled)
  *           - Abort DMA transfer by calling HAL_DMA_Abort_IT (in case of transfer in DMA mode)
  *           - Set handle State to READY
  *           - At abort completion, call user abort complete callback
  * @note   This procedure is executed in Interrupt mode, meaning that abort procedure could be
  *         considered as completed only when user abort complete callback is executed (not when exiting function).
  * @retval HAL status
  *//* Reset Tx and Rx transfer counters *//* if no DMA abort complete callback execution is required => call user Abort Complete callback *//* UART Rx DMA Abort callback has already been initialised :
         will lead to call HAL_UART_AbortCpltCallback() at end of DMA abort procedure *//* UART Tx DMA Abort callback has already been initialised :
         will lead to call HAL_UART_AbortCpltCallback() at end of DMA abort procedure *//* Disable DMA Tx at UART level *//* Set DMA Abort Complete callback if UART DMA Rx request if enabled.
       Otherwise, set it to NULL *//* DMA Rx Handle is valid *//* Set DMA Abort Complete callback if UART DMA Tx request if enabled.
       Otherwise, set it to NULL *//* DMA Tx Handle is valid *//* If DMA Tx and/or DMA Rx Handles are associated to UART Handle, DMA Abort complete callbacks should be initialised
     before any call to DMA Abort functions *//**
  * @brief  Abort ongoing transfers (Interrupt mode).
  * @param  huart UART handle.
  * @note   This procedure could be used for aborting any ongoing transfer started in Interrupt or DMA mode.
  *         This procedure performs following operations :
  *           - Disable UART Interrupts (Tx and Rx)
  *           - Disable the DMA transfer in the peripheral register (if enabled)
  *           - Abort DMA transfer by calling HAL_DMA_Abort_IT (in case of transfer in DMA mode)
  *           - Set handle State to READY
  *           - At abort completion, call user abort complete callback
  * @note   This procedure is executed in Interrupt mode, meaning that abort procedure could be
  *         considered as completed only when user abort complete callback is executed (not when exiting function).
  * @retval HAL status
  *//* Set the UART DMA Abort callback to Null.
         No call back execution at end of DMA abort procedure *//* Abort the UART DMA Rx channel : use blocking DMA Abort API (no callback) *//**
  * @brief  Abort ongoing Receive transfer (blocking mode).
  * @param  huart UART handle.
  * @note   This procedure could be used for aborting any ongoing Rx transfer started in Interrupt or DMA mode.
  *         This procedure performs following operations :
  *           - Disable UART Interrupts (Rx)
  *           - Disable the DMA transfer in the peripheral register (if enabled)
  *           - Abort DMA transfer by calling HAL_DMA_Abort (in case of transfer in DMA mode)
  *           - Set handle State to READY
  * @note   This procedure is executed in blocking mode : when exiting function, Abort is considered as completed.
  * @retval HAL status
  *//* Abort the UART DMA Tx channel : use blocking DMA Abort API (no callback) *//**
  * @brief  Abort ongoing Transmit transfer (blocking mode).
  * @param  huart UART handle.
  * @note   This procedure could be used for aborting any ongoing Tx transfer started in Interrupt or DMA mode.
  *         This procedure performs following operations :
  *           - Disable UART Interrupts (Tx)
  *           - Disable the DMA transfer in the peripheral register (if enabled)
  *           - Abort DMA transfer by calling HAL_DMA_Abort (in case of transfer in DMA mode)
  *           - Set handle State to READY
  * @note   This procedure is executed in blocking mode : when exiting function, Abort is considered as completed.
  * @retval HAL status
  *//* Disable TXEIE, TCIE, RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts *//**
  * @brief  Abort ongoing transfers (blocking mode).
  * @param  huart UART handle.
  * @note   This procedure could be used for aborting any ongoing transfer started in Interrupt or DMA mode.
  *         This procedure performs following operations :
  *           - Disable UART Interrupts (Tx and Rx)
  *           - Disable the DMA transfer in the peripheral register (if enabled)
  *           - Abort DMA transfer by calling HAL_DMA_Abort (in case of transfer in DMA mode)
  *           - Set handle State to READY
  * @note   This procedure is executed in blocking mode : when exiting function, Abort is considered as completed.
  * @retval HAL status
  *//* Abort the UART DMA Tx channel *//* The Lock is not implemented on this API to allow the user application
     to call the HAL UART API under callbacks HAL_UART_TxCpltCallback() / HAL_UART_RxCpltCallback() /
     HAL_UART_TxHalfCpltCallback / HAL_UART_RxHalfCpltCallback:
     indeed, when HAL_DMA_Abort() API is called, the DMA TX/RX Transfer or Half Transfer complete
     interrupt is generated if the DMA transfer interruption occurs at the middle or at the end of
     the stream and the corresponding call back is executed. *//**
  * @brief Stop the DMA Transfer.
  * @param huart UART handle.
  * @retval HAL status
  *//* Enable the UART DMA Rx request *//* Re-enable PE and ERR (Frame error, noise error, overrun error) interrupts *//* Clear the Overrun flag before resuming the Rx transfer *//* Enable the UART DMA Tx request *//**
  * @brief Resume the DMA Transfer.
  * @param huart UART handle.
  * @retval HAL status
  *//* Disable the UART DMA Rx request *//* Disable the UART DMA Tx request *//**
  * @brief Pause the DMA Transfer.
  * @param huart UART handle.
  * @retval HAL status
  *//* Set Reception type to Standard reception *//* Check that a Rx process is not already ongoing *//**
  * @brief Receive an amount of data in DMA mode.
  * @note   When the UART parity is enabled (PCE = 1), the received data contain
  *         the parity bit (MSB position).
  * @note   When UART parity is not enabled (PCE = 0), and Word Length is configured to 9 bits (M1-M0 = 01),
  *         the received data is handled as a set of u16. In this case, Size must indicate the number
  *         of u16 available through pData.
  * @param huart UART handle.
  * @param pData Pointer to data buffer (u8 or u16 data elements).
  * @param Size  Amount of data elements (u8 or u16) to be received.
  * @retval HAL status
  *//* Enable the DMA transfer for transmit request by setting the DMAT bit
    in the UART CR3 register *//* Clear the TC flag in the ICR register *//* Restore huart->gState to ready *//* Enable the UART transmit DMA channel *//* Check that a Tx process is not already ongoing *//**
  * @brief Send an amount of data in DMA mode.
  * @note   When UART parity is not enabled (PCE = 0), and Word Length is configured to 9 bits (M1-M0 = 01),
  *         the sent data is handled as a set of u16. In this case, Size must indicate the number
  *         of u16 provided through pData.
  * @param huart UART handle.
  * @param pData Pointer to data buffer (u8 or u16 data elements).
  * @param Size  Amount of data elements (u8 or u16) to be sent.
  * @retval HAL status
  *//**
  * @brief Receive an amount of data in interrupt mode.
  * @note   When UART parity is not enabled (PCE = 0), and Word Length is configured to 9 bits (M1-M0 = 01),
  *         the received data is handled as a set of u16. In this case, Size must indicate the number
  *         of u16 available through pData.
  * @param huart UART handle.
  * @param pData Pointer to data buffer (u8 or u16 data elements).
  * @param Size  Amount of data elements (u8 or u16) to be received.
  * @retval HAL status
  *//* Enable the Transmit Data Register Empty interrupt *//* Set the Tx ISR function pointer according to the data word length *//**
  * @brief Send an amount of data in interrupt mode.
  * @note   When UART parity is not enabled (PCE = 0), and Word Length is configured to 9 bits (M1-M0 = 01),
  *         the sent data is handled as a set of u16. In this case, Size must indicate the number
  *         of u16 provided through pData.
  * @param huart UART handle.
  * @param pData Pointer to data buffer (u8 or u16 data elements).
  * @param Size  Amount of data elements (u8 or u16) to be sent.
  * @retval HAL status
  *//* as long as data have to be received *//* In case of 9bits/No Parity transfer, pRxData needs to be handled as a uint16_t pointer *//**
  * @brief Receive an amount of data in blocking mode.
  * @note   When UART parity is not enabled (PCE = 0), and Word Length is configured to 9 bits (M1-M0 = 01),
  *         the received data is handled as a set of u16. In this case, Size must indicate the number
  *         of u16 available through pData.
  * @param huart   UART handle.
  * @param pData   Pointer to data buffer (u8 or u16 data elements).
  * @param Size    Amount of data elements (u8 or u16) to be received.
  * @param Timeout Timeout duration.
  * @retval HAL status
  *//* In case of 9bits/No Parity transfer, pData needs to be handled as a uint16_t pointer *//**
  * @brief Send an amount of data in blocking mode.
  * @note   When UART parity is not enabled (PCE = 0), and Word Length is configured to 9 bits (M1-M0 = 01),
  *         the sent data is handled as a set of u16. In this case, Size must indicate the number
  *         of u16 provided through pData.
  * @param huart   UART handle.
  * @param pData   Pointer to data buffer (u8 or u16 data elements).
  * @param Size    Amount of data elements (u8 or u16) to be sent.
  * @param Timeout Timeout duration.
  * @retval HAL status
  *//** @defgroup UART_Exported_Functions_Group2 IO operation functions
  * @brief UART Transmit/Receive functions
  *
@verbatim
 ===============================================================================
                      ##### IO operation functions #####
 ===============================================================================
    This subsection provides a set of functions allowing to manage the UART asynchronous
    and Half duplex data transfers.

    (#) There are two mode of transfer:
       (+) Blocking mode: The communication is performed in polling mode.
           The HAL status of all data processing is returned by the same function
           after finishing transfer.
       (+) Non-Blocking mode: The communication is performed using Interrupts
           or DMA, These API's return the HAL status.
           The end of the data processing will be indicated through the
           dedicated UART IRQ when using Interrupt mode or the DMA IRQ when
           using DMA mode.
           The HAL_UART_TxCpltCallback(), HAL_UART_RxCpltCallback() user callbacks
           will be executed respectively at the end of the transmit or Receive process
           The HAL_UART_ErrorCallback()user callback will be executed when a communication error is detected

    (#) Blocking mode API's are :
        (+) HAL_UART_Transmit()
        (+) HAL_UART_Receive()

    (#) Non-Blocking mode API's with Interrupt are :
        (+) HAL_UART_Transmit_IT()
        (+) HAL_UART_Receive_IT()
        (+) HAL_UART_IRQHandler()

    (#) Non-Blocking mode API's with DMA are :
        (+) HAL_UART_Transmit_DMA()
        (+) HAL_UART_Receive_DMA()
        (+) HAL_UART_DMAPause()
        (+) HAL_UART_DMAResume()
        (+) HAL_UART_DMAStop()

    (#) A set of Transfer Complete Callbacks are provided in Non_Blocking mode:
        (+) HAL_UART_TxHalfCpltCallback()
        (+) HAL_UART_TxCpltCallback()
        (+) HAL_UART_RxHalfCpltCallback()
        (+) HAL_UART_RxCpltCallback()
        (+) HAL_UART_ErrorCallback()

    (#) Non-Blocking mode transfers could be aborted using Abort API's :
        (+) HAL_UART_Abort()
        (+) HAL_UART_AbortTransmit()
        (+) HAL_UART_AbortReceive()
        (+) HAL_UART_Abort_IT()
        (+) HAL_UART_AbortTransmit_IT()
        (+) HAL_UART_AbortReceive_IT()

    (#) For Abort services based on interrupts (HAL_UART_Abortxxx_IT), a set of Abort Complete Callbacks are provided:
        (+) HAL_UART_AbortCpltCallback()
        (+) HAL_UART_AbortTransmitCpltCallback()
        (+) HAL_UART_AbortReceiveCpltCallback()

    (#) A Rx Event Reception Callback (Rx event notification) is available for Non_Blocking modes of enhanced
        reception services:
        (+) HAL_UARTEx_RxEventCallback()
#if defined(USART_CR1_UESM)

    (#) Wakeup from Stop mode Callback:
        (+) HAL_UARTEx_WakeupCallback()
#endif

    (#) In Non-Blocking mode transfers, possible errors are split into 2 categories.
        Errors are handled as follows :
       (+) Error is considered as Recoverable and non blocking : Transfer could go till end, but error severity is
           to be evaluated by user : this concerns Frame Error, Parity Error or Noise Error
           in Interrupt mode reception .
           Received character is then retrieved and stored in Rx buffer, Error code is set to allow user
           to identify error type, and HAL_UART_ErrorCallback() user callback is executed.
           Transfer is kept ongoing on UART side.
           If user wants to abort it, Abort services should be called by user.
       (+) Error is considered as Blocking : Transfer could not be completed properly and is aborted.
           This concerns Overrun Error In Interrupt mode reception and all errors in DMA mode.
           Error code is set to allow user to identify error type, and HAL_UART_ErrorCallback()
           user callback is executed.

    -@- In the Half duplex communication, it is forbidden to run the transmit
        and receive process in parallel, the UART state HAL_UART_STATE_BUSY_TX_RX can't be useful.

@endverbatim
  * @{
  *//* Legacy weak UART Rx Event Callback  *//**
  * @brief  UnRegister the UART Rx Event Callback
  *         UART Rx Event Callback is redirected to the weak HAL_UARTEx_RxEventCallback() predefined callback
  * @param  huart     Uart handle
  * @retval HAL status
  *//**
  * @brief  Register a User UART Rx Event Callback
  *         To be used instead of the weak predefined callback
  * @param  huart     Uart handle
  * @param  pCallback Pointer to the Rx Event Callback function
  * @retval HAL status
  *//* Legacy weak MspDeInitCallback      *//* Legacy weak MspInitCallback        *//* Legacy weak WakeupCallback         *//* Legacy weak
                                                                                  AbortReceiveCpltCallback           *//* Legacy weak
                                                                                  AbortTransmitCpltCallback          *//* Legacy weak AbortCpltCallback      *//* Legacy weak ErrorCallback          *//* Legacy weak RxCpltCallback         *//* Legacy weak RxHalfCpltCallback     *//* Legacy weak TxCpltCallback         *//* Legacy weak  TxHalfCpltCallback    *//**
  * @brief  Unregister an UART Callback
  *         UART callaback is redirected to the weak predefined callback
  * @note   The HAL_UART_UnRegisterCallback() may be called before HAL_UART_Init(), HAL_HalfDuplex_Init(),
  *         HAL_LIN_Init(), HAL_MultiProcessor_Init() or HAL_RS485Ex_Init() in HAL_UART_STATE_RESET to un-register
  *         callbacks for HAL_UART_MSPINIT_CB_ID and HAL_UART_MSPDEINIT_CB_ID
  * @param  huart uart handle
  * @param  CallbackID ID of the callback to be unregistered
  *         This parameter can be one of the following values:
  *           @arg @ref HAL_UART_TX_HALFCOMPLETE_CB_ID Tx Half Complete Callback ID
  *           @arg @ref HAL_UART_TX_COMPLETE_CB_ID Tx Complete Callback ID
  *           @arg @ref HAL_UART_RX_HALFCOMPLETE_CB_ID Rx Half Complete Callback ID
  *           @arg @ref HAL_UART_RX_COMPLETE_CB_ID Rx Complete Callback ID
  *           @arg @ref HAL_UART_ERROR_CB_ID Error Callback ID
  *           @arg @ref HAL_UART_ABORT_COMPLETE_CB_ID Abort Complete Callback ID
  *           @arg @ref HAL_UART_ABORT_TRANSMIT_COMPLETE_CB_ID Abort Transmit Complete Callback ID
  *           @arg @ref HAL_UART_ABORT_RECEIVE_COMPLETE_CB_ID Abort Receive Complete Callback ID
  *           @arg @ref HAL_UART_WAKEUP_CB_ID Wakeup Callback ID
  *           @arg @ref HAL_UART_MSPINIT_CB_ID MspInit Callback ID
  *           @arg @ref HAL_UART_MSPDEINIT_CB_ID MspDeInit Callback ID
  * @retval HAL status
  *//**
  * @brief  Register a User UART Callback
  *         To be used to override the weak predefined callback
  * @note   The HAL_UART_RegisterCallback() may be called before HAL_UART_Init(), HAL_HalfDuplex_Init(),
  *         HAL_LIN_Init(), HAL_MultiProcessor_Init() or HAL_RS485Ex_Init() in HAL_UART_STATE_RESET to register
  *         callbacks for HAL_UART_MSPINIT_CB_ID and HAL_UART_MSPDEINIT_CB_ID
  * @param  huart uart handle
  * @param  CallbackID ID of the callback to be registered
  *         This parameter can be one of the following values:
  *           @arg @ref HAL_UART_TX_HALFCOMPLETE_CB_ID Tx Half Complete Callback ID
  *           @arg @ref HAL_UART_TX_COMPLETE_CB_ID Tx Complete Callback ID
  *           @arg @ref HAL_UART_RX_HALFCOMPLETE_CB_ID Rx Half Complete Callback ID
  *           @arg @ref HAL_UART_RX_COMPLETE_CB_ID Rx Complete Callback ID
  *           @arg @ref HAL_UART_ERROR_CB_ID Error Callback ID
  *           @arg @ref HAL_UART_ABORT_COMPLETE_CB_ID Abort Complete Callback ID
  *           @arg @ref HAL_UART_ABORT_TRANSMIT_COMPLETE_CB_ID Abort Transmit Complete Callback ID
  *           @arg @ref HAL_UART_ABORT_RECEIVE_COMPLETE_CB_ID Abort Receive Complete Callback ID
  *           @arg @ref HAL_UART_WAKEUP_CB_ID Wakeup Callback ID
  *           @arg @ref HAL_UART_MSPINIT_CB_ID MspInit Callback ID
  *           @arg @ref HAL_UART_MSPDEINIT_CB_ID MspDeInit Callback ID
  * @param  pCallback pointer to the Callback function
  * @retval HAL status
  *//* NOTE : This function should not be modified, when the callback is needed,
            the HAL_UART_MspDeInit can be implemented in the user file
   *//**
  * @brief DeInitialize the UART MSP.
  * @param huart UART handle.
  * @retval None
  *//* NOTE : This function should not be modified, when the callback is needed,
            the HAL_UART_MspInit can be implemented in the user file
   *//**
  * @brief Initialize the UART MSP.
  * @param huart UART handle.
  * @retval None
  *//* Check the UART handle allocation *//**
  * @brief DeInitialize the UART peripheral.
  * @param huart UART handle.
  * @retval HAL status
  *//* TEACK and/or REACK to check before moving huart->gState and huart->RxState to Ready *//* Set the wake up method by setting the WAKE bit in the CR1 register *//* If address mark wake up method is chosen, set the USART address node *//* In multiprocessor mode, the following bits must be kept cleared:
  - LINEN and CLKEN bits in the USART_CR2 register,
  - SCEN, HDSEL and IREN  bits in the USART_CR3 register. *//* Set the UART Communication parameters *//* For some items, configuration requires to be done prior TE and RE bits are set *//* Perform advanced settings configuration *//* Init the low level hardware : GPIO, CLOCK *//* Check the wake up method parameter *//**
  * @brief Initialize the multiprocessor mode according to the specified
  *        parameters in the UART_InitTypeDef and initialize the associated handle.
  * @param huart        UART handle.
  * @param Address      UART node address (4-, 6-, 7- or 8-bit long).
  * @param WakeUpMethod Specifies the UART wakeup method.
  *        This parameter can be one of the following values:
  *          @arg @ref UART_WAKEUPMETHOD_IDLELINE WakeUp by an idle line detection
  *          @arg @ref UART_WAKEUPMETHOD_ADDRESSMARK WakeUp by an address mark
  * @note  If the user resorts to idle line detection wake up, the Address parameter
  *        is useless and ignored by the initialization function.
  * @note  If the user resorts to address mark wake up, the address length detection
  *        is configured by default to 4 bits only. For the UART to be able to
  *        manage 6-, 7- or 8-bit long addresses detection, the API
  *        HAL_MultiProcessorEx_AddressLength_Set() must be called after
  *        HAL_MultiProcessor_Init().
  * @retval HAL status
  *//* Set the USART LIN Break detection length. *//* Enable the LIN mode by setting the LINEN bit in the CR2 register *//* In LIN mode, the following bits must be kept cleared:
  - LINEN and CLKEN bits in the USART_CR2 register,
  - SCEN and IREN bits in the USART_CR3 register.*//* LIN mode limited to 8-bit data length *//* LIN mode limited to 16-bit oversampling only *//* Check the Break detection length parameter *//* Check the LIN UART instance *//**
  * @brief Initialize the LIN mode according to the specified
  *        parameters in the UART_InitTypeDef and creates the associated handle.
  * @param huart             UART handle.
  * @param BreakDetectLength Specifies the LIN break detection length.
  *        This parameter can be one of the following values:
  *          @arg @ref UART_LINBREAKDETECTLENGTH_10B 10-bit break detection
  *          @arg @ref UART_LINBREAKDETECTLENGTH_11B 11-bit break detection
  * @retval HAL status
  *//* Enable the Half-Duplex mode by setting the HDSEL bit in the CR3 register *//* In half-duplex mode, the following bits must be kept cleared:
  - LINEN and CLKEN bits in the USART_CR2 register,
  - SCEN and IREN bits in the USART_CR3 register.*//* Check UART instance *//**
  * @brief Initialize the half-duplex mode according to the specified
  *        parameters in the UART_InitTypeDef and creates the associated handle.
  * @param huart UART handle.
  * @retval HAL status
  *//* In asynchronous mode, the following bits must be kept cleared:
  - LINEN and CLKEN bits in the USART_CR2 register,
  - SCEN, HDSEL and IREN  bits in the USART_CR3 register.*//**
  * @brief Initialize the UART mode according to the specified
  *        parameters in the UART_InitTypeDef and initialize the associated handle.
  * @param huart UART handle.
  * @retval HAL status
  *//** @defgroup UART_Exported_Functions_Group1 Initialization and de-initialization functions
  *  @brief    Initialization and Configuration functions
  *
@verbatim
===============================================================================
            ##### Initialization and Configuration functions #####
 ===============================================================================
    [..]
    This subsection provides a set of functions allowing to initialize the USARTx or the UARTy
    in asynchronous mode.
      (+) For the asynchronous mode the parameters below can be configured:
        (++) Baud Rate
        (++) Word Length
        (++) Stop Bit
        (++) Parity: If the parity is enabled, then the MSB bit of the data written
             in the data register is transmitted but is changed by the parity bit.
        (++) Hardware flow control
        (++) Receiver/transmitter modes
        (++) Over Sampling Method
        (++) One-Bit Sampling Method
      (+) For the asynchronous mode, the following advanced features can be configured as well:
        (++) TX and/or RX pin level inversion
        (++) data logical level inversion
        (++) RX and TX pins swap
        (++) RX overrun detection disabling
        (++) DMA disabling on RX error
        (++) MSB first on communication line
        (++) auto Baud rate detection
    [..]
    The HAL_UART_Init(), HAL_HalfDuplex_Init(), HAL_LIN_Init()and HAL_MultiProcessor_Init()API
    follow respectively the UART asynchronous, UART Half duplex, UART LIN mode
    and UART multiprocessor mode configuration procedures (details for the procedures
    are available in reference manual).

@endverbatim

  Depending on the frame length defined by the M1 and M0 bits (7-bit,
  8-bit or 9-bit), the possible UART formats are listed in the
  following table.

  Table 1. UART frame format.
    +-----------------------------------------------------------------------+
    |  M1 bit |  M0 bit |  PCE bit  |             UART frame                |
    |---------|---------|-----------|---------------------------------------|
    |    0    |    0    |    0      |    | SB |    8 bit data   | STB |     |
    |---------|---------|-----------|---------------------------------------|
    |    0    |    0    |    1      |    | SB | 7 bit data | PB | STB |     |
    |---------|---------|-----------|---------------------------------------|
    |    0    |    1    |    0      |    | SB |    9 bit data   | STB |     |
    |---------|---------|-----------|---------------------------------------|
    |    0    |    1    |    1      |    | SB | 8 bit data | PB | STB |     |
    |---------|---------|-----------|---------------------------------------|
    |    1    |    0    |    0      |    | SB |    7 bit data   | STB |     |
    |---------|---------|-----------|---------------------------------------|
    |    1    |    0    |    1      |    | SB | 6 bit data | PB | STB |     |
    +-----------------------------------------------------------------------+

  * @{
  *//** @defgroup UART_Exported_Functions UART Exported Functions
  * @{
  *//* Exported Constants --------------------------------------------------------*//** @addtogroup UART_Private_Functions
  * @{
  *//* UART BRR maximum authorized value *//* UART BRR minimum authorized value *//*!< UART or USART CR3 fields of parameters set by UART_SetConfig API *//*!< UART or USART CR1 fields of parameters set by UART_SetConfig API *//** @defgroup UART_Private_Constants UART Private Constants
  * @{
  *//** @defgroup UART UART
  * @brief HAL UART module driver
  * @{
  *//**
  ******************************************************************************
  * @file    stm32f7xx_hal_uart.c
  * @author  MCD Application Team
  * @brief   UART HAL module driver.
  *          This file provides firmware functions to manage the following
  *          functionalities of the Universal Asynchronous Receiver Transmitter Peripheral (UART).
  *           + Initialization and de-initialization functions
  *           + IO operation functions
  *           + Peripheral Control functions
  *
  *
  ******************************************************************************
  * @attention
  *
  * Copyright (c) 2017 STMicroelectronics.
  * All rights reserved.
  *
  * This software is licensed under terms that can be found in the LICENSE file
  * in the root directory of this software component.
  * If no LICENSE file comes with this software, it is provided AS-IS.
  *
  ******************************************************************************
  @verbatim
 ===============================================================================
                        ##### How to use this driver #####
 ===============================================================================
  [..]
    The UART HAL driver can be used as follows:

    (#) Declare a UART_HandleTypeDef handle structure (eg. UART_HandleTypeDef huart).
    (#) Initialize the UART low level resources by implementing the HAL_UART_MspInit() API:
        (++) Enable the USARTx interface clock.
        (++) UART pins configuration:
            (+++) Enable the clock for the UART GPIOs.
            (+++) Configure these UART pins as alternate function pull-up.
        (++) NVIC configuration if you need to use interrupt process (HAL_UART_Transmit_IT()
             and HAL_UART_Receive_IT() APIs):
            (+++) Configure the USARTx interrupt priority.
            (+++) Enable the NVIC USART IRQ handle.
        (++) UART interrupts handling:
              -@@-  The specific UART interrupts (Transmission complete interrupt,
                RXNE interrupt, RX/TX FIFOs related interrupts and Error Interrupts)
                are managed using the macros __HAL_UART_ENABLE_IT() and __HAL_UART_DISABLE_IT()
                inside the transmit and receive processes.
        (++) DMA Configuration if you need to use DMA process (HAL_UART_Transmit_DMA()
             and HAL_UART_Receive_DMA() APIs):
            (+++) Declare a DMA handle structure for the Tx/Rx channel.
            (+++) Enable the DMAx interface clock.
            (+++) Configure the declared DMA handle structure with the required Tx/Rx parameters.
            (+++) Configure the DMA Tx/Rx channel.
            (+++) Associate the initialized DMA handle to the UART DMA Tx/Rx handle.
            (+++) Configure the priority and enable the NVIC for the transfer complete
                  interrupt on the DMA Tx/Rx channel.

    (#) Program the Baud Rate, Word Length, Stop Bit, Parity, Hardware
        flow control and Mode (Receiver/Transmitter) in the huart handle Init structure.

    (#) If required, program UART advanced features (TX/RX pins swap, auto Baud rate detection,...)
        in the huart handle AdvancedInit structure.

    (#) For the UART asynchronous mode, initialize the UART registers by calling
        the HAL_UART_Init() API.

    (#) For the UART Half duplex mode, initialize the UART registers by calling
        the HAL_HalfDuplex_Init() API.

    (#) For the UART LIN (Local Interconnection Network) mode, initialize the UART registers
        by calling the HAL_LIN_Init() API.

    (#) For the UART Multiprocessor mode, initialize the UART registers
        by calling the HAL_MultiProcessor_Init() API.

    (#) For the UART RS485 Driver Enabled mode, initialize the UART registers
        by calling the HAL_RS485Ex_Init() API.

    [..]
    (@) These API's (HAL_UART_Init(), HAL_HalfDuplex_Init(), HAL_LIN_Init(), HAL_MultiProcessor_Init(),
        also configure the low level Hardware GPIO, CLOCK, CORTEX...etc) by
        calling the customized HAL_UART_MspInit() API.

    ##### Callback registration #####
    ==================================

    [..]
    The compilation define USE_HAL_UART_REGISTER_CALLBACKS when set to 1
    allows the user to configure dynamically the driver callbacks.

    [..]
    Use Function HAL_UART_RegisterCallback() to register a user callback.
    Function HAL_UART_RegisterCallback() allows to register following callbacks:
    (+) TxHalfCpltCallback        : Tx Half Complete Callback.
    (+) TxCpltCallback            : Tx Complete Callback.
    (+) RxHalfCpltCallback        : Rx Half Complete Callback.
    (+) RxCpltCallback            : Rx Complete Callback.
    (+) ErrorCallback             : Error Callback.
    (+) AbortCpltCallback         : Abort Complete Callback.
    (+) AbortTransmitCpltCallback : Abort Transmit Complete Callback.
    (+) AbortReceiveCpltCallback  : Abort Receive Complete Callback.
    (+) WakeupCallback            : Wakeup Callback.
    (+) MspInitCallback           : UART MspInit.
    (+) MspDeInitCallback         : UART MspDeInit.
    This function takes as parameters the HAL peripheral handle, the Callback ID
    and a pointer to the user callback function.

    [..]
    Use function HAL_UART_UnRegisterCallback() to reset a callback to the default
    weak function.
    HAL_UART_UnRegisterCallback() takes as parameters the HAL peripheral handle,
    and the Callback ID.
    This function allows to reset following callbacks:
    (+) TxHalfCpltCallback        : Tx Half Complete Callback.
    (+) TxCpltCallback            : Tx Complete Callback.
    (+) RxHalfCpltCallback        : Rx Half Complete Callback.
    (+) RxCpltCallback            : Rx Complete Callback.
    (+) ErrorCallback             : Error Callback.
    (+) AbortCpltCallback         : Abort Complete Callback.
    (+) AbortTransmitCpltCallback : Abort Transmit Complete Callback.
    (+) AbortReceiveCpltCallback  : Abort Receive Complete Callback.
    (+) WakeupCallback            : Wakeup Callback.
    (+) MspInitCallback           : UART MspInit.
    (+) MspDeInitCallback         : UART MspDeInit.

    [..]
    For specific callback RxEventCallback, use dedicated registration/reset functions:
    respectively HAL_UART_RegisterRxEventCallback() , HAL_UART_UnRegisterRxEventCallback().

    [..]
    By default, after the HAL_UART_Init() and when the state is HAL_UART_STATE_RESET
    all callbacks are set to the corresponding weak functions:
    examples HAL_UART_TxCpltCallback(), HAL_UART_RxHalfCpltCallback().
    Exception done for MspInit and MspDeInit functions that are respectively
    reset to the legacy weak functions in the HAL_UART_Init()
    and HAL_UART_DeInit() only when these callbacks are null (not registered beforehand).
    If not, MspInit or MspDeInit are not null, the HAL_UART_Init() and HAL_UART_DeInit()
    keep and use the user MspInit/MspDeInit callbacks (registered beforehand).

    [..]
    Callbacks can be registered/unregistered in HAL_UART_STATE_READY state only.
    Exception done MspInit/MspDeInit that can be registered/unregistered
    in HAL_UART_STATE_READY or HAL_UART_STATE_RESET state, thus registered (user)
    MspInit/DeInit callbacks can be used during the Init/DeInit.
    In that case first register the MspInit/MspDeInit user callbacks
    using HAL_UART_RegisterCallback() before calling HAL_UART_DeInit()
    or HAL_UART_Init() function.

    [..]
    When The compilation define USE_HAL_UART_REGISTER_CALLBACKS is set to 0 or
    not defined, the callback registration feature is not available
    and weak callbacks are used.


  @endverbatim
  ******************************************************************************
  *//Users/jie/Documents/posixGen_Demos-main/LwIP_StreamingServer/Drivers/STM32F7xx_HAL_Driver/Src/stm32f7xx_ll_fmc.cIS_FMC_SDRAM_DEVICE(Device)IS_FMC_SDRAM_BANK(Bank)IS_FMC_AUTOREFRESH_NUMBER(AutoRefreshNumber)Device->SDCMR(0xFUL << (5U))((AutoRefreshNumber - 1U) << FMC_SDCMR_NRFS_Pos)((AutoRefreshNumber - 1U) << (5U))(Device->SDCMR)(((READ_REG(Device->SDCMR)) & (~((0xFUL << (5U))))) | (((AutoRefreshNumber - 1U) << (5U))))(((((Device->SDCMR))) & (~((0xFUL << (5U))))) | (((AutoRefreshNumber - 1U) << (5U))))IS_FMC_REFRESH_RATE(RefreshRate)Device->SDRTR(0x1FFFUL << (1U))(RefreshRate << FMC_SDRTR_COUNT_Pos)(RefreshRate << (1U))(Device->SDRTR)(((READ_REG(Device->SDRTR)) & (~((0x1FFFUL << (1U))))) | ((RefreshRate << (1U))))(((((Device->SDRTR))) & (~((0x1FFFUL << (1U))))) | ((RefreshRate << (1U))))163824294950913IS_FMC_COMMAND_MODE(Command->CommandMode)IS_FMC_COMMAND_TARGET(Command->CommandTarget)IS_FMC_AUTOREFRESH_NUMBER(Command->AutoRefreshNumber)IS_FMC_MODE_REGISTER(Command->ModeRegisterDefinition)(FMC_SDCMR_MODE | FMC_SDCMR_CTB2 | FMC_SDCMR_CTB1 | FMC_SDCMR_NRFS | FMC_SDCMR_MRD)((0x7UL << (0U)) | (0x1UL << (3U)) | (0x1UL << (4U)) | (0xFUL << (5U)) | (0x1FFFUL << (9U)))((Command->CommandMode) | (Command->CommandTarget) | (((Command->AutoRefreshNumber) - 1U) << FMC_SDCMR_NRFS_Pos) | ((Command->ModeRegisterDefinition) << FMC_SDCMR_MRD_Pos))((Command->CommandMode) | (Command->CommandTarget) | (((Command->AutoRefreshNumber) - 1U) << (5U)) | ((Command->ModeRegisterDefinition) << (9U)))(((READ_REG(Device->SDCMR)) & (~(((0x7UL << (0U)) | (0x1UL << (3U)) | (0x1UL << (4U)) | (0xFUL << (5U)) | (0x1FFFUL << (9U)))))) | (((Command->CommandMode) | (Command->CommandTarget) | (((Command->AutoRefreshNumber) - 1U) << (5U)) | ((Command->ModeRegisterDefinition) << (9U)))))(((((Device->SDCMR))) & (~(((0x7UL << (0U)) | (0x1UL << (3U)) | (0x1UL << (4U)) | (0xFUL << (5U)) | (0x1FFFUL << (9U)))))) | (((Command->CommandMode) | (Command->CommandTarget) | (((Command->AutoRefreshNumber) - 1U) << (5U)) | ((Command->ModeRegisterDefinition) << (9U)))))419379241943034290772992Device->SDCR[Bank]7200x000002D0U0x0FFFFFFFUIS_FMC_LOADTOACTIVE_DELAY(Timing->LoadToActiveDelay)IS_FMC_EXITSELFREFRESH_DELAY(Timing->ExitSelfRefreshDelay)IS_FMC_SELFREFRESH_TIME(Timing->SelfRefreshTime)IS_FMC_ROWCYCLE_DELAY(Timing->RowCycleDelay)IS_FMC_WRITE_RECOVERY_TIME(Timing->WriteRecoveryTime)IS_FMC_RP_DELAY(Timing->RPDelay)IS_FMC_RCD_DELAY(Timing->RCDDelay)Device->SDTR[FMC_SDRAM_BANK1]Device->SDTR[(0x00000000U)]SDTR_CLEAR_MASK((uint32_t)((0xFUL << (0U)) | (0xFUL << (4U)) | (0xFUL << (8U)) | (0xFUL << (12U)) | (0xFUL << (16U)) | (0xFUL << (20U)) | (0xFUL << (24U))))(((Timing->LoadToActiveDelay) - 1U) | (((Timing->ExitSelfRefreshDelay) - 1U) << FMC_SDTR1_TXSR_Pos) | (((Timing->SelfRefreshTime) - 1U) << FMC_SDTR1_TRAS_Pos) | (((Timing->RowCycleDelay) - 1U) << FMC_SDTR1_TRC_Pos) | (((Timing->WriteRecoveryTime) - 1U) << FMC_SDTR1_TWR_Pos) | (((Timing->RPDelay) - 1U) << FMC_SDTR1_TRP_Pos) | (((Timing->RCDDelay) - 1U) << FMC_SDTR1_TRCD_Pos))(((Timing->LoadToActiveDelay) - 1U) | (((Timing->ExitSelfRefreshDelay) - 1U) << (4U)) | (((Timing->SelfRefreshTime) - 1U) << (8U)) | (((Timing->RowCycleDelay) - 1U) << (12U)) | (((Timing->WriteRecoveryTime) - 1U) << (16U)) | (((Timing->RPDelay) - 1U) << (20U)) | (((Timing->RCDDelay) - 1U) << (24U)))(Device->SDTR[(0x00000000U)])(((READ_REG(Device->SDTR[(0x00000000U)])) & (~(((uint32_t)((0xFUL << (0U)) | (0xFUL << (4U)) | (0xFUL << (8U)) | (0xFUL << (12U)) | (0xFUL << (16U)) | (0xFUL << (20U)) | (0xFUL << (24U))))))) | ((((Timing->LoadToActiveDelay) - 1U) | (((Timing->ExitSelfRefreshDelay) - 1U) << (4U)) | (((Timing->SelfRefreshTime) - 1U) << (8U)) | (((Timing->RowCycleDelay) - 1U) << (12U)) | (((Timing->WriteRecoveryTime) - 1U) << (16U)) | (((Timing->RPDelay) - 1U) << (20U)) | (((Timing->RCDDelay) - 1U) << (24U)))))(((((Device->SDTR[(0x00000000U)]))) & (~(((uint32_t)((0xFUL << (0U)) | (0xFUL << (4U)) | (0xFUL << (8U)) | (0xFUL << (12U)) | (0xFUL << (16U)) | (0xFUL << (20U)) | (0xFUL << (24U))))))) | ((((Timing->LoadToActiveDelay) - 1U) | (((Timing->ExitSelfRefreshDelay) - 1U) << (4U)) | (((Timing->SelfRefreshTime) - 1U) << (8U)) | (((Timing->RowCycleDelay) - 1U) << (12U)) | (((Timing->WriteRecoveryTime) - 1U) << (16U)) | (((Timing->RPDelay) - 1U) << (20U)) | (((Timing->RCDDelay) - 1U) << (24U)))))FMC_SDTR1_TRC | FMC_SDTR1_TRP(0xFUL << (12U)) | (0xFUL << (20U))(((Timing->RowCycleDelay) - 1U) << FMC_SDTR1_TRC_Pos) | (((Timing->RPDelay) - 1U) << FMC_SDTR1_TRP_Pos)(((Timing->RowCycleDelay) - 1U) << (12U)) | (((Timing->RPDelay) - 1U) << (20U))(((READ_REG(Device->SDTR[(0x00000000U)])) & (~((0xFUL << (12U)) | (0xFUL << (20U))))) | ((((Timing->RowCycleDelay) - 1U) << (12U)) | (((Timing->RPDelay) - 1U) << (20U))))(((((Device->SDTR[(0x00000000U)]))) & (~((0xFUL << (12U)) | (0xFUL << (20U))))) | ((((Timing->RowCycleDelay) - 1U) << (12U)) | (((Timing->RPDelay) - 1U) << (20U))))Device->SDTR[FMC_SDRAM_BANK2]Device->SDTR[(0x00000001U)](((Timing->LoadToActiveDelay) - 1U) | (((Timing->ExitSelfRefreshDelay) - 1U) << FMC_SDTR1_TXSR_Pos) | (((Timing->SelfRefreshTime) - 1U) << FMC_SDTR1_TRAS_Pos) | (((Timing->WriteRecoveryTime) - 1U) << FMC_SDTR1_TWR_Pos) | (((Timing->RCDDelay) - 1U) << FMC_SDTR1_TRCD_Pos))(((Timing->LoadToActiveDelay) - 1U) | (((Timing->ExitSelfRefreshDelay) - 1U) << (4U)) | (((Timing->SelfRefreshTime) - 1U) << (8U)) | (((Timing->WriteRecoveryTime) - 1U) << (16U)) | (((Timing->RCDDelay) - 1U) << (24U)))(Device->SDTR[(0x00000001U)])(((READ_REG(Device->SDTR[(0x00000001U)])) & (~(((uint32_t)((0xFUL << (0U)) | (0xFUL << (4U)) | (0xFUL << (8U)) | (0xFUL << (12U)) | (0xFUL << (16U)) | (0xFUL << (20U)) | (0xFUL << (24U))))))) | ((((Timing->LoadToActiveDelay) - 1U) | (((Timing->ExitSelfRefreshDelay) - 1U) << (4U)) | (((Timing->SelfRefreshTime) - 1U) << (8U)) | (((Timing->WriteRecoveryTime) - 1U) << (16U)) | (((Timing->RCDDelay) - 1U) << (24U)))))(((((Device->SDTR[(0x00000001U)]))) & (~(((uint32_t)((0xFUL << (0U)) | (0xFUL << (4U)) | (0xFUL << (8U)) | (0xFUL << (12U)) | (0xFUL << (16U)) | (0xFUL << (20U)) | (0xFUL << (24U))))))) | ((((Timing->LoadToActiveDelay) - 1U) | (((Timing->ExitSelfRefreshDelay) - 1U) << (4U)) | (((Timing->SelfRefreshTime) - 1U) << (8U)) | (((Timing->WriteRecoveryTime) - 1U) << (16U)) | (((Timing->RCDDelay) - 1U) << (24U)))))1048575157900804279177215IS_FMC_SDRAM_BANK(Init->SDBank)IS_FMC_COLUMNBITS_NUMBER(Init->ColumnBitsNumber)IS_FMC_ROWBITS_NUMBER(Init->RowBitsNumber)IS_FMC_SDMEMORY_WIDTH(Init->MemoryDataWidth)IS_FMC_INTERNALBANK_NUMBER(Init->InternalBankNumber)IS_FMC_CAS_LATENCY(Init->CASLatency)IS_FMC_WRITE_PROTECTION(Init->WriteProtection)IS_FMC_SDCLOCK_PERIOD(Init->SDClockPeriod)IS_FMC_READ_BURST(Init->ReadBurst)IS_FMC_READPIPE_DELAY(Init->ReadPipeDelay)Device->SDCR[FMC_SDRAM_BANK1]Device->SDCR[(0x00000000U)]SDCR_CLEAR_MASK((uint32_t)((0x3UL << (0U)) | (0x3UL << (2U)) | (0x3UL << (4U)) | (0x1UL << (6U)) | (0x3UL << (7U)) | (0x1UL << (9U)) | (0x3UL << (10U)) | (0x1UL << (12U)) | (0x3UL << (13U))))(Init->ColumnBitsNumber | Init->RowBitsNumber | Init->MemoryDataWidth | Init->InternalBankNumber | Init->CASLatency | Init->WriteProtection | Init->SDClockPeriod | Init->ReadBurst | Init->ReadPipeDelay)(Device->SDCR[(0x00000000U)])(((READ_REG(Device->SDCR[(0x00000000U)])) & (~(((uint32_t)((0x3UL << (0U)) | (0x3UL << (2U)) | (0x3UL << (4U)) | (0x1UL << (6U)) | (0x3UL << (7U)) | (0x1UL << (9U)) | (0x3UL << (10U)) | (0x1UL << (12U)) | (0x3UL << (13U))))))) | ((Init->ColumnBitsNumber | Init->RowBitsNumber | Init->MemoryDataWidth | Init->InternalBankNumber | Init->CASLatency | Init->WriteProtection | Init->SDClockPeriod | Init->ReadBurst | Init->ReadPipeDelay)))(((((Device->SDCR[(0x00000000U)]))) & (~(((uint32_t)((0x3UL << (0U)) | (0x3UL << (2U)) | (0x3UL << (4U)) | (0x1UL << (6U)) | (0x3UL << (7U)) | (0x1UL << (9U)) | (0x3UL << (10U)) | (0x1UL << (12U)) | (0x3UL << (13U))))))) | ((Init->ColumnBitsNumber | Init->RowBitsNumber | Init->MemoryDataWidth | Init->InternalBankNumber | Init->CASLatency | Init->WriteProtection | Init->SDClockPeriod | Init->ReadBurst | Init->ReadPipeDelay)))FMC_SDCR1_SDCLK | FMC_SDCR1_RBURST | FMC_SDCR1_RPIPE(0x3UL << (10U)) | (0x1UL << (12U)) | (0x3UL << (13U))(Init->SDClockPeriod | Init->ReadBurst | Init->ReadPipeDelay)(((READ_REG(Device->SDCR[(0x00000000U)])) & (~((0x3UL << (10U)) | (0x1UL << (12U)) | (0x3UL << (13U))))) | ((Init->SDClockPeriod | Init->ReadBurst | Init->ReadPipeDelay)))(((((Device->SDCR[(0x00000000U)]))) & (~((0x3UL << (10U)) | (0x1UL << (12U)) | (0x3UL << (13U))))) | ((Init->SDClockPeriod | Init->ReadBurst | Init->ReadPipeDelay)))Device->SDCR[FMC_SDRAM_BANK2]Device->SDCR[(0x00000001U)](Init->ColumnBitsNumber | Init->RowBitsNumber | Init->MemoryDataWidth | Init->InternalBankNumber | Init->CASLatency | Init->WriteProtection)(Device->SDCR[(0x00000001U)])(((READ_REG(Device->SDCR[(0x00000001U)])) & (~(((uint32_t)((0x3UL << (0U)) | (0x3UL << (2U)) | (0x3UL << (4U)) | (0x1UL << (6U)) | (0x3UL << (7U)) | (0x1UL << (9U)) | (0x3UL << (10U)) | (0x1UL << (12U)) | (0x3UL << (13U))))))) | ((Init->ColumnBitsNumber | Init->RowBitsNumber | Init->MemoryDataWidth | Init->InternalBankNumber | Init->CASLatency | Init->WriteProtection)))(((((Device->SDCR[(0x00000001U)]))) & (~(((uint32_t)((0x3UL << (0U)) | (0x3UL << (2U)) | (0x3UL << (4U)) | (0x1UL << (6U)) | (0x3UL << (7U)) | (0x1UL << (9U)) | (0x3UL << (10U)) | (0x1UL << (12U)) | (0x3UL << (13U))))))) | ((Init->ColumnBitsNumber | Init->RowBitsNumber | Init->MemoryDataWidth | Init->InternalBankNumber | Init->CASLatency | Init->WriteProtection)))4294935551IS_FMC_NAND_DEVICE(Device)IS_FMC_NAND_BANK(Bank)Device->PCR(Device)->PCRDevice->SRDevice->PMEM0xFCFCFCFCU4244438268Device->PATTIS_FMC_SETUP_TIME(Timing->SetupTime)IS_FMC_WAIT_TIME(Timing->WaitSetupTime)IS_FMC_HOLD_TIME(Timing->HoldSetupTime)IS_FMC_HIZ_TIME(Timing->HiZSetupTime)PATT_CLEAR_MASK((uint32_t)((0xFFUL << (0U)) | (0xFFUL << (8U)) | (0xFFUL << (16U)) | (0xFFUL << (24U))))(Timing->SetupTime | ((Timing->WaitSetupTime) << FMC_PATT_ATTWAIT3_Pos) | ((Timing->HoldSetupTime) << FMC_PATT_ATTHOLD3_Pos) | ((Timing->HiZSetupTime) << FMC_PATT_ATTHIZ3_Pos))(Timing->SetupTime | ((Timing->WaitSetupTime) << (8U)) | ((Timing->HoldSetupTime) << (16U)) | ((Timing->HiZSetupTime) << (24U)))(Device->PATT)(((READ_REG(Device->PATT)) & (~(((uint32_t)((0xFFUL << (0U)) | (0xFFUL << (8U)) | (0xFFUL << (16U)) | (0xFFUL << (24U))))))) | ((Timing->SetupTime | ((Timing->WaitSetupTime) << (8U)) | ((Timing->HoldSetupTime) << (16U)) | ((Timing->HiZSetupTime) << (24U)))))(((((Device->PATT))) & (~(((uint32_t)((0xFFUL << (0U)) | (0xFFUL << (8U)) | (0xFFUL << (16U)) | (0xFFUL << (24U))))))) | ((Timing->SetupTime | ((Timing->WaitSetupTime) << (8U)) | ((Timing->HoldSetupTime) << (16U)) | ((Timing->HiZSetupTime) << (24U)))))PMEM_CLEAR_MASK(Timing->SetupTime | ((Timing->WaitSetupTime) << FMC_PMEM_MEMWAIT3_Pos) | ((Timing->HoldSetupTime) << FMC_PMEM_MEMHOLD3_Pos) | ((Timing->HiZSetupTime) << FMC_PMEM_MEMHIZ3_Pos))(Device->PMEM)(((READ_REG(Device->PMEM)) & (~(((uint32_t)((0xFFUL << (0U)) | (0xFFUL << (8U)) | (0xFFUL << (16U)) | (0xFFUL << (24U))))))) | ((Timing->SetupTime | ((Timing->WaitSetupTime) << (8U)) | ((Timing->HoldSetupTime) << (16U)) | ((Timing->HiZSetupTime) << (24U)))))(((((Device->PMEM))) & (~(((uint32_t)((0xFFUL << (0U)) | (0xFFUL << (8U)) | (0xFFUL << (16U)) | (0xFFUL << (24U))))))) | ((Timing->SetupTime | ((Timing->WaitSetupTime) << (8U)) | ((Timing->HoldSetupTime) << (16U)) | ((Timing->HiZSetupTime) << (24U)))))IS_FMC_NAND_BANK(Init->NandBank)IS_FMC_WAIT_FEATURE(Init->Waitfeature)IS_FMC_NAND_MEMORY_WIDTH(Init->MemoryDataWidth)IS_FMC_ECC_STATE(Init->EccComputation)IS_FMC_ECCPAGE_SIZE(Init->ECCPageSize)IS_FMC_TCLR_TIME(Init->TCLRSetupTime)IS_FMC_TAR_TIME(Init->TARSetupTime)PCR_CLEAR_MASK((uint32_t)((0x1UL << (1U)) | (0x1UL << (2U)) | (0x1UL << (3U)) | (0x3UL << (4U)) | (0x1UL << (6U)) | (0xFUL << (9U)) | (0xFUL << (13U)) | (0x7UL << (17U))))(Init->Waitfeature | FMC_PCR_MEMORY_TYPE_NAND | Init->MemoryDataWidth | Init->EccComputation | Init->ECCPageSize | ((Init->TCLRSetupTime) << FMC_PCR_TCLR_Pos) | ((Init->TARSetupTime) << FMC_PCR_TAR_Pos))(Init->Waitfeature | (0x00000008U) | Init->MemoryDataWidth | Init->EccComputation | Init->ECCPageSize | ((Init->TCLRSetupTime) << (9U)) | ((Init->TARSetupTime) << (13U)))(Device->PCR)(((READ_REG(Device->PCR)) & (~(((uint32_t)((0x1UL << (1U)) | (0x1UL << (2U)) | (0x1UL << (3U)) | (0x3UL << (4U)) | (0x1UL << (6U)) | (0xFUL << (9U)) | (0xFUL << (13U)) | (0x7UL << (17U))))))) | ((Init->Waitfeature | (0x00000008U) | Init->MemoryDataWidth | Init->EccComputation | Init->ECCPageSize | ((Init->TCLRSetupTime) << (9U)) | ((Init->TARSetupTime) << (13U)))))(((((Device->PCR))) & (~(((uint32_t)((0x1UL << (1U)) | (0x1UL << (2U)) | (0x1UL << (3U)) | (0x3UL << (4U)) | (0x1UL << (6U)) | (0xFUL << (9U)) | (0xFUL << (13U)) | (0x7UL << (17U))))))) | ((Init->Waitfeature | (0x00000008U) | Init->MemoryDataWidth | Init->EccComputation | Init->ECCPageSize | ((Init->TCLRSetupTime) << (9U)) | ((Init->TARSetupTime) << (13U)))))7680780612288013068610481904293919105IS_FMC_NORSRAM_DEVICE(Device)IS_FMC_NORSRAM_BANK(Bank)Device->BTCR[Bank]IS_FMC_EXTENDED_MODE(ExtendedMode)IS_FMC_NORSRAM_EXTENDED_DEVICE(Device)IS_FMC_ADDRESS_SETUP_TIME(Timing->AddressSetupTime)IS_FMC_ADDRESS_HOLD_TIME(Timing->AddressHoldTime)IS_FMC_DATASETUP_TIME(Timing->DataSetupTime)IS_FMC_TURNAROUND_TIME(Timing->BusTurnAroundDuration)IS_FMC_ACCESS_MODE(Timing->AccessMode)Device->BWTR[Bank]BWTR_CLEAR_MASK((uint32_t)((0xFUL << (0U)) | (0xFUL << (4U)) | (0xFFUL << (8U)) | (0xFUL << (16U)) | (0x3UL << (28U))))(Timing->AddressSetupTime | ((Timing->AddressHoldTime) << FMC_BWTR1_ADDHLD_Pos) | ((Timing->DataSetupTime) << FMC_BWTR1_DATAST_Pos) | Timing->AccessMode | ((Timing->BusTurnAroundDuration) << FMC_BWTR1_BUSTURN_Pos))(Timing->AddressSetupTime | ((Timing->AddressHoldTime) << (4U)) | ((Timing->DataSetupTime) << (8U)) | Timing->AccessMode | ((Timing->BusTurnAroundDuration) << (16U)))(Device->BWTR[Bank])(((READ_REG(Device->BWTR[Bank])) & (~(((uint32_t)((0xFUL << (0U)) | (0xFUL << (4U)) | (0xFFUL << (8U)) | (0xFUL << (16U)) | (0x3UL << (28U))))))) | ((Timing->AddressSetupTime | ((Timing->AddressHoldTime) << (4U)) | ((Timing->DataSetupTime) << (8U)) | Timing->AccessMode | ((Timing->BusTurnAroundDuration) << (16U)))))(((((Device->BWTR[Bank]))) & (~(((uint32_t)((0xFUL << (0U)) | (0xFUL << (4U)) | (0xFFUL << (8U)) | (0xFUL << (16U)) | (0x3UL << (28U))))))) | ((Timing->AddressSetupTime | ((Timing->AddressHoldTime) << (4U)) | ((Timing->DataSetupTime) << (8U)) | Timing->AccessMode | ((Timing->BusTurnAroundDuration) << (16U)))))8063549433488612352tmprIS_FMC_CLK_DIV(Timing->CLKDivision)IS_FMC_DATA_LATENCY(Timing->DataLatency)Device->BTCR[Bank + 1U]BTR_CLEAR_MASK((uint32_t)((0xFUL << (0U)) | (0xFUL << (4U)) | (0xFFUL << (8U)) | (0xFUL << (16U)) | (0xFUL << (20U)) | (0xFUL << (24U)) | (0x3UL << (28U))))(Timing->AddressSetupTime | ((Timing->AddressHoldTime) << FMC_BTR1_ADDHLD_Pos) | ((Timing->DataSetupTime) << FMC_BTR1_DATAST_Pos) | ((Timing->BusTurnAroundDuration) << FMC_BTR1_BUSTURN_Pos) | (((Timing->CLKDivision) - 1U) << FMC_BTR1_CLKDIV_Pos) | (((Timing->DataLatency) - 2U) << FMC_BTR1_DATLAT_Pos) | (Timing->AccessMode))(Timing->AddressSetupTime | ((Timing->AddressHoldTime) << (4U)) | ((Timing->DataSetupTime) << (8U)) | ((Timing->BusTurnAroundDuration) << (16U)) | (((Timing->CLKDivision) - 1U) << (20U)) | (((Timing->DataLatency) - 2U) << (24U)) | (Timing->AccessMode))(Device->BTCR[Bank + 1U])(((READ_REG(Device->BTCR[Bank + 1U])) & (~(((uint32_t)((0xFUL << (0U)) | (0xFUL << (4U)) | (0xFFUL << (8U)) | (0xFUL << (16U)) | (0xFUL << (20U)) | (0xFUL << (24U)) | (0x3UL << (28U))))))) | ((Timing->AddressSetupTime | ((Timing->AddressHoldTime) << (4U)) | ((Timing->DataSetupTime) << (8U)) | ((Timing->BusTurnAroundDuration) << (16U)) | (((Timing->CLKDivision) - 1U) << (20U)) | (((Timing->DataLatency) - 2U) << (24U)) | (Timing->AccessMode))))(((((Device->BTCR[Bank + 1U]))) & (~(((uint32_t)((0xFUL << (0U)) | (0xFUL << (4U)) | (0xFFUL << (8U)) | (0xFUL << (16U)) | (0xFUL << (20U)) | (0xFUL << (24U)) | (0x3UL << (28U))))))) | ((Timing->AddressSetupTime | ((Timing->AddressHoldTime) << (4U)) | ((Timing->DataSetupTime) << (8U)) | ((Timing->BusTurnAroundDuration) << (16U)) | (((Timing->CLKDivision) - 1U) << (20U)) | (((Timing->DataLatency) - 2U) << (24U)) | (Timing->AccessMode))))Device->BTCR[FMC_NORSRAM_BANK1]Device->BTCR[(0x00000000U)]Device->BTCR[FMC_NORSRAM_BANK1 + 1U]Device->BTCR[(0x00000000U) + 1U](Device->BTCR[(0x00000000U) + 1U])(((READ_REG(Device->BTCR[(0x00000000U) + 1U])) & (~((0xFUL << (20U))))) | (tmpr))(((((Device->BTCR[(0x00000000U) + 1U]))) & (~((0xFUL << (20U))))) | (tmpr))(0x0FU)(0x0FU) << FMC_BTR1_CLKDIV_Pos((0x0FU) << FMC_BTR1_CLKDIV_Pos)~((0x0FU) << FMC_BTR1_CLKDIV_Pos)IS_FMC_NORSRAM_EXTENDED_DEVICE(ExDevice)125070x000030DBU124980x000030D2Uflashaccessbtcr_regmaskIS_FMC_NORSRAM_BANK(Init->NSBank)IS_FMC_MUX(Init->DataAddressMux)IS_FMC_MEMORY(Init->MemoryType)IS_FMC_NORSRAM_MEMORY_WIDTH(Init->MemoryDataWidth)IS_FMC_BURSTMODE(Init->BurstAccessMode)IS_FMC_WAIT_POLARITY(Init->WaitSignalPolarity)IS_FMC_WAIT_SIGNAL_ACTIVE(Init->WaitSignalActive)IS_FMC_WRITE_OPERATION(Init->WriteOperation)IS_FMC_WAITE_SIGNAL(Init->WaitSignal)IS_FMC_EXTENDED_MODE(Init->ExtendedMode)IS_FMC_ASYNWAIT(Init->AsynchronousWait)IS_FMC_WRITE_BURST(Init->WriteBurst)IS_FMC_CONTINOUS_CLOCK(Init->ContinuousClock)IS_FMC_WRITE_FIFO(Init->WriteFifo)IS_FMC_PAGESIZE(Init->PageSize)Init->NSBank38389529437039152313161564383588671(FMC_BCR1_MBKEN                |
          FMC_BCR1_MUXEN                |
          FMC_BCR1_MTYP                 |
          FMC_BCR1_MWID                 |
          FMC_BCR1_FACCEN               |
          FMC_BCR1_BURSTEN              |
          FMC_BCR1_WAITPOL              |
          FMC_BCR1_WAITCFG              |
          FMC_BCR1_WREN                 |
          FMC_BCR1_WAITEN               |
          FMC_BCR1_EXTMOD               |
          FMC_BCR1_ASYNCWAIT            |
          FMC_BCR1_CBURSTRW)Device->BTCR[Init->NSBank](Device->BTCR[Init->NSBank])(((READ_REG(Device->BTCR[Init->NSBank])) & (~(mask))) | (btcr_reg))(((((Device->BTCR[Init->NSBank]))) & (~(mask))) | (btcr_reg))Init->ContinuousClock(Device->BTCR[(0x00000000U)])(((READ_REG(Device->BTCR[(0x00000000U)])) & (~((0x1UL << (20U))))) | (Init->ContinuousClock))(((((Device->BTCR[(0x00000000U)]))) & (~((0x1UL << (20U))))) | (Init->ContinuousClock))(uint32_t)(Init->WriteFifo)((uint32_t)(FMC_SDTR1_TMRD | FMC_SDTR1_TXSR | FMC_SDTR1_TRAS | FMC_SDTR1_TRC | FMC_SDTR1_TWR | FMC_SDTR1_TRP | FMC_SDTR1_TRCD))((uint32_t)(FMC_SDCR1_NC | FMC_SDCR1_NR | FMC_SDCR1_MWID | FMC_SDCR1_NB | FMC_SDCR1_CAS | FMC_SDCR1_WP | FMC_SDCR1_SDCLK | FMC_SDCR1_RBURST | FMC_SDCR1_RPIPE))((uint32_t)(FMC_PATT_ATTSET3 | FMC_PATT_ATTWAIT3 | FMC_PATT_ATTHOLD3 | FMC_PATT_ATTHIZ3))((uint32_t)(FMC_PMEM_MEMSET3 | FMC_PMEM_MEMWAIT3 | FMC_PMEM_MEMHOLD3 | FMC_PMEM_MEMHIZ3))((uint32_t)(FMC_PCR_PWAITEN | FMC_PCR_PBKEN | FMC_PCR_PTYP | FMC_PCR_PWID | FMC_PCR_ECCEN | FMC_PCR_TCLR | FMC_PCR_TAR | FMC_PCR_ECCPS))((uint32_t)(FMC_BWTR1_ADDSET | FMC_BWTR1_ADDHLD | FMC_BWTR1_DATAST | FMC_BWTR1_BUSTURN | FMC_BWTR1_ACCMOD))((uint32_t)(FMC_BTR1_ADDSET | FMC_BTR1_ADDHLD | FMC_BTR1_DATAST | FMC_BTR1_BUSTURN | FMC_BTR1_CLKDIV | FMC_BTR1_DATLAT | FMC_BTR1_ACCMOD))defined(HAL_NOR_MODULE_ENABLED) || defined(HAL_NAND_MODULE_ENABLED) || defined(HAL_SDRAM_MODULE_ENABLED) || defined(HAL_SRAM_MODULE_ENABLED)/* Return the mode status *//* Get the corresponding bank mode *//**
  * @brief  Returns the indicated FMC SDRAM bank mode status.
  * @param  Device Pointer to SDRAM device instance
  * @param  Bank Defines the FMC SDRAM bank. This parameter can be
  *                     FMC_Bank1_SDRAM or FMC_Bank2_SDRAM.
  * @retval The FMC SDRAM bank mode status, could be on of the following values:
  *         FMC_SDRAM_NORMAL_MODE, FMC_SDRAM_SELF_REFRESH_MODE or
  *         FMC_SDRAM_POWER_DOWN_MODE.
  *//* Set the Auto-refresh number in command register *//**
  * @brief  Set the Number of consecutive SDRAM Memory auto Refresh commands.
  * @param  Device Pointer to SDRAM device instance
  * @param  AutoRefreshNumber Specifies the auto Refresh number.
  * @retval None
  *//* Set the refresh rate in command register *//**
  * @brief  Program the SDRAM Memory Refresh rate.
  * @param  Device Pointer to SDRAM device instance
  * @param  RefreshRate The SDRAM refresh rate value.
  * @retval HAL state
  *//* Set command register *//**
  * @brief  Send Command to the FMC SDRAM bank
  * @param  Device Pointer to SDRAM device instance
  * @param  Command Pointer to SDRAM command structure
  * @param  Timing Pointer to SDRAM Timing structure
  * @param  Timeout Timeout wait value
  * @retval HAL state
  *//**
  * @brief  Disables dynamically FMC_SDRAM write protection.
  * @param  hsdram FMC_SDRAM handle
  * @retval HAL status
  *//**
  * @brief  Enables dynamically FMC_SDRAM write protection.
  * @param  Device Pointer to SDRAM device instance
  * @param  Bank SDRAM bank number
  * @retval HAL status
  *//** @addtogroup FMC_LL_SDRAMPrivate_Functions_Group2
  *  @brief   management functions
  *
@verbatim
  ==============================================================================
                      ##### FMC_SDRAM Control functions #####
  ==============================================================================
  [..]
    This subsection provides a set of functions allowing to control dynamically
    the FMC SDRAM interface.

@endverbatim
  * @{
  *//* De-initialize the SDRAM device *//**
  * @brief  DeInitializes the FMC_SDRAM peripheral
  * @param  Device Pointer to SDRAM device instance
  * @retval HAL status
  *//* FMC_Bank2_SDRAM *//* Set SDRAM device timing parameters *//**
  * @brief  Initializes the FMC_SDRAM device timing according to the specified
  *         parameters in the FMC_SDRAM_TimingTypeDef
  * @param  Device Pointer to SDRAM device instance
  * @param  Timing Pointer to SDRAM Timing structure
  * @param  Bank SDRAM bank number
  * @retval HAL status
  *//* Set SDRAM bank configuration parameters *//**
  * @brief  Initializes the FMC_SDRAM device according to the specified
  *         control parameters in the FMC_SDRAM_InitTypeDef
  * @param  Device Pointer to SDRAM device instance
  * @param  Init Pointer to SDRAM Initialization structure
  * @retval HAL status
  *//** @addtogroup FMC_LL_SDRAM_Private_Functions_Group1
  *  @brief    Initialization and Configuration functions
  *
@verbatim
  ==============================================================================
              ##### Initialization and de_initialization functions #####
  ==============================================================================
  [..]
    This section provides functions allowing to:
    (+) Initialize and configure the FMC SDRAM interface
    (+) De-initialize the FMC SDRAM interface
    (+) Configure the FMC clock and associated GPIOs

@endverbatim
  * @{
  *//** @defgroup FMC_LL_SDRAM
  * @brief    SDRAM Controller functions
  *
  @verbatim
  ==============================================================================
                     ##### How to use SDRAM device driver #####
  ==============================================================================
  [..]
    This driver contains a set of APIs to interface with the FMC SDRAM banks in order
    to run the SDRAM external devices.

    (+) FMC SDRAM bank reset using the function FMC_SDRAM_DeInit()
    (+) FMC SDRAM bank control configuration using the function FMC_SDRAM_Init()
    (+) FMC SDRAM bank timing configuration using the function FMC_SDRAM_Timing_Init()
    (+) FMC SDRAM bank enable/disable write operation using the functions
        FMC_SDRAM_WriteOperation_Enable()/FMC_SDRAM_WriteOperation_Disable()
    (+) FMC SDRAM bank send command using the function FMC_SDRAM_SendCommand()

@endverbatim
  * @{
  *//* Get the ECCR register value *//* Prevent unused argument(s) compilation warning if no assert_param check *//* Wait until FIFO is empty *//**
  * @brief  Disables dynamically FMC_NAND ECC feature.
  * @param  Device Pointer to NAND device instance
  * @param  ECCval Pointer to ECC value
  * @param  Bank NAND bank number
  * @param  Timeout Timeout wait value
  * @retval HAL status
  *//* Disable ECC feature *//**
  * @brief  Disables dynamically FMC_NAND ECC feature.
  * @param  Device Pointer to NAND device instance
  * @param  Bank NAND bank number
  * @retval HAL status
  *//* Enable ECC feature *//**
  * @brief  Enables dynamically FMC_NAND ECC feature.
  * @param  Device Pointer to NAND device instance
  * @param  Bank NAND bank number
  * @retval HAL status
  *//** @defgroup HAL_FMC_NAND_Group2 Peripheral Control functions
  *  @brief   management functions
  *
@verbatim
  ==============================================================================
                       ##### FMC_NAND Control functions #####
  ==============================================================================
  [..]
    This subsection provides a set of functions allowing to control dynamically
    the FMC NAND interface.

@endverbatim
  * @{
  *//* Set the FMC_NAND_BANK3 registers to their reset values *//* De-initialize the NAND Bank *//* Disable the NAND Bank *//**
  * @brief  DeInitializes the FMC_NAND device
  * @param  Device Pointer to NAND device instance
  * @param  Bank NAND bank number
  * @retval HAL status
  *//* NAND bank 3 registers configuration *//**
  * @brief  Initializes the FMC_NAND Attribute space Timing according to the specified
  *         parameters in the FMC_NAND_PCC_TimingTypeDef
  * @param  Device Pointer to NAND device instance
  * @param  Timing Pointer to NAND timing structure
  * @param  Bank NAND bank number
  * @retval HAL status
  *//**
  * @brief  Initializes the FMC_NAND Common space Timing according to the specified
  *         parameters in the FMC_NAND_PCC_TimingTypeDef
  * @param  Device Pointer to NAND device instance
  * @param  Timing Pointer to NAND timing structure
  * @param  Bank NAND bank number
  * @retval HAL status
  *//**
  * @brief  Initializes the FMC_NAND device according to the specified
  *         control parameters in the FMC_NAND_HandleTypeDef
  * @param  Device Pointer to NAND device instance
  * @param  Init Pointer to NAND Initialization structure
  * @retval HAL status
  *//** @defgroup FMC_LL_NAND_Exported_Functions_Group1 Initialization and de-initialization functions
  *  @brief    Initialization and Configuration functions
  *
@verbatim
  ==============================================================================
              ##### Initialization and de_initialization functions #####
  ==============================================================================
  [..]
    This section provides functions allowing to:
    (+) Initialize and configure the FMC NAND interface
    (+) De-initialize the FMC NAND interface
    (+) Configure the FMC clock and associated GPIOs

@endverbatim
  * @{
  *//** @defgroup FMC_LL_Exported_Functions_NAND FMC Low Layer NAND Exported Functions
  * @brief    NAND Controller functions
  *
  @verbatim
  ==============================================================================
                    ##### How to use NAND device driver #####
  ==============================================================================
  [..]
    This driver contains a set of APIs to interface with the FMC NAND banks in order
    to run the NAND external devices.

    (+) FMC NAND bank reset using the function FMC_NAND_DeInit()
    (+) FMC NAND bank control configuration using the function FMC_NAND_Init()
    (+) FMC NAND bank common space timing configuration using the function
        FMC_NAND_CommonSpace_Timing_Init()
    (+) FMC NAND bank attribute space timing configuration using the function
        FMC_NAND_AttributeSpace_Timing_Init()
    (+) FMC NAND bank enable/disable ECC correction feature using the functions
        FMC_NAND_ECC_Enable()/FMC_NAND_ECC_Disable()
    (+) FMC NAND bank get ECC correction code using the function FMC_NAND_GetECC()

@endverbatim
  * @{
  *//* Disable write operation *//**
  * @brief  Disables dynamically FMC_NORSRAM write operation.
  * @param  Device Pointer to NORSRAM device instance
  * @param  Bank NORSRAM bank number
  * @retval HAL status
  *//* Enable write operation *//**
  * @brief  Enables dynamically FMC_NORSRAM write operation.
  * @param  Device Pointer to NORSRAM device instance
  * @param  Bank NORSRAM bank number
  * @retval HAL status
  *//** @addtogroup FMC_LL_NORSRAM_Private_Functions_Group2
  *  @brief   management functions
  *
@verbatim
  ==============================================================================
                      ##### FMC_NORSRAM Control functions #####
  ==============================================================================
  [..]
    This subsection provides a set of functions allowing to control dynamically
    the FMC NORSRAM interface.

@endverbatim
  * @{
  *//* Set NORSRAM device timing register for write configuration, if extended mode is used *//**
  * @brief  Initialize the FMC_NORSRAM Extended mode Timing according to the specified
  *         parameters in the FMC_NORSRAM_TimingTypeDef
  * @param  Device Pointer to NORSRAM device instance
  * @param  Timing Pointer to NORSRAM Timing structure
  * @param  Bank NORSRAM bank number
  * @param  ExtendedMode FMC Extended Mode
  *          This parameter can be one of the following values:
  *            @arg FMC_EXTENDED_MODE_DISABLE
  *            @arg FMC_EXTENDED_MODE_ENABLE
  * @retval HAL status
  *//* Configure Clock division value (in NORSRAM bank 1) when continuous clock is enabled *//* Set FMC_NORSRAM device timing parameters *//**
  * @brief  Initialize the FMC_NORSRAM Timing according to the specified
  *         parameters in the FMC_NORSRAM_TimingTypeDef
  * @param  Device Pointer to NORSRAM device instance
  * @param  Timing Pointer to NORSRAM Timing structure
  * @param  Bank NORSRAM bank number
  * @retval HAL status
  *//* FMC_NORSRAM_BANK2, FMC_NORSRAM_BANK3 or FMC_NORSRAM_BANK4 *//* FMC_NORSRAM_BANK1 *//* De-initialize the FMC_NORSRAM device *//* Disable the FMC_NORSRAM device *//**
  * @brief  DeInitialize the FMC_NORSRAM peripheral
  * @param  Device Pointer to NORSRAM device instance
  * @param  ExDevice Pointer to NORSRAM extended mode device instance
  * @param  Bank NORSRAM bank number
  * @retval HAL status
  *//* Configure Write FIFO mode when Write Fifo is enabled for bank2..4 *//* Configure synchronous mode when Continuous clock is enabled for bank2..4 *//* Set NORSRAM device control parameters *//* Disable NORSRAM Device *//**
  * @brief  Initialize the FMC_NORSRAM device according to the specified
  *         control parameters in the FMC_NORSRAM_InitTypeDef
  * @param  Device Pointer to NORSRAM device instance
  * @param  Init Pointer to NORSRAM Initialization structure
  * @retval HAL status
  *//** @defgroup FMC_LL_NORSRAM_Exported_Functions_Group1 Initialization and de-initialization functions
  * @brief    Initialization and Configuration functions
  *
  @verbatim
  ==============================================================================
              ##### Initialization and de_initialization functions #####
  ==============================================================================
  [..]
    This section provides functions allowing to:
    (+) Initialize and configure the FMC NORSRAM interface
    (+) De-initialize the FMC NORSRAM interface
    (+) Configure the FMC clock and associated GPIOs

@endverbatim
  * @{
  *//** @defgroup FMC_LL_Exported_Functions_NORSRAM FMC Low Layer NOR SRAM Exported Functions
  * @brief  NORSRAM Controller functions
  *
  @verbatim
  ==============================================================================
                   ##### How to use NORSRAM device driver #####
  ==============================================================================

  [..]
    This driver contains a set of APIs to interface with the FMC NORSRAM banks in order
    to run the NORSRAM external devices.

    (+) FMC NORSRAM bank reset using the function FMC_NORSRAM_DeInit()
    (+) FMC NORSRAM bank control configuration using the function FMC_NORSRAM_Init()
    (+) FMC NORSRAM bank timing configuration using the function FMC_NORSRAM_Timing_Init()
    (+) FMC NORSRAM bank extended timing configuration using the function
        FMC_NORSRAM_Extended_Timing_Init()
    (+) FMC NORSRAM bank enable/disable write operation using the functions
        FMC_NORSRAM_WriteOperation_Enable()/FMC_NORSRAM_WriteOperation_Disable()

@endverbatim
  * @{
  *//** @defgroup FMC_LL_Exported_Functions FMC Low Layer Exported Functions
  * @{
  *//* SDTR register clear mask *//* --- SDTR Register ---*//* SDCR register clear mask *//* --- SDCR Register ---*//* PATT register clear mask *//* --- PATT Register ---*//* PMEM register clear mask *//* --- PMEM Register ---*//* PCR register clear mask *//* --- PCR Register ---*//* BWTR register clear mask *//* --- BWTR Register ---*//* BTR register clear mask *//* --- BTR Register ---*//* BCR register clear mask *//* --- BCR Register ---*//* ----------------------- FMC registers bit mask --------------------------- *//** @defgroup FMC_LL_Private_Constants FMC Low Layer Private Constants
  * @{
  *//** @defgroup FMC_LL  FMC Low Layer
  * @brief FMC driver modules
  * @{
  *//**
  ******************************************************************************
  * @file    stm32f7xx_ll_fmc.c
  * @author  MCD Application Team
  * @brief   FMC Low Layer HAL module driver.
  *
  *          This file provides firmware functions to manage the following
  *          functionalities of the Flexible Memory Controller (FMC) peripheral memories:
  *           + Initialization/de-initialization functions
  *           + Peripheral Control functions
  *           + Peripheral State functions
  *
  ******************************************************************************
  * @attention
  *
  * Copyright (c) 2017 STMicroelectronics.
  * All rights reserved.
  *
  * This software is licensed under terms that can be found in the LICENSE file
  * in the root directory of this software component.
  * If no LICENSE file comes with this software, it is provided AS-IS.
  *
  ******************************************************************************
  @verbatim
  ==============================================================================
                        ##### FMC peripheral features #####
  ==============================================================================
  [..] The Flexible memory controller (FMC) includes following memory controllers:
       (+) The NOR/PSRAM memory controller
     (+) The NAND memory controller
       (+) The Synchronous DRAM (SDRAM) controller

  [..] The FMC functional block makes the interface with synchronous and asynchronous static
       memories and SDRAM memories. Its main purposes are:
       (+) to translate AHB transactions into the appropriate external device protocol
       (+) to meet the access time requirements of the external memory devices

  [..] All external memories share the addresses, data and control signals with the controller.
       Each external device is accessed by means of a unique Chip Select. The FMC performs
       only one access at a time to an external device.
       The main features of the FMC controller are the following:
        (+) Interface with static-memory mapped devices including:
           (++) Static random access memory (SRAM)
           (++) Read-only memory (ROM)
           (++) NOR Flash memory/OneNAND Flash memory
           (++) PSRAM (4 memory banks)
           (++) Two banks of NAND Flash memory with ECC hardware to check up to 8 Kbytes of
                data
        (+) Interface with synchronous DRAM (SDRAM) memories
        (+) Independent Chip Select control for each memory bank
        (+) Independent configuration for each memory bank

  @endverbatim
  ******************************************************************************
  *//Users/jie/Documents/posixGen_Demos-main/LwIP_StreamingServer/Middlewares/Third_Party/FreeRTOS/Source/CMSIS_RTOS/cmsis_os.h"event_groups.h""semphr.h""queue.h""timers.h""task.h""FreeRTOS.h"osSignalClearosKernelInitializeosEventosMessageQDef_tos_messageQ_defosPoolDef_tos_pool_defosSemaphoreDef_tos_semaphore_defosMutexDef_tos_mutex_defosTimerDef_tos_timer_defosThreadDef_tos_thread_defos_mailQ_cb *osMailQIdosMailQDef_tos_mailQ_defosMessageQIdQueueDefinition *os_pool_cb *osPoolIdosSemaphoreIdosMutexIdosTimerIdtmrTimerControl *osThreadIdtskTaskControlBlock *const voidconst void *os_ptimeros_pthreados_timer_typeosTimerOnceosTimerPeriodicosStatusosOKosEventSignalosEventMessageosEventMailosEventTimeoutosErrorParameterosErrorResourceosErrorTimeoutResourceosErrorISRosErrorISRRecursiveosErrorPriorityosErrorNoMemoryosErrorValue0x86osErrorOSos_status_reserved0x7FFFFFFFosPriorityosPriorityIdleosPriorityLowosPriorityBelowNormalosPriorityNormalosPriorityAboveNormal+1osPriorityHigh+2osPriorityRealtime+3osPriorityErrordefmessage_idmail_idsignalspitem_szqueue_szpoolpool_szdummyptimerstacksizeinstancestprioritypthreadchar *nameos_mailQ_cb **cbosMailQ(name)&os_mailQ_def_ ## nameosMailQDef(name,queue_sz,type)struct os_mailQ_cb *os_mailQ_cb_ ## name; const osMailQDef_t os_mailQ_def_ ## name = { (queue_sz), sizeof (type), (&os_mailQ_cb_ ## name) }osMessageQ(name)&os_messageQ_def_ ## nameosMessageQDef(name,queue_sz,type)const osMessageQDef_t os_messageQ_def_ ## name = { (queue_sz), sizeof (type) }osPool(name)&os_pool_def_ ## nameosPoolDef(name,no,type)const osPoolDef_t os_pool_def_ ## name = { (no), sizeof(type), NULL }osSemaphore(name)&os_semaphore_def_ ## nameosSemaphoreDef(name)const osSemaphoreDef_t os_semaphore_def_ ## name = { 0 }osMutex(name)&os_mutex_def_ ## nameosMutexDef(name)const osMutexDef_t os_mutex_def_ ## name = { 0 }osTimer(name)&os_timer_def_ ## nameosTimerDef(name,function)const osTimerDef_t os_timer_def_ ## name = { (function) }osThread(name)&os_thread_def_ ## nameosThreadDef(name,thread,priority,instances,stacksz)const osThreadDef_t os_thread_def_ ## name = { #name, (thread), (priority), (instances), (stacksz)}osKernelSysTickMicroSec(microsec)(((uint64_t)microsec * (osKernelSysTickFrequency)) / 1000000)osKernelSysTickFrequency(configTICK_RATE_HZ)osWaitForeverosFeature_SysTickosFeature_WaitosFeature_SemaphoreosFeature_SignalsosFeature_MessageQosFeature_MailQosFeature_PoolosFeature_MainThreadosKernelSystemId"KERNEL V1.00"osCMSIS_KERNEL0x10000osCMSIS0x10002_CMSIS_OS_H( INCLUDE_eTaskGetState == 1 )( configSUPPORT_STATIC_ALLOCATION == 1 )(defined (osFeature_SysTick) && (osFeature_SysTick != 0))defined (osObjectsExternal)(defined (osFeature_Wait) && (osFeature_Wait != 0))(defined (osFeature_Semaphore) && (osFeature_Semaphore != 0))(defined (osFeature_Pool) && (osFeature_Pool != 0))(defined (osFeature_MessageQ) && (osFeature_MessageQ != 0))(defined (osFeature_MailQ) && (osFeature_MailQ != 0))osSemaphoreGetCountosRecursiveMutexWaitosRecursiveMutexReleaseosRecursiveMutexCreateconst osMutexDef_tconst osMutexDef_t *os_mutex_def *osMessageDeleteosMessageAvailableSpaceosMessageWaitingosMessagePeekosThreadListosAbortDelayosDelayUntilosThreadResumeAllosThreadSuspendAllosThreadResumeosThreadSuspendosSystickHandlerosMailFreeosMailGetosMailPutosMailCAllocosMailAllocosMailCreateconst osMailQDef_tconst osMailQDef_t *os_mailQ_def *osMessageGetosMessagePutosMessageCreateconst osMessageQDef_tconst osMessageQDef_t *os_messageQ_def *osPoolFreeosPoolCAllocosPoolAllocosPoolCreateconst osPoolDef_tconst osPoolDef_t *os_pool_def *osSemaphoreDeleteosSemaphoreReleaseosSemaphoreWaitosSemaphoreCreateconst osSemaphoreDef_tconst osSemaphoreDef_t *os_semaphore_def *osMutexDeleteosMutexReleaseosMutexWaitosMutexCreateosSignalWaitosSignalSetosTimerDeleteosTimerStoposTimerStartosTimerCreateconst osTimerDef_tconst osTimerDef_t *os_timer_def *osDelayosThreadGetPriorityosThreadSetPriorityosThreadYieldosThreadTerminateosThreadGetIdosThreadCreateconst osThreadDef_tconst osThreadDef_t *os_thread_def *osKernelSysTickosKernelRunningosKernelStartos_mailQ_cbos_pool_cb// _CMSIS_OS_H/**
* @brief  Returns the current count value of a counting semaphore
* @param   semaphore_id  semaphore_id ID obtained by \ref osSemaphoreCreate.
* @retval  count value
*//**
* @brief  Release a Recursive Mutex
* @param   mutex_id    mutex ID obtained by \ref osRecursiveMutexCreate.
* @param millisec      timeout value or 0 in case of no time-out.
* @retval  status code that indicates the execution status of the function.
*//**
* @brief  Release a Recursive Mutex
* @param   mutex_id      mutex ID obtained by \ref osRecursiveMutexCreate.
* @retval  status code that indicates the execution status of the function.
*//**
* @brief  Create and Initialize a Recursive Mutex
* @param  mutex_def     mutex definition referenced with \ref osMutex.
* @retval  mutex ID for reference by other functions or NULL in case of error..
*//**
* @brief Delete a Message Queue
* @param  queue_id  message queue ID obtained with \ref osMessageCreate.
* @retval  status code that indicates the execution status of the function.
*//**
* @brief  Get the available space in a message queue.
* @param  queue_id  message queue ID obtained with \ref osMessageCreate.
* @retval available space in a message queue.
*//**
* @brief  Get the number of messaged stored in a queue.
* @param  queue_id  message queue ID obtained with \ref osMessageCreate.
* @retval number of messages stored in a queue.
*//**
* @brief  Receive an item from a queue without removing the item from the queue.
* @param  queue_id  message queue ID obtained with \ref osMessageCreate.
* @param  millisec  timeout value or 0 in case of no time-out.
* @retval event information that includes status code.
*//**
* @brief   Lists all the current threads, along with their current state 
*          and stack usage high water mark.
* @param   buffer   A buffer into which the above mentioned details
*          will be written
* @retval  status code that indicates the execution status of the function.
*//**
* @brief   Abort the delay for a specific thread
* @param   thread_id   thread ID obtained by \ref osThreadCreate or \ref osThreadGetId   
* @retval  status code that indicates the execution status of the function.
*//**
* @brief  Delay a task until a specified time
* @param   PreviousWakeTime   Pointer to a variable that holds the time at which the 
*          task was last unblocked. PreviousWakeTime must be initialised with the current time
*          prior to its first use (PreviousWakeTime = osKernelSysTick() )
* @param   millisec    time delay value
* @retval  status code that indicates the execution status of the function.
*//**
* @brief  Resume execution of a all suspended threads.
* @retval  status code that indicates the execution status of the function.
*//**
* @brief  Suspend execution of a all active threads.
* @retval  status code that indicates the execution status of the function.
*//**
* @brief  Resume execution of a suspended thread.
* @param   thread_id   thread ID obtained by \ref osThreadCreate or \ref osThreadGetId.
* @retval  status code that indicates the execution status of the function.
*//**
* @brief  Suspend execution of a thread.
* @param   thread_id   thread ID obtained by \ref osThreadCreate or \ref osThreadGetId.
* @retval  status code that indicates the execution status of the function.
*//* INCLUDE_eTaskGetState *//**
* @brief Check if a thread is already suspended or not.
* @param thread_id thread ID obtained by \ref osThreadCreate or \ref osThreadGetId.
* @retval status code that indicates the execution status of the function.
*//**
* @brief  Obtain the state of any thread.
* @param   thread_id   thread ID obtained by \ref osThreadCreate or \ref osThreadGetId.
* @retval  the stae of the thread, states are encoded by the osThreadState enumerated type.
*//**
* @brief  Handles the tick increment
* @param  none.
* @retval none.
*//*************************** Additional specific APIs to Free RTOS ************/// Mail Queues available/// \note MUST REMAIN UNCHANGED: \b osMailFree shall be consistent in every CMSIS-RTOS./// \return status code that indicates the execution status of the function./// \param[in]     mail          pointer to the memory block that was obtained with \ref osMailGet./// \param[in]     queue_id      mail queue ID obtained with \ref osMailCreate./// Free a memory block from a mail./// \note MUST REMAIN UNCHANGED: \b osMailGet shall be consistent in every CMSIS-RTOS./// \return event that contains mail information or error code./// \param[in]     millisec      timeout value or 0 in case of no time-out/// Get a mail from a queue./// \note MUST REMAIN UNCHANGED: \b osMailPut shall be consistent in every CMSIS-RTOS./// \param[in]     mail          memory block previously allocated with \ref osMailAlloc or \ref osMailCAlloc./// Put a mail to a queue./// \note MUST REMAIN UNCHANGED: \b osMailCAlloc shall be consistent in every CMSIS-RTOS./// \return pointer to memory block that can be filled with mail or NULL in case of error./// Allocate a memory block from a mail and set memory block to zero./// \note MUST REMAIN UNCHANGED: \b osMailAlloc shall be consistent in every CMSIS-RTOS./// Allocate a memory block from a mail./// \note MUST REMAIN UNCHANGED: \b osMailCreate shall be consistent in every CMSIS-RTOS./// \return mail queue ID for reference by other functions or NULL in case of error./// \param[in]     thread_id     thread ID (obtained by \ref osThreadCreate or \ref osThreadGetId) or NULL./// \param[in]     queue_def     reference to the mail queue definition obtain with \ref osMailQ/// Create and Initialize mail queue.///       macro body is implementation specific in every CMSIS-RTOS./// \note CAN BE CHANGED: The parameter to \b osMailQ shall be consistent but the/// \param         name          name of the queue/// \brief Access a Mail Queue Definition.// define the object// object is external/// \note CAN BE CHANGED: The parameter to \b osMailQDef shall be consistent but the/// \param         type          data type of a single message element/// \param         queue_sz      maximum number of messages in queue/// \brief Create a Mail Queue Definition.//  ==== Mail Queue Management Functions ====// Message Queues available/// \note MUST REMAIN UNCHANGED: \b osMessageGet shall be consistent in every CMSIS-RTOS./// \return event information that includes status code./// \param[in]     millisec      timeout value or 0 in case of no time-out./// \param[in]     queue_id      message queue ID obtained with \ref osMessageCreate./// Get a Message or Wait for a Message from a Queue./// \note MUST REMAIN UNCHANGED: \b osMessagePut shall be consistent in every CMSIS-RTOS./// \param[in]     info          message information./// Put a Message to a Queue./// \note MUST REMAIN UNCHANGED: \b osMessageCreate shall be consistent in every CMSIS-RTOS./// \return message queue ID for reference by other functions or NULL in case of error./// \param[in]     queue_def     queue definition referenced with \ref osMessageQ./// Create and Initialize a Message Queue./// \note CAN BE CHANGED: The parameter to \b osMessageQ shall be consistent but the/// \brief Access a Message Queue Definition.//configSUPPORT_STATIC_ALLOCATION == 1/// \note CAN BE CHANGED: The parameter to \b osMessageQDef shall be consistent but the/// \param         type          data type of a single message element (for debugger)./// \param         queue_sz      maximum number of messages in the queue./// \param         name          name of the queue./// \brief Create a Message Queue Definition.//  ==== Message Queue Management Functions ====// Memory Pool Management available/// \note MUST REMAIN UNCHANGED: \b osPoolFree shall be consistent in every CMSIS-RTOS./// \param[in]     block         address of the allocated memory block that is returned to the memory pool./// \param[in]     pool_id       memory pool ID obtain referenced with \ref osPoolCreate./// Return an allocated memory block back to a specific memory pool./// \note MUST REMAIN UNCHANGED: \b osPoolCAlloc shall be consistent in every CMSIS-RTOS./// \return address of the allocated memory block or NULL in case of no memory available./// Allocate a memory block from a memory pool and set memory block to zero./// \note MUST REMAIN UNCHANGED: \b osPoolAlloc shall be consistent in every CMSIS-RTOS./// Allocate a memory block from a memory pool./// \note MUST REMAIN UNCHANGED: \b osPoolCreate shall be consistent in every CMSIS-RTOS./// \return memory pool ID for reference by other functions or NULL in case of error./// \param[in]     pool_def      memory pool definition referenced with \ref osPool./// Create and Initialize a memory pool./// \note CAN BE CHANGED: The parameter to \b osPool shall be consistent but the/// \param         name          name of the memory pool/// \brief Access a Memory Pool definition./// \note CAN BE CHANGED: The parameter to \b osPoolDef shall be consistent but the/// \param         type          data type of a single block (object)./// \param         no            maximum number of blocks (objects) in the memory pool./// \param         name          name of the memory pool./// \brief Define a Memory Pool.//  ==== Memory Pool Management Functions ====// Semaphore available/// \note MUST REMAIN UNCHANGED: \b osSemaphoreDelete shall be consistent in every CMSIS-RTOS./// \param[in]     semaphore_id  semaphore object referenced with \ref osSemaphoreCreate./// Delete a Semaphore that was created by \ref osSemaphoreCreate./// \note MUST REMAIN UNCHANGED: \b osSemaphoreRelease shall be consistent in every CMSIS-RTOS./// Release a Semaphore token./// \note MUST REMAIN UNCHANGED: \b osSemaphoreWait shall be consistent in every CMSIS-RTOS./// \return number of available tokens, or -1 in case of incorrect parameters./// Wait until a Semaphore token becomes available./// \note MUST REMAIN UNCHANGED: \b osSemaphoreCreate shall be consistent in every CMSIS-RTOS./// \return semaphore ID for reference by other functions or NULL in case of error./// \param[in]     count         number of available resources./// \param[in]     semaphore_def semaphore definition referenced with \ref osSemaphore./// Create and Initialize a Semaphore object used for managing resources./// \note CAN BE CHANGED: The parameter to \b osSemaphore shall be consistent but the/// \param         name          name of the semaphore object./// Access a Semaphore definition.//configSUPPORT_STATIC_ALLOCATION == 0/// \note CAN BE CHANGED: The parameter to \b osSemaphoreDef shall be consistent but the/// Define a Semaphore object.//  ==== Semaphore Management Functions ====/// \note MUST REMAIN UNCHANGED: \b osMutexDelete shall be consistent in every CMSIS-RTOS./// \param[in]     mutex_id      mutex ID obtained by \ref osMutexCreate./// Delete a Mutex that was created by \ref osMutexCreate./// \note MUST REMAIN UNCHANGED: \b osMutexRelease shall be consistent in every CMSIS-RTOS./// Release a Mutex that was obtained by \ref osMutexWait./// \note MUST REMAIN UNCHANGED: \b osMutexWait shall be consistent in every CMSIS-RTOS./// Wait until a Mutex becomes available./// \note MUST REMAIN UNCHANGED: \b osMutexCreate shall be consistent in every CMSIS-RTOS./// \return mutex ID for reference by other functions or NULL in case of error./// \param[in]     mutex_def     mutex definition referenced with \ref osMutex./// Create and Initialize a Mutex object./// \note CAN BE CHANGED: The parameter to \b osMutex shall be consistent but the/// \param         name          name of the mutex object./// Access a Mutex definition./// \note CAN BE CHANGED: The parameter to \b osMutexDef shall be consistent but the/// Define a Mutex.//  ==== Mutex Management ====/// \note MUST REMAIN UNCHANGED: \b osSignalWait shall be consistent in every CMSIS-RTOS./// \return event flag information or error code./// \param[in]     signals       wait until all specified signal flags set or 0 for any single signal flag./// Wait for one or more Signal Flags to become signaled for the current \b RUNNING thread./// \note MUST REMAIN UNCHANGED: \b osSignalClear shall be consistent in every CMSIS-RTOS./// \return previous signal flags of the specified thread or 0x80000000 in case of incorrect parameters./// \param[in]     signals       specifies the signal flags of the thread that shall be cleared./// \param[in]     thread_id     thread ID obtained by \ref osThreadCreate or \ref osThreadGetId./// Clear the specified Signal Flags of an active thread./// \note MUST REMAIN UNCHANGED: \b osSignalSet shall be consistent in every CMSIS-RTOS./// \return osOK if successful, osErrorOS if failed./// \param[in]     signals       specifies the signal flags of the thread that should be set./// Set the specified Signal Flags of an active thread.//  ==== Signal Management ====/// \note MUST REMAIN UNCHANGED: \b osTimerDelete shall be consistent in every CMSIS-RTOS./// \param[in]     timer_id      timer ID obtained by \ref osTimerCreate./// Delete a timer that was created by \ref osTimerCreate./// \note MUST REMAIN UNCHANGED: \b osTimerStop shall be consistent in every CMSIS-RTOS./// Stop the timer./// \note MUST REMAIN UNCHANGED: \b osTimerStart shall be consistent in every CMSIS-RTOS./// \param[in]     millisec      time delay value of the timer./// Start or restart a timer./// \note MUST REMAIN UNCHANGED: \b osTimerCreate shall be consistent in every CMSIS-RTOS./// \return timer ID for reference by other functions or NULL in case of error./// \param[in]     argument      argument to the timer call back function./// \param[in]     type          osTimerOnce for one-shot or osTimerPeriodic for periodic behavior./// \param[in]     timer_def     timer object referenced with \ref osTimer./// Create a timer./// \note CAN BE CHANGED: The parameter to \b osTimer shall be consistent but the/// \param         name          name of the timer object./// Access a Timer definition./// \note CAN BE CHANGED: The parameter to \b osTimerDef shall be consistent but the/// \param         function      name of the timer call back function./// Define a Timer object.//  ==== Timer Management Functions ====// Generic Wait available/// \note MUST REMAIN UNCHANGED: \b osWait shall be consistent in every CMSIS-RTOS./// \return event that contains signal, message, or mail information or error code./// \param[in] millisec          timeout value or 0 in case of no time-out/// Wait for Signal, Message, Mail, or Timeout./// \param[in]     millisec      time delay value/// Wait for Timeout (Time Delay).//  ==== Generic Wait Functions ====/// \note MUST REMAIN UNCHANGED: \b osThreadGetPriority shall be consistent in every CMSIS-RTOS./// \return current priority value of the thread function./// Get current priority of an active thread./// \note MUST REMAIN UNCHANGED: \b osThreadSetPriority shall be consistent in every CMSIS-RTOS./// \param[in]     priority      new priority value for the thread function./// Change priority of an active thread./// \note MUST REMAIN UNCHANGED: \b osThreadYield shall be consistent in every CMSIS-RTOS./// Pass control to next thread that is in state \b READY./// \note MUST REMAIN UNCHANGED: \b osThreadTerminate shall be consistent in every CMSIS-RTOS./// \param[in]     thread_id   thread ID obtained by \ref osThreadCreate or \ref osThreadGetId./// Terminate execution of a thread and remove it from Active Threads./// \note MUST REMAIN UNCHANGED: \b osThreadGetId shall be consistent in every CMSIS-RTOS./// \return thread ID for reference by other functions or NULL in case of error./// Return the thread ID of the current running thread./// \note MUST REMAIN UNCHANGED: \b osThreadCreate shall be consistent in every CMSIS-RTOS./// \param[in]     argument      pointer that is passed to the thread function as start argument./// \param[in]     thread_def    thread definition referenced with \ref osThread./// Create a thread and add it to Active Threads and set it to state READY./// \note CAN BE CHANGED: The parameter to \b osThread shall be consistent but the/// \param         name          name of the thread definition object./// Access a Thread definition./// \note CAN BE CHANGED: The parameters to \b osThreadDef shall be consistent but the/// \param         stacksz      stack size (in bytes) requirements for the thread function./// \param         instances    number of possible thread instances./// \param         priority     initial priority of the thread function./// \param         name         name of the thread function./// Create a Thread Definition with function, priority, and stack requirements.//  ==== Thread Management ====// System Timer available/// \return time value normalized to the \ref osKernelSysTickFrequency/// \param         microsec     time value in microseconds./// Convert a microseconds value to a RTOS kernel system timer value./// \note Reflects the system timer setting and is typically defined in a configuration file./// The RTOS kernel system timer frequency in Hz/// \return RTOS kernel system timer as 32-bit value /// \note MUST REMAIN UNCHANGED: \b osKernelSysTick shall be consistent in every CMSIS-RTOS./// Get the RTOS kernel system timer counter /// \return 0 RTOS is not started, 1 RTOS is started./// \note MUST REMAIN UNCHANGED: \b osKernelRunning shall be consistent in every CMSIS-RTOS./// Check if the RTOS kernel is already started./// \note MUST REMAIN UNCHANGED: \b osKernelStart shall be consistent in every CMSIS-RTOS./// Start the RTOS Kernel./// \note MUST REMAIN UNCHANGED: \b osKernelInitialize shall be consistent in every CMSIS-RTOS./// Initialize the RTOS Kernel for creating objects.//  ==== Kernel Control Functions ====///< event definition///< message id obtained by \ref osMessageCreate///< mail id obtained by \ref osMailCreate///< event value///< signal flags///< message or mail as void pointer///< message as 32-bit value///< status code: event or error information///       However the struct may be extended at the end./// \note MUST REMAIN UNCHANGED: \b os_event shall be consistent in every CMSIS-RTOS./// Event structure contains detailed information about an event.///< size of an item///< number of elements in the queue/// \note CAN BE CHANGED: \b os_mailQ_def is implementation specific in every CMSIS-RTOS./// Definition structure for mail queue.//void                       *pool;    ///< memory array for messages///< control block to hold queue's data for static allocation; NULL for dynamic allocation///< buffer for static allocation; NULL for dynamic allocation/// \note CAN BE CHANGED: \b os_messageQ_def is implementation specific in every CMSIS-RTOS./// Definition structure for message queue.///< pointer to memory for pool///< number of items (elements) in the pool/// \note CAN BE CHANGED: \b os_pool_def is implementation specific in every CMSIS-RTOS./// Definition structure for memory block allocation.///< control block for static allocation; NULL for dynamic allocation///< dummy value./// \note CAN BE CHANGED: \b os_semaphore_def is implementation specific in every CMSIS-RTOS./// Semaphore Definition structure contains setup information for a semaphore./// \note CAN BE CHANGED: \b os_mutex_def is implementation specific in every CMSIS-RTOS./// Mutex Definition structure contains setup information for a mutex.///< control block to hold timer's data for static allocation; NULL for dynamic allocation///< start address of a timer function/// \note CAN BE CHANGED: \b os_timer_def is implementation specific in every CMSIS-RTOS./// Timer Definition structure contains timer parameters.///< control block to hold thread's data for static allocation; NULL for dynamic allocation///< stack buffer for static allocation; NULL for dynamic allocation///< stack size requirements in bytes; 0 is default stack size///< maximum number of instances of that thread function///< initial thread priority///< start address of thread function///< Thread name /// \note CAN BE CHANGED: \b os_thread_def is implementation specific in every CMSIS-RTOS./// Thread Definition structure contains startup information of a thread./// \note CAN BE CHANGED: \b os_mailQ_cb is implementation specific in every CMSIS-RTOS./// Mail ID identifies the mail queue (pointer to a mail queue control block)./// \note CAN BE CHANGED: \b os_messageQ_cb is implementation specific in every CMSIS-RTOS./// Message ID identifies the message queue (pointer to a message queue control block)./// \note CAN BE CHANGED: \b os_pool_cb is implementation specific in every CMSIS-RTOS./// Pool ID identifies the memory pool (pointer to a memory pool control block)./// \note CAN BE CHANGED: \b os_semaphore_cb is implementation specific in every CMSIS-RTOS./// Semaphore ID identifies the semaphore (pointer to a semaphore control block)./// \note CAN BE CHANGED: \b os_mutex_cb is implementation specific in every CMSIS-RTOS./// Mutex ID identifies the mutex (pointer to a mutex control block)./// \note CAN BE CHANGED: \b os_timer_cb is implementation specific in every CMSIS-RTOS./// Timer ID identifies the timer (pointer to a timer control block)./// \note CAN BE CHANGED: \b os_thread_cb is implementation specific in every CMSIS-RTOS./// Thread ID identifies the thread (pointer to a thread control block).// >>> the following data type definitions may shall adapted towards a specific RTOS/// \note MUST REMAIN UNCHANGED: \b os_ptimer shall be consistent in every CMSIS-RTOS./// Entry point of a timer call back function./// \note MUST REMAIN UNCHANGED: \b os_pthread shall be consistent in every CMSIS-RTOS./// Entry point of a thread.///< repeating timer///< one-shot timer/// \note MUST REMAIN UNCHANGED: \b os_timer_type shall be consistent in every CMSIS-RTOS./// Timer type value for the timer definition./* The thread being queried has been deleted, but its TCB has not yet been freed. *//* The thread being queried is in the Suspended state, or is in the Blocked state with an infinite time out. *//* The thread being queried is in the Blocked state. *//* The thread being queried is in a read or pending ready list. *//* A thread is querying the state of itself, so must be running. *//* Thread state returned by osThreadGetState *////< prevent from enum down-size compiler optimization.///< unspecified RTOS error: run-time error but no other error message fits.///< value of a parameter is out of range.///< system is out of memory: it was impossible to allocate or reserve memory for the operation.///< system cannot determine priority or thread has illegal priority.///< function called multiple times from ISR with same object.///< not allowed in ISR context: the function cannot be called from interrupt service routines.///< resource not available within given time: a specified resource was not available within the timeout period.///< resource not available: a specified resource was not available.///< parameter error: a mandatory parameter was missing or specified an incorrect object.///< function completed; timeout occurred.///< function completed; mail event occurred.///< function completed; message event occurred.///< function completed; signal event occurred.///< function completed; no error or event occurred./// \note MUST REMAIN UNCHANGED: \b osStatus shall be consistent in every CMSIS-RTOS./// Status code values returned by CMSIS-RTOS functions.///< wait forever timeout value/// \note MUST REMAIN UNCHANGED: \b osWaitForever shall be consistent in every CMSIS-RTOS./// Timeout value.///< system cannot determine priority or thread has illegal priority///< priority: realtime (highest)///< priority: high///< priority: above normal///< priority: normal (default)///< priority: below normal///< priority: low///< priority: idle (lowest)/// \note MUST REMAIN UNCHANGED: \b osPriority shall be consistent in every CMSIS-RTOS./// Priority used for thread control.// ==== Enumeration, structures, defines ====///< osKernelSysTick functions: 1=available, 0=not available///< osWait function: 1=available, 0=not available///< osFeature_Semaphore function: 1=available, 0=not available///< maximum number of Signal Flags available per thread///< Message Queues:  1=available, 0=not available///< Mail Queues:     1=available, 0=not available///< Memory Pools:    1=available, 0=not available///< main thread      1=main can be thread, 0=not available/// \note MUST REMAIN UNCHANGED: \b osFeature_xxx shall be consistent in every CMSIS-RTOS.///< RTOS identification string/// \note MUST REMAIN UNCHANGED: \b osKernelSystemId shall be consistent in every CMSIS-RTOS.///< RTOS identification and version (main [31:16] .sub [15:0])/// \note CAN BE CHANGED: \b osCMSIS_KERNEL identifies the underlying RTOS kernel and version number.///< API version (main [31:16] .sub [15:0])/// \note MUST REMAIN UNCHANGED: \b osCMSIS identifies the CMSIS-RTOS API version./**
\page cmsis_os_h Header File Template: cmsis_os.h

The file \b cmsis_os.h is a template header file for a CMSIS-RTOS compliant Real-Time Operating System (RTOS).
Each RTOS that is compliant with CMSIS-RTOS shall provide a specific \b cmsis_os.h header file that represents
its implementation.

The file cmsis_os.h contains:
 - CMSIS-RTOS API function definitions
 - struct definitions for parameters and return types
 - status and priority values used by CMSIS-RTOS API functions
 - macros for defining threads and other kernel objects


<b>Name conventions and header file modifications</b>

All definitions are prefixed with \b os to give an unique name space for CMSIS-RTOS functions.
Definitions that are prefixed \b os_ are not used in the application code but local to this header file.
All definitions and functions that belong to a module are grouped and have a common prefix, i.e. \b osThread.

Definitions that are marked with <b>CAN BE CHANGED</b> can be adapted towards the needs of the actual CMSIS-RTOS implementation.
These definitions can be specific to the underlying RTOS kernel.

Definitions that are marked with <b>MUST REMAIN UNCHANGED</b> cannot be altered. Otherwise the CMSIS-RTOS implementation is no longer
compliant to the standard. Note that some functions are optional and need not to be provided by every CMSIS-RTOS implementation.


<b>Function calls from interrupt service routines</b>

The following CMSIS-RTOS functions can be called from threads and interrupt service routines (ISR):
  - \ref osSignalSet
  - \ref osSemaphoreRelease
  - \ref osPoolAlloc, \ref osPoolCAlloc, \ref osPoolFree
  - \ref osMessagePut, \ref osMessageGet
  - \ref osMailAlloc, \ref osMailCAlloc, \ref osMailGet, \ref osMailPut, \ref osMailFree

Functions that cannot be called from an ISR are verifying the interrupt status and return in case that they are called
from an ISR context the status code \b osErrorISR. In some implementations this condition might be caught using the HARD FAULT vector.

Some CMSIS-RTOS implementations support CMSIS-RTOS function calls from multiple ISR at the same time.
If this is impossible, the CMSIS-RTOS rejects calls by nested ISR functions with the status code \b osErrorISRRecursive.


<b>Define and reference object definitions</b>

With <b>\#define osObjectsExternal</b> objects are defined as external symbols. This allows to create a consistent header file
that is used throughout a project as shown below:

<i>Header File</i>
\code
#include <cmsis_os.h>                                         // CMSIS RTOS header file

// Thread definition
extern void thread_sample (void const *argument);             // function prototype
osThreadDef (thread_sample, osPriorityBelowNormal, 1, 100);

// Pool definition
osPoolDef(MyPool, 10, long);
\endcode


This header file defines all objects when included in a C/C++ source file. When <b>\#define osObjectsExternal</b> is
present before the header file, the objects are defined as external symbols. A single consistent header file can therefore be
used throughout the whole project.

<i>Example</i>
\code
#include "osObjects.h"     // Definition of the CMSIS-RTOS objects
\endcode

\code
#define osObjectExternal   // Objects will be defined as external symbols
#include "osObjects.h"     // Reference to the CMSIS-RTOS objects
\endcode

*//* ----------------------------------------------------------------------
 * $Date:        5. February 2013
 * $Revision:    V1.02
 *
 * Project:      CMSIS-RTOS API
 * Title:        cmsis_os.h header file
 *
 * Version 0.02
 *    Initial Proposal Phase
 * Version 0.03
 *    osKernelStart added, optional feature: main started as thread
 *    osSemaphores have standard behavior
 *    osTimerCreate does not start the timer, added osTimerStart
 *    osThreadPass is renamed to osThreadYield
 * Version 1.01
 *    Support for C++ interface
 *     - const attribute removed from the osXxxxDef_t typedef's
 *     - const attribute added to the osXxxxDef macros
 *    Added: osTimerDelete, osMutexDelete, osSemaphoreDelete
 *    Added: osKernelInitialize
 * Version 1.02
 *    Control functions for short timeouts in microsecond resolution:
 *    Added: osKernelSysTick, osKernelSysTickFrequency, osKernelSysTickMicroSec
 *    Removed: osSignalGet 
 *    
 *  
 *----------------------------------------------------------------------------
 *
 * Portions Copyright  2016 STMicroelectronics International N.V. All rights reserved.
 * Portions Copyright (c) 2013 ARM LIMITED
 * All rights reserved.
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *  - Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *  - Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *  - Neither the name of ARM  nor the names of its contributors may be used
 *    to endorse or promote products derived from this software without
 *    specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 *---------------------------------------------------------------------------*//Users/jie/Documents/posixGen_Demos-main/LwIP_StreamingServer/Middlewares/Third_Party/FreeRTOS/Source/CMSIS_RTOS/Users/jie/Documents/posixGen_Demos-main/LwIP_StreamingServer/Middlewares/Third_Party/FreeRTOS/Source/Users/jie/Documents/posixGen_Demos-main/LwIP_StreamingServer/Middlewares/Third_Party/FreeRTOS/Users/jie/Documents/posixGen_Demos-main/LwIP_StreamingServer/Middlewares/Third_Party/Users/jie/Documents/posixGen_Demos-main/LwIP_StreamingServer/Middlewaressemaphore_idmutex_idmillisecmutex_defqueue_idthread_idPreviousWakeTimemailqueue_definfopool_idblockpool_defsemaphore_deftimer_idtimer_deftypeargumentthread_def/Users/jie/Documents/posixGen_Demos-main/LwIP_StreamingServer/Middlewares/Third_Party/FreeRTOS/Source/include/FreeRTOS.h/Users/jie/Documents/posixGen_Demos-main/LwIP_StreamingServer/Inc/FreeRTOSConfig.h/Users/jie/Documents/posixGen_Demos-main/LwIP_StreamingServer/Middlewares/Third_Party/FreeRTOS/Source/include/projdefs.h/Users/jie/Documents/posixGen_Demos-main/LwIP_StreamingServer/Middlewares/Third_Party/FreeRTOS/Source/include/portable.h/Users/jie/Documents/posixGen_Demos-main/LwIP_StreamingServer/Middlewares/Third_Party/FreeRTOS/Source/include/deprecated_definitions.h/Users/jie/Documents/posixGen_Demos-main/LwIP_StreamingServer/Middlewares/Third_Party/FreeRTOS/Source/portable/GCC/ARM_CM7/r0p1/portmacro.h/Users/jie/Documents/posixGen_Demos-main/LwIP_StreamingServer/Middlewares/Third_Party/FreeRTOS/Source/include/mpu_wrappers.h/Users/jie/Documents/posixGen_Demos-main/LwIP_StreamingServer/Middlewares/Third_Party/FreeRTOS/Source/include/task.h/Users/jie/Documents/posixGen_Demos-main/LwIP_StreamingServer/Middlewares/Third_Party/FreeRTOS/Source/include/list.h/Users/jie/Documents/posixGen_Demos-main/LwIP_StreamingServer/Middlewares/Third_Party/FreeRTOS/Source/include/timers.h/Users/jie/Documents/posixGen_Demos-main/LwIP_StreamingServer/Middlewares/Third_Party/FreeRTOS/Source/include/queue.h/Users/jie/Documents/posixGen_Demos-main/LwIP_StreamingServer/Middlewares/Third_Party/FreeRTOS/Source/include/semphr.h/Users/jie/Documents/posixGen_Demos-main/LwIP_StreamingServer/Middlewares/Third_Party/FreeRTOS/Source/include/event_groups.h/Users/jie/Documents/posixGen_Demos-main/LwIP_StreamingServer/Middlewares/Third_Party/FreeRTOS/Source/CMSIS_RTOS/cmsis_os.c"cmsis_os.h"const QueueHandle_tportMAX_DELAYportTICK_PERIOD_MSpdTRUEeventvoid *consttaskSCHEDULER_NOT_STARTEDtaskWokenpdFALSEBaseType_t *long *BaseType_t *const3758157060queue_id->handle&mail&taskWokenconst void *constconst BaseType_tsizeof(struct os_mailQ_cb)queue_def->queue_szsizeof(void *)const UBaseType_tosPoolDef_t *&infoqueue_def->item_szsizeof(pool_id->pool_sz)thePoolitemSizesizeof(os_pool_cb_t)sema( sema )int32_t *xHigherPriorityTaskWokenulPreviousNotificationValueeSetBitspdPASS0x80000000-2147483648const TickType_tconst TaskHandle_thandleconst charconst char *const char *constTaskHandle_t *tskTaskControlBlock **TaskHandle_t *constinHandlerModemakeCmsisPrioritytskIDLE_PRIORITYosPriorityRealtime - osPriorityIdle(osPriorityRealtime - osPriorityIdle)(int)osPriorityIdlemakeFreeRtosPriorityfpriorityxPortSysTickHandleros_mailQ_cb_tos_pool_cb_tcurrentIndexmarkers(INCLUDE_uxTaskPriorityGet == 1)( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )( configSUPPORT_STATIC_ALLOCATION == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )( ( INCLUDE_xTaskGetCurrentTaskHandle == 1 ) || ( configUSE_MUTEXES == 1 ) )(INCLUDE_vTaskDelete == 1)(INCLUDE_vTaskPrioritySet == 1)INCLUDE_vTaskDelay(configUSE_TIMERS == 1)( ( configSUPPORT_STATIC_ALLOCATION == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )( configUSE_TASK_NOTIFICATIONS == 1 )( configUSE_MUTEXES == 1)(configUSE_COUNTING_SEMAPHORES == 1 )(configSUPPORT_DYNAMIC_ALLOCATION == 1)(INCLUDE_xTaskGetSchedulerState == 1 )(INCLUDE_eTaskGetState == 1)(INCLUDE_vTaskSuspend == 1)INCLUDE_vTaskDelayUntilINCLUDE_xTaskAbortDelaysignal( ( configUSE_TRACE_FACILITY == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS == 1 ) )(configUSE_RECURSIVE_MUTEXES == 1)/**
* @brief  Returns the current count value of a counting semaphore
* @param  semaphore_id  semaphore_id ID obtained by \ref osSemaphoreCreate.
* @retval  count value
*//* We have mail *//* INCLUDE_xTaskGetSchedulerState *//* Use Mail Queues *//**
* @brief Free a memory block from a mail
* @param  queue_id mail queue ID obtained with \ref osMailCreate.
* @param  mail     pointer to the memory block that was obtained with \ref osMailGet.
* @retval status code that indicates the execution status of the function.
* @note   MUST REMAIN UNCHANGED: \b osMailFree shall be consistent in every CMSIS-RTOS.
*//**
* @brief Get a mail from a queue
* @param  queue_id   mail queue ID obtained with \ref osMailCreate.
* @param millisec    timeout value or 0 in case of no time-out
* @retval event that contains mail information or error code.
* @note   MUST REMAIN UNCHANGED: \b osMailGet shall be consistent in every CMSIS-RTOS.
*//**
* @brief Put a mail to a queue
* @param  queue_id      mail queue ID obtained with \ref osMailCreate.
* @param  mail          memory block previously allocated with \ref osMailAlloc or \ref osMailCAlloc.
* @retval status code that indicates the execution status of the function.
* @note   MUST REMAIN UNCHANGED: \b osMailPut shall be consistent in every CMSIS-RTOS.
*//**
* @brief Allocate a memory block from a mail and set memory block to zero
* @param  queue_id      mail queue ID obtained with \ref osMailCreate.
* @param  millisec      timeout value or 0 in case of no time-out.
* @retval pointer to memory block that can be filled with mail or NULL in case error.
* @note   MUST REMAIN UNCHANGED: \b osMailCAlloc shall be consistent in every CMSIS-RTOS.
*//**
* @brief Allocate a memory block from a mail
* @param  queue_id      mail queue ID obtained with \ref osMailCreate.
* @param  millisec      timeout value or 0 in case of no time-out.
* @retval pointer to memory block that can be filled with mail or NULL in case error.
* @note   MUST REMAIN UNCHANGED: \b osMailAlloc shall be consistent in every CMSIS-RTOS.
*///TODO: Delete queue. How to do it in FreeRTOS?/* Create a mail pool *//* Create a queue in FreeRTOS *//* Create a mail queue control block *//**
* @brief Create and Initialize mail queue
* @param  queue_def     reference to the mail queue definition obtain with \ref osMailQ
* @param   thread_id     thread ID (obtained by \ref osThreadCreate or \ref osThreadGetId) or NULL.
* @retval mail queue ID for reference by other functions or NULL in case of error.
* @note   MUST REMAIN UNCHANGED: \b osMailCreate shall be consistent in every CMSIS-RTOS.
*//********************   Mail Queue Management Functions  ***********************//* Use Message Queues *//**
* @brief Get a Message or Wait for a Message from a Queue.
* @param  queue_id  message queue ID obtained with \ref osMessageCreate.
* @param  millisec  timeout value or 0 in case of no time-out.
* @retval event information that includes status code.
* @note   MUST REMAIN UNCHANGED: \b osMessageGet shall be consistent in every CMSIS-RTOS.
*//**
* @brief Put a Message to a Queue.
* @param  queue_id  message queue ID obtained with \ref osMessageCreate.
* @param  info      message information.
* @param  millisec  timeout value or 0 in case of no time-out.
* @retval status code that indicates the execution status of the function.
* @note   MUST REMAIN UNCHANGED: \b osMessagePut shall be consistent in every CMSIS-RTOS.
*//**
* @brief Create and Initialize a Message Queue
* @param queue_def     queue definition referenced with \ref osMessageQ.
* @param  thread_id     thread ID (obtained by \ref osThreadCreate or \ref osThreadGetId) or NULL.
* @retval  message queue ID for reference by other functions or NULL in case of error.
* @note   MUST REMAIN UNCHANGED: \b osMessageCreate shall be consistent in every CMSIS-RTOS.
*//*******************   Message Queue Management Functions  *********************//* Use Memory Pool Management *//**
* @brief Return an allocated memory block back to a specific memory pool
* @param  pool_id       memory pool ID obtain referenced with \ref osPoolCreate.
* @param  block         address of the allocated memory block that is returned to the memory pool.
* @retval  status code that indicates the execution status of the function.
* @note   MUST REMAIN UNCHANGED: \b osPoolFree shall be consistent in every CMSIS-RTOS.
*//**
* @brief Allocate a memory block from a memory pool and set memory block to zero
* @param  pool_id       memory pool ID obtain referenced with \ref osPoolCreate.
* @retval  address of the allocated memory block or NULL in case of no memory available.
* @note   MUST REMAIN UNCHANGED: \b osPoolCAlloc shall be consistent in every CMSIS-RTOS.
*//**
* @brief Allocate a memory block from a memory pool
* @param pool_id       memory pool ID obtain referenced with \ref osPoolCreate.
* @retval  address of the allocated memory block or NULL in case of no memory available.
* @note   MUST REMAIN UNCHANGED: \b osPoolAlloc shall be consistent in every CMSIS-RTOS.
*//* Now allocate the pool itself. *//* Memory for markers *//* First have to allocate memory for the pool control block. *//**
* @brief Create and Initialize a memory pool
* @param  pool_def      memory pool definition referenced with \ref osPool.
* @retval  memory pool ID for reference by other functions or NULL in case of error.
* @note   MUST REMAIN UNCHANGED: \b osPoolCreate shall be consistent in every CMSIS-RTOS.
*///A better implementation will have to modify heap_x.c!//This is a primitive and inefficient wrapper around the existing FreeRTOS memory management.//TODO/*******************   Memory Pool Management Functions  ***********************//* Use Semaphores *//**
* @brief Delete a Semaphore
* @param  semaphore_id  semaphore object referenced with \ref osSemaphore.
* @retval  status code that indicates the execution status of the function.
* @note   MUST REMAIN UNCHANGED: \b osSemaphoreDelete shall be consistent in every CMSIS-RTOS.
*//**
* @brief Release a Semaphore token
* @param  semaphore_id  semaphore object referenced with \ref osSemaphore.
* @retval  status code that indicates the execution status of the function.
* @note   MUST REMAIN UNCHANGED: \b osSemaphoreRelease shall be consistent in every CMSIS-RTOS.
*//**
* @brief Wait until a Semaphore token becomes available
* @param  semaphore_id  semaphore object referenced with \ref osSemaphore.
* @param  millisec      timeout value or 0 in case of no time-out.
* @retval  number of available tokens, or -1 in case of incorrect parameters.
* @note   MUST REMAIN UNCHANGED: \b osSemaphoreWait shall be consistent in every CMSIS-RTOS.
*/// configSUPPORT_STATIC_ALLOCATION == 0  && configSUPPORT_DYNAMIC_ALLOCATION == 1// configSUPPORT_DYNAMIC_ALLOCATION == 0/**
* @brief Create and Initialize a Semaphore object used for managing resources
* @param semaphore_def semaphore definition referenced with \ref osSemaphore.
* @param count         number of available resources.
* @retval  semaphore ID for reference by other functions or NULL in case of error.
* @note   MUST REMAIN UNCHANGED: \b osSemaphoreCreate shall be consistent in every CMSIS-RTOS.
*//********************  Semaphore Management Functions **************************//**
* @brief Delete a Mutex
* @param mutex_id  mutex ID obtained by \ref osMutexCreate.
* @retval  status code that indicates the execution status of the function.
* @note   MUST REMAIN UNCHANGED: \b osMutexDelete shall be consistent in every CMSIS-RTOS.
*//**
* @brief Release a Mutex that was obtained by \ref osMutexWait
* @param mutex_id      mutex ID obtained by \ref osMutexCreate.
* @retval  status code that indicates the execution status of the function.
* @note   MUST REMAIN UNCHANGED: \b osMutexRelease shall be consistent in every CMSIS-RTOS.
*//**
* @brief Wait until a Mutex becomes available
* @param mutex_id      mutex ID obtained by \ref osMutexCreate.
* @param millisec      timeout value or 0 in case of no time-out.
* @retval  status code that indicates the execution status of the function.
* @note   MUST REMAIN UNCHANGED: \b osMutexWait shall be consistent in every CMSIS-RTOS.
*//**
* @brief  Create and Initialize a Mutex object
* @param  mutex_def     mutex definition referenced with \ref osMutex.
* @retval  mutex ID for reference by other functions or NULL in case of error.
* @note   MUST REMAIN UNCHANGED: \b osMutexCreate shall be consistent in every CMSIS-RTOS.
*//****************************  Mutex Management ********************************//* Task Notification not supported *//*Not allowed in ISR*//**
* @brief  Wait for one or more Signal Flags to become signaled for the current \b RUNNING thread.
* @param  signals   wait until all specified signal flags set or 0 for any single signal flag.
* @param  millisec  timeout value or 0 in case of no time-out.
* @retval  event flag information or error code.
* @note   MUST REMAIN UNCHANGED: \b osSignalWait shall be consistent in every CMSIS-RTOS.
*//**
* @brief  Clear the specified Signal Flags of an active thread.
* @param  thread_id  thread ID obtained by \ref osThreadCreate or \ref osThreadGetId.
* @param  signals    specifies the signal flags of the thread that shall be cleared.
* @retval  previous signal flags of the specified thread or 0x80000000 in case of incorrect parameters.
* @note   MUST REMAIN UNCHANGED: \b osSignalClear shall be consistent in every CMSIS-RTOS.
*//**
* @brief  Set the specified Signal Flags of an active thread.
* @param  thread_id     thread ID obtained by \ref osThreadCreate or \ref osThreadGetId.
* @param  signals       specifies the signal flags of the thread that should be set.
* @retval previous signal flags of the specified thread or 0x80000000 in case of incorrect parameters.
* @note   MUST REMAIN UNCHANGED: \b osSignalSet shall be consistent in every CMSIS-RTOS.
*//***************************  Signal Management ********************************//**
* @brief  Delete a timer.
* @param  timer_id      timer ID obtained by \ref osTimerCreate
* @retval  status code that indicates the execution status of the function.
* @note   MUST REMAIN UNCHANGED: \b osTimerDelete shall be consistent in every CMSIS-RTOS.
*//**
* @brief  Stop a timer.
* @param  timer_id      timer ID obtained by \ref osTimerCreate
* @retval  status code that indicates the execution status of the function.
* @note   MUST REMAIN UNCHANGED: \b osTimerStop shall be consistent in every CMSIS-RTOS.
*//**
* @brief  Start or restart a timer.
* @param  timer_id      timer ID obtained by \ref osTimerCreate.
* @param  millisec      time delay value of the timer.
* @retval  status code that indicates the execution status of the function
* @note   MUST REMAIN UNCHANGED: \b osTimerStart shall be consistent in every CMSIS-RTOS.
*/// period should be filled when starting the Timer using osTimerStart/**
* @brief  Create a timer.
* @param  timer_def     timer object referenced with \ref osTimer.
* @param  type          osTimerOnce for one-shot or osTimerPeriodic for periodic behavior.
* @param  argument      argument to the timer call back function.
* @retval  timer ID for reference by other functions or NULL in case of error.
* @note   MUST REMAIN UNCHANGED: \b osTimerCreate shall be consistent in every CMSIS-RTOS.
*//***********************  Timer Management Functions ***************************//* Generic Wait available *//**
* @brief  Wait for Signal, Message, Mail, or Timeout
* @param   millisec  timeout value or 0 in case of no time-out
* @retval  event that contains signal, message, or mail information or error code.
* @note   MUST REMAIN UNCHANGED: \b osWait shall be consistent in every CMSIS-RTOS.
*//* Minimum delay = 1 tick *//**
* @brief   Wait for Timeout (Time Delay)
* @param   millisec      time delay value
* @retval  status code that indicates the execution status of the function.
*//*********************** Generic Wait Functions *******************************//**
* @brief   Get current priority of an active thread.
* @param   thread_id     thread ID obtained by \ref osThreadCreate or \ref osThreadGetId.
* @retval  current priority value of the thread function.
* @note   MUST REMAIN UNCHANGED: \b osThreadGetPriority shall be consistent in every CMSIS-RTOS.
*//**
* @brief   Change priority of an active thread.
* @param   thread_id     thread ID obtained by \ref osThreadCreate or \ref osThreadGetId.
* @param   priority      new priority value for the thread function.
* @retval  status code that indicates the execution status of the function.
* @note   MUST REMAIN UNCHANGED: \b osThreadSetPriority shall be consistent in every CMSIS-RTOS.
*//**
* @brief  Pass control to next thread that is in state \b READY.
* @retval status code that indicates the execution status of the function.
* @note   MUST REMAIN UNCHANGED: \b osThreadYield shall be consistent in every CMSIS-RTOS.
*//**
* @brief  Terminate execution of a thread and remove it from Active Threads.
* @param   thread_id   thread ID obtained by \ref osThreadCreate or \ref osThreadGetId.
* @retval  status code that indicates the execution status of the function.
* @note   MUST REMAIN UNCHANGED: \b osThreadTerminate shall be consistent in every CMSIS-RTOS.
*//**
* @brief  Return the thread ID of the current running thread.
* @retval thread ID for reference by other functions or NULL in case of error.
* @note   MUST REMAIN UNCHANGED: \b osThreadGetId shall be consistent in every CMSIS-RTOS.
*//**
* @brief  Create a thread and add it to Active Threads and set it to state READY.
* @param  thread_def    thread definition referenced with \ref osThread.
* @param  argument      pointer that is passed to the thread function as start argument.
* @retval thread ID for reference by other functions or NULL in case of error.
* @note   MUST REMAIN UNCHANGED: \b osThreadCreate shall be consistent in every CMSIS-RTOS.
*//*********************** Thread Management *****************************//**
* @brief  Get the value of the Kernel SysTick timer
* @param  None
* @retval None
* @note   MUST REMAIN UNCHANGED: \b osKernelSysTick shall be consistent in every CMSIS-RTOS.
*//**
* @brief  Check if the RTOS kernel is already started
* @param  None
* @retval (0) RTOS is not started
*         (1) RTOS is started
*         (-1) if this feature is disabled in FreeRTOSConfig.h 
* @note  MUST REMAIN UNCHANGED: \b osKernelRunning shall be consistent in every CMSIS-RTOS.
*//**
* @brief  Start the RTOS Kernel with executing the specified thread.
* @param  thread_def    thread definition referenced with \ref osThread.
* @param  argument      pointer that is passed to the thread function as start argument.
* @retval status code that indicates the execution status of the function
* @note   MUST REMAIN UNCHANGED: \b osKernelStart shall be consistent in every CMSIS-RTOS.
*//**
* @brief  Initialize the RTOS Kernel for creating objects.
* @retval status code that indicates the execution status of the function.
* @note   MUST REMAIN UNCHANGED: \b osKernelInitialize shall be consistent in every CMSIS-RTOS.
*//*********************** Kernel Control Functions *****************************//* Determine whether we are in thread mode or handler mode. *//* Convert from FreeRTOS priority number to CMSIS type osPriority *//* Convert from CMSIS type osPriority to FreeRTOS priority number *//*!< inline keyword for GNU Compiler       *//*!< asm keyword for GNU Compiler          *//*
 * ARM Compiler 4/5
 *//* ----------------------------------------------------------------------
 * $Date:        5. February 2013
 * $Revision:    V1.02
 *
 * Project:      CMSIS-RTOS API
 * Title:        cmsis_os.c
 *
 * Version 0.02
 *    Initial Proposal Phase
 * Version 0.03
 *    osKernelStart added, optional feature: main started as thread
 *    osSemaphores have standard behavior
 *    osTimerCreate does not start the timer, added osTimerStart
 *    osThreadPass is renamed to osThreadYield
 * Version 1.01
 *    Support for C++ interface
 *     - const attribute removed from the osXxxxDef_t typedef's
 *     - const attribute added to the osXxxxDef macros
 *    Added: osTimerDelete, osMutexDelete, osSemaphoreDelete
 *    Added: osKernelInitialize
 * Version 1.02
 *    Control functions for short timeouts in microsecond resolution:
 *    Added: osKernelSysTick, osKernelSysTickFrequency, osKernelSysTickMicroSec
 *    Removed: osSignalGet 
 *    
 *  
 *----------------------------------------------------------------------------
 *
 * Portions Copyright  2016 STMicroelectronics International N.V. All rights reserved.
 * Portions Copyright (c) 2013 ARM LIMITED
 * All rights reserved.
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *  - Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *  - Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *  - Neither the name of ARM  nor the names of its contributors may be used
 *    to endorse or promote products derived from this software without
 *    specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 *---------------------------------------------------------------------------*/INC_FREERTOS_HLIST_HconfigLIST_VOLATILE( configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES == 0 )/*
 * Remove an item from a list.  The list item has a pointer to the list that
 * it is in, so only the list item need be passed into the function.
 *
 * @param uxListRemove The item to be removed.  The item will remove itself from
 * the list pointed to by it's pxContainer parameter.
 *
 * @return The number of items that remain in the list after the list item has
 * been removed.
 *
 * \page uxListRemove uxListRemove
 * \ingroup LinkedList
 *//*
 * Insert a list item into a list.  The item will be inserted in a position
 * such that it will be the last item within the list returned by multiple
 * calls to listGET_OWNER_OF_NEXT_ENTRY.
 *
 * The list member pxIndex is used to walk through a list.  Calling
 * listGET_OWNER_OF_NEXT_ENTRY increments pxIndex to the next item in the list.
 * Placing an item in a list using vListInsertEnd effectively places the item
 * in the list position pointed to by pxIndex.  This means that every other
 * item within the list will be returned by listGET_OWNER_OF_NEXT_ENTRY before
 * the pxIndex parameter again points to the item being inserted.
 *
 * @param pxList The list into which the item is to be inserted.
 *
 * @param pxNewListItem The list item to be inserted into the list.
 *
 * \page vListInsertEnd vListInsertEnd
 * \ingroup LinkedList
 *//*
 * Insert a list item into a list.  The item will be inserted into the list in
 * a position determined by its item value (descending item value order).
 *
 * @param pxList The list into which the item is to be inserted.
 *
 * @param pxNewListItem The item that is to be placed in the list.
 *
 * \page vListInsert vListInsert
 * \ingroup LinkedList
 *//*
 * Must be called before a list item is used.  This sets the list container to
 * null so the item does not think that it is already contained in a list.
 *
 * @param pxItem Pointer to the list item being initialised.
 *
 * \page vListInitialiseItem vListInitialiseItem
 * \ingroup LinkedList
 *//*
 * Must be called before a list is used!  This initialises all the members
 * of the list structure and inserts the xListEnd item into the list as a
 * marker to the back of the list.
 *
 * @param pxList Pointer to the list being initialised.
 *
 * \page vListInitialise vListInitialise
 * \ingroup LinkedList
 *//*
 * This provides a crude means of knowing if a list has been initialised, as
 * pxList->xListEnd.xItemValue is set to portMAX_DELAY by the vListInitialise()
 * function.
 *//*
 * Return the list a list item is contained within (referenced from).
 *
 * @param pxListItem The list item being queried.
 * @return A pointer to the List_t object that references the pxListItem
 *//*
 * Check to see if a list item is within a list.  The list item maintains a
 * "container" pointer that points to the list it is in.  All this macro does
 * is check to see if the container and the list match.
 *
 * @param pxList The list we want to know if the list item is within.
 * @param pxListItem The list item we want to know if is in the list.
 * @return pdTRUE if the list item is in the list, otherwise pdFALSE.
 *//*
 * Access function to obtain the owner of the first entry in a list.  Lists
 * are normally sorted in ascending item value order.
 *
 * This function returns the pxOwner member of the first item in the list.
 * The pxOwner parameter of a list item is a pointer to the object that owns
 * the list item.  In the scheduler this is normally a task control block.
 * The pxOwner parameter effectively creates a two way link between the list
 * item and its owner.
 *
 * @param pxList The list from which the owner of the head item is to be
 * returned.
 *
 * \page listGET_OWNER_OF_HEAD_ENTRY listGET_OWNER_OF_HEAD_ENTRY
 * \ingroup LinkedList
 *//* we don't return the marker used at the end of the list.  *//* Increment the index to the next item and return the item, ensuring *//*
 * Access function to obtain the owner of the next entry in a list.
 *
 * The list member pxIndex is used to walk through a list.  Calling
 * listGET_OWNER_OF_NEXT_ENTRY increments pxIndex to the next item in the list
 * and returns that entry's pxOwner parameter.  Using multiple calls to this
 * function it is therefore possible to move through every item contained in
 * a list.
 *
 * The pxOwner parameter of a list item is a pointer to the object that owns
 * the list item.  In the scheduler this is normally a task control block.
 * The pxOwner parameter effectively creates a two way link between the list
 * item and its owner.
 *
 * @param pxTCB pxTCB is set to the address of the owner of the next list item.
 * @param pxList The list from which the next item owner is to be returned.
 *
 * \page listGET_OWNER_OF_NEXT_ENTRY listGET_OWNER_OF_NEXT_ENTRY
 * \ingroup LinkedList
 *//*
 * Access macro to return the number of items in the list.
 *//*
 * Access macro to determine if a list contains any items.  The macro will
 * only have the value true if the list is empty.
 *
 * \page listLIST_IS_EMPTY listLIST_IS_EMPTY
 * \ingroup LinkedList
 *//*
 * Return the list item that marks the end of the list
 *
 * \page listGET_END_MARKER listGET_END_MARKER
 * \ingroup LinkedList
 *//*
 * Return the list item at the head of the list.
 *
 * \page listGET_NEXT listGET_NEXT
 * \ingroup LinkedList
 *//*
 * Return the list item at the head of the list.
 *
 * \page listGET_HEAD_ENTRY listGET_HEAD_ENTRY
 * \ingroup LinkedList
 *//*
 * Access macro to retrieve the value of the list item at the head of a given
 * list.
 *
 * \page listGET_LIST_ITEM_VALUE listGET_LIST_ITEM_VALUE
 * \ingroup LinkedList
 *//*
 * Access macro to retrieve the value of the list item.  The value can
 * represent anything - for example the priority of a task, or the time at
 * which a task should be unblocked.
 *
 * \page listGET_LIST_ITEM_VALUE listGET_LIST_ITEM_VALUE
 * \ingroup LinkedList
 *//*
 * Access macro to set the value of the list item.  In most cases the value is
 * used to sort the list in descending order.
 *
 * \page listSET_LIST_ITEM_VALUE listSET_LIST_ITEM_VALUE
 * \ingroup LinkedList
 *//*
 * Access macro to get the owner of a list item.  The owner of a list item
 * is the object (usually a TCB) that contains the list item.
 *
 * \page listSET_LIST_ITEM_OWNER listSET_LIST_ITEM_OWNER
 * \ingroup LinkedList
 *//*
 * Access macro to set the owner of a list item.  The owner of a list item
 * is the object (usually a TCB) that contains the list item.
 *
 * \page listSET_LIST_ITEM_OWNER listSET_LIST_ITEM_OWNER
 * \ingroup LinkedList
 *//*< Set to a known value if configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. *//*< List item that contains the maximum possible item value meaning it is always at the end of the list and is therefore used as a marker. *//*< Used to walk through the list.  Points to the last item returned by a call to listGET_OWNER_OF_NEXT_ENTRY (). *//*
 * Definition of the type of queue used by the scheduler.
 *//* For some reason lint wants this as two separate definitions. *//*< Pointer to the list in which this list item is placed (if any). *//*< Pointer to the object (normally a TCB) that contains the list item.  There is therefore a two way link between the object containing the list item and the list item itself. *//*< Pointer to the previous ListItem_t in the list. *//*< Pointer to the next ListItem_t in the list. *//*< The value being listed.  In most cases this is used to sort the list in descending order. *//*
 * Definition of the only type of object that a list can contain.
 *//* configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES *//* Define macros that will assert if one of the structure members does not
	contain its expected value. *//* Define macros that set the new structure members to known values. *//* Define macros that add new members into the list structures. *//* Define the macros to do nothing. *//* Macros that can be used to place known values within the list structures,
then check that the known values do not get corrupted during the execution of
the application.   These may catch the list data structures being overwritten in
memory.  They will not catch data errors caused by incorrect configuration or
use of FreeRTOS.*//* configSUPPORT_CROSS_MODULE_OPTIMISATION *//*
 * The list structure members are modified from within interrupts, and therefore
 * by rights should be declared volatile.  However, they are only modified in a
 * functionally atomic way (within critical sections of with the scheduler
 * suspended) and are either passed by reference into a function or indexed via
 * a volatile variable.  Therefore, in all use cases tested so far, the volatile
 * qualifier can be omitted in order to provide a moderate performance
 * improvement without adversely affecting functional behaviour.  The assembly
 * instructions generated by the IAR, ARM and GCC compilers when the respective
 * compiler's options were set for maximum optimisation has been inspected and
 * deemed to be as intended.  That said, as compiler technology advances, and
 * especially if aggressive cross module optimisation is used (a use case that
 * has not been exercised to any great extend) then it is feasible that the
 * volatile qualifier will be needed for correct optimisation.  It is expected
 * that a compiler removing essential code because, without the volatile
 * qualifier on the list structure members and with aggressive cross module
 * optimisation, the compiler deemed the code unnecessary will result in
 * complete and obvious failure of the scheduler.  If this is ever experienced
 * then the volatile qualifier can be inserted in the relevant places within the
 * list structures by simply defining configLIST_VOLATILE to volatile in
 * FreeRTOSConfig.h (as per the example at the bottom of this comment block).
 * If configLIST_VOLATILE is not defined then the preprocessor directives below
 * will simply #define configLIST_VOLATILE away completely.
 *
 * To use volatile list structure members then add the following line to
 * FreeRTOSConfig.h (without the quotes):
 * "#define configLIST_VOLATILE volatile"
 *//*
 * This is the list implementation used by the scheduler.  While it is tailored
 * heavily for the schedulers needs, it is also available for use by
 * application code.
 *
 * list_ts can only store pointers to list_item_ts.  Each ListItem_t contains a
 * numeric value (xItemValue).  Most of the time the lists are sorted in
 * descending item value order.
 *
 * Lists are created already containing one list item.  The value of this
 * item is the maximum possible that can be stored, it is therefore always at
 * the end of the list and acts as a marker.  The list member pxHead always
 * points to this marker - even though it is at the tail of the list.  This
 * is because the tail contains a wrap back pointer to the true head of
 * the list.
 *
 * In addition to it's value, each list item contains a pointer to the next
 * item in the list (pxNext), a pointer to the list it is in (pxContainer)
 * and a pointer to back to the object that contains it.  These later two
 * pointers are included for efficiency of list manipulation.  There is
 * effectively a two way link between the object containing the list item and
 * the list item itself.
 *
 *
 * \page ListIntroduction List Implementation
 * \ingroup FreeRTOSIntro
 *//*
 * FreeRTOS Kernel V10.2.1
 * Copyright (C) 2019 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
 * the Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
 * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 * http://www.FreeRTOS.org
 * http://aws.amazon.com/freertos
 *
 * 1 tab == 4 spaces!
 *//Users/jie/Documents/posixGen_Demos-main/LwIP_StreamingServer/Middlewares/Third_Party/FreeRTOS/Source/include/Users/jie/Documents/posixGen_Demos-main/LwIP_StreamingServer/Middlewares/Third_Party/FreeRTOS/Source/include/croutine.h"list.h"xCoRoutineRemoveFromEventListconst List_tconst List_t *xLIST *vCoRoutineAddToDelayedListList_t *vCoRoutineSchedulexCoRoutineCreateCRCB_tcorCoRoutineControlBlockcrCOROUTINE_CODECoRoutineHandle_tuxStateuxIndexuxPriorityxEventListItemxGenericListItempxCoRoutineFunctioncrQUEUE_RECEIVE_FROM_ISR(pxQueue,pvBuffer,pxCoRoutineWoken)xQueueCRReceiveFromISR( ( pxQueue ), ( pvBuffer ), ( pxCoRoutineWoken ) )crQUEUE_SEND_FROM_ISR(pxQueue,pvItemToQueue,xCoRoutinePreviouslyWoken)xQueueCRSendFromISR( ( pxQueue ), ( pvItemToQueue ), ( xCoRoutinePreviouslyWoken ) )crQUEUE_RECEIVE(xHandle,pxQueue,pvBuffer,xTicksToWait,pxResult){ *( pxResult ) = xQueueCRReceive( ( pxQueue) , ( pvBuffer ), ( xTicksToWait ) ); if( *( pxResult ) == errQUEUE_BLOCKED ) { crSET_STATE0( ( xHandle ) ); *( pxResult ) = xQueueCRReceive( ( pxQueue) , ( pvBuffer ), 0 ); } if( *( pxResult ) == errQUEUE_YIELD ) { crSET_STATE1( ( xHandle ) ); *( pxResult ) = pdPASS; } }crQUEUE_SEND(xHandle,pxQueue,pvItemToQueue,xTicksToWait,pxResult){ *( pxResult ) = xQueueCRSend( ( pxQueue) , ( pvItemToQueue) , ( xTicksToWait ) ); if( *( pxResult ) == errQUEUE_BLOCKED ) { crSET_STATE0( ( xHandle ) ); *pxResult = xQueueCRSend( ( pxQueue ), ( pvItemToQueue ), 0 ); } if( *pxResult == errQUEUE_YIELD ) { crSET_STATE1( ( xHandle ) ); *pxResult = pdPASS; } }crDELAY(xHandle,xTicksToDelay)if( ( xTicksToDelay ) > 0 ) { vCoRoutineAddToDelayedList( ( xTicksToDelay ), NULL ); } crSET_STATE0( ( xHandle ) );crSET_STATE1(xHandle)( ( CRCB_t * )( xHandle ) )->uxState = ((__LINE__ * 2)+1); return; case ((__LINE__ * 2)+1):crSET_STATE0(xHandle)( ( CRCB_t * )( xHandle ) )->uxState = (__LINE__ * 2); return; case (__LINE__ * 2):crEND()}crSTART(pxCRCB)switch( ( ( CRCB_t * )( pxCRCB ) )->uxState ) { case 0:CO_ROUTINE_H/* CO_ROUTINE_H *//*
 * This function is intended for internal use by the queue implementation only.
 * The function should not be used by application writers.
 *
 * Removes the highest priority co-routine from the event list and places it in
 * the pending ready list.
 *//*
 * This function is intended for internal use by the co-routine macros only.
 * The macro nature of the co-routine implementation requires that the
 * prototype appears here.  The function should not be used by application
 * writers.
 *
 * Removes the current co-routine from its ready list and places it in the
 * appropriate delayed list.
 *//**
 * croutine. h
 * <pre>
  crQUEUE_SEND_FROM_ISR(
                            QueueHandle_t pxQueue,
                            void *pvBuffer,
                            BaseType_t * pxCoRoutineWoken
                       )</pre>
 *
 * The macro's crQUEUE_SEND_FROM_ISR() and crQUEUE_RECEIVE_FROM_ISR() are the
 * co-routine equivalent to the xQueueSendFromISR() and xQueueReceiveFromISR()
 * functions used by tasks.
 *
 * crQUEUE_SEND_FROM_ISR() and crQUEUE_RECEIVE_FROM_ISR() can only be used to
 * pass data between a co-routine and and ISR, whereas xQueueSendFromISR() and
 * xQueueReceiveFromISR() can only be used to pass data between a task and and
 * ISR.
 *
 * crQUEUE_RECEIVE_FROM_ISR can only be called from an ISR to receive data
 * from a queue that is being used from within a co-routine (a co-routine
 * posted to the queue).
 *
 * See the co-routine section of the WEB documentation for information on
 * passing data between tasks and co-routines and between ISR's and
 * co-routines.
 *
 * @param xQueue The handle to the queue on which the item is to be posted.
 *
 * @param pvBuffer A pointer to a buffer into which the received item will be
 * placed.  The size of the items the queue will hold was defined when the
 * queue was created, so this many bytes will be copied from the queue into
 * pvBuffer.
 *
 * @param pxCoRoutineWoken A co-routine may be blocked waiting for space to become
 * available on the queue.  If crQUEUE_RECEIVE_FROM_ISR causes such a
 * co-routine to unblock *pxCoRoutineWoken will get set to pdTRUE, otherwise
 * *pxCoRoutineWoken will remain unchanged.
 *
 * @return pdTRUE an item was successfully received from the queue, otherwise
 * pdFALSE.
 *
 * Example usage:
 <pre>
 // A co-routine that posts a character to a queue then blocks for a fixed
 // period.  The character is incremented each time.
 static void vSendingCoRoutine( CoRoutineHandle_t xHandle, UBaseType_t uxIndex )
 {
 // cChar holds its value while this co-routine is blocked and must therefore
 // be declared static.
 static char cCharToTx = 'a';
 BaseType_t xResult;

     // All co-routines must start with a call to crSTART().
     crSTART( xHandle );

     for( ;; )
     {
         // Send the next character to the queue.
         crQUEUE_SEND( xHandle, xCoRoutineQueue, &cCharToTx, NO_DELAY, &xResult );

         if( xResult == pdPASS )
         {
             // The character was successfully posted to the queue.
         }
		 else
		 {
			// Could not post the character to the queue.
		 }

         // Enable the UART Tx interrupt to cause an interrupt in this
		 // hypothetical UART.  The interrupt will obtain the character
		 // from the queue and send it.
		 ENABLE_RX_INTERRUPT();

		 // Increment to the next character then block for a fixed period.
		 // cCharToTx will maintain its value across the delay as it is
		 // declared static.
		 cCharToTx++;
		 if( cCharToTx > 'x' )
		 {
			cCharToTx = 'a';
		 }
		 crDELAY( 100 );
     }

     // All co-routines must end with a call to crEND().
     crEND();
 }

 // An ISR that uses a queue to receive characters to send on a UART.
 void vUART_ISR( void )
 {
 char cCharToTx;
 BaseType_t xCRWokenByPost = pdFALSE;

     while( UART_TX_REG_EMPTY() )
     {
         // Are there any characters in the queue waiting to be sent?
		 // xCRWokenByPost will automatically be set to pdTRUE if a co-routine
		 // is woken by the post - ensuring that only a single co-routine is
		 // woken no matter how many times we go around this loop.
         if( crQUEUE_RECEIVE_FROM_ISR( pxQueue, &cCharToTx, &xCRWokenByPost ) )
		 {
			 SEND_CHARACTER( cCharToTx );
		 }
     }
 }</pre>
 * \defgroup crQUEUE_RECEIVE_FROM_ISR crQUEUE_RECEIVE_FROM_ISR
 * \ingroup Tasks
 *//**
 * croutine. h
 * <pre>
  crQUEUE_SEND_FROM_ISR(
                            QueueHandle_t pxQueue,
                            void *pvItemToQueue,
                            BaseType_t xCoRoutinePreviouslyWoken
                       )</pre>
 *
 * The macro's crQUEUE_SEND_FROM_ISR() and crQUEUE_RECEIVE_FROM_ISR() are the
 * co-routine equivalent to the xQueueSendFromISR() and xQueueReceiveFromISR()
 * functions used by tasks.
 *
 * crQUEUE_SEND_FROM_ISR() and crQUEUE_RECEIVE_FROM_ISR() can only be used to
 * pass data between a co-routine and and ISR, whereas xQueueSendFromISR() and
 * xQueueReceiveFromISR() can only be used to pass data between a task and and
 * ISR.
 *
 * crQUEUE_SEND_FROM_ISR can only be called from an ISR to send data to a queue
 * that is being used from within a co-routine.
 *
 * See the co-routine section of the WEB documentation for information on
 * passing data between tasks and co-routines and between ISR's and
 * co-routines.
 *
 * @param xQueue The handle to the queue on which the item is to be posted.
 *
 * @param pvItemToQueue A pointer to the item that is to be placed on the
 * queue.  The size of the items the queue will hold was defined when the
 * queue was created, so this many bytes will be copied from pvItemToQueue
 * into the queue storage area.
 *
 * @param xCoRoutinePreviouslyWoken This is included so an ISR can post onto
 * the same queue multiple times from a single interrupt.  The first call
 * should always pass in pdFALSE.  Subsequent calls should pass in
 * the value returned from the previous call.
 *
 * @return pdTRUE if a co-routine was woken by posting onto the queue.  This is
 * used by the ISR to determine if a context switch may be required following
 * the ISR.
 *
 * Example usage:
 <pre>
 // A co-routine that blocks on a queue waiting for characters to be received.
 static void vReceivingCoRoutine( CoRoutineHandle_t xHandle, UBaseType_t uxIndex )
 {
 char cRxedChar;
 BaseType_t xResult;

     // All co-routines must start with a call to crSTART().
     crSTART( xHandle );

     for( ;; )
     {
         // Wait for data to become available on the queue.  This assumes the
         // queue xCommsRxQueue has already been created!
         crQUEUE_RECEIVE( xHandle, xCommsRxQueue, &uxLEDToFlash, portMAX_DELAY, &xResult );

         // Was a character received?
         if( xResult == pdPASS )
         {
             // Process the character here.
         }
     }

     // All co-routines must end with a call to crEND().
     crEND();
 }

 // An ISR that uses a queue to send characters received on a serial port to
 // a co-routine.
 void vUART_ISR( void )
 {
 char cRxedChar;
 BaseType_t xCRWokenByPost = pdFALSE;

     // We loop around reading characters until there are none left in the UART.
     while( UART_RX_REG_NOT_EMPTY() )
     {
         // Obtain the character from the UART.
         cRxedChar = UART_RX_REG;

         // Post the character onto a queue.  xCRWokenByPost will be pdFALSE
         // the first time around the loop.  If the post causes a co-routine
         // to be woken (unblocked) then xCRWokenByPost will be set to pdTRUE.
         // In this manner we can ensure that if more than one co-routine is
         // blocked on the queue only one is woken by this ISR no matter how
         // many characters are posted to the queue.
         xCRWokenByPost = crQUEUE_SEND_FROM_ISR( xCommsRxQueue, &cRxedChar, xCRWokenByPost );
     }
 }</pre>
 * \defgroup crQUEUE_SEND_FROM_ISR crQUEUE_SEND_FROM_ISR
 * \ingroup Tasks
 *//**
 * croutine. h
 * <pre>
  crQUEUE_RECEIVE(
                     CoRoutineHandle_t xHandle,
                     QueueHandle_t pxQueue,
                     void *pvBuffer,
                     TickType_t xTicksToWait,
                     BaseType_t *pxResult
                 )</pre>
 *
 * The macro's crQUEUE_SEND() and crQUEUE_RECEIVE() are the co-routine
 * equivalent to the xQueueSend() and xQueueReceive() functions used by tasks.
 *
 * crQUEUE_SEND and crQUEUE_RECEIVE can only be used from a co-routine whereas
 * xQueueSend() and xQueueReceive() can only be used from tasks.
 *
 * crQUEUE_RECEIVE can only be called from the co-routine function itself - not
 * from within a function called by the co-routine function.  This is because
 * co-routines do not maintain their own stack.
 *
 * See the co-routine section of the WEB documentation for information on
 * passing data between tasks and co-routines and between ISR's and
 * co-routines.
 *
 * @param xHandle The handle of the calling co-routine.  This is the xHandle
 * parameter of the co-routine function.
 *
 * @param pxQueue The handle of the queue from which the data will be received.
 * The handle is obtained as the return value when the queue is created using
 * the xQueueCreate() API function.
 *
 * @param pvBuffer The buffer into which the received item is to be copied.
 * The number of bytes of each queued item is specified when the queue is
 * created.  This number of bytes is copied into pvBuffer.
 *
 * @param xTickToDelay The number of ticks that the co-routine should block
 * to wait for data to become available from the queue, should data not be
 * available immediately. The actual amount of time this equates to is defined
 * by configTICK_RATE_HZ (set in FreeRTOSConfig.h).  The constant
 * portTICK_PERIOD_MS can be used to convert ticks to milliseconds (see the
 * crQUEUE_SEND example).
 *
 * @param pxResult The variable pointed to by pxResult will be set to pdPASS if
 * data was successfully retrieved from the queue, otherwise it will be set to
 * an error code as defined within ProjDefs.h.
 *
 * Example usage:
 <pre>
 // A co-routine receives the number of an LED to flash from a queue.  It
 // blocks on the queue until the number is received.
 static void prvCoRoutineFlashWorkTask( CoRoutineHandle_t xHandle, UBaseType_t uxIndex )
 {
 // Variables in co-routines must be declared static if they must maintain value across a blocking call.
 static BaseType_t xResult;
 static UBaseType_t uxLEDToFlash;

    // All co-routines must start with a call to crSTART().
    crSTART( xHandle );

    for( ;; )
    {
        // Wait for data to become available on the queue.
        crQUEUE_RECEIVE( xHandle, xCoRoutineQueue, &uxLEDToFlash, portMAX_DELAY, &xResult );

        if( xResult == pdPASS )
        {
            // We received the LED to flash - flash it!
            vParTestToggleLED( uxLEDToFlash );
        }
    }

    crEND();
 }</pre>
 * \defgroup crQUEUE_RECEIVE crQUEUE_RECEIVE
 * \ingroup Tasks
 *//**
 * <pre>
 crQUEUE_SEND(
                  CoRoutineHandle_t xHandle,
                  QueueHandle_t pxQueue,
                  void *pvItemToQueue,
                  TickType_t xTicksToWait,
                  BaseType_t *pxResult
             )</pre>
 *
 * The macro's crQUEUE_SEND() and crQUEUE_RECEIVE() are the co-routine
 * equivalent to the xQueueSend() and xQueueReceive() functions used by tasks.
 *
 * crQUEUE_SEND and crQUEUE_RECEIVE can only be used from a co-routine whereas
 * xQueueSend() and xQueueReceive() can only be used from tasks.
 *
 * crQUEUE_SEND can only be called from the co-routine function itself - not
 * from within a function called by the co-routine function.  This is because
 * co-routines do not maintain their own stack.
 *
 * See the co-routine section of the WEB documentation for information on
 * passing data between tasks and co-routines and between ISR's and
 * co-routines.
 *
 * @param xHandle The handle of the calling co-routine.  This is the xHandle
 * parameter of the co-routine function.
 *
 * @param pxQueue The handle of the queue on which the data will be posted.
 * The handle is obtained as the return value when the queue is created using
 * the xQueueCreate() API function.
 *
 * @param pvItemToQueue A pointer to the data being posted onto the queue.
 * The number of bytes of each queued item is specified when the queue is
 * created.  This number of bytes is copied from pvItemToQueue into the queue
 * itself.
 *
 * @param xTickToDelay The number of ticks that the co-routine should block
 * to wait for space to become available on the queue, should space not be
 * available immediately. The actual amount of time this equates to is defined
 * by configTICK_RATE_HZ (set in FreeRTOSConfig.h).  The constant
 * portTICK_PERIOD_MS can be used to convert ticks to milliseconds (see example
 * below).
 *
 * @param pxResult The variable pointed to by pxResult will be set to pdPASS if
 * data was successfully posted onto the queue, otherwise it will be set to an
 * error defined within ProjDefs.h.
 *
 * Example usage:
   <pre>
 // Co-routine function that blocks for a fixed period then posts a number onto
 // a queue.
 static void prvCoRoutineFlashTask( CoRoutineHandle_t xHandle, UBaseType_t uxIndex )
 {
 // Variables in co-routines must be declared static if they must maintain value across a blocking call.
 static BaseType_t xNumberToPost = 0;
 static BaseType_t xResult;

    // Co-routines must begin with a call to crSTART().
    crSTART( xHandle );

    for( ;; )
    {
        // This assumes the queue has already been created.
        crQUEUE_SEND( xHandle, xCoRoutineQueue, &xNumberToPost, NO_DELAY, &xResult );

        if( xResult != pdPASS )
        {
            // The message was not posted!
        }

        // Increment the number to be posted onto the queue.
        xNumberToPost++;

        // Delay for 100 ticks.
        crDELAY( xHandle, 100 );
    }

    // Co-routines must end with a call to crEND().
    crEND();
 }</pre>
 * \defgroup crQUEUE_SEND crQUEUE_SEND
 * \ingroup Tasks
 *//**
 * croutine. h
 *<pre>
 crDELAY( CoRoutineHandle_t xHandle, TickType_t xTicksToDelay );</pre>
 *
 * Delay a co-routine for a fixed period of time.
 *
 * crDELAY can only be called from the co-routine function itself - not
 * from within a function called by the co-routine function.  This is because
 * co-routines do not maintain their own stack.
 *
 * @param xHandle The handle of the co-routine to delay.  This is the xHandle
 * parameter of the co-routine function.
 *
 * @param xTickToDelay The number of ticks that the co-routine should delay
 * for.  The actual amount of time this equates to is defined by
 * configTICK_RATE_HZ (set in FreeRTOSConfig.h).  The constant portTICK_PERIOD_MS
 * can be used to convert ticks to milliseconds.
 *
 * Example usage:
   <pre>
 // Co-routine to be created.
 void vACoRoutine( CoRoutineHandle_t xHandle, UBaseType_t uxIndex )
 {
 // Variables in co-routines must be declared static if they must maintain value across a blocking call.
 // This may not be necessary for const variables.
 // We are to delay for 200ms.
 static const xTickType xDelayTime = 200 / portTICK_PERIOD_MS;

     // Must start every co-routine with a call to crSTART();
     crSTART( xHandle );

     for( ;; )
     {
        // Delay for 200ms.
        crDELAY( xHandle, xDelayTime );

        // Do something here.
     }

     // Must end every co-routine with a call to crEND();
     crEND();
 }</pre>
 * \defgroup crDELAY crDELAY
 * \ingroup Tasks
 *//*
 * These macros are intended for internal use by the co-routine implementation
 * only.  The macros should not be used directly by application writers.
 *//**
 * croutine. h
 * <pre>
 crEND();</pre>
 *
 * This macro MUST always be called at the end of a co-routine function.
 *
 * Example usage:
   <pre>
 // Co-routine to be created.
 void vACoRoutine( CoRoutineHandle_t xHandle, UBaseType_t uxIndex )
 {
 // Variables in co-routines must be declared static if they must maintain value across a blocking call.
 static int32_t ulAVariable;

     // Must start every co-routine with a call to crSTART();
     crSTART( xHandle );

     for( ;; )
     {
          // Co-routine functionality goes here.
     }

     // Must end every co-routine with a call to crEND();
     crEND();
 }</pre>
 * \defgroup crSTART crSTART
 * \ingroup Tasks
 *//**
 * croutine. h
 * <pre>
 crSTART( CoRoutineHandle_t xHandle );</pre>
 *
 * This macro MUST always be called at the start of a co-routine function.
 *
 * Example usage:
   <pre>
 // Co-routine to be created.
 void vACoRoutine( CoRoutineHandle_t xHandle, UBaseType_t uxIndex )
 {
 // Variables in co-routines must be declared static if they must maintain value across a blocking call.
 static int32_t ulAVariable;

     // Must start every co-routine with a call to crSTART();
     crSTART( xHandle );

     for( ;; )
     {
          // Co-routine functionality goes here.
     }

     // Must end every co-routine with a call to crEND();
     crEND();
 }</pre>
 * \defgroup crSTART crSTART
 * \ingroup Tasks
 *//**
 * croutine. h
 *<pre>
 void vCoRoutineSchedule( void );</pre>
 *
 * Run a co-routine.
 *
 * vCoRoutineSchedule() executes the highest priority co-routine that is able
 * to run.  The co-routine will execute until it either blocks, yields or is
 * preempted by a task.  Co-routines execute cooperatively so one
 * co-routine cannot be preempted by another, but can be preempted by a task.
 *
 * If an application comprises of both tasks and co-routines then
 * vCoRoutineSchedule should be called from the idle task (in an idle task
 * hook).
 *
 * Example usage:
   <pre>
 // This idle task hook will schedule a co-routine each time it is called.
 // The rest of the idle task will execute between co-routine calls.
 void vApplicationIdleHook( void )
 {
	vCoRoutineSchedule();
 }

 // Alternatively, if you do not require any other part of the idle task to
 // execute, the idle task hook can call vCoRoutineScheduler() within an
 // infinite loop.
 void vApplicationIdleHook( void )
 {
    for( ;; )
    {
        vCoRoutineSchedule();
    }
 }
 </pre>
 * \defgroup vCoRoutineSchedule vCoRoutineSchedule
 * \ingroup Tasks
 *//**
 * croutine. h
 *<pre>
 BaseType_t xCoRoutineCreate(
                                 crCOROUTINE_CODE pxCoRoutineCode,
                                 UBaseType_t uxPriority,
                                 UBaseType_t uxIndex
                               );</pre>
 *
 * Create a new co-routine and add it to the list of co-routines that are
 * ready to run.
 *
 * @param pxCoRoutineCode Pointer to the co-routine function.  Co-routine
 * functions require special syntax - see the co-routine section of the WEB
 * documentation for more information.
 *
 * @param uxPriority The priority with respect to other co-routines at which
 *  the co-routine will run.
 *
 * @param uxIndex Used to distinguish between different co-routines that
 * execute the same function.  See the example below and the co-routine section
 * of the WEB documentation for further information.
 *
 * @return pdPASS if the co-routine was successfully created and added to a ready
 * list, otherwise an error code defined with ProjDefs.h.
 *
 * Example usage:
   <pre>
 // Co-routine to be created.
 void vFlashCoRoutine( CoRoutineHandle_t xHandle, UBaseType_t uxIndex )
 {
 // Variables in co-routines must be declared static if they must maintain value across a blocking call.
 // This may not be necessary for const variables.
 static const char cLedToFlash[ 2 ] = { 5, 6 };
 static const TickType_t uxFlashRates[ 2 ] = { 200, 400 };

     // Must start every co-routine with a call to crSTART();
     crSTART( xHandle );

     for( ;; )
     {
         // This co-routine just delays for a fixed period, then toggles
         // an LED.  Two co-routines are created using this function, so
         // the uxIndex parameter is used to tell the co-routine which
         // LED to flash and how int32_t to delay.  This assumes xQueue has
         // already been created.
         vParTestToggleLED( cLedToFlash[ uxIndex ] );
         crDELAY( xHandle, uxFlashRates[ uxIndex ] );
     }

     // Must end every co-routine with a call to crEND();
     crEND();
 }

 // Function that creates two co-routines.
 void vOtherFunction( void )
 {
 uint8_t ucParameterToPass;
 TaskHandle_t xHandle;

     // Create two co-routines at priority 0.  The first is given index 0
     // so (from the code above) toggles LED 5 every 200 ticks.  The second
     // is given index 1 so toggles LED 6 every 400 ticks.
     for( uxIndex = 0; uxIndex < 2; uxIndex++ )
     {
         xCoRoutineCreate( vFlashCoRoutine, 0, uxIndex );
     }
 }
   </pre>
 * \defgroup xCoRoutineCreate xCoRoutineCreate
 * \ingroup Tasks
 *//* Co-routine control block.  Note must be identical in size down to uxPriority with TCB_t. *//*< Used internally by the co-routine implementation. *//*< Used to distinguish between co-routines when multiple co-routines use the same co-routine function. *//*< The priority of the co-routine in relation to other co-routines. *//*< List item used to place the CRCB in event lists. *//*< List item used to place the CRCB in ready and blocked queues. *//* Defines the prototype to which co-routine functions must conform. *//* Used to hide the implementation of the co-routine control block.  The
control block structure however has to be included in the header due to
the macro implementation of the co-routine functionality. */pxEventListxTicksToDelaypxCoRoutineCode/Users/jie/Documents/posixGen_Demos-main/LwIP_StreamingServer/Middlewares/Third_Party/FreeRTOS/Source/croutine.c"croutine.h"( configUSE_CO_ROUTINES != 0 )portREMOVE_STATIC_QUALIFIER/* configUSE_CO_ROUTINES == 0 *//* This function is called from within an interrupt.  It can only access
	event lists and the pending ready list.  This function assumes that a
	check has already been made to ensure pxEventList is not empty. *//*-----------------------------------------------------------*//* Start with pxDelayedCoRoutineList using list1 and the
	pxOverflowDelayedCoRoutineList using list2. *//* Call the co-routine. *//* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the co-routines
	 of the	same priority get an equal share of the processor time. *//* No more co-routines to check. *//* Find the highest priority queue that contains ready co-routines. *//* See if any delayed co-routines have timed out. *//* See if any co-routines readied by events need moving to the ready lists. *//* Is the co-routine waiting on an event also? *//* The event could have occurred just before this critical
				section.  If this is the case then the generic list item will
				have been moved to the pending ready list and the following
				line is still valid.  Also the pvContainer parameter will have
				been set to NULL so the following lines are also valid. *//* Timeout not yet expired. *//* See if this tick has made a timeout expire. *//* Tick count has overflowed so we need to swap the delay lists.  If there are
			any items in pxDelayedCoRoutineList here then there is an error! *//* If the tick count has overflowed we need to swap the ready lists. *//* The pending ready list can be accessed by an ISR. *//* Are there any co-routines waiting to get moved to the ready list?  These
	are co-routines that have been readied by an ISR.  The ISR cannot access
	the	ready lists itself. *//* Also add the co-routine to an event list.  If this is done then the
		function must be called with interrupts disabled. *//* The wake time has not overflowed, so we can use the
		current block list. *//* Wake time has overflowed.  Place this item in the
		overflow list. *//* The list item will be inserted in wake time order. *//* We must remove ourselves from the ready list before adding
	ourselves to the blocked list as the same list item is used for
	both lists. *//* Calculate the time to wake - this may overflow but this is
	not a problem. *//* Now the co-routine has been initialised it can be added to the ready
		list at the correct priority. *//* Event lists are always in priority order. *//* Set the co-routine control block as a link back from the ListItem_t.
		This is so we can get back to the containing CRCB from a generic item
		in a list. *//* Initialise all the other co-routine control block parameters. *//* Fill out the co-routine control block from the function parameters. *//* Check the priority is within limits. *//* If pxCurrentCoRoutine is NULL then this is the first co-routine to
		be created and the co-routine data structures need initialising. *//* Allocate the memory that will store the co-routine control block. *//*
 * Macro that looks at the list of co-routines that are currently delayed to
 * see if any require waking.
 *
 * Co-routines are stored in the queue in the order of their wake time -
 * meaning once one co-routine has been found whose timer has not expired
 * we need not look any further down the list.
 *//*
 * Co-routines that are readied by an interrupt cannot be placed directly into
 * the ready lists (there is no mutual exclusion).  Instead they are placed in
 * in the pending ready list in order that they can later be moved to the ready
 * list by the co-routine scheduler.
 *//*
 * Utility to ready all the lists used by the scheduler.  This is called
 * automatically upon the creation of the first co-routine.
 *//*
 * Place the co-routine represented by pxCRCB into the appropriate ready queue
 * for the priority.  It is inserted at the end of the list.
 *
 * This macro accesses the co-routine ready lists and therefore must not be
 * used from within an ISR.
 *//* The initial state of the co-routine when it is created. *//* Other file private variables. --------------------------------*//*< Holds co-routines that have been readied by an external event.  They cannot be added directly to the ready lists as the ready lists cannot be accessed by interrupts. *//*< Points to the delayed co-routine list currently being used to hold co-routines that have overflowed the current tick count. *//*< Points to the delayed co-routine list currently being used. *//*< Delayed co-routines (two lists are used - one for delays that have overflowed the current tick count. *//*< Delayed co-routines. *//*< Prioritised ready co-routines. *//* Lists for ready and blocked co-routines. --------------------*//*
 * Some kernel aware debuggers require data to be viewed to be global, rather
 * than file scope.
 *//* Remove the whole file is co-routines are not being used. *//Users/jie/Documents/arm-gnu-toolchain-14.3.rel1-darwin-arm64-arm-none-eabi/arm-none-eabi/include/stdlib.h/Users/jie/Documents/arm-gnu-toolchain-14.3.rel1-darwin-arm64-arm-none-eabi/arm-none-eabi/include/machine/stdlib.h/Users/jie/Documents/arm-gnu-toolchain-14.3.rel1-darwin-arm64-arm-none-eabi/arm-none-eabi/include/alloca.h/Users/jie/Documents/posixGen_Demos-main/LwIP_StreamingServer/Middlewares/Third_Party/FreeRTOS/Source/list.c<stdlib.h>uxListRemoveListItem_t *xLIST_ITEM *ListItem_t *constList_t *constpxListvolatile UBaseType_tvListInsertpxIteratorxValueOfInsertionMiniListItem_t *xMINI_LIST_ITEM *pxNewListItemvListInsertEndpxIndexvListInitialiseItempxItemvListInitialise( UBaseType_t ) 0U/* Make sure the index is left pointing to a valid item. *//* Only used during decision coverage testing. *//* The list item knows which list it is in.  Obtain the list from the list
item. *//* Remember which list the item is in.  This allows fast removal of the
	item later. *//* There is nothing to do here, just iterating to the wanted
			insertion position. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. *//*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//* *** NOTE ***********************************************************
		If you find your application is crashing here then likely causes are
		listed below.  In addition see https://www.freertos.org/FAQHelp.html for
		more tips, and ensure configASSERT() is defined!
		https://www.freertos.org/a00110.html#configASSERT

			1) Stack overflow -
			   see https://www.freertos.org/Stacks-and-stack-overflow-checking.html
			2) Incorrect interrupt priority assignment, especially on Cortex-M
			   parts where numerically high priority values denote low actual
			   interrupt priorities, which can seem counter intuitive.  See
			   https://www.freertos.org/RTOS-Cortex-M3-M4.html and the definition
			   of configMAX_SYSCALL_INTERRUPT_PRIORITY on
			   https://www.freertos.org/a00110.html
			3) Calling an API function from within a critical section or when
			   the scheduler is suspended, or calling an API function that does
			   not end in "FromISR" from an interrupt.
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************//* Insert the new list item into the list, sorted in xItemValue order.

	If the list already contains a list item with the same item value then the
	new list item should be placed after it.  This ensures that TCBs which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. *//* Only effective when configASSERT() is also defined, these tests may catch
	the list data structures being overwritten in memory.  They will not catch
	data errors caused by incorrect configuration or use of FreeRTOS. *//* Remember which list the item is in. *//* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). *//* Write known values into the list item if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. *//* Make sure the list item is not recorded as being on a list. *//* Write known values into the list if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. *//* The list end next and previous pointers point to itself so we know
	when the list is empty. *//* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. *//* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. *//*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/pxItemToRemove/Users/jie/Documents/posixGen_Demos-main/LwIP_StreamingServer/Middlewares/Third_Party/FreeRTOS/Source/portable/GCC/ARM_CM7/r0p1/port.cvPortValidateInterruptPriorityulCurrentInterruptucCurrentPriorityucCurrentPriority >= ucMaxSysCallPriorityportFIRST_USER_INTERRUPT_NUMBERconst volatile uint8_tconst volatile uint8_t *3758154736pcInterruptPriorityRegisters( portAIRCR_REG & portPRIORITY_GROUP_MASK ) <= ulMaxPRIGROUPValue( ( * ( ( volatile uint32_t * ) 0xE000ED0C ) ) & ( 0x07UL << 8UL ) ) <= ulMaxPRIGROUPValue3758157068vPortEnableVFPvPortSetupTimerInterrupt37581537523758153748configTICK_RATE_HZportNVIC_SYSTICK_CLK_BITportNVIC_SYSTICK_INT_BITportNVIC_SYSTICK_ENABLE_BIT( portNVIC_SYSTICK_CLK_BIT | portNVIC_SYSTICK_INT_BIT | portNVIC_SYSTICK_ENABLE_BIT )portNVIC_PENDSVSET_BITPendSV_HandlerconfigMAX_SYSCALL_INTERRUPT_PRIORITYvPortExitCriticaluxCriticalNestingvPortEnterCritical( portNVIC_INT_CTRL_REG & portVECTACTIVE_MASK ) == 0( ( * ( ( volatile uint32_t * ) 0xe000ed04 ) ) & ( 0xFFUL ) ) == 0vPortEndScheduleruxCriticalNesting == 1000ULxPortStartScheduler3758157088portNVIC_PENDSV_PRIportNVIC_SYSTICK_PRI3758157620portFPCCR( portFPCCR )portASPEN_AND_LSPEN_BITSprvPortStartFirstTaskSVC_HandlerprvTaskExitErrorulDummyuxCriticalNesting == ~0ULStackType_t *pxPortInitialiseStackportINITIAL_XPSRportSTART_ADDRESS_MASKportINITIAL_EXC_RETURNconst volatile uint8_t *const( const volatile uint8_t * const ) portNVIC_IP_REGISTERS_OFFSET_16ulMaxPRIGROUPValueucMaxSysCallPriority28633115300xaaaaaaaaportTASK_RETURN_ADDRESSportMISSED_COUNTS_FACTOR( 45UL )( ( StackType_t ) 0xfffffffeUL )portMAX_24_BIT_NUMBER( 0xffffffUL )( 0xfffffffd )( 0x01000000 )( 0x3UL << 30UL )( ( volatile uint32_t * ) 0xe000ef34 )portVECTACTIVE_MASK( 0xFFUL )portPRIGROUP_SHIFT( 8UL )portPRIORITY_GROUP_MASK( 0x07UL << 8UL )portMAX_PRIGROUP_BITS( ( uint8_t ) 7 )portTOP_BIT_OF_BYTE( ( uint8_t ) 0x80 )portMAX_8_BIT_VALUE( ( uint8_t ) 0xff )portAIRCR_REG( * ( ( volatile uint32_t * ) 0xE000ED0C ) )portNVIC_IP_REGISTERS_OFFSET_16( 0xE000E3F0 )( 16 )( ( ( uint32_t ) configKERNEL_INTERRUPT_PRIORITY ) << 24UL )( ( ( uint32_t ) configKERNEL_INTERRUPT_PRIORITY ) << 16UL )portNVIC_PEND_SYSTICK_CLEAR_BIT( 1UL << 25UL )portNVIC_PENDSVCLEAR_BIT( 1UL << 27UL )portNVIC_SYSTICK_COUNT_FLAG_BIT( 1UL << 16UL )( 1UL << 0UL )( 1UL << 1UL )portNVIC_SYSPRI2_REG( * ( ( volatile uint32_t * ) 0xe000ed20 ) )portNVIC_SYSTICK_CURRENT_VALUE_REG( * ( ( volatile uint32_t * ) 0xe000e018 ) )portNVIC_SYSTICK_LOAD_REG( * ( ( volatile uint32_t * ) 0xe000e014 ) )portNVIC_SYSTICK_CTRL_REG( * ( ( volatile uint32_t * ) 0xe000e010 ) )( 1UL << 2UL )configSYSTICK_CLOCK_HZconfigCPU_CLOCK_HZconfigTASK_RETURN_ADDRESS( configUSE_TICKLESS_IDLE == 1 )( configASSERT_DEFINED == 1 )WORKAROUND_PMU_CM001WORKAROUND_PMU_CM001 == 1/* configASSERT_DEFINED *//* Priority grouping:  The interrupt controller (NVIC) allows the bits
		that define each interrupt's priority to be split between bits that
		define the interrupt's pre-emption priority bits and bits that define
		the interrupt's sub-priority.  For simplicity all bits must be defined
		to be pre-emption priority bits.  The following assertion will fail if
		this is not the case (if some bits represent a sub-priority).

		If the application only uses CMSIS libraries for interrupt
		configuration then the correct setting can be achieved on all Cortex-M
		devices by calling NVIC_SetPriorityGrouping( 0 ); before starting the
		scheduler.  Note however that some vendor specific peripheral libraries
		assume a non-zero priority group setting, in which cases using a value
		of zero will result in unpredictable behaviour. *//* The following assertion will fail if a service routine (ISR) for
			an interrupt that has been assigned a priority above
			configMAX_SYSCALL_INTERRUPT_PRIORITY calls an ISR safe FreeRTOS API
			function.  ISR safe FreeRTOS API functions must *only* be called
			from interrupts that have been assigned a priority at or below
			configMAX_SYSCALL_INTERRUPT_PRIORITY.

			Numerically low interrupt priority numbers represent logically high
			interrupt priorities, therefore the priority of the interrupt must
			be set to a value equal to or numerically *higher* than
			configMAX_SYSCALL_INTERRUPT_PRIORITY.

			Interrupts that	use the FreeRTOS API must not be left at their
			default priority of	zero as that is the highest possible priority,
			which is guaranteed to be above configMAX_SYSCALL_INTERRUPT_PRIORITY,
			and	therefore also guaranteed to be invalid.

			FreeRTOS maintains separate thread and ISR API functions to ensure
			interrupt entry is as fast and simple as possible.

			The following links provide detailed information:
			http://www.freertos.org/RTOS-Cortex-M3-M4.html
			http://www.freertos.org/FAQHelp.html *//* Look up the interrupt's priority. *//* Is the interrupt number a user defined interrupt? *//* Obtain the number of the currently executing interrupt. *//* Enable CP10 and CP11 coprocessors, then save back. *//* The FPU enable bits are in the CPACR. *//* This is a naked function. *//* Configure SysTick to interrupt at the requested rate. *//* Stop and clear the SysTick. *//* configUSE_TICKLESS_IDLE *//* Calculate the constants required to configure the tick interrupt. *//*
 * Setup the systick timer to generate the tick interrupts at the required
 * frequency.
 *//* #if configUSE_TICKLESS_IDLE *//* Exit with interrpts enabled. *//* Restart SysTick so it runs from portNVIC_SYSTICK_LOAD_REG
			again, then set portNVIC_SYSTICK_LOAD_REG back to its standard
			value. *//* The reload value is set to whatever fraction of a single tick
				period remains. *//* How many complete tick periods passed while the processor
				was waiting? *//* Something other than the tick interrupt ended the sleep.
				Work out how long the sleep lasted rounded to complete tick
				periods (not the ulReload value which accounted for part
				ticks). *//* As the pending tick will be processed as soon as this
				function exits, the tick value maintained by the tick is stepped
				forward by one less than the time spent waiting. *//* Don't allow a tiny value, or values that have somehow
				underflowed because the post sleep hook did something
				that took too long. *//* The tick interrupt is already pending, and the SysTick count
				reloaded with ulReloadValue.  Reset the
				portNVIC_SYSTICK_LOAD_REG with whatever remains of this tick
				period. *//* Determine if the SysTick clock has already counted to zero and
			been set back to the current reload value (the reload back being
			correct for the entire expected idle time) or if the SysTick is yet
			to count to zero (in which case an interrupt other than the SysTick
			must have brought the system out of sleep mode). *//* Disable the SysTick clock without reading the
			portNVIC_SYSTICK_CTRL_REG register to ensure the
			portNVIC_SYSTICK_COUNT_FLAG_BIT is not cleared if it is set.  Again,
			the time the SysTick is stopped for is accounted for as best it can
			be, but using the tickless mode will inevitably result in some tiny
			drift of the time maintained by the kernel with respect to calendar
			time*//* Disable interrupts again because the clock is about to be stopped
			and interrupts that execute while the clock is stopped will increase
			any slippage between the time maintained by the RTOS and calendar
			time. *//* Re-enable interrupts to allow the interrupt that brought the MCU
			out of sleep mode to execute immediately.  see comments above
			__disable_interrupt() call above. *//* Sleep until something happens.  configPRE_SLEEP_PROCESSING() can
			set its parameter to 0 to indicate that its implementation contains
			its own wait for interrupt or wait for event instruction, and so wfi
			should not be executed again.  However, the original expected idle
			time variable must remain unmodified, so a copy is taken. *//* Restart SysTick. *//* Clear the SysTick count flag and set the count value back to
			zero. *//* Set the new reload value. *//* Re-enable interrupts - see comments above the cpsid instruction()
			above. *//* Reset the reload register to the value required for normal tick
			periods. *//* Restart from whatever is left in the count register to complete
			this tick period. *//* If a context switch is pending or a task is waiting for the scheduler
		to be unsuspended then abandon the low power entry. *//* Enter a critical section but don't use the taskENTER_CRITICAL()
		method as that will mask interrupts that should exit sleep mode. *//* Calculate the reload value required to wait xExpectedIdleTime
		tick periods.  -1 is used because this code will execute part way
		through one of the tick periods. *//* Stop the SysTick momentarily.  The time the SysTick is stopped for
		is accounted for as best it can be, but using the tickless mode will
		inevitably result in some tiny drift of the time maintained by the
		kernel with respect to calendar time. *//* Make sure the SysTick reload value does not overflow the counter. *//* A context switch is required.  Context switching is performed in
			the PendSV interrupt.  Pend the PendSV interrupt. *//* Increment the RTOS tick. *//* The SysTick runs at the lowest interrupt priority, so when this interrupt
	executes all interrupts must be unmasked.  There is therefore no need to
	save and then restore the interrupt mask value as its value is already
	known. *//* XMC4000 specific errata workaround. *//* Is the task using the FPU context?  If so, pop the high vfp registers too. *//* Pop the core registers. *//* The first item in pxCurrentTCB is the task top of stack. *//* Errata workaround. *//* Save the new top of stack into the first member of the TCB. *//* Save the core registers. *//* Is the task using the FPU context?  If so, push high vfp registers. *//* Get the location of the current TCB. *//* This is not the interrupt safe version of the enter critical function so
	assert() if it is being called from an interrupt context.  Only API
	functions that end in "FromISR" can be used in an interrupt.  Only assert if
	the critical nesting count is 1 to protect against recursive calls if the
	assert function also uses a critical section. *//* Not implemented in ports where there is nothing to return to.
	Artificially force an assert. *//* Should not get here! *//* Should never get here as the tasks will now be executing!  Call the task
	exit error function to prevent compiler warnings about a static function
	not being called in the case that the application writer overrides this
	functionality by defining configTASK_RETURN_ADDRESS.  Call
	vTaskSwitchContext() so link time optimisation does not remove the
	symbol. *//* Start the first task. *//* Lazy save always. *//* Ensure the VFP is enabled - it should be anyway. *//* Initialise the critical nesting count ready for the first task. *//* Start the timer that generates the tick ISR.  Interrupts are disabled
	here already. *//* Make PendSV and SysTick the lowest priority interrupts. */// #endif /* conifgASSERT_DEFINED */// }// 	*pucFirstUserPriorityRegister = ulOriginalPriority;// 	value. */// 	/* Restore the clobbered interrupt priority register to its original// 	ulMaxPRIGROUPValue &= portPRIORITY_GROUP_MASK;// 	ulMaxPRIGROUPValue <<= portPRIGROUP_SHIFT;// 	register. */// 	/* Shift the priority group value back to its position within the AIRCR// 	#endif// 	}// 		// configASSERT( ( portMAX_PRIGROUP_BITS - ulMaxPRIGROUPValue ) == configPRIO_BITS );// 		from the hardware. */// 		priority bits matches the number of priority bits actually queried// 		/* Check the FreeRTOS configuration that defines the number of// 	{// 	#ifdef configPRIO_BITS// 		// configASSERT( ( portMAX_PRIGROUP_BITS - ulMaxPRIGROUPValue ) == __NVIC_PRIO_BITS );// 		/* Check the CMSIS configuration that defines the number of// 	#ifdef __NVIC_PRIO_BITS// 		ucMaxPriorityValue <<= ( uint8_t ) 0x01;// 		ulMaxPRIGROUPValue--;// 	while( ( ucMaxPriorityValue & portTOP_BIT_OF_BYTE ) == portTOP_BIT_OF_BYTE )// 	ulMaxPRIGROUPValue = portMAX_PRIGROUP_BITS;// 	of bits read back. */// 	/* Calculate the maximum acceptable priority group value for the number// 	ucMaxSysCallPriority = configMAX_SYSCALL_INTERRUPT_PRIORITY & ucMaxPriorityValue;// 	/* Use the same mask on the maximum system call priority. */// 	ucMaxPriorityValue = *pucFirstUserPriorityRegister;// 	/* Read the value back to see how many bits stuck. */// 	*pucFirstUserPriorityRegister = portMAX_8_BIT_VALUE;// 	possible bits. */// 	/* Determine the number of priority bits available.  First write to all// 	ulOriginalPriority = *pucFirstUserPriorityRegister;// 	Save the interrupt priority value that is about to be clobbered. */// 	ensure interrupt entry is as fast and simple as possible.// 	"FromISR".  FreeRTOS maintains separate thread and ISR API functions to// 	functions can be called.  ISR safe functions are those that end in// 	/* Determine the maximum priority from which ISR safe FreeRTOS API// 	volatile uint8_t ucMaxPriorityValue;// 	volatile uint8_t * const pucFirstUserPriorityRegister = ( volatile uint8_t * const ) ( portNVIC_IP_REGISTERS_OFFSET_16 + portFIRST_USER_INTERRUPT_NUMBER );// 	volatile uint32_t ulOriginalPriority;// {// #if( configASSERT_DEFINED == 1 )// configASSERT( configMAX_SYSCALL_INTERRUPT_PRIORITY );// See http://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */// /* configMAX_SYSCALL_INTERRUPT_PRIORITY must not be set to 0./*
 * See header file for description.
 *//* System call to start first task. *//* Globally enable interrupts. *//* Clear the bit that indicates the FPU is in use, see comment above. *//* Set the msp back to the start of the stack. *//* Use the NVIC offset register to locate the stack. *//* Start the first task.  This also clears the bit that indicates the FPU is
	in use in case the FPU was used before the scheduler was started - which
	would otherwise result in the unnecessary leaving of space in the SVC stack
	for lazy saving of FPU registers. *//* Restore the task stack pointer. *//* Pop the registers that are not automatically saved on exception entry and the critical nesting count. *//* Use pxCurrentTCBConst to get the pxCurrentTCB address. *//* Restore the context. *//* This file calls prvTaskExitError() after the scheduler has been
		started to remove a compiler warning about the function being defined
		but never called.  ulDummy is used purely to quieten other warnings
		about code appearing after this function is called - making ulDummy
		volatile makes the compiler think the function could return and
		therefore not output an 'unreachable code' warning for code that appears
		after it. *//* A function that implements a task must not exit or attempt to return to
	its caller as there is nothing to return to.  If a task wants to exit it
	should instead call vTaskDelete( NULL ).

	Artificially force an assert() to be triggered if configASSERT() is
	defined, then stop here so application writers can catch the error. *//* R11, R10, R9, R8, R7, R6, R5 and R4. *//* A save method is being used that requires each task to maintain its
	own exec return value. *//* R0 *//* R12, R3, R2 and R1. *//* Save code space by skipping register initialisation. *//* LR *//* PC *//* xPSR *//* Offset added to account for the way the MCU uses the stack on entry/exit
	of interrupts, and to ensure alignment. *//* Simulate the stack frame as it would be created by a context switch
	interrupt. *//*
 * Used by the portASSERT_IF_INTERRUPT_PRIORITY_INVALID() macro to ensure
 * FreeRTOS API functions are not called from interrupts that have been assigned
 * a priority above configMAX_SYSCALL_INTERRUPT_PRIORITY.
 *//*
 * Compensate for the CPU cycles that pass while the SysTick is stopped (low
 * power functionality only.
 *//*
 * The maximum number of tick periods that can be suppressed is limited by the
 * 24 bit resolution of the SysTick timer.
 *//*
 * The number of SysTick increments that make up one tick period.
 *//* Each task maintains its own interrupt status in the critical nesting
variable. *//*
 * Used to catch tasks that attempt to return from their implementing function.
 *//*
 * Function to enable the VFP.
 *//*
 * Start first task is a separate function so it can be tested in isolation.
 *//*
 * Exception handlers.
 *//*
 * Setup the timer to generate the tick interrupts.  The implementation in this
 * file is weak to allow application writers to change the timer used to
 * generate the tick interrupt.
 *//* Let the user override the pre-loading of the initial LR with the address of
prvTaskExitError() in case it messes up unwinding of the stack in the
debugger. *//* A fiddle factor to estimate the number of SysTick counts that would have
occurred while the SysTick counter is stopped during tickless idle
calculations. *//* For strict compliance with the Cortex-M spec the task start address should
have bit-0 clear, as it is loaded into the PC on exit from an ISR. *//* The systick is a 24-bit counter. *//* Constants required to set up the initial stack. *//* Floating point context control register. *//* Constants required to manipulate the VFP. *//* Masks off all bits but the VECTACTIVE bits in the ICSR register. *//* Constants required to check the validity of an interrupt priority. *//* ...then bits in the registers. *//* Constants required to manipulate the core.  Registers first... *//* The way the SysTick is clocked is not modified in case it is not the same
	as the core. *//* Ensure the SysTick is clocked at the same frequency as the core. *//* Scheduler includes. *//*-----------------------------------------------------------
 * Implementation of functions defined in portable.h for the ARM CM4F port.
 *----------------------------------------------------------*//Users/jie/Documents/posixGen_Demos-main/LwIP_StreamingServer/Middlewares/Third_Party/FreeRTOS/Source/portable/GCC/ARM_CM7/r0p1/Users/jie/Documents/posixGen_Demos-main/LwIP_StreamingServer/Middlewares/Third_Party/FreeRTOS/Source/portable/GCC/ARM_CM7/Users/jie/Documents/posixGen_Demos-main/LwIP_StreamingServer/Middlewares/Third_Party/FreeRTOS/Source/portable/GCC/Users/jie/Documents/posixGen_Demos-main/LwIP_StreamingServer/Middlewares/Third_Party/FreeRTOS/Source/portablepxTopOfStackpxCodepvParametersnaked<assert.h><sys/lock.h><sys/_types.h><sys/cdefs.h><_ansi.h>_fwalk_sglue_reent *__FILE *__sFILE *_glue *_reclaim_reent_glue__sFILE_reent_misc_reent_rand48_mprec__FILE__sbuf_atexit_on_exit_args__tm_Bigint__locale_t_flock_t__lock *__ULong_iobs_niobs_next_flags2_mbstate_lock_offset_blksize_lbunsigned char[1]_nbuf_ubuf_ur_up_ub_close_seek_write_read_cookie_data_signal_buf_misc_reent *_misc_wcsrtombs_state_wcrtomb_state_mbsrtowcs_state_mbrtowc_state_mbrlen_state_getdate_errchar[8]_l64a_buf_mbtowc_state_wctomb_state_mblen_state_strtok_last__sf..(**)(..)_sig_func_asctime_buf__tm *_localtime_buf_rand48 *_r48_rand_next_add_mult_seed_cvtbuf_cvtlen_gamma_signgam__cleanup_mprec *_mp_Bigint *_Bigint **_freelist_p5s_result_k_result__locale_t *_locale_emergency_inc_stderr_stdout_stdin_errno_lbfsize_bf_file_flags_w_r_p_size_base_on_exit_args *_on_exit_args_ptr..(*[32])(..)_ATEXIT_SIZE_fns_ind_atexit *_is_cxa_fntypesvoid *[32]_dso_handle_fnargs__tm_isdst__tm_yday__tm_wday__tm_year__tm_mon__tm_mday__tm_hour__tm_min__tm_sec__ULong[1]_x_wds_sign_maxwds_k__stdio_exit_handler__atexit0__atexit_impure_data_impure_ptr__sglue__FILE[3]__sFILE[3]_Kmax(sizeof (size_t) << 3)_GLOBAL_REENT(&_impure_data)_REENT_IS_NULL(_ptr)((_ptr) == NULL)_REENT__ATTRIBUTE_IMPURE_DATA____ATTRIBUTE_IMPURE_PTR___REENT_INIT_PTR(var){ memset((var), 0, sizeof(*(var))); _REENT_INIT_PTR_ZEROED(var); }_REENT_STDERR(_ptr)((_ptr)->_stderr)_REENT_STDOUT(_ptr)((_ptr)->_stdout)_REENT_STDIN(_ptr)((_ptr)->_stdin)_REENT_SIG_FUNC(_ptr)((_ptr)->_sig_func)_REENT_LOCALE(_ptr)((_ptr)->_locale)_REENT_INC(_ptr)((_ptr)->_inc)_REENT_ERRNO(_ptr)((_ptr)->_errno)_REENT_EMERGENCY(_ptr)((_ptr)->_emergency)_REENT_CVTLEN(_ptr)((_ptr)->_cvtlen)_REENT_CVTBUF(_ptr)((_ptr)->_cvtbuf)_REENT_CLEANUP(_ptr)((_ptr)->__cleanup)_REENT_SIGNAL_BUF(ptr)((ptr)->_signal_buf)_REENT_GETDATE_ERR_P(ptr)(&((ptr)->_misc->_getdate_err))_REENT_L64A_BUF(ptr)((ptr)->_misc->_l64a_buf)_REENT_WCSRTOMBS_STATE(ptr)((ptr)->_misc->_wcsrtombs_state)_REENT_WCRTOMB_STATE(ptr)((ptr)->_misc->_wcrtomb_state)_REENT_MBSRTOWCS_STATE(ptr)((ptr)->_misc->_mbsrtowcs_state)_REENT_MBRTOWC_STATE(ptr)((ptr)->_misc->_mbrtowc_state)_REENT_MBRLEN_STATE(ptr)((ptr)->_misc->_mbrlen_state)_REENT_WCTOMB_STATE(ptr)((ptr)->_misc->_wctomb_state)_REENT_MBTOWC_STATE(ptr)((ptr)->_misc->_mbtowc_state)_REENT_MBLEN_STATE(ptr)((ptr)->_misc->_mblen_state)_REENT_STRTOK_LAST(ptr)((ptr)->_misc->_strtok_last)_REENT_TM(ptr)((ptr)->_localtime_buf)_REENT_ASCTIME_BUF(ptr)((ptr)->_asctime_buf)_REENT_MP_FREELIST(ptr)((ptr)->_mp->_freelist)_REENT_MP_P5S(ptr)((ptr)->_mp->_p5s)_REENT_MP_RESULT_K(ptr)((ptr)->_mp->_result_k)_REENT_MP_RESULT(ptr)((ptr)->_mp->_result)_REENT_RAND48_ADD(ptr)((ptr)->_r48->_add)_REENT_RAND48_MULT(ptr)((ptr)->_r48->_mult)_REENT_RAND48_SEED(ptr)((ptr)->_r48->_seed)_REENT_RAND_NEXT(ptr)((ptr)->_r48->_rand_next)_REENT_SIGNGAM(ptr)((ptr)->_gamma_signgam)_REENT_CHECK_SIGNAL_BUF(var)_REENT_CHECK(var, _signal_buf, char *, _REENT_SIGNAL_SIZE, )_REENT_CHECK_MISC(var)_REENT_CHECK(var, _misc, struct _misc_reent *, sizeof *((var)->_misc), _REENT_INIT_MISC(var))_REENT_INIT_MISC(var)do { struct _reent *_r = (var); _r->_misc->_strtok_last = _NULL; _r->_misc->_mblen_state.__count = 0; _r->_misc->_mblen_state.__value.__wch = 0; _r->_misc->_wctomb_state.__count = 0; _r->_misc->_wctomb_state.__value.__wch = 0; _r->_misc->_mbtowc_state.__count = 0; _r->_misc->_mbtowc_state.__value.__wch = 0; _r->_misc->_mbrlen_state.__count = 0; _r->_misc->_mbrlen_state.__value.__wch = 0; _r->_misc->_mbrtowc_state.__count = 0; _r->_misc->_mbrtowc_state.__value.__wch = 0; _r->_misc->_mbsrtowcs_state.__count = 0; _r->_misc->_mbsrtowcs_state.__value.__wch = 0; _r->_misc->_wcrtomb_state.__count = 0; _r->_misc->_wcrtomb_state.__value.__wch = 0; _r->_misc->_wcsrtombs_state.__count = 0; _r->_misc->_wcsrtombs_state.__value.__wch = 0; __REENT_INIT_MISC_GETLOCALENAME_L; _r->_misc->_l64a_buf[0] = '\0'; _r->_misc->_getdate_err = 0; } while (0)__REENT_INIT_MISC_GETLOCALENAME_L_REENT_CHECK_EMERGENCY(var)_REENT_CHECK(var, _emergency, char *, _REENT_EMERGENCY_SIZE, )_REENT_CHECK_MP(var)_REENT_CHECK(var, _mp, struct _mprec *, sizeof *((var)->_mp), _REENT_INIT_MP(var))_REENT_INIT_MP(var)do { struct _reent *_r = (var); _r->_mp->_result_k = 0; _r->_mp->_result = _r->_mp->_p5s = _NULL; _r->_mp->_freelist = _NULL; } while (0)_REENT_CHECK_RAND48(var)_REENT_CHECK(var, _r48, struct _rand48 *, sizeof *((var)->_r48), _REENT_INIT_RAND48((var)))_REENT_INIT_RAND48(var)do { struct _reent *_r = (var); _r->_r48->_seed[0] = _RAND48_SEED_0; _r->_r48->_seed[1] = _RAND48_SEED_1; _r->_r48->_seed[2] = _RAND48_SEED_2; _r->_r48->_mult[0] = _RAND48_MULT_0; _r->_r48->_mult[1] = _RAND48_MULT_1; _r->_r48->_mult[2] = _RAND48_MULT_2; _r->_r48->_add = _RAND48_ADD; _r->_r48->_rand_next = 1; } while (0)_REENT_CHECK_ASCTIME_BUF(var)_REENT_CHECK(var, _asctime_buf, char *, _REENT_ASCTIME_SIZE, memset((var)->_asctime_buf, 0, _REENT_ASCTIME_SIZE))_REENT_CHECK_TM(var)_REENT_CHECK(var, _localtime_buf, struct __tm *, sizeof *((var)->_localtime_buf), )_REENT_CHECK(var,what,type,size,init)do { struct _reent *_r = (var); if (_r->what == NULL) { _r->what = (type)malloc(size); __reent_assert(_r->what); init; } } while (0)__reent_assert(x)((x) ? (void)0 : __assert_func(__FILE__, __LINE__, (char *)0, "REENT malloc succeeded"))_REENT_INIT_PTR_ZEROED(var){ (var)->_stdin = &__sf[0]; (var)->_stdout = &__sf[1]; (var)->_stderr = &__sf[2]; }_REENT_INIT(var){ 0, &__sf[0], &__sf[1], &__sf[2], 0, _NULL, _REENT_INIT_RESERVED_0 _REENT_INIT_RESERVED_1 _NULL, _NULL, _NULL, 0, 0, _NULL, _NULL, _NULL, _NULL, _NULL, _REENT_INIT_RESERVED_6_7 _REENT_INIT_RESERVED_8 _NULL, _NULL, _NULL }_REENT_INIT_RESERVED_8_REENT_INIT_RESERVED_6_7_REENT_INIT_RESERVED_2_REENT_INIT_RESERVED_1_REENT_INIT_RESERVED_0_REENT_SIGNAL_SIZE_REENT_ASCTIME_SIZE_REENT_EMERGENCY_SIZE_RAND48_ADD(0x000b)_RAND48_MULT_2(0x0005)_RAND48_MULT_1(0xdeec)_RAND48_MULT_0(0xe66d)_RAND48_SEED_2(0x1234)_RAND48_SEED_1(0xabcd)_RAND48_SEED_0(0x330e)_REENT_SMALL_CHECK_INIT(ptr)_ATEXIT_INIT{_NULL, 0, {_NULL}, _NULL}__Longlong_NULL_SYS_REENT_H___LONG_MAX__ == 2147483647L__INT_MAX__ == 2147483647!defined( __Long)__machine_flock_t_defined_REENT_SMALL__CYGWIN____SINGLE_THREAD____CUSTOM_FILE_IO__defined (__LARGE64_FILES) || defined (__CYGWIN__)_REENT_THREAD_LOCAL_REENT_BACKWARD_BINARY_COMPAT_MB_CAPABLE_REENT_CHECK_VERIFYdefined(__DYNAMIC_REENT__) && !defined(__SINGLE_THREAD__)__getreent__LONG_MAX__0x7fffffffL/* _SYS_REENT_H_ *//* one guaranteed table, required by ANSI *//* points to head of LIFO stack *//* This value is used in stdlib/misc.c.  reent/reent.c has to know it
   as well to make sure the freelist is correctly free'd.  Therefore
   we define it here, rather than in stdlib/misc.c, as before. *//* !_REENT_THREAD_LOCAL *//*ENCODING + 1*//* nothing *//*
 * Since _REENT is defined as NULL, this macro ensures that calls to
 * CHECK_INIT() do not automatically fail.
 *//* _REENT_THREAD_LOCAL *//* __SINGLE_THREAD__ || !__DYNAMIC_REENT__ *//* #define _REENT_ONLY define this to get only reentrant routines *//*
 * All references to struct _reent are via this pointer.
 * Internally, newlib routines that need to reference it should use _REENT.
 *//* !_REENT_SMALL *//* signal info *//* ENCODING_LEN + 1 *//* _LC_LAST *//* No errors are defined for getlocalename_l.  So we can't use
	     buffer allocation which might lead to an ENOMEM error.  We
	     have to use a "static" buffer here instead. *//* should be size_t *//* used by some fp conversion routines *//* used by mprec routines *//* per-thread locale *//* used by tmpnam *//* FILE is a big struct and may change over time.  To try to achieve binary
     compatibility with future versions, put stdin,stdout,stderr here.
     These are pointers into member __sf defined below.  *//* local copy of errno *//* Handle the dynamically allocated rand48 structure. *//* Generic _REENT check macro.  *//* Specify how to handle reent_check malloc failures. *//* strsignal *//* strtok, multibyte states *//* file descriptors *//* XXX *//* As an exception to the above put _errno first for binary
     compatibility with non _REENT_SMALL targets.  *//* This version of _reent is laid out with "int"s in pairs, to help
 * ports with 16-bit int's but 32-bit pointers, align nicely.  *//* miscellaneous reentrant data *//*
 * struct _reent
 *
 * This structure contains the thread-local objects needed by the library.
 * It's raison d'etre is to facilitate threads by making all library routines
 * reentrant.  The exit handler support and FILE maintenance use dedicated
 * global objects which are not included in this structure.
 *//* Nothing to initialize *//* How big the some arrays are.  *//* Put this in here as well, for good luck.  *//*
 * rand48 family support
 *
 * Copyright (c) 1993 Martin Birgmeier
 * All rights reserved.
 *
 * You may redistribute unmodified or modified versions of this source
 * code provided that the above copyright notice and this and the
 * following conditions are retained.
 *
 * This software is provided ``as is'', and comes with no warranties
 * of any kind. I shall in no event be liable for anything that happens
 * to anyone/anything when using this software.
 *//* !__CUSTOM_FILE_IO__ *//* __LARGE64_FILES *//* for wide char stdio functions. *//* for thread-safety locking *//* current lseek offset *//* for future use *//* stat.st_blksize (may be != _bf._size) *//* Unix stdio files get aligned to block boundaries on fseek() *//* buffer for fgetline() *//* separate buffer for fgetline() when line crosses buffer boundary *//* guarantee a getc() buffer *//* guarantee an ungetc() buffer *//* tricks to meet minimum requirements even when malloc() fails *//* saved _r when _r is counting ungetc data *//* saved _p when _p is doing ungetc data *//* ungetc buffer *//* separate buffer for long sequences of ungetc() *//* cookie passed to io functions *//* operations *//* 0 or -_bf._size, for inline putc *//* the buffer (at least 1 byte, if !NULL) *//* fileno, if Unix descriptor, else -1 *//* flags, below; this FILE is free if 0 *//* write space left for putc() *//* read space left for getc() *//* current position in (some) buffer *//* Cygwin must use __sFILE64 for backward compatibility, even though
   it's not defining __LARGE64_FILES anymore.  It also has to make
   sure the name is the same to satisfy C++ name mangling.  Overloading
   _fpos64_t just fixes a build problem.  The _seek64 function is
   actually never used without __LARGE64_FILES being defined. *//* Get custom _FILE definition.  *//* !__CYGWIN__ *//* Here for binary compatibility? Remove? *//* Cygwin must use __sFILE64 for backward compatibility, even though
   it's not defining __LARGE64_FILES anymore.  To make sure that __sFILE
   is never defined, disable it here explicitely. *//*
 * Stdio state variables.
 *
 * The following always hold:
 *
 *	if (_flags&(__SLBF|__SWR)) == (__SLBF|__SWR),
 *		_lbfsize is -_bf._size, else _lbfsize is 0
 *	if _flags&__SRD, _w is 0
 *	if _flags&__SWR, _r is 0
 *
 * This ensures that the getc and putc macros (or inline functions) never
 * try to write or read from a file that is in `read' or `write' mode.
 * (Moreover, they can, and do, automatically switch from read mode to
 * write mode, and back, on "r+" and "w+" files.)
 *
 * _lbfsize is used only to make the inline line-buffered output stream
 * code as compact as possible.
 *
 * _ub, _up, and _ur are used when ungetc() pushes back more characters
 * than fit in the current _bf, or when ungetc() pushes back a character
 * that does not match the previous one in _bf.  When this happens,
 * _ub._base becomes non-nil (i.e., a stream has ungetc() data iff
 * _ub._base!=NULL) and _up and _ur save the current values of _p and _r.
 *//*
 * Stdio buffers.
 *
 * This and __FILE are defined here because we need them for struct _reent,
 * but we don't want stdio.h included when stdlib.h is.
 *//* the table itself *//* Some entries may already have been called, and will be NULL.  *//* next index in this table *//* next in list *//* Bitmask is set if function was registered via __cxa_atexit.  *//* type of exit routine -
				   Must have at least _ATEXIT_SIZE bits *//* Bitmask is set if user function takes arguments.  *//* user fn args *//* must be at least 32 to guarantee ANSI conformance *//*
 * atexit() support.
 *//* needed by reentrant structure *//*
 * If _REENT_SMALL is defined, we make struct _reent as small as possible,
 * by having nearly everything possible allocated at first use.
 *//* WARNING: All identifiers here must begin with an underscore.  This file is
   included by stdio.h and others and we therefore must only use identifiers
   in the namespace allotted to us.  *//* This header file provides the reentrancy.  *//Users/jie/Documents/arm-gnu-toolchain-14.3.rel1-darwin-arm64-arm-none-eabi/arm-none-eabi/include/sys/Users/jie/Documents/arm-gnu-toolchain-14.3.rel1-darwin-arm64-arm-none-eabi/arm-none-eabi/include/Users/jie/Documents/arm-gnu-toolchain-14.3.rel1-darwin-arm64-arm-none-eabi/arm-none-eabi/Users/jie/Documents/arm-gnu-toolchain-14.3.rel1-darwin-arm64-arm-none-eabi/Users/jie/Documents/posixGen_Demos-main/LwIP_StreamingServer/Middlewares/Third_Party/FreeRTOS/Source/portable/MemMang/heap_4.cprvInsertBlockIntoFreeListBlockLink_t *A_BLOCK_LINK *pucprvHeapInitpxFirstFreeBlockpucAlignedHeapuxAddressxTotalHeapSizeconfigTOTAL_HEAP_SIZEuint8_t[25600]unsigned char[25600]portBYTE_ALIGNMENT_MASKportBYTE_ALIGNMENT( portBYTE_ALIGNMENT - 1 )( size_t ) portBYTE_ALIGNMENT_MASK( ( size_t ) portBYTE_ALIGNMENT_MASK )~( ( size_t ) portBYTE_ALIGNMENT_MASK )( size_t ) 0const size_txHeapStructSize( size_t ) 1( ( size_t ) 1 )sizeof( size_t )heapBITS_PER_BYTEsizeof( size_t ) * heapBITS_PER_BYTE( sizeof( size_t ) * heapBITS_PER_BYTE )( sizeof( size_t ) * heapBITS_PER_BYTE ) - 1( ( sizeof( size_t ) * heapBITS_PER_BYTE ) - 1 )( ( size_t ) 1 ) << ( ( sizeof( size_t ) * heapBITS_PER_BYTE ) - 1 )vPortInitialiseBlocksxPortGetMinimumEverFreeHeapSizexPortGetFreeHeapSizevPortFreepxLink( pxLink->xBlockSize & xBlockAllocatedBit ) != 0pxLink->pxNextFreeBlock == NULLpxLink->pxNextFreeBlock == ((void *)0)pvpxLink->xBlockSizepvPortMallocpxBlockpxPreviousBlockpxNewBlockLinkpvReturn( xWantedSize & portBYTE_ALIGNMENT_MASK ) == 0( xWantedSize & ( 0x0007 ) ) == 0( ( ( size_t ) pxNewBlockLink ) & portBYTE_ALIGNMENT_MASK ) == 0( ( ( size_t ) pxNewBlockLink ) & ( 0x0007 ) ) == 0heapMINIMUM_BLOCK_SIZExWantedSize( ( ( size_t ) pvReturn ) & ( size_t ) portBYTE_ALIGNMENT_MASK ) == 0( ( ( size_t ) pvReturn ) & ( size_t ) ( 0x0007 ) ) == 0BlockLink_tA_BLOCK_LINKxBlockSizepxNextFreeBlockxBlockAllocatedBitxMinimumEverFreeBytesRemainingxFreeBytesRemainingpxEndxStartsizeof( BlockLink_t )( size_t ) ( portBYTE_ALIGNMENT - 1 )( ( size_t ) ( portBYTE_ALIGNMENT - 1 ) )sizeof( BlockLink_t ) + ( ( size_t ) ( portBYTE_ALIGNMENT - 1 ) )( sizeof( BlockLink_t ) + ( ( size_t ) ( portBYTE_ALIGNMENT - 1 ) ) )( sizeof( BlockLink_t ) + ( ( size_t ) ( portBYTE_ALIGNMENT - 1 ) ) ) & ~( ( size_t ) portBYTE_ALIGNMENT_MASK )ucHeap( ( size_t ) 8 )( ( size_t ) ( xHeapStructSize << 1 ) )MPU_WRAPPERS_INCLUDED_FROM_API_FILE( configSUPPORT_DYNAMIC_ALLOCATION == 0 )( configAPPLICATION_ALLOCATED_HEAP == 1 )( configUSE_MALLOC_FAILED_HOOK == 1 )/* If the block being inserted plugged a gab, so was merged with the block
	before and the block after, then it's pxNextFreeBlock pointer will have
	already been set, and should not be set here as that would make it point
	to itself. *//* Form one big block from the two blocks. *//* Do the block being inserted, and the block it is being inserted before
	make a contiguous block of memory? *//* Do the block being inserted, and the block it is being inserted after
	make a contiguous block of memory? *//* Nothing to do here, just iterate to the right position. *//* Iterate through the list until a block is found that has a higher address
	than the block being inserted. *//* Work out the position of the top bit in a size_t variable. *//* Only one block exists - and it covers the entire usable heap space. *//* To start with there is a single free block that is sized to take up the
	entire heap space, minus the space taken by pxEnd. *//* pxEnd is used to mark the end of the list of free blocks and is inserted
	at the end of the heap space. *//* xStart is used to hold a pointer to the first item in the list of free
	blocks.  The void cast is used to prevent compiler warnings. *//* Ensure the heap starts on a correctly aligned boundary. *//* This just exists to keep the linker quiet. *//* Add this block to the list of free blocks. *//* The block is being returned to the heap - it is no longer
				allocated. *//* Check the block is actually allocated. *//* This casting is to keep the compiler from issuing warnings. *//* The memory being freed will have an BlockLink_t structure immediately
		before it. *//* The block is being returned - it is allocated and owned
					by the application and has no "next" block. *//* Insert the new block into the list of free blocks. *//* Calculate the sizes of two blocks split from the
						single block. *//* This block is to be split into two.  Create a new
						block following the number of bytes requested. The void
						cast is used to prevent byte alignment warnings from the
						compiler. *//* If the block is larger than required it can be split into
					two. *//* This block is being returned for use so must be taken out
					of the list of free blocks. *//* Return the memory space pointed to - jumping over the
					BlockLink_t structure at its start. *//* If the end marker was reached then a block of adequate size
				was	not found. *//* Traverse the list from the start	(lowest address) block until
				one	of adequate size is found. *//* Byte alignment required. *//* Ensure that blocks are always aligned to the required number
				of bytes. *//* The wanted size is increased so it can contain a BlockLink_t
			structure in addition to the requested amount of bytes. *//* Check the requested block size is not so large that the top bit is
		set.  The top bit of the block size member of the BlockLink_t structure
		is used to determine who owns the block - the application or the
		kernel, so it must be free. *//* If this is the first call to malloc then the heap will require
		initialisation to setup the list of free blocks. *//* Gets set to the top bit of an size_t type.  When this bit in the xBlockSize
member of an BlockLink_t structure is set then the block belongs to the
application.  When the bit is free the block is still part of the free heap
space. *//* Keeps track of the number of free bytes remaining, but says nothing about
fragmentation. *//* Create a couple of list links to mark the start and end of the list. *//* The size of the structure placed at the beginning of each allocated memory
block must by correctly byte aligned. *//*
 * Called automatically to setup the required heap structures the first time
 * pvPortMalloc() is called.
 *//*
 * Inserts a block of memory that is being freed into the correct position in
 * the list of free memory blocks.  The block being freed will be merged with
 * the block in front it and/or the block behind it if the memory blocks are
 * adjacent to each other.
 *//*<< The size of the free block. *//*<< The next free block in the list. *//* Define the linked list structure.  This is used to link free blocks in order
of their memory address. *//* configAPPLICATION_ALLOCATED_HEAP *//* The application writer has already defined the array used for the RTOS
	heap - probably so it can be placed in a special segment or address. *//* Allocate the memory for the heap. *//* Assumes 8bit bytes! *//* Block sizes must not get too small. *//* Defining MPU_WRAPPERS_INCLUDED_FROM_API_FILE prevents task.h from redefining
all the API functions to use the MPU wrappers.  That should only be done when
task.h is included from an application file. *//*
 * A sample implementation of pvPortMalloc() and vPortFree() that combines
 * (coalescences) adjacent memory blocks as they are freed, and in so doing
 * limits memory fragmentation.
 *
 * See heap_1.c, heap_2.c and heap_3.c for alternative implementations, and the
 * memory management pages of http://www.FreeRTOS.org for more information.
 *//Users/jie/Documents/posixGen_Demos-main/LwIP_StreamingServer/Middlewares/Third_Party/FreeRTOS/Source/portable/MemMangpxBlockToInsertvQueueWaitForMessageRestrictedxQueueSelectFromSetFromISRxQueueSelectFromSetxQueueRemoveFromSetxQueueAddToSetxQueueCreateSetxQueueGetMutexHolderFromISRxQueueGetMutexHolderxQueueCreateCountingSemaphoreStaticStaticQueue_t *xSTATIC_QUEUE *xQueueCreateMutexStaticxQueueCRReceivexQueueCRSendxQueueCRReceiveFromISRxQueueCRSendFromISRQueueSetMemberHandle_tQueueSetHandle_tQueueHandle_txQueueReset(xQueue)xQueueGenericReset( xQueue, pdFALSE )xQueueSendFromISR(xQueue,pvItemToQueue,pxHigherPriorityTaskWoken)xQueueGenericSendFromISR( ( xQueue ), ( pvItemToQueue ), ( pxHigherPriorityTaskWoken ), queueSEND_TO_BACK )xQueueOverwriteFromISR(xQueue,pvItemToQueue,pxHigherPriorityTaskWoken)xQueueGenericSendFromISR( ( xQueue ), ( pvItemToQueue ), ( pxHigherPriorityTaskWoken ), queueOVERWRITE )xQueueSendToBackFromISR(xQueue,pvItemToQueue,pxHigherPriorityTaskWoken)xQueueSendToFrontFromISR(xQueue,pvItemToQueue,pxHigherPriorityTaskWoken)xQueueGenericSendFromISR( ( xQueue ), ( pvItemToQueue ), ( pxHigherPriorityTaskWoken ), queueSEND_TO_FRONT )xQueueOverwrite(xQueue,pvItemToQueue)xQueueGenericSend( ( xQueue ), ( pvItemToQueue ), 0, queueOVERWRITE )xQueueSend(xQueue,pvItemToQueue,xTicksToWait)xQueueGenericSend( ( xQueue ), ( pvItemToQueue ), ( xTicksToWait ), queueSEND_TO_BACK )xQueueSendToBack(xQueue,pvItemToQueue,xTicksToWait)xQueueSendToFront(xQueue,pvItemToQueue,xTicksToWait)xQueueGenericSend( ( xQueue ), ( pvItemToQueue ), ( xTicksToWait ), queueSEND_TO_FRONT )xQueueCreate(uxQueueLength,uxItemSize)xQueueGenericCreate( ( uxQueueLength ), ( uxItemSize ), ( queueQUEUE_TYPE_BASE ) )queueQUEUE_TYPE_RECURSIVE_MUTEX( ( uint8_t ) 4U )queueQUEUE_TYPE_BINARY_SEMAPHORE( ( uint8_t ) 3U )queueQUEUE_TYPE_COUNTING_SEMAPHORE( ( uint8_t ) 2U )queueQUEUE_TYPE_MUTEX( ( uint8_t ) 1U )queueQUEUE_TYPE_SET( ( uint8_t ) 0U )queueQUEUE_TYPE_BASEqueueOVERWRITE( ( BaseType_t ) 2 )queueSEND_TO_FRONT( ( BaseType_t ) 1 )queueSEND_TO_BACK( ( BaseType_t ) 0 )QUEUE_H( configSUPPORT_DYNAMIC_ALLOCATION == 1 )( configQUEUE_REGISTRY_SIZE > 0 )ucQueueGetQueueTypeuxQueueGetQueueNumbervQueueSetQueueNumberxQueueGenericResetxQueueGenericCreatepcQueueGetNamevQueueUnregisterQueuevQueueAddToRegistryxQueueGiveMutexRecursivexQueueTakeMutexRecursivexQueueSemaphoreTakexQueueCreateCountingSemaphorexQueueCreateMutexuxQueueMessagesWaitingFromISRxQueueIsQueueFullFromISRxQueueIsQueueEmptyFromISRxQueueReceiveFromISRxQueueGiveFromISRxQueueGenericSendFromISRvQueueDeleteuxQueueSpacesAvailableuxQueueMessagesWaitingxQueueReceivexQueuePeekFromISRxQueuePeekxQueueGenericSendQueueDefinition/* QUEUE_H *//* Not public API functions. *//*
 * A version of xQueueSelectFromSet() that can be used from an ISR.
 *//*
 * xQueueSelectFromSet() selects from the members of a queue set a queue or
 * semaphore that either contains data (in the case of a queue) or is available
 * to take (in the case of a semaphore).  xQueueSelectFromSet() effectively
 * allows a task to block (pend) on a read operation on all the queues and
 * semaphores in a queue set simultaneously.
 *
 * See FreeRTOS/Source/Demo/Common/Minimal/QueueSet.c for an example using this
 * function.
 *
 * Note 1:  See the documentation on http://wwwFreeRTOS.org/RTOS-queue-sets.html
 * for reasons why queue sets are very rarely needed in practice as there are
 * simpler methods of blocking on multiple objects.
 *
 * Note 2:  Blocking on a queue set that contains a mutex will not cause the
 * mutex holder to inherit the priority of the blocked task.
 *
 * Note 3:  A receive (in the case of a queue) or take (in the case of a
 * semaphore) operation must not be performed on a member of a queue set unless
 * a call to xQueueSelectFromSet() has first returned a handle to that set member.
 *
 * @param xQueueSet The queue set on which the task will (potentially) block.
 *
 * @param xTicksToWait The maximum time, in ticks, that the calling task will
 * remain in the Blocked state (with other tasks executing) to wait for a member
 * of the queue set to be ready for a successful queue read or semaphore take
 * operation.
 *
 * @return xQueueSelectFromSet() will return the handle of a queue (cast to
 * a QueueSetMemberHandle_t type) contained in the queue set that contains data,
 * or the handle of a semaphore (cast to a QueueSetMemberHandle_t type) contained
 * in the queue set that is available, or NULL if no such queue or semaphore
 * exists before before the specified block time expires.
 *//*
 * Removes a queue or semaphore from a queue set.  A queue or semaphore can only
 * be removed from a set if the queue or semaphore is empty.
 *
 * See FreeRTOS/Source/Demo/Common/Minimal/QueueSet.c for an example using this
 * function.
 *
 * @param xQueueOrSemaphore The handle of the queue or semaphore being removed
 * from the queue set (cast to an QueueSetMemberHandle_t type).
 *
 * @param xQueueSet The handle of the queue set in which the queue or semaphore
 * is included.
 *
 * @return If the queue or semaphore was successfully removed from the queue set
 * then pdPASS is returned.  If the queue was not in the queue set, or the
 * queue (or semaphore) was not empty, then pdFAIL is returned.
 *//*
 * Adds a queue or semaphore to a queue set that was previously created by a
 * call to xQueueCreateSet().
 *
 * See FreeRTOS/Source/Demo/Common/Minimal/QueueSet.c for an example using this
 * function.
 *
 * Note 1:  A receive (in the case of a queue) or take (in the case of a
 * semaphore) operation must not be performed on a member of a queue set unless
 * a call to xQueueSelectFromSet() has first returned a handle to that set member.
 *
 * @param xQueueOrSemaphore The handle of the queue or semaphore being added to
 * the queue set (cast to an QueueSetMemberHandle_t type).
 *
 * @param xQueueSet The handle of the queue set to which the queue or semaphore
 * is being added.
 *
 * @return If the queue or semaphore was successfully added to the queue set
 * then pdPASS is returned.  If the queue could not be successfully added to the
 * queue set because it is already a member of a different queue set then pdFAIL
 * is returned.
 *//*
 * Queue sets provide a mechanism to allow a task to block (pend) on a read
 * operation from multiple queues or semaphores simultaneously.
 *
 * See FreeRTOS/Source/Demo/Common/Minimal/QueueSet.c for an example using this
 * function.
 *
 * A queue set must be explicitly created using a call to xQueueCreateSet()
 * before it can be used.  Once created, standard FreeRTOS queues and semaphores
 * can be added to the set using calls to xQueueAddToSet().
 * xQueueSelectFromSet() is then used to determine which, if any, of the queues
 * or semaphores contained in the set is in a state where a queue read or
 * semaphore take operation would be successful.
 *
 * Note 1:  See the documentation on http://wwwFreeRTOS.org/RTOS-queue-sets.html
 * for reasons why queue sets are very rarely needed in practice as there are
 * simpler methods of blocking on multiple objects.
 *
 * Note 2:  Blocking on a queue set that contains a mutex will not cause the
 * mutex holder to inherit the priority of the blocked task.
 *
 * Note 3:  An additional 4 bytes of RAM is required for each space in a every
 * queue added to a queue set.  Therefore counting semaphores that have a high
 * maximum count value should not be added to a queue set.
 *
 * Note 4:  A receive (in the case of a queue) or take (in the case of a
 * semaphore) operation must not be performed on a member of a queue set unless
 * a call to xQueueSelectFromSet() has first returned a handle to that set member.
 *
 * @param uxEventQueueLength Queue sets store events that occur on
 * the queues and semaphores contained in the set.  uxEventQueueLength specifies
 * the maximum number of events that can be queued at once.  To be absolutely
 * certain that events are not lost uxEventQueueLength should be set to the
 * total sum of the length of the queues added to the set, where binary
 * semaphores and mutexes have a length of 1, and counting semaphores have a
 * length set by their maximum count value.  Examples:
 *  + If a queue set is to hold a queue of length 5, another queue of length 12,
 *    and a binary semaphore, then uxEventQueueLength should be set to
 *    (5 + 12 + 1), or 18.
 *  + If a queue set is to hold three binary semaphores then uxEventQueueLength
 *    should be set to (1 + 1 + 1 ), or 3.
 *  + If a queue set is to hold a counting semaphore that has a maximum count of
 *    5, and a counting semaphore that has a maximum count of 3, then
 *    uxEventQueueLength should be set to (5 + 3), or 8.
 *
 * @return If the queue set is created successfully then a handle to the created
 * queue set is returned.  Otherwise NULL is returned.
 *//*
 * Generic version of the function used to creaet a queue using dynamic memory
 * allocation.  This is called by other functions and macros that create other
 * RTOS objects that use the queue structure as their base.
 *//*lint !e971 Unqualified char types are allowed for strings and single characters only. *//*
 * The queue registry is provided as a means for kernel aware debuggers to
 * locate queues, semaphores and mutexes.  Call pcQueueGetName() to look
 * up and return the name of a queue in the queue registry from the queue's
 * handle.
 *
 * @param xQueue The handle of the queue the name of which will be returned.
 * @return If the queue is in the registry then a pointer to the name of the
 * queue is returned.  If the queue is not in the registry then NULL is
 * returned.
 *//*
 * The registry is provided as a means for kernel aware debuggers to
 * locate queues, semaphores and mutexes.  Call vQueueAddToRegistry() add
 * a queue, semaphore or mutex handle to the registry if you want the handle
 * to be available to a kernel aware debugger, and vQueueUnregisterQueue() to
 * remove the queue, semaphore or mutex from the register.  If you are not using
 * a kernel aware debugger then this function can be ignored.
 *
 * @param xQueue The handle of the queue being removed from the registry.
 *//*
 * The registry is provided as a means for kernel aware debuggers to
 * locate queues, semaphores and mutexes.  Call vQueueAddToRegistry() add
 * a queue, semaphore or mutex handle to the registry if you want the handle
 * to be available to a kernel aware debugger.  If you are not using a kernel
 * aware debugger then this function can be ignored.
 *
 * configQUEUE_REGISTRY_SIZE defines the maximum number of handles the
 * registry can hold.  configQUEUE_REGISTRY_SIZE must be greater than 0
 * within FreeRTOSConfig.h for the registry to be available.  Its value
 * does not effect the number of queues, semaphores and mutexes that can be
 * created - just the number that the registry can hold.
 *
 * @param xQueue The handle of the queue being added to the registry.  This
 * is the handle returned by a call to xQueueCreate().  Semaphore and mutex
 * handles can also be passed in here.
 *
 * @param pcName The name to be associated with the handle.  This is the
 * name that the kernel aware debugger will display.  The queue registry only
 * stores a pointer to the string - so the string must be persistent (global or
 * preferably in ROM/Flash), not on the stack.
 *//*
 * Reset a queue back to its original empty state.  The return value is now
 * obsolete and is always set to pdPASS.
 *//*
 * For internal use only.  Use xSemaphoreTakeMutexRecursive() or
 * xSemaphoreGiveMutexRecursive() instead of calling these functions directly.
 *//*
 * For internal use only.  Use xSemaphoreCreateMutex(),
 * xSemaphoreCreateCounting() or xSemaphoreGetMutexHolder() instead of calling
 * these functions directly.
 *//*
 * The functions defined above are for passing data to and from tasks.  The
 * functions below are the equivalents for passing data to and from
 * co-routines.
 *
 * These functions are called from the co-routine macro implementation and
 * should not be called directly from application code.   S  elO    